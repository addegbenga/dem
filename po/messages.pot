
msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: 2024-07-01T00:37:38+01:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md src/title-page.md
msgid "The Cairo Book"
msgstr ""

#: src/SUMMARY.md
msgid "The Cairo Book Foreword Introduction"
msgstr ""

#: src/SUMMARY.md
msgid "The Cairo Programming Language"
msgstr ""

#: src/SUMMARY.md src/ch01-00-getting-started.md
msgid "Getting Started"
msgstr ""

#: src/SUMMARY.md src/ch01-01-installation.md:1 src/ch01-01-installation.md:22
msgid "Installation"
msgstr ""

#: src/SUMMARY.md
msgid "Hello, World!"
msgstr ""

#: src/SUMMARY.md src/ch02-00-common-programming-concepts.md
msgid "Common Programming Concepts"
msgstr ""

#: src/SUMMARY.md src/ch02-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr ""

#: src/SUMMARY.md src/ch02-02-data-types.md:1
msgid "Data Types"
msgstr ""

#: src/SUMMARY.md src/ch02-03-functions.md:1
msgid "Functions"
msgstr ""

#: src/SUMMARY.md src/ch02-04-comments.md:1
msgid "Comments"
msgstr ""

#: src/SUMMARY.md src/ch02-05-control-flow.md:1
msgid "Control Flow"
msgstr ""

#: src/SUMMARY.md src/ch03-00-common-collections.md
msgid "Common Collections"
msgstr ""

#: src/SUMMARY.md src/ch03-01-arrays.md:1
msgid "Arrays"
msgstr ""

#: src/SUMMARY.md src/ch03-02-dictionaries.md:1
msgid "Dictionaries"
msgstr ""

#: src/SUMMARY.md
msgid "Understanding Ownership"
msgstr ""

#: src/SUMMARY.md
msgid "What is Ownership?"
msgstr ""

#: src/SUMMARY.md src/ch04-02-references-and-snapshots.md:1
msgid "References and Snapshots"
msgstr ""

#: src/SUMMARY.md src/ch05-00-using-structs-to-structure-related-data.md
msgid "Using Structs to Structure Related Data"
msgstr ""

#: src/SUMMARY.md src/ch05-01-defining-and-instantiating-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr ""

#: src/SUMMARY.md src/ch05-02-an-example-program-using-structs.md:1
msgid "An Example Program Using Structs"
msgstr ""

#: src/SUMMARY.md src/ch05-03-method-syntax.md:1
msgid "Method Syntax"
msgstr ""

#: src/SUMMARY.md src/ch06-00-enums-and-pattern-matching.md
msgid "Enums and Pattern Matching"
msgstr ""

#: src/SUMMARY.md src/ch06-01-enums.md:1 src/ch08-01-generic-data-types.md:181
msgid "Enums"
msgstr ""

#: src/SUMMARY.md src/ch06-02-the-match-control-flow-construct.md:1
msgid "The Match Control Flow Construct"
msgstr ""

#: src/SUMMARY.md
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:1
msgid "Concise Control Flow with `if let` and `while let`"
msgstr ""

#: src/SUMMARY.md
#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr ""

#: src/SUMMARY.md src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr ""

#: src/SUMMARY.md src/ch07-02-defining-modules-to-control-scope.md:1
msgid "Defining Modules to Control Scope"
msgstr ""

#: src/SUMMARY.md
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr ""

#: src/SUMMARY.md
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr ""

#: src/SUMMARY.md src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr ""

#: src/SUMMARY.md src/ch08-01-generic-data-types.md:1
msgid "Generic Data Types"
msgstr ""

#: src/SUMMARY.md src/ch08-00-generic-types-and-traits.md
msgid "Generic Types and Traits"
msgstr ""

#: src/SUMMARY.md src/ch08-02-traits-in-cairo.md:1
msgid "Traits in Cairo"
msgstr ""

#: src/SUMMARY.md
msgid "Error Handling"
msgstr ""

#: src/SUMMARY.md
msgid "Unrecoverable Errors with panic"
msgstr ""

#: src/SUMMARY.md
msgid "Recoverable Errors with Result"
msgstr ""

#: src/SUMMARY.md src/ch10-00-testing-cairo-programs.md
msgid "Testing Cairo Programs"
msgstr ""

#: src/SUMMARY.md src/ch10-01-how-to-write-tests.md:1
msgid "How To Write Tests"
msgstr ""

#: src/SUMMARY.md src/ch10-02-test-organization.md:1
msgid "Testing Organization"
msgstr ""

#: src/SUMMARY.md
msgid "Advanced Cairo Features"
msgstr ""

#: src/SUMMARY.md src/ch11-01-custom-data-structures.md:1
msgid "Custom Data Structures"
msgstr ""

#: src/SUMMARY.md src/ch11-02-smart-pointers.md:1
msgid "Smart Pointers"
msgstr ""

#: src/SUMMARY.md src/ch11-03-operator-overloading.md:1
msgid "Operator Overloading"
msgstr ""

#: src/SUMMARY.md src/ch11-04-hash.md:24
msgid "Working with Hashes"
msgstr ""

#: src/SUMMARY.md src/ch11-05-macros.md:1
msgid "Macros"
msgstr ""

#: src/SUMMARY.md src/ch11-06-inlining-in-cairo.md:1
msgid "Inlining in Cairo"
msgstr ""

#: src/SUMMARY.md src/ch11-08-printing.md:1
msgid "Printing"
msgstr ""

#: src/SUMMARY.md
msgid "Appendix (Cairo)"
msgstr ""

#: src/SUMMARY.md
msgid "A - Keywords"
msgstr ""

#: src/SUMMARY.md
msgid "B - Operators and Symbols"
msgstr ""

#: src/SUMMARY.md
msgid "C - Derivable Traits"
msgstr ""

#: src/SUMMARY.md
msgid "D - The Cairo Prelude"
msgstr ""

#: src/SUMMARY.md
msgid "E - Common Error Messages"
msgstr ""

#: src/SUMMARY.md
msgid "F - Useful Development Tools"
msgstr ""

#: src/SUMMARY.md
msgid "G - Installing Cairo binaries"
msgstr ""

#: src/SUMMARY.md
msgid "Smart Contracts in Cairo"
msgstr ""

#: src/SUMMARY.md src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Introduction to Starknet Smart Contracts"
msgstr ""

#: src/SUMMARY.md src/ch13-01-general-introduction-to-smart-contracts.md:1
msgid "General Introduction to Smart Contracts"
msgstr ""

#: src/SUMMARY.md src/ch13-02-anatomy-of-a-simple-contract.md:1
msgid "Anatomy of a Simple Contract"
msgstr ""

#: src/SUMMARY.md src/ch14-00-building-starknet-smart-contracts.md
msgid "Building Starknet Smart Contracts"
msgstr ""

#: src/SUMMARY.md src/ch14-01-contract-storage.md:1
msgid "Contract Storage"
msgstr ""

#: src/SUMMARY.md src/ch14-02-contract-functions.md:1
msgid "Contract Functions"
msgstr ""

#: src/SUMMARY.md src/ch14-03-contract-events.md:1
msgid "Contract Events"
msgstr ""

#: src/SUMMARY.md src/ch15-00-starknet-cross-contract-interactions.md
msgid "Starknet Cross-Contract Interactions"
msgstr ""

#: src/SUMMARY.md src/ch15-01-abis-and-contract-interfaces.md:1
msgid "ABIs and Contract Interfaces"
msgstr ""

#: src/SUMMARY.md
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:1
msgid "Contract Dispatchers, Library Dispatchers and System Calls"
msgstr ""

#: src/SUMMARY.md src/ch16-00-building-advanced-starknet-smart-contracts.md
msgid "Building Advanced Starknet Smart Contracts"
msgstr ""

#: src/SUMMARY.md src/ch16-01-optimizing-storage-costs.md:1
msgid "Optimizing Storage Costs"
msgstr ""

#: src/SUMMARY.md
msgid "Composability and Components"
msgstr ""

#: src/SUMMARY.md
msgid "Under the Hood"
msgstr ""

#: src/SUMMARY.md src/ch16-02-02-component-dependencies.md:1
msgid "Component Dependencies"
msgstr ""

#: src/SUMMARY.md src/ch16-02-03-testing-components.md:1
msgid "Testing Components"
msgstr ""

#: src/SUMMARY.md
msgid "Upgradeability"
msgstr ""

#: src/SUMMARY.md
msgid "L1 \\<\\> L2 Messaging"
msgstr ""

#: src/SUMMARY.md src/ch16-05-oracle-interactions.md:1
msgid "Oracle Interactions"
msgstr ""

#: src/SUMMARY.md src/ch16-05-01-price-feeds.md:1
msgid "Price Feeds"
msgstr ""

#: src/SUMMARY.md src/ch16-05-02-randomness.md:1
msgid "Randomness"
msgstr ""

#: src/SUMMARY.md src/ch16-06-00-other-examples.md:1
msgid "Other Examples"
msgstr ""

#: src/SUMMARY.md
msgid "Deploying and Interacting with a Voting Contract"
msgstr ""

#: src/SUMMARY.md src/ch17-00-starknet-smart-contracts-security.md
msgid "Starknet Smart Contracts Security"
msgstr ""

#: src/SUMMARY.md src/ch17-01-general-recommendations.md:1
msgid "General Recommendations"
msgstr ""

#: src/SUMMARY.md src/ch17-02-testing-smart-contracts.md:1
msgid "Testing Smart Contracts"
msgstr ""

#: src/SUMMARY.md src/ch17-03-static-analysis-tools.md:1
msgid "Static Analysis Tools"
msgstr ""

#: src/SUMMARY.md
msgid "Formal Verification"
msgstr ""

#: src/SUMMARY.md src/appendix-00.md src/appendix-000.md
msgid "Appendix"
msgstr ""

#: src/SUMMARY.md
msgid "Appendix (Starknet)"
msgstr ""

#: src/SUMMARY.md
msgid "A - System Calls"
msgstr ""

#: src/SUMMARY.md
msgid "Cairo VM"
msgstr ""

#: src/SUMMARY.md src/ch00-00-introduction.md src/ch200-introduction.md
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md
msgid "Architecture"
msgstr ""

#: src/SUMMARY.md
msgid "Memory"
msgstr ""

#: src/SUMMARY.md
msgid "Non-Deterministic Read-only Memory"
msgstr ""

#: src/SUMMARY.md
msgid "Segments"
msgstr ""

#: src/SUMMARY.md
msgid "Segment Value"
msgstr ""

#: src/SUMMARY.md
msgid "Relocation"
msgstr ""

#: src/SUMMARY.md
msgid "Layout"
msgstr ""

#: src/SUMMARY.md
msgid "Execution Model"
msgstr ""

#: src/SUMMARY.md
msgid "Registers"
msgstr ""

#: src/SUMMARY.md
msgid "Instructions"
msgstr ""

#: src/SUMMARY.md
msgid "Cairo Assembly (CASM)"
msgstr ""

#: src/SUMMARY.md
msgid "State transition"
msgstr ""

#: src/SUMMARY.md
msgid "Builtins"
msgstr ""

#: src/SUMMARY.md
msgid "Memory Communication"
msgstr ""

#: src/SUMMARY.md
msgid "List of builtins"
msgstr ""

#: src/SUMMARY.md
msgid "Hints"
msgstr ""

#: src/SUMMARY.md
msgid "Structure"
msgstr ""

#: src/SUMMARY.md
msgid "Hint runner"
msgstr ""

#: src/SUMMARY.md
msgid "List of hints"
msgstr ""

#: src/SUMMARY.md
msgid "Runner"
msgstr ""

#: src/SUMMARY.md
msgid "Program"
msgstr ""

#: src/SUMMARY.md
msgid "Program Artifacts"
msgstr ""

#: src/SUMMARY.md
msgid "Program Parsing"
msgstr ""

#: src/SUMMARY.md
msgid "Runner Mode"
msgstr ""

#: src/SUMMARY.md
msgid "Execution Mode"
msgstr ""

#: src/SUMMARY.md
msgid "Proof Mode"
msgstr ""

#: src/SUMMARY.md
msgid "Output"
msgstr ""

#: src/SUMMARY.md
msgid "Cairo PIE"
msgstr ""

#: src/SUMMARY.md
msgid "Memory File"
msgstr ""

#: src/SUMMARY.md
msgid "Trace file"
msgstr ""

#: src/SUMMARY.md
msgid "AIR public input"
msgstr ""

#: src/SUMMARY.md
msgid "AIR private input"
msgstr ""

#: src/SUMMARY.md
msgid "Tracer"
msgstr ""

#: src/SUMMARY.md
msgid "Implementations"
msgstr ""

#: src/SUMMARY.md
msgid "Resources"
msgstr ""

#: src/title-page.md
msgid ""
"By the Cairo Community and its "
"[contributors](https://github.com/cairo-book/cairo-book.github.io). Special "
"thanks to [StarkWare](https://starkware.co/) through "
"[OnlyDust](https://www.onlydust.xyz/), and "
"[Voyager](https://voyager.online/) for supporting the creation of this book."
msgstr ""

#: src/title-page.md
msgid ""
"This version of the text assumes you’re using the [Cairo "
"Compiler](https://github.com/starkware-libs/cairo) [version "
"2.6.3](https://github.com/starkware-libs/cairo/releases). See the "
"[Installation](ch01-01-installation.md) section of Chapter 1 to install or "
"update Cairo."
msgstr ""

#: src/title-page.md
msgid ""
"If you want to play around with Cairo code and see how it compiles into "
"Sierra (Intermediate Representation) and CASM (Cairo Assembly), you can use "
"[cairovm.codes](https://cairovm.codes/) playground."
msgstr ""

#: src/ch00-01-foreword.md
msgid "Foreword"
msgstr ""

#: src/ch00-01-foreword.md
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and "
"gradually became more expressive. The learning curve was initially steep, as "
"Cairo 0.x was a low-level language that did not entirely abstract the "
"underlying cryptographic primitives required to build a proof for the "
"execution of a program."
msgstr ""

#: src/ch00-01-foreword.md
msgid ""
"With the release of Cairo 1, the developer experience has considerably "
"improved, abstracting away the underlying immutable memory model of the "
"Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has "
"been built to help you create provable programs without specific knowledge "
"of its underlying architecture so that you can focus on the program itself, "
"increasing the overall security of Cairo programs. Powered by a Rust VM, the "
"execution of Cairo programs is now _blazingly_ fast, allowing you to build "
"an extensive test suite without compromising on performance."
msgstr ""

#: src/ch00-01-foreword.md
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the "
"Cairo programming language to code their smart contracts. This allows the "
"Starknet OS to generate execution traces for transactions to be proved by a "
"prover, which is then verified on Ethereum L1 prior to updating the state "
"root of Starknet."
msgstr ""

#: src/ch00-01-foreword.md
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit "
"from being proved on one computer and verified on other machines with lower "
"hardware requirements."
msgstr ""

#: src/ch00-01-foreword.md
msgid ""
"This book is designed for developers with a basic understanding of "
"programming concepts. It is a friendly and approachable text intended to "
"help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there "
"is to know about Cairo!"
msgstr ""

#: src/ch00-01-foreword.md
msgid "Acknowledgements"
msgstr ""

#: src/ch00-01-foreword.md
msgid ""
"This book would not have been possible without the help of the Cairo "
"community. We would like to thank every contributor for their contributions "
"to this book!"
msgstr ""

#: src/ch00-01-foreword.md
msgid ""
"We would like to thank the Rust community for the [Rust "
"Book](https://doc.rust-lang.org/book/), which has been a great source of "
"inspiration for this book. Many examples and explanations have been adapted "
"from the Rust Book to fit the Cairo programming language, as the two "
"languages share many similarities."
msgstr ""

#: src/ch00-00-introduction.md
msgid "What is Cairo?"
msgstr ""

#: src/ch00-00-introduction.md
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name. "
"The unique aspect of this processor is that it was not created for the "
"physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. "
"This means that you can perform time consuming operations on a machine you "
"don't trust, and check the result very quickly on a cheaper machine. While "
"Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo "
"1 is a higher level language. It first compiles to Sierra, an intermediate "
"representation of Cairo which will compile later down to a safe subset of "
"CASM. The point of Sierra is to ensure your CASM will always be provable, "
"even when the computation fails."
msgstr ""

#: src/ch00-00-introduction.md
msgid "What Can you Do with It?"
msgstr ""

#: src/ch00-00-introduction.md
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One "
"major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a "
"decentralized blockchain platform that enables the creation of decentralized "
"applications where every single interaction between a user and a d-app is "
"verified by all the participants. Starknet is a Layer 2 built on top of "
"Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the "
"programs and generates proofs that the computations were done correctly. "
"These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and "
"reduced transaction costs while preserving Ethereum security."
msgstr ""

#: src/ch00-00-introduction.md
msgid "What Are the Differences with Other Programming Languages?"
msgstr ""

#: src/ch00-00-introduction.md
msgid ""
"Cairo is quite different from traditional programming languages, especially "
"when it comes to overhead costs and its primary advantages. Your program can "
"be executed in two different ways:"
msgstr ""

#: src/ch00-00-introduction.md
msgid ""
"When executed by the prover, it is similar to any other language. Because "
"Cairo is virtualized, and because the operations were not specifically "
"designed for maximum efficiency, this can lead to some performance overhead "
"but it is not the most relevant part to optimize."
msgstr ""

#: src/ch00-00-introduction.md
msgid ""
"When the generated proof is verified by a verifier, it is a bit different. "
"This has to be as cheap as possible since it could potentially be verified "
"on many very small machines. Fortunately verifying is faster than computing "
"and Cairo has some unique advantages to improve it even more. A notable one "
"is non-determinism. This is a topic you will cover in more detail later in "
"this book, but the idea is that you can theoretically use a different "
"algorithm for verifying than for computing. Currently, writing custom "
"non-deterministic code is not supported for the developers, but the standard "
"library leverages non-determinism for improved performance. For example "
"sorting an array in Cairo costs the same price as copying it. Because the "
"verifier doesn't sort the array, it just checks that it is sorted, which is "
"cheaper."
msgstr ""

#: src/ch00-00-introduction.md
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, "
"memory access is immutable, meaning that once a value is written to memory, "
"it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. "
"Therefore, developers must think carefully about how they manage memory and "
"data structures in their programs to optimize performance."
msgstr ""

#: src/ch00-00-introduction.md
msgid "References"
msgstr ""

#: src/ch00-00-introduction.md
msgid "Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>"
msgstr ""

#: src/ch00-00-introduction.md
msgid ""
"Cairo, Sierra and Casm: "
"<https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5>"
msgstr ""

#: src/ch00-00-introduction.md
msgid ""
"State of non determinism: "
"<https://twitter.com/PapiniShahar/status/1638203716535713798>"
msgstr ""

#: src/ch01-00-getting-started.md
msgid ""
"Let’s start your Cairo journey! There’s a lot to learn, but every journey "
"starts somewhere. In this chapter, we’ll discuss:"
msgstr ""

#: src/ch01-00-getting-started.md
msgid ""
"Installing Scarb, which is Cairo's build toolchain and package manager, on "
"Linux, macOS, and Windows."
msgstr ""

#: src/ch01-00-getting-started.md
msgid "Writing a program that prints `Hello, world!`."
msgstr ""

#: src/ch01-00-getting-started.md
msgid "Using basic Scarb commands to create a project and execute a program."
msgstr ""

#: src/ch01-00-getting-started.md
msgid "Getting Help"
msgstr ""

#: src/ch01-00-getting-started.md
msgid ""
"If you have any questions about Starknet or Cairo, you can ask them in the "
"[Starknet Discord server](https://discord.gg/starknet-community). The "
"community is friendly and always willing to help."
msgstr ""

#: src/ch01-00-getting-started.md
msgid "Interacting with the Cairo Chatbot"
msgstr ""

#: src/ch01-00-getting-started.md
msgid ""
"Cairo has its own chatbot, which can help you with Cairo-related questions. "
"The chatbot is trained on the Cairo book, and uses RAG to efficiently "
"retrieve information to provide help. You can find the chatbot on the "
"[Cairo-Chatbot](https://cairo-chatbot.vercel.app/) website."
msgstr ""

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading "
"[Scarb](https://docs.swmansion.com/scarb/docs). Scarb bundles the Cairo "
"compiler and the Cairo language server together in an easy-to-install "
"package so that you can start writing Cairo code right away."
msgstr ""

#: src/ch01-01-installation.md:5
msgid ""
"Scarb is also Cairo's package manager and is heavily inspired by "
"[Cargo](https://doc.rust-lang.org/cargo/), Rust’s build system and package "
"manager."
msgstr ""

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either "
"pure Cairo or Starknet contracts), downloading the libraries your code "
"depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""

#: src/ch01-01-installation.md:9
msgid ""
"As you write more complex Cairo programs, you might add dependencies, and if "
"you start a project using Scarb, managing external code and dependencies "
"will be a lot easier to do."
msgstr ""

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr ""

#: src/ch01-01-installation.md:16
msgid "Installing Scarb"
msgstr ""

#: src/ch01-01-installation.md:18
msgid "Requirements"
msgstr ""

#: src/ch01-01-installation.md:20
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment "
"variable."
msgstr ""

#: src/ch01-01-installation.md:24
msgid ""
"To install Scarb, please refer to the [installation "
"instructions](https://docs.swmansion.com/scarb/download). We strongly "
"recommend that you install Scarb [via "
"asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf), a "
"CLI tool that can manage multiple language runtime versions on a per-project "
"basis. This will ensure that the version of Scarb you use to work on a "
"project always matches the one defined in the project settings, avoiding "
"problems related to version mismatches."
msgstr ""

#: src/ch01-01-installation.md:28
msgid ""
"Please refer to the [asdf "
"documentation](https://asdf-vm.com/guide/getting-started.html) to install "
"all prerequisites."
msgstr ""

#: src/ch01-01-installation.md:30
msgid ""
"Once you have asdf installed locally, you can download Scarb plugin with the "
"following command:"
msgstr ""

#: src/ch01-01-installation.md:36
msgid "This will allow you to download specific versions:"
msgstr ""

#: src/ch01-01-installation.md:42
msgid "and set a global version:"
msgstr ""

#: src/ch01-01-installation.md:48
msgid ""
"Otherwise, you can simply run the following command in your terminal, and "
"follow the onscreen instructions. This will install the latest stable "
"release of Scarb."
msgstr ""

#: src/ch01-01-installation.md:51
msgid "'=https'"
msgstr ""

#: src/ch01-01-installation.md:68
msgid "Installing the VSCode Extension"
msgstr ""

#: src/ch01-01-installation.md:70
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code "
"completion, and other useful features. You can install it from the [VSCode "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1). "
"Once installed, go into the extension settings, and make sure to tick the "
"`Enable Language Server` and `Enable Scarb` options."
msgstr ""

#: src/ch01-01-installation.md:75
msgid "{{#quiz ../quizzes/ch01-01-installation.toml}}"
msgstr ""

#: src/ch01-02-hello-world.md:1
msgid "Hello, World"
msgstr ""

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first "
"Cairo program. It’s traditional when learning a new language to write a "
"little program that prints the text `Hello, world!` to the screen, so we’ll "
"do the same here!"
msgstr ""

#: src/ch01-02-hello-world.md:7
msgid ""
"Note: This book assumes basic familiarity with the command line. Cairo makes "
"no specific demands about your editing or tooling or where your code lives, "
"so if you prefer to use an integrated development environment (IDE) instead "
"of the command line, feel free to use your favorite IDE. The Cairo team has "
"developed a VSCode extension for the Cairo language that you can use to get "
"the features from the language server and code highlighting. See [Appendix "
"F](./appendix-06-useful-development-tools.md) for more details."
msgstr ""

#: src/ch01-02-hello-world.md:17
msgid "Creating a Project Directory"
msgstr ""

#: src/ch01-02-hello-world.md:19
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t "
"matter to Cairo where your code lives, but for the exercises and projects in "
"this book, we suggest making a _cairo_projects_ directory in your home "
"directory and keeping all your projects there."
msgstr ""

#: src/ch01-02-hello-world.md:24
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory."
msgstr ""

#: src/ch01-02-hello-world.md:26
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr ""

#: src/ch01-02-hello-world.md:33
msgid "For Windows CMD, enter this:"
msgstr ""

#: src/ch01-02-hello-world.md:36 src/ch01-02-hello-world.md:37
msgid "\"%USERPROFILE%\\cairo_projects\""
msgstr ""

#: src/ch01-02-hello-world.md:40
msgid ""
"Note: From now on, for each example shown in the book, we assume that you "
"will be working from a Scarb project directory. If you are not using Scarb, "
"and try to run the examples from a different directory, you might need to "
"adjust the commands accordingly or create a Scarb project."
msgstr ""

#: src/ch01-02-hello-world.md:43
msgid "Creating a Project with Scarb"
msgstr ""

#: src/ch01-02-hello-world.md:45
msgid "Let’s create a new project using Scarb."
msgstr ""

#: src/ch01-02-hello-world.md:47
msgid ""
"Navigate to your _cairo_projects_ directory (or wherever you decided to "
"store your code). Then run the following:"
msgstr ""

#: src/ch01-02-hello-world.md:53
msgid ""
"It creates a new directory and project called _hello_world_. We’ve named our "
"project _hello_world_, and Scarb creates its files in a directory of the "
"same name."
msgstr ""

#: src/ch01-02-hello-world.md:55
msgid ""
"Go into the _hello_world_ directory with the command `cd hello_world`. "
"You’ll see that Scarb has generated two files and one directory for us: a "
"_Scarb.toml_ file and a _src_ directory with a _lib.cairo_ file inside."
msgstr ""

#: src/ch01-02-hello-world.md:57
msgid ""
"It has also initialized a new Git repository along with a `.gitignore` file"
msgstr ""

#: src/ch01-02-hello-world.md:59
msgid ""
"Note: Git is a common version control system. You can stop using version "
"control system by using the `--no-vcs` flag. Run `scarb new --help` to see "
"the available options."
msgstr ""

#: src/ch01-02-hello-world.md:62
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-1."
msgstr ""

#: src/ch01-02-hello-world.md:64
msgid "<span class=\"filename\">Filename: Scarb.toml</span>"
msgstr ""

#: src/ch01-02-hello-world.md:66
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"edition = \"2023_11\"\n"
"\n"
"# See more keys and their definitions at "
"https://docs.swmansion.com/scarb/docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:78
msgid ""
"<span class=\"caption\">Listing 1-1: Contents of _Scarb.toml_ generated by "
"`scarb new`</span>"
msgstr ""

#: src/ch01-02-hello-world.md:80
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal "
"Language) format, which is Scarb’s configuration format."
msgstr ""

#: src/ch01-02-hello-world.md:82
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr ""

#: src/ch01-02-hello-world.md:84
msgid ""
"The next three lines set the configuration information Scarb needs to "
"compile your program: the name of the package and the version of Scarb to "
"use, and the edition of the prelude to use. The prelude is the collection of "
"the most commonly used items that are automatically imported into every "
"Cairo program. You can learn more about the prelude in [Appendix "
"D](./appendix-04-cairo-prelude.md)."
msgstr ""

#: src/ch01-02-hello-world.md:86
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Cairo, packages of code are referred "
"to as crates. We won’t need any other crates for this project."
msgstr ""

#: src/ch01-02-hello-world.md:88
msgid ""
"Note: If you're building contracts for Starknet, you will need to add the "
"`starknet` dependency as mentioned in the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-package.html)."
msgstr ""

#: src/ch01-02-hello-world.md:90
msgid ""
"The other file created by Scarb is _src/lib.cairo_, let's delete all the "
"content and put in the following content, we will explain the reason later."
msgstr ""

#: src/ch01-02-hello-world.md:96
msgid ""
"Then create a new file called _src/hello_world.cairo_ and put the following "
"code in it:"
msgstr ""

#: src/ch01-02-hello-world.md:98
msgid "<span class=\"filename\">Filename: src/hello_world.cairo</span>"
msgstr ""

#: src/ch01-02-hello-world.md:102 src/ch01-02-hello-world.md:185
msgid "\"Hello, World!\""
msgstr ""

#: src/ch01-02-hello-world.md:106
msgid ""
"We have just created a file called _lib.cairo_, which contains a module "
"declaration referencing another module named `hello_world`, as well as the "
"file _hello_world.cairo_, containing the implementation details of the "
"`hello_world` module."
msgstr ""

#: src/ch01-02-hello-world.md:108
msgid ""
"Scarb requires your source files to be located within the _src_ directory."
msgstr ""

#: src/ch01-02-hello-world.md:110
msgid ""
"The top-level project directory is reserved for README files, license "
"information, configuration files, and any other non-code-related content. "
"Scarb ensures a designated location for all project components, maintaining "
"a structured organization."
msgstr ""

#: src/ch01-02-hello-world.md:113
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a "
"project that does use Scarb. Move the project code into the _src_ directory "
"and create an appropriate _Scarb.toml_ file. You can also use `scarb init` "
"command to generate the _src_ folder and the _Scarb.toml_ it contains."
msgstr ""

#: src/ch01-02-hello-world.md:122
msgid "<span class=\"caption\"> A sample Scarb project structure</span>"
msgstr ""

#: src/ch01-02-hello-world.md:128
msgid "Building a Scarb Project"
msgstr ""

#: src/ch01-02-hello-world.md:130
msgid ""
"From your _hello_world_ directory, build your project by entering the "
"following command:"
msgstr ""

#: src/ch01-02-hello-world.md:138
msgid ""
"This command creates a `sierra` file in _target/dev_, let's ignore the "
"`sierra` file for now."
msgstr ""

#: src/ch01-02-hello-world.md:140
msgid ""
"If you have installed Cairo correctly, you should be able to run the `main` "
"function of your program with the `scarb cairo-run` command and see the "
"following output:"
msgstr ""

#: src/ch01-02-hello-world.md:149
msgid ""
"Regardless of your operating system, the string `Hello, world!` should be "
"printed to the terminal."
msgstr ""

#: src/ch01-02-hello-world.md:152
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Cairo program. That makes you a Cairo programmer — welcome!"
msgstr ""

#: src/ch01-02-hello-world.md:155
msgid "Anatomy of a Cairo Program"
msgstr ""

#: src/ch01-02-hello-world.md:157
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of the puzzle:"
msgstr ""

#: src/ch01-02-hello-world.md:166
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it is always the first code that runs in every executable Cairo program. "
"Here, the first line declares a function named `main` that has no parameters "
"and returns nothing. If there were parameters, they would go inside the "
"parentheses `()`."
msgstr ""

#: src/ch01-02-hello-world.md:171
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around "
"all function bodies. It’s good style to place the opening curly bracket on "
"the same line as the function declaration, adding one space in between."
msgstr ""

#: src/ch01-02-hello-world.md:175
msgid ""
"Note: If you want to stick to a standard style across Cairo projects, you "
"can use the automatic formatter tool available with `scarb fmt` to format "
"your code in a particular style (more on `scarb fmt` in [Appendix "
"F](./appendix-06-useful-development-tools.md)). The Cairo team has included "
"this tool with the standard Cairo distribution, as `cairo-run` is, so it "
"should already be installed on your computer!"
msgstr ""

#: src/ch01-02-hello-world.md:182
msgid "The body of the `main` function holds the following code:"
msgstr ""

#: src/ch01-02-hello-world.md:188
msgid ""
"This line does all the work in this little program: it prints text to the "
"screen. There are four important details to notice here."
msgstr ""

#: src/ch01-02-hello-world.md:191
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr ""

#: src/ch01-02-hello-world.md:193
msgid ""
"Second, `println!` calls a Cairo macro. If it had called a function instead, "
"it would be entered as `println` (without the `!`). We’ll discuss Cairo "
"macros in more detail in the [\"Macros\"](./ch11-05-macros.md) chapter. For "
"now, you just need to know that using a `!` means that you’re calling a "
"macro instead of a normal function and that macros don’t always follow the "
"same rules as functions."
msgstr ""

#: src/ch01-02-hello-world.md:196
msgid ""
"Third, you see the `\"Hello, world!\"` string. We pass this string as an "
"argument to `println!`, and the string is printed to the screen."
msgstr ""

#: src/ch01-02-hello-world.md:198
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this "
"expression is over and the next one is ready to begin. Most lines of Cairo "
"code end with a semicolon."
msgstr ""

#: src/ch01-02-hello-world.md:205
msgid "{{#quiz ../quizzes/ch01-02-hello-world.toml}}"
msgstr ""

#: src/ch01-02-hello-world.md:207 src/ch02-05-control-flow.md:311
#: src/ch07-05-separating-modules-into-different-files.md:97
#: src/ch09-02-recoverable-errors.md:188 src/ch10-02-test-organization.md:265
#: src/ch11-01-custom-data-structures.md:345
#: src/ch11-06-inlining-in-cairo.md:269
#: src/ch17-02-testing-smart-contracts.md:730
msgid "Summary"
msgstr ""

#: src/ch01-02-hello-world.md:209
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr ""

#: src/ch01-02-hello-world.md:211
msgid ""
"We can install one or multiple Scarb versions, either the latest stable or a "
"specific one, using asdf."
msgstr ""

#: src/ch01-02-hello-world.md:212
msgid "We can create a project using `scarb new`."
msgstr ""

#: src/ch01-02-hello-world.md:213
msgid ""
"We can build a project using `scarb build` to generate the compiled Sierra "
"code."
msgstr ""

#: src/ch01-02-hello-world.md:214
msgid "We can execute a Cairo program using the `scarb cairo-run` command."
msgstr ""

#: src/ch01-02-hello-world.md:216
msgid ""
"An additional advantage of using Scarb is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no "
"longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""

#: src/ch01-02-hello-world.md:218
msgid ""
"You’re already off to a great start on your Cairo journey! This is a great "
"time to build a more substantial program to get used to reading and writing "
"Cairo code."
msgstr ""

#: src/ch02-00-common-programming-concepts.md
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Cairo. Many programming languages have much in "
"common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain "
"the conventions around using these concepts."
msgstr ""

#: src/ch02-00-common-programming-concepts.md
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Cairo "
"program, and learning them early will give you a strong core to start from."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is "
"written to, it can't be overwritten but only read from. To reflect this "
"immutable memory model, variables in Cairo are immutable by default. "
"However, the language abstracts this model and gives you the option to make "
"your variables mutable. Let’s explore how and why Cairo enforces "
"immutability, and how you can make your variables mutable."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t "
"change that value. To illustrate this, generate a new project called "
"_variables_ in your _cairo_projects_ directory by using `scarb new "
"variables`."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace "
"its code with the following code, which won’t compile just yet:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:17
#: src/ch04-01-what-is-ownership.md:265 src/ch04-01-what-is-ownership.md:310
#: src/ch04-02-references-and-snapshots.md:26
#: src/ch04-02-references-and-snapshots.md:118
#: src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:27
#: src/ch05-01-defining-and-instantiating-structs.md:53
#: src/ch05-01-defining-and-instantiating-structs.md:89
#: src/ch05-01-defining-and-instantiating-structs.md:125
#: src/ch05-01-defining-and-instantiating-structs.md:167
#: src/ch05-01-defining-and-instantiating-structs.md:203
#: src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:50
#: src/ch05-02-an-example-program-using-structs.md:75
#: src/ch07-02-defining-modules-to-control-scope.md:80
#: src/ch07-02-defining-modules-to-control-scope.md:137
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:14
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:90
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:116
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:150
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:36
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:81
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:133
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:206
#: src/ch07-05-separating-modules-into-different-files.md:18
#: src/ch09-01-unrecoverable-errors-with-panic.md:9
#: src/ch10-01-how-to-write-tests.md:32 src/ch10-01-how-to-write-tests.md:95
#: src/ch10-01-how-to-write-tests.md:146 src/ch10-01-how-to-write-tests.md:228
#: src/ch10-01-how-to-write-tests.md:340 src/ch10-01-how-to-write-tests.md:564
#: src/ch10-01-how-to-write-tests.md:658 src/ch10-01-how-to-write-tests.md:747
msgid "<span class=\"filename\">Filename: src/lib.cairo</span>"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:22
#: src/ch02-01-variables-and-mutability.md:24
#: src/ch02-01-variables-and-mutability.md:89
#: src/ch02-01-variables-and-mutability.md:91
#: src/ch02-01-variables-and-mutability.md:248
#: src/ch02-01-variables-and-mutability.md:250 src/ch02-03-functions.md:71
#: src/ch02-03-functions.md:287 src/ch02-03-functions.md:325
#: src/ch02-03-functions.md:341
msgid "\"The value of x is: {}\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:29
msgid ""
"Save and run the program using `scarb cairo-run`. You should receive an "
"error message regarding an immutability error, as shown in this output:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:45
msgid ""
"This example shows how the compiler helps you find errors in your programs. "
"Compiler errors can be frustrating, but they only mean your program isn’t "
"safely doing what you want it to do yet; they do _not_ mean that you’re not "
"a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"You received the error message `Cannot assign to an immutable variable.` "
"because you tried to assign a second value to the immutable `x` variable."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:53
msgid ""
"It’s important that we get compile-time errors when we attempt to change a "
"value that’s designated as immutable because this specific situation can "
"lead to bugs. If one part of our code operates on the assumption that a "
"value will never change and another part of our code changes that value, "
"it’s possible that the first part of the code won’t do what it was designed "
"to do. The cause of this kind of bug can be difficult to track down after "
"the fact, especially when the second piece of code changes the value only "
"_sometimes_."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:61
msgid ""
"Cairo, unlike most other languages, has immutable memory. This makes a whole "
"class of bugs impossible, because values will never change unexpectedly. "
"This makes code easier to reason about."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:65
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write. Although variables are immutable by default, you can make them "
"mutable by adding `mut` in front of the variable name. Adding `mut` also "
"conveys intent to future readers of the code by indicating that other parts "
"of the code will be changing the value associated to this variable."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:73
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable is declared as `mut`, as we previously mentioned that Cairo's "
"memory is immutable. The answer is that the _value_ is immutable, but the "
"_variable_ isn't. The value associated to the variable can be changed. "
"Assigning to a mutable variable in Cairo is essentially equivalent to "
"redeclaring it to refer to another value in another memory cell, but the "
"compiler handles that for you, and the keyword `mut` makes it explicit. Upon "
"examining the low-level Cairo Assembly code, it becomes clear that variable "
"mutation is implemented as syntactic sugar, which translates mutation "
"operations into a series of steps equivalent to variable shadowing. The only "
"difference is that at the Cairo level, the variable is not redeclared so its "
"type cannot change."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:84
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:95
msgid "When we run the program now, we get this:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:108
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is "
"used. Ultimately, deciding whether to use mutability or not is up to you and "
"depends on what you think is clearest in that particular situation."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:112
msgid "Constants"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:114
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and are not allowed to change, but there are a few differences between "
"constants and variables."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:118
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just "
"immutable by default—they’re always immutable. You declare constants using "
"the `const` keyword instead of the `let` keyword, and the type of the value "
"_must_ be annotated. We’ll cover types and type annotations in the next "
"section, [“Data Types”](./ch02-02-data-types.md), so don’t worry about the "
"details right now. Just know that you must always annotate the type."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:125
msgid ""
"Constant variables can be declared with any usual data type, including "
"structs, enums and fixed-size arrays."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:127
msgid ""
"Constants can only be declared in the global scope, which makes them useful "
"for values that many parts of code need to know about."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:130
msgid ""
"The last difference is that constants may natively be set only to a constant "
"expression, not the result of a value that could only be computed at runtime."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:133
msgid "Here’s an example of constants declaration:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:152
msgid ""
"Nonetheless, it is possible to use the `consteval_int!` macro to create a "
"`const` variable that is the result of some computation:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:158
msgid ""
"We will dive into more detail about macros in the [dedicated "
"section](./ch11-05-macros.md)."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:160
msgid ""
"Cairo's naming convention for constants is to use all uppercase with "
"underscores between words."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:162
msgid ""
"Constants are valid for the entire time a program runs, within the scope in "
"which they were declared. This property makes constants useful for values in "
"your application domain that multiple parts of the program might need to "
"know about, such as the maximum number of points any player of a game is "
"allowed to earn, or the speed of light."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:168
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in conveying the meaning of that value to future maintainers of the code. It "
"also helps to have only one place in your code you would need to change if "
"the hardcoded value needed to be updated in the future."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:175
msgid "Shadowing"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:177
msgid ""
"Variable shadowing refers to the declaration of a new variable with the same "
"name as a previous variable. Caironautes say that the first variable is "
"_shadowed_ by the second, which means that the second variable is what the "
"compiler will see when you use the name of the variable. In effect, the "
"second variable overshadows the first, taking any uses of the variable name "
"to itself until either it itself is shadowed or the scope ends. We can "
"shadow a variable by using the same variable’s name and repeating the use of "
"the `let` keyword as follows:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:192
msgid "\"Inner scope x value is: {}\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:194
msgid "\"Outer scope x value is: {}\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:198
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable `x` by repeating `let x =`, taking the original value and adding "
"`1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and "
"creates a new variable, multiplying the previous value by `2` to give `x` a "
"value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the following:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:217
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a "
"compile-time error if we accidentally try to reassign to this variable "
"without using the `let` keyword. By using `let`, we can perform a few "
"transformations on a value but have the variable be immutable after those "
"transformations have been completed."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:223
msgid ""
"Another distinction between `mut` and shadowing is that when we use the "
"`let` keyword again, we are effectively creating a new variable, which "
"allows us to change the type of the value while reusing the same name. As "
"mentioned before, variable shadowing and mutable variables are equivalent at "
"the lower level. The only difference is that by shadowing a variable, the "
"compiler will not complain if you change its type. For example, say our "
"program performs a type conversion between the `u64` and `felt252` types."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:234
msgid "\"The value of x is {} of type u64\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:235
msgid "// converts x to a felt, type annotation is required.\n"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:236
msgid "\"The value of x is {} of type felt252\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:240
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type. Shadowing thus spares us from having to come up with "
"different names, such as `x_u64` and `x_felt252`; instead, we can reuse the "
"simpler `x` name. However, if we try to use `mut` for this, as shown here, "
"we’ll get a compile-time error:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:254
msgid ""
"The error says we were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:269
msgid "{{#quiz ../quizzes/ch02-01-variables-and-mutability.toml}}"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:271
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they can have."
msgstr ""

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what "
"kind of data is being specified so it knows how to work with that data. This "
"section covers two subsets of data types: scalars and compounds."
msgstr ""

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that "
"it must know the types of all variables at compile time. The compiler can "
"usually infer the desired type based on the value and its usage. In cases "
"when many types are possible, we can use a cast method where we specify the "
"desired output type."
msgstr ""

#: src/ch02-02-data-types.md:16
msgid "You’ll see different type annotations for other data types."
msgstr ""

#: src/ch02-02-data-types.md:18
msgid "Scalar Types"
msgstr ""

#: src/ch02-02-data-types.md:20
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar "
"types: felts, integers, and booleans. You may recognize these from other "
"programming languages. Let’s jump into how they work in Cairo."
msgstr ""

#: src/ch02-02-data-types.md:24
msgid "Felt Type"
msgstr ""

#: src/ch02-02-data-types.md:26
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the "
"context of Cairo, when we say “a field element” we mean an integer in the "
"range \\\\( 0 \\leq x \\< P \\\\), where \\\\( P \\\\) is a very large prime "
"number currently equal to \\\\( {2^{251}} + 17 \\cdot {2^{192}} + 1 \\\\). "
"When adding, subtracting, or multiplying, if the result falls outside the "
"specified range of the prime number, an overflow (or underflow) occurs, and "
"an appropriate multiple of \\\\( P \\\\) is added or subtracted to bring the "
"result back within the range (i.e., the result is computed \\\\( \\mod P "
"\\\\) )."
msgstr ""

#: src/ch02-02-data-types.md:29
msgid ""
"The most important difference between integers and field elements is "
"division: Division of field elements (and therefore division in Cairo) is "
"unlike regular CPUs division, where integer division \\\\( \\frac{x}{y} "
"\\\\) is defined as \\\\( \\left\\lfloor \\frac{x}{y} \\right\\rfloor \\\\) "
"where the integer part of the quotient is returned (so you get \\\\( "
"\\frac{7}{3} = 2 \\\\)) and it may or may not satisfy the equation \\\\( "
"\\frac{x}{y} \\cdot y == x \\\\), depending on the divisibility of `x` by "
"`y`."
msgstr ""

#: src/ch02-02-data-types.md:34
msgid ""
"In Cairo, the result of \\\\( \\frac{x}{y} \\\\) is defined to always "
"satisfy the equation \\\\( \\frac{x}{y} \\cdot y == x \\\\). If y divides x "
"as integers, you will get the expected result in Cairo (for example \\\\( "
"\\frac{6}{2} \\\\) will indeed result in `3`). But when y does not divide x, "
"you may get a surprising result: for example, since \\\\( 2 \\cdot \\frac{P "
"+ 1}{2} = P + 1 \\equiv 1 \\mod P \\\\), the value of \\\\( \\frac{1}{2} "
"\\\\) in Cairo is \\\\( \\frac{P + 1}{2} \\\\) (and not 0 or 0.5), as it "
"satisfies the above equation."
msgstr ""

#: src/ch02-02-data-types.md:37
msgid "Integer Types"
msgstr ""

#: src/ch02-02-data-types.md:39
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating "
"all types in the core library. However, it is highly recommended for "
"programmers to use the integer types instead of the `felt252` type whenever "
"possible, as the `integer` types come with added security features that "
"provide extra protection against potential vulnerabilities in the code, such "
"as overflow and underflow checks. By using these integer types, programmers "
"can ensure that their programs are more secure and less susceptible to "
"attacks or other security threats. An `integer` is a number without a "
"fractional component. This type declaration indicates the number of bits the "
"programmer can use to store the integer. Table 3-1 shows the built-in "
"integer types in Cairo. We can use any of these variants to declare the type "
"of an integer value."
msgstr ""

#: src/ch02-02-data-types.md:44
msgid "Length"
msgstr ""

#: src/ch02-02-data-types.md:44
msgid "Unsigned"
msgstr ""

#: src/ch02-02-data-types.md:46
msgid "8-bit"
msgstr ""

#: src/ch02-02-data-types.md:46
msgid "`u8`"
msgstr ""

#: src/ch02-02-data-types.md:47
msgid "16-bit"
msgstr ""

#: src/ch02-02-data-types.md:47
msgid "`u16`"
msgstr ""

#: src/ch02-02-data-types.md:48 src/ch02-02-data-types.md:52
msgid "32-bit"
msgstr ""

#: src/ch02-02-data-types.md:48
msgid "`u32`"
msgstr ""

#: src/ch02-02-data-types.md:49
msgid "64-bit"
msgstr ""

#: src/ch02-02-data-types.md:49
msgid "`u64`"
msgstr ""

#: src/ch02-02-data-types.md:50
msgid "128-bit"
msgstr ""

#: src/ch02-02-data-types.md:50
msgid "`u128`"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid "256-bit"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid "`u256`"
msgstr ""

#: src/ch02-02-data-types.md:52
msgid "`usize`"
msgstr ""

#: src/ch02-02-data-types.md:57
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is "
"just an alias for `u32`; however, it might be useful when in the future "
"Cairo can be compiled to MLIR. As variables are unsigned, they can't contain "
"a negative number. This code will cause the program to panic:"
msgstr ""

#: src/ch02-02-data-types.md:70
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for "
"`u256` which needs 4 more bits to be stored. Under the hood, `u256` is "
"basically a struct with 2 fields: `u256 {low: u128, high: u128}`."
msgstr ""

#: src/ch02-02-data-types.md:72
msgid ""
"Cairo also provides support for signed integers, starting with the prefix "
"`i`. These integers can represent both positive and negative values, with "
"sizes ranging from `i8` to `i128`. Each signed variant can store numbers "
"from \\\\( -({2^{n - 1}}) \\\\) to \\\\( {2^{n - 1}} - 1 \\\\) inclusive, "
"where `n` is the number of bits that variant uses. So an i8 can store "
"numbers from \\\\( -({2^7}) \\\\) to \\\\( {2^7} - 1 \\\\), which equals "
"`-128` to `127`."
msgstr ""

#: src/ch02-02-data-types.md:75
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note "
"that number literals that can be multiple numeric types allow a type suffix, "
"such as `57_u8`, to designate the type. It is also possible to use a visual "
"separator `_` for number literals, in order to improve code readability."
msgstr ""

#: src/ch02-02-data-types.md:80
msgid "Numeric literals"
msgstr ""

#: src/ch02-02-data-types.md:80 src/appendix-02-operators-and-symbols.md:9
#: src/appendix-08-system-calls.md:177 src/appendix-08-system-calls.md:256
#: src/appendix-08-system-calls.md:331
msgid "Example"
msgstr ""

#: src/ch02-02-data-types.md:82
msgid "Decimal"
msgstr ""

#: src/ch02-02-data-types.md:82
msgid "`98222`"
msgstr ""

#: src/ch02-02-data-types.md:83
msgid "Hex"
msgstr ""

#: src/ch02-02-data-types.md:83
msgid "`0xff`"
msgstr ""

#: src/ch02-02-data-types.md:84
msgid "Octal"
msgstr ""

#: src/ch02-02-data-types.md:84
msgid "`0o04321`"
msgstr ""

#: src/ch02-02-data-types.md:85
msgid "Binary"
msgstr ""

#: src/ch02-02-data-types.md:85
msgid "`0b01`"
msgstr ""

#: src/ch02-02-data-types.md:90
msgid ""
"So how do you know which type of integer to use? Try to estimate the max "
"value your int can have and choose the good size. The primary situation in "
"which you’d use `usize` is when indexing some sort of collection."
msgstr ""

#: src/ch02-02-data-types.md:93
msgid "Numeric Operations"
msgstr ""

#: src/ch02-02-data-types.md:95
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the "
"integer types: addition, subtraction, multiplication, division, and "
"remainder. Integer division truncates toward zero to the nearest integer. "
"The following code shows how you’d use each numeric operation in a `let` "
"statement:"
msgstr ""

#: src/ch02-02-data-types.md:102
msgid "// addition\n"
msgstr ""

#: src/ch02-02-data-types.md:105
msgid "// subtraction\n"
msgstr ""

#: src/ch02-02-data-types.md:108
msgid "// multiplication\n"
msgstr ""

#: src/ch02-02-data-types.md:111
msgid "// division\n"
msgstr ""

#: src/ch02-02-data-types.md:112
msgid "//result is 1\n"
msgstr ""

#: src/ch02-02-data-types.md:113
msgid "//result is 2\n"
msgstr ""

#: src/ch02-02-data-types.md:115
msgid "// remainder\n"
msgstr ""

#: src/ch02-02-data-types.md:116
msgid "// result is 3\n"
msgstr ""

#: src/ch02-02-data-types.md:120
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates to a single value, which is then bound to a variable."
msgstr ""

#: src/ch02-02-data-types.md:123
msgid ""
"[Appendix B](./appendix-02-operators-and-symbols.md#operators) contains a "
"list of all operators that Cairo provides."
msgstr ""

#: src/ch02-02-data-types.md:127
msgid "The Boolean Type"
msgstr ""

#: src/ch02-02-data-types.md:129
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two "
"possible values: `true` and `false`. Booleans are one `felt252` in size. The "
"Boolean type in Cairo is specified using `bool`. For example:"
msgstr ""

#: src/ch02-02-data-types.md:137
msgid "// with explicit type annotation\n"
msgstr ""

#: src/ch02-02-data-types.md:141
msgid ""
"When declaring a `bool` variable, it is mandatory to use either `true` or "
"`false` literals as value. Hence, it is not allowed to use integer literals "
"(i.e. `0` instead of false) for `bool` declarations."
msgstr ""

#: src/ch02-02-data-types.md:143
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` "
"expression. We’ll cover how `if` expressions work in Cairo in the [\"Control "
"Flow\"](./ch02-05-control-flow.md) section."
msgstr ""

#: src/ch02-02-data-types.md:148
msgid "String Types"
msgstr ""

#: src/ch02-02-data-types.md:150
msgid ""
"Cairo doesn't have a native type for strings but provides two ways to handle "
"them: short strings using simple quotes and ByteArray using double quotes."
msgstr ""

#: src/ch02-02-data-types.md:152
msgid "Short strings"
msgstr ""

#: src/ch02-02-data-types.md:154
msgid ""
"A short string is an ASCII string where each character is encoded on one "
"byte (see the [ASCII table](https://www.asciitable.com/)). For example:"
msgstr ""

#: src/ch02-02-data-types.md:156
msgid "`'a'` is equivalent to `0x61`"
msgstr ""

#: src/ch02-02-data-types.md:157
msgid "`'b'` is equivalent to `0x62`"
msgstr ""

#: src/ch02-02-data-types.md:158
msgid "`'c'` is equivalent to `0x63`"
msgstr ""

#: src/ch02-02-data-types.md:159
msgid "`0x616263` is equivalent to `'abc'`."
msgstr ""

#: src/ch02-02-data-types.md:161
msgid ""
"Cairo uses the `felt252` for short strings. As the `felt252` is on 251 bits, "
"a short string is limited to 31 characters (31 \\* 8 = 248 bits, which is "
"the maximum multiple of 8 that fits in 251 bits)."
msgstr ""

#: src/ch02-02-data-types.md:163
msgid ""
"You can choose to represent your short string with an hexadecimal value like "
"`0x616263` or by directly writing the string using simple quotes like "
"`'abc'`, which is more convenient."
msgstr ""

#: src/ch02-02-data-types.md:165
msgid "Here are some examples of declaring short strings in Cairo:"
msgstr ""

#: src/ch02-02-data-types.md:169 src/ch02-02-data-types.md:187
msgid "'C'"
msgstr ""

#: src/ch02-02-data-types.md:175 src/ch02-02-data-types.md:193
msgid "\"this is a string which has more than 31 characters\""
msgstr ""

#: src/ch02-02-data-types.md:181
msgid "Byte Array Strings"
msgstr ""

#: src/ch02-02-data-types.md:183
msgid ""
"With the `ByteArray` struct added in Cairo 2.4.0, you are not limited to 31 "
"characters anymore. These `ByteArray` strings are written in double quotes "
"like in the following example:"
msgstr ""

#: src/ch02-02-data-types.md:197
msgid "Type Casting"
msgstr ""

#: src/ch02-02-data-types.md:199
msgid ""
"In Cairo, you can convert scalar types from one type to another by using the "
"`try_into` and `into` methods provided by the `TryInto` and `Into` traits "
"from the core library."
msgstr ""

#: src/ch02-02-data-types.md:201
msgid ""
"The `try_into` method allows for safe type casting when the target type "
"might not fit the source value. Keep in mind that `try_into` returns an "
"`Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""

#: src/ch02-02-data-types.md:203
msgid ""
"On the other hand, the `into` method can be used for type casting when "
"success is guaranteed, such as when the source type is smaller than the "
"destination type."
msgstr ""

#: src/ch02-02-data-types.md:205
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the "
"source value to cast it to another type. The new variable's type must be "
"explicitly defined, as demonstrated in the example below."
msgstr ""

#: src/ch02-02-data-types.md:210
msgid ""
"// Since a felt252 might not fit in a u8, we need to unwrap the Option<T> "
"type\n"
msgstr ""

#: src/ch02-02-data-types.md:216
msgid "// As a felt252 is smaller than a u256, we can use the into() method\n"
msgstr ""

#: src/ch02-02-data-types.md:224
msgid "The Tuple Type"
msgstr ""

#: src/ch02-02-data-types.md:226
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a "
"variety of types into one compound type. Tuples have a fixed length: once "
"declared, they cannot grow or shrink in size."
msgstr ""

#: src/ch02-02-data-types.md:230
msgid ""
"We create a tuple by writing a comma-separated list of values inside "
"parentheses. Each position in the tuple has a type, and the types of the "
"different values in the tuple don’t have to be the same. We’ve added "
"optional type annotations in this example:"
msgstr ""

#: src/ch02-02-data-types.md:241
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a "
"single compound element. To get the individual values out of a tuple, we can "
"use pattern matching to destructure a tuple value, like this:"
msgstr ""

#: src/ch02-02-data-types.md:252
msgid "\"y is 6!\""
msgstr ""

#: src/ch02-02-data-types.md:257
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then uses a pattern with `let` to take `tup` and turn it into three separate "
"variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints `y is "
"6!` as the value of `y` is `6`."
msgstr ""

#: src/ch02-02-data-types.md:263
msgid ""
"We can also declare the tuple with value and types, and destructure it at "
"the same time. For example:"
msgstr ""

#: src/ch02-02-data-types.md:272
msgid "The Unit Type ()"
msgstr ""

#: src/ch02-02-data-types.md:274
msgid ""
"A _unit type_ is a type which has only one value `()`. It is represented by "
"a tuple with no elements. Its size is always zero, and it is guaranteed to "
"not exist in the compiled code."
msgstr ""

#: src/ch02-02-data-types.md:278
msgid ""
"You might be wondering why you would even need a unit type? In Cairo, "
"everything is an expression, and an expression that returns nothing actually "
"returns `()` implicitly."
msgstr ""

#: src/ch02-02-data-types.md:280
msgid "{{#quiz ../quizzes/ch02-02-data-types.toml}}"
msgstr ""

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry "
"point of many programs. You’ve also seen the `fn` keyword, which allows you "
"to declare new functions."
msgstr ""

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr ""

#: src/ch02-03-functions.md:14
msgid "\"Another function.\""
msgstr ""

#: src/ch02-03-functions.md:18
msgid "\"Hello, world!\""
msgstr ""

#: src/ch02-03-functions.md:23
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr ""

#: src/ch02-03-functions.md:27
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it "
"can be called from inside the `main` function. Note that we defined "
"`another_function` _before_ the `main` function in the source code; we could "
"have defined it after as well. Cairo doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr ""

#: src/ch02-03-functions.md:34
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions "
"further. Place the `another_function` example in _src/lib.cairo_ and run it. "
"You should see the following output:"
msgstr ""

#: src/ch02-03-functions.md:49
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the `Hello, world!` message prints, and then `another_function` is "
"called and its message is printed."
msgstr ""

#: src/ch02-03-functions.md:53
msgid "Parameters"
msgstr ""

#: src/ch02-03-functions.md:55
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you "
"can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr ""

#: src/ch02-03-functions.md:63
msgid "In this version of `another_function` we add a parameter:"
msgstr ""

#: src/ch02-03-functions.md:75
msgid "Try running this program; you should get the following output:"
msgstr ""

#: src/ch02-03-functions.md:87
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `felt252`. When we pass `5` in to `another_function`, "
"the `println!` macro puts `5` where the pair of curly brackets containing "
"`x` was in the format string."
msgstr ""

#: src/ch02-03-functions.md:91
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Cairo’s design: requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also "
"able to give more helpful error messages if it knows what types the function "
"expects."
msgstr ""

#: src/ch02-03-functions.md:97
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr ""

#: src/ch02-03-functions.md:102
msgid "\"h\""
msgstr ""

#: src/ch02-03-functions.md:106
msgid "\"The measurement is: {value}{unit_label}\""
msgstr ""

#: src/ch02-03-functions.md:110
msgid ""
"This example creates a function named `print_labeled_measurement` with two "
"parameters. The first parameter is named `value` and is a `u128`. The second "
"is named `unit_label` and is of type `ByteArray` - Cairo's internal type to "
"represent string literals. The function then prints text containing both the "
"`value` and the `unit_label`."
msgstr ""

#: src/ch02-03-functions.md:114
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/lib.cairo_ file with the preceding example and "
"run it using `scarb cairo-run`:"
msgstr ""

#: src/ch02-03-functions.md:127
msgid ""
"Because we called the function with `5` as the value for value and `\"h\"` "
"as the value for `unit_label`, the program output contains those values."
msgstr ""

#: src/ch02-03-functions.md:129
msgid "Named Parameters"
msgstr ""

#: src/ch02-03-functions.md:131
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when "
"you call a function. This makes the function calls more readable and "
"self-descriptive. If you want to use named parameters, you need to specify "
"the name of the parameter and the value you want to pass to it. The syntax "
"is `parameter_name: value`. If you pass a variable that has the same name as "
"the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""

#: src/ch02-03-functions.md:134
#: src/ch09-01-unrecoverable-errors-with-panic.md:72
#: src/ch09-02-recoverable-errors.md:141
#: src/appendix-03-derivable-traits.md:151
#: src/appendix-03-derivable-traits.md:200
msgid "Here is an example:"
msgstr ""

#: src/ch02-03-functions.md:149
msgid "Statements and Expressions"
msgstr ""

#: src/ch02-03-functions.md:151
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Cairo is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions, "
"so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr ""

#: src/ch02-03-functions.md:159
msgid ""
"**Statements** are instructions that perform some action and do not return a "
"value."
msgstr ""

#: src/ch02-03-functions.md:161
msgid ""
"**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr ""

#: src/ch02-03-functions.md:163
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 2-1, `let y = 6;` is a statement."
msgstr ""

#: src/ch02-03-functions.md:173
msgid ""
"<span class=\"caption\">Listing 2-1: A `main` function declaration "
"containing one statement</span>"
msgstr ""

#: src/ch02-03-functions.md:175
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself."
msgstr ""

#: src/ch02-03-functions.md:177
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get "
"an error:"
msgstr ""

#: src/ch02-03-functions.md:186
msgid "When you run this program, the error you’ll get looks like this:"
msgstr ""

#: src/ch02-03-functions.md:226
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Cairo."
msgstr ""

#: src/ch02-03-functions.md:232
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Cairo. Consider a math operation, such as `5 + 6`, "
"which is an expression that evaluates to the value `11`. Expressions can be "
"part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is "
"an expression that evaluates to the value `6`."
msgstr ""

#: src/ch02-03-functions.md:238
msgid ""
"Calling a function is an expression since it always evaluates to a value: "
"the function's explicit return value, if specified, or the 'unit' type `()` "
"otherwise."
msgstr ""

#: src/ch02-03-functions.md:240
msgid ""
"A new scope block created with curly brackets is an expression, for example:"
msgstr ""

#: src/ch02-03-functions.md:249
msgid "\"The value of y is: {}\""
msgstr ""

#: src/ch02-03-functions.md:253
msgid "This expression:"
msgstr ""

#: src/ch02-03-functions.md:262
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note that the `x + 1` line doesn’t have "
"a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to "
"the end of an expression, you turn it into a statement, and it will then not "
"return a value. Keep this in mind as you explore function return values and "
"expressions next."
msgstr ""

#: src/ch02-03-functions.md:270
msgid "Functions with Return Values"
msgstr ""

#: src/ch02-03-functions.md:272
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Cairo, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr ""

#: src/ch02-03-functions.md:291
msgid ""
"There are no function calls, or even `let` statements in the `five` "
"function—just the number `5` by itself. That’s a perfectly valid function in "
"Cairo. Note that the function’s return type is specified too, as `-> u32`. "
"Try running this code; the output should look like this:"
msgstr ""

#: src/ch02-03-functions.md:306
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `u32`. Let’s examine this in more detail. There are two important "
"bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr ""

#: src/ch02-03-functions.md:316
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon "
"because it’s an expression whose value we want to return. Let’s look at "
"another example:"
msgstr ""

#: src/ch02-03-functions.md:333
msgid ""
"Running this code will print `x = 6`. But if we place a semicolon at the end "
"of the line containing `x + 1`, changing it from an expression to a "
"statement, we’ll get an error:"
msgstr ""

#: src/ch02-03-functions.md:349
msgid ""
"```shell\n"
"$ scarb cairo-run \n"
"   Compiling no_listing_22_function_return_invalid v0.1.0 "
"(listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml)\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: "
"\"()\".\n"
" --> "
"listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:9:28\n"
"fn plus_one(x: u32) -> u32 {\n"
"                           ^\n"
"\n"
"error: could not compile `no_listing_22_function_return_invalid` due to "
"previous error\n"
"error: `scarb metadata` exited with error\n"
"\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:362
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue "
"with this code. The definition of the function `plus_one` says that it will "
"return an `u32`, but statements don’t evaluate to a value, which is "
"expressed by `()`, the unit type. Therefore, nothing is returned, which "
"contradicts the function definition and results in an error."
msgstr ""

#: src/ch02-03-functions.md:368
msgid "{{#quiz ../quizzes/ch02-03-functions.toml}}"
msgstr ""

#: src/ch02-04-comments.md:3
msgid ""
"All programmers strive to make their code easy to understand, but sometimes "
"extra explanation is warranted. In these cases, programmers leave comments "
"in their source code that the compiler will ignore but people reading the "
"source code may find useful."
msgstr ""

#: src/ch02-04-comments.md:5
msgid "Here’s a simple comment:"
msgstr ""

#: src/ch02-04-comments.md:8
msgid "// hello, world\n"
msgstr ""

#: src/ch02-04-comments.md:11
msgid ""
"In Cairo, the idiomatic comment style starts a comment with two slashes, and "
"the comment continues until the end of the line. For comments that extend "
"beyond a single line, you’ll need to include `//` on each line, like this:"
msgstr ""

#: src/ch02-04-comments.md:14
msgid ""
"// So we’re doing something complicated here, long enough that we need\n"
"// multiple lines of comments to do it! Whew! Hopefully, this comment will\n"
"// explain what’s going on.\n"
msgstr ""

#: src/ch02-04-comments.md:19
msgid "Comments can also be placed at the end of lines containing code:"
msgstr ""

#: src/ch02-04-comments.md:23
msgid "// return the sum of 1 and 4\n"
msgstr ""

#: src/ch02-04-comments.md:27
msgid ""
"But you’ll more often see them used in this format, with the comment on a "
"separate line above the code it’s annotating:"
msgstr ""

#: src/ch02-04-comments.md:31
msgid "// this function performs a simple addition\n"
msgstr ""

#: src/ch02-04-comments.md:36
msgid "Item-level Documentation"
msgstr ""

#: src/ch02-04-comments.md:38
msgid ""
"Item-level documentation comments refer to specific items such as functions, "
"implementations, traits, etc. They are prefixed with three slashes (`///`). "
"These comments provide a detailed description of the item, examples of "
"usage, and any conditions that might cause a panic. In case of functions, "
"the comments may also include separate sections for parameter and return "
"value descriptions."
msgstr ""

#: src/ch02-04-comments.md:41
msgid ""
"/// Returns the sum of `arg1` and `arg2`.\n"
"/// `arg1` cannot be zero.\n"
"///\n"
"/// # Panics\n"
"///\n"
"/// This function will panic if `arg1` is `0`.\n"
"///\n"
"/// # Examples\n"
"///\n"
"/// ```\n"
"/// let a: felt252 = 2;\n"
"/// let b: felt252 = 3;\n"
"/// let c: felt252 = add(a, b);\n"
"/// assert(c == a + b, \"Should equal a + b\");\n"
"/// ```\n"
msgstr ""

#: src/ch02-04-comments.md:62
msgid "Module Documentation"
msgstr ""

#: src/ch02-04-comments.md:64
msgid ""
"Module documentation comments provide an overview of the entire module, "
"including its purpose and examples of use. These comments are meant to be "
"placed above the module they're describing and are prefixed with `//!`. This "
"type of documentation gives a broad understanding of what the module does "
"and how it can be used."
msgstr ""

#: src/ch02-04-comments.md:67
msgid ""
"//! # my_module and implementation\n"
"//!\n"
"//! This is an example description of my_module and some of its features.\n"
"//!\n"
"//! # Examples\n"
"//!\n"
"//! ```\n"
"//! mod my_other_module {\n"
"//!   use path::to::my_module;\n"
"//!\n"
"//!   fn foo() {\n"
"//!     my_module.bar();\n"
"//!   }\n"
"//! }\n"
"//! ```\n"
msgstr ""

#: src/ch02-04-comments.md:82
msgid "// rest of implementation...\n"
msgstr ""

#: src/ch02-04-comments.md:86
msgid "{{#quiz ../quizzes/ch02-04-comments.toml}}"
msgstr ""

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to "
"run some code repeatedly while a condition is true are basic building blocks "
"in most programming languages. The most common constructs that let you "
"control the flow of execution of Cairo code are if expressions and loops."
msgstr ""

#: src/ch02-05-control-flow.md:5
msgid "`if` Expressions"
msgstr ""

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You "
"provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr ""

#: src/ch02-05-control-flow.md:9
msgid ""
"Create a new project called _branches_ in your _cairo_projects_ directory to "
"explore the `if` expression. In the _src/lib.cairo_ file, input the "
"following:"
msgstr ""

#: src/ch02-05-control-flow.md:16
msgid "\"condition was true and number = {}\""
msgstr ""

#: src/ch02-05-control-flow.md:18
msgid "\"condition was false and number = {}\""
msgstr ""

#: src/ch02-05-control-flow.md:23
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value equal to 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets."
msgstr ""

#: src/ch02-05-control-flow.md:25
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the "
"condition evaluate to `false`. If you don’t provide an `else` expression and "
"the condition is `false`, the program will just skip the `if` block and move "
"on to the next bit of code."
msgstr ""

#: src/ch02-05-control-flow.md:27
msgid "Try running this code; you should see the following output:"
msgstr ""

#: src/ch02-05-control-flow.md:39
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition "
"`true` to see what happens:"
msgstr ""

#: src/ch02-05-control-flow.md:51
msgid ""
"It’s also worth noting that the condition in this code must be a `bool`. If "
"the condition isn’t a `bool`, we’ll get an error. For example, try running "
"the following code:"
msgstr ""

#: src/ch02-05-control-flow.md:58
msgid "\"number was three\""
msgstr ""

#: src/ch02-05-control-flow.md:63
msgid ""
"The `if` condition evaluates to a value of 3 this time, and Cairo throws an "
"error:"
msgstr ""

#: src/ch02-05-control-flow.md:77
msgid ""
"The error indicates that Cairo inferred the type of `number` to be a `bool` "
"based on its later use as a condition of the `if` statement. It tries to "
"create a `bool` from the value `3`, but Cairo doesn't support instantiating "
"a `bool` from a numeric literal anyway - you can only use `true` or `false` "
"to create a `bool`. Unlike languages such as Ruby and JavaScript, Cairo will "
"not automatically try to convert non-Boolean types to a Boolean. If we want "
"the `if` code block to run only when a number is not equal to 0, for "
"example, we can change the if expression to the following:"
msgstr ""

#: src/ch02-05-control-flow.md:91
msgid "\"number was something other than zero\""
msgstr ""

#: src/ch02-05-control-flow.md:97
msgid "Running this code will print `number was something other than zero`."
msgstr ""

#: src/ch02-05-control-flow.md:99
msgid "Handling Multiple Conditions with `else if`"
msgstr ""

#: src/ch02-05-control-flow.md:101
msgid ""
"You can use multiple conditions by combining `if` and `else` in an `else if` "
"expression. For example:"
msgstr ""

#: src/ch02-05-control-flow.md:108
msgid "\"number is 12\""
msgstr ""

#: src/ch02-05-control-flow.md:110
msgid "\"number is 3\""
msgstr ""

#: src/ch02-05-control-flow.md:112
msgid "\"number minus 2 is 1\""
msgstr ""

#: src/ch02-05-control-flow.md:114
msgid "\"number not found\""
msgstr ""

#: src/ch02-05-control-flow.md:119
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr ""

#: src/ch02-05-control-flow.md:131
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1` nor do we see the `number not found` text from the "
"`else` block. That’s because Cairo only executes the block for the first "
"true condition, and once it finds one, it doesn’t even check the rest. Using "
"too many `else if` expressions can clutter your code, so if you have more "
"than one, you might want to refactor your code. [Chapter "
"6](./ch06-02-the-match-control-flow-construct.md) describes a powerful Cairo "
"branching construct called `match` for these cases."
msgstr ""

#: src/ch02-05-control-flow.md:135
msgid "Using `if` in a `let` Statement"
msgstr ""

#: src/ch02-05-control-flow.md:137
msgid ""
"Because `if` is an expression, we can use it on the right side of a `let` "
"statement to assign the outcome to a variable."
msgstr ""

#: src/ch02-05-control-flow.md:149
msgid "\"condition was true and number is {}\""
msgstr ""

#: src/ch02-05-control-flow.md:164
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression, which will be 5 here."
msgstr ""

#: src/ch02-05-control-flow.md:166
msgid "Repetition with Loops"
msgstr ""

#: src/ch02-05-control-flow.md:168
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Cairo provides a simple loop syntax, which will run through the code inside "
"the loop body to the end and then start immediately back at the beginning. "
"To experiment with loops, let’s create a new project called _loops_."
msgstr ""

#: src/ch02-05-control-flow.md:170
msgid "Cairo has two kinds of loops: `loop` and `while`."
msgstr ""

#: src/ch02-05-control-flow.md:172
msgid "Repeating Code with `loop`"
msgstr ""

#: src/ch02-05-control-flow.md:174
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over "
"again forever or until you explicitly tell it to stop."
msgstr ""

#: src/ch02-05-control-flow.md:176
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to "
"look like this:"
msgstr ""

#: src/ch02-05-control-flow.md:181
msgid "\"again!\""
msgstr ""

#: src/ch02-05-control-flow.md:189
msgid ""
"Note: This program would not compile without a break condition. For the "
"purpose of the example, we added a `break` statement that will never be "
"reached, but satisfies the compiler."
msgstr ""

#: src/ch02-05-control-flow.md:191
msgid ""
"When we run this program, we’ll see `again!` printed over and over "
"continuously until either the program runs out of gas or we stop the program "
"manually. Most terminals support the keyboard shortcut ctrl-c to interrupt a "
"program that is stuck in a continual loop. Give it a try:"
msgstr ""

#: src/ch02-05-control-flow.md:193
msgid ""
"```shell\n"
"$ scarb cairo-run --available-gas=20000000\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished release target(s) in 0 seconds\n"
"     Running loops\n"
"again!\n"
"again!\n"
"again!\n"
"^Cagain!\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:204
msgid ""
"The symbol `^C` represents where you pressed ctrl-c. You may or may not see "
"the word `again!` printed after the ^C, depending on where the code was in "
"the loop when it received the interrupt signal."
msgstr ""

#: src/ch02-05-control-flow.md:206
msgid ""
"Note: Cairo prevents us from running program with infinite loops by "
"including a gas meter. The gas meter is a mechanism that limits the amount "
"of computation that can be done in a program. By setting a value to the "
"`--available-gas` flag, we can set the maximum amount of gas available to "
"the program. Gas is a unit of measurement that expresses the computation "
"cost of an instruction. When the gas meter runs out, the program will stop. "
"In the previous case, we set the gas limit high enough for the program to "
"run for quite some time."
msgstr ""

#: src/ch02-05-control-flow.md:208
msgid ""
"It is particularly important in the context of smart contracts deployed on "
"Starknet, as it prevents from running infinite loops on the network. If "
"you're writing a program that needs to run a loop, you will need to execute "
"it with the `--available-gas` flag set to a value that is large enough to "
"run the program."
msgstr ""

#: src/ch02-05-control-flow.md:211
msgid ""
"Now, try running the same program again, but this time with the "
"`--available-gas` flag set to `200000` instead of `2000000000000`. You will "
"see the program only prints `again!` 3 times before it stops, as it ran out "
"of gas to keep executing the loop."
msgstr ""

#: src/ch02-05-control-flow.md:213
msgid ""
"Fortunately, Cairo also provides a way to break out of a loop using code. "
"You can place the `break` keyword within the loop to tell the program when "
"to stop executing the loop."
msgstr ""

#: src/ch02-05-control-flow.md:222 src/ch02-05-control-flow.md:242
msgid "\"i = {}\""
msgstr ""

#: src/ch02-05-control-flow.md:228
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the "
"loop and to skip the rest of the code in this iteration. Let's add a "
"`continue` statement to our loop to skip the `println!` statement when `i` "
"is equal to `5`."
msgstr ""

#: src/ch02-05-control-flow.md:248
msgid ""
"Executing this program will not print the value of `i` when it is equal to "
"`5`."
msgstr ""

#: src/ch02-05-control-flow.md:250
msgid "Returning Values from Loops"
msgstr ""

#: src/ch02-05-control-flow.md:252
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such as checking whether an operation has succeeded. You might also need to "
"pass the result of that operation out of the loop to the rest of your code. "
"To do this, you can add the value you want returned after the `break` "
"expression you use to stop the loop; that value will be returned out of the "
"loop so you can use it, as shown here:"
msgstr ""

#: src/ch02-05-control-flow.md:270
msgid "\"The result is {}\""
msgstr ""

#: src/ch02-05-control-flow.md:274
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to "
"`0`. Then we declare a variable named `result` to hold the value returned "
"from the loop. On every iteration of the loop, we check whether the "
"`counter` is equal to `10`, and then add `1` to the `counter` variable. When "
"the condition is met, we use the `break` keyword with the value `counter * "
"2`. After the loop, we use a semicolon to end the statement that assigns the "
"value to `result`. Finally, we print the value in `result`, which in this "
"case is `20`."
msgstr ""

#: src/ch02-05-control-flow.md:281
msgid "Conditional Loops with `while`"
msgstr ""

#: src/ch02-05-control-flow.md:283
msgid ""
"A program will often need to evaluate a condition within a loop. While the "
"condition is `true`, the loop runs. When the condition ceases to be `true`, "
"the program calls `break`, stopping the loop. It’s possible to implement "
"behavior like this using a combination of `loop`, `if`, `else`, and `break`; "
"you could try that now in a program, if you’d like. However, this pattern is "
"so common that Cairo has a built-in language construct for it, called a "
"`while` loop."
msgstr ""

#: src/ch02-05-control-flow.md:289
msgid ""
"In Listing 2-2, we use `while` to loop the program three times, counting "
"down each time after printing the value of `number`, and then, after the "
"loop, print a message and exit."
msgstr ""

#: src/ch02-05-control-flow.md:296
msgid "\"{number}!\""
msgstr ""

#: src/ch02-05-control-flow.md:300
msgid "\"LIFTOFF!!!\""
msgstr ""

#: src/ch02-05-control-flow.md:304
msgid ""
"<span class=\"caption\">Listing 2-2: Using a `while` loop to run code while "
"a condition holds `true`.</span>"
msgstr ""

#: src/ch02-05-control-flow.md:306
msgid ""
"This construct eliminates a lot of nesting that would be necessary if you "
"used `loop`, `if`, `else`, and `break`, and it’s clearer. While a condition "
"evaluates to `true`, the code runs; otherwise, it exits the loop."
msgstr ""

#: src/ch02-05-control-flow.md:309
msgid "{{#quiz ../quizzes/ch02-05-control-flow.toml}}"
msgstr ""

#: src/ch02-05-control-flow.md:313
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data "
"types, functions, comments, `if` expressions and loops! To practice with the "
"concepts discussed in this chapter, try building programs to do the "
"following:"
msgstr ""

#: src/ch02-05-control-flow.md:317
msgid "Generate the _n_\\-th Fibonacci number."
msgstr ""

#: src/ch02-05-control-flow.md:318
msgid "Compute the factorial of a number _n_."
msgstr ""

#: src/ch02-05-control-flow.md:320
msgid ""
"Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr ""

#: src/ch03-00-common-collections.md
msgid ""
"Cairo provides a set of common collection types that can be used to store "
"and manipulate data. These collections are designed to be efficient, "
"flexible, and easy to use. This section introduces the primary collection "
"types available in Cairo: Arrays and Dictionaries."
msgstr ""

#: src/ch03-01-arrays.md:3
msgid ""
"An array is a collection of elements of the same type. You can create and "
"use array methods by using the `ArrayTrait` trait from the core library."
msgstr ""

#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modification options. "
"Arrays are, in fact, queues whose values can't be modified. This has to do "
"with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of "
"an array and remove items from the front."
msgstr ""

#: src/ch03-01-arrays.md:8
msgid "Creating an Array"
msgstr ""

#: src/ch03-01-arrays.md:10
msgid ""
"Creating an array is done with the `ArrayTrait::new()` call. Here's an "
"example of creating an array and appending 3 elements to it::"
msgstr ""

#: src/ch03-01-arrays.md:21
msgid ""
"When required, you can pass the expected type of items inside the array when "
"instantiating the array like this, or explicitly define the type of the "
"variable."
msgstr ""

#: src/ch03-01-arrays.md:31
msgid "Updating an Array"
msgstr ""

#: src/ch03-01-arrays.md:33
msgid "Adding Elements"
msgstr ""

#: src/ch03-01-arrays.md:35
msgid ""
"To add an element to the end of an array, you can use the `append()` method:"
msgstr ""

#: src/ch03-01-arrays.md:46
msgid "Removing Elements"
msgstr ""

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the "
"`pop_front()` method. This method returns an `Option` that can be unwrapped, "
"containing the removed element, or `Option::None` if the array is empty."
msgstr ""

#: src/ch03-01-arrays.md:59
msgid "\"The first value is {}\""
msgstr ""

#: src/ch03-01-arrays.md:63
msgid ""
"The above code will print `The first value is 10` as we remove the first "
"element that was added."
msgstr ""

#: src/ch03-01-arrays.md:65
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify "
"the elements of an array once they've been added. You can only add elements "
"to the end of an array and remove elements from the front of an array. These "
"operations do not require memory mutation, as they involve updating pointers "
"rather than directly modifying the memory cells."
msgstr ""

#: src/ch03-01-arrays.md:67
msgid "Reading Elements from an Array"
msgstr ""

#: src/ch03-01-arrays.md:69
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that "
"return different types. Using `arr.at(index)` is equivalent to using the "
"subscripting operator `arr[index]`."
msgstr ""

#: src/ch03-01-arrays.md:71
msgid "`get()` Method"
msgstr ""

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an "
"option to a Box type (Cairo's smart-pointer type) containing a snapshot to "
"the element at the specified index if that element exists in the array. If "
"the element doesn't exist, `get` returns `None`. This method is useful when "
"you expect to access indices that may not be within the array's bounds and "
"want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [\"References and "
"Snapshots\"](./ch04-02-references-and-snapshots.md#snapshots) chapter."
msgstr ""

#: src/ch03-01-arrays.md:75
msgid "Here is an example with the `get()` method:"
msgstr ""

#: src/ch03-01-arrays.md:82
msgid ""
"// Change this value to see different results, what would happen if the "
"index doesn't exist?\n"
msgstr ""

#: src/ch03-01-arrays.md:86
msgid ""
"// Don't worry about * for now, if you are curious see Chapter 4.2 #desnap "
"operator\n"
"        // It basically means \"transform what get(idx) returned into a real "
"value\"\n"
msgstr ""

#: src/ch03-01-arrays.md:89
msgid "\"out of bounds\""
msgstr ""

#: src/ch03-01-arrays.md:96
msgid "`at()` Method"
msgstr ""

#: src/ch03-01-arrays.md:98
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the "
"element at the specified index using the `unbox()` operator to extract the "
"value stored in a box. If the index is out of bounds, a panic error occurs. "
"You should only use `at` when you want the program to panic if the provided "
"index is out of the array's bounds, which can prevent unexpected behavior."
msgstr ""

#: src/ch03-01-arrays.md:100
msgid "Here is an example with the `at()` method:"
msgstr ""

#: src/ch03-01-arrays.md:113
msgid ""
"In this example, the variable named `first` will get the value `0` because "
"that is the value at index `0` in the array. The variable named `second` "
"will get the value `1` from index `1` in the array."
msgstr ""

#: src/ch03-01-arrays.md:117
msgid ""
"If you want to use the subscripting operator `arr[index]`, you will need to "
"explicitly define the type of the elements of the array, otherwise it will "
"not compile. For example:"
msgstr ""

#: src/ch03-01-arrays.md:130
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access "
"attempts, and use `get` when you prefer to handle such cases gracefully "
"without panicking."
msgstr ""

#: src/ch03-01-arrays.md:132
msgid "Size-related Methods"
msgstr ""

#: src/ch03-01-arrays.md:134
msgid ""
"To determine the number of elements in an array, use the `len()` method. The "
"return value is of type `usize`."
msgstr ""

#: src/ch03-01-arrays.md:136
msgid ""
"If you want to check if an array is empty or not, you can use the "
"`is_empty()` method, which returns `true` if the array is empty and `false` "
"otherwise."
msgstr ""

#: src/ch03-01-arrays.md:138 src/ch11-05-macros.md:25
msgid "`array!` Macro"
msgstr ""

#: src/ch03-01-arrays.md:140
msgid ""
"Sometimes, we need to create arrays with values that are already known at "
"compile time. The basic way of doing that is redundant. You would first "
"declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, "
"the compiler will expand the macro to generate the code that appends the "
"items sequentially."
msgstr ""

#: src/ch03-01-arrays.md:143
msgid "Without `array!`:"
msgstr ""

#: src/ch03-01-arrays.md:154
msgid "With `array!`:"
msgstr ""

#: src/ch03-01-arrays.md:160
msgid "Storing Multiple Types with Enums"
msgstr ""

#: src/ch03-01-arrays.md:162
msgid ""
"If you want to store elements of different types in an array, you can use an "
"`Enum` to define a custom data type that can hold multiple types. Enums will "
"be explained in more detail in the [\"Enums and Pattern "
"Matching\"](./ch06-00-enums-and-pattern-matching.md) chapter."
msgstr ""

#: src/ch03-01-arrays.md:182
msgid "Span"
msgstr ""

#: src/ch03-01-arrays.md:184
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed "
"to provide safe and controlled access to the elements of an array without "
"modifying the original array. Span is particularly useful for ensuring data "
"integrity and avoiding borrowing issues when passing arrays between "
"functions or when performing read-only operations, as introduced in "
"[\"References and Snapshots\"](./ch04-02-references-and-snapshots.md)."
msgstr ""

#: src/ch03-01-arrays.md:186
msgid ""
"All methods provided by `Array` can also be used with `Span`, except for the "
"`append()` method."
msgstr ""

#: src/ch03-01-arrays.md:190
msgid "Turning an Array into Span"
msgstr ""

#: src/ch03-01-arrays.md:192
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr ""

#: src/ch03-01-arrays.md:201
msgid "{{#quiz ../quizzes/ch03-01-arrays.toml}}"
msgstr ""

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The "
"`Felt252Dict<T>` data type represents a collection of key-value pairs where "
"each key is unique and associated with a corresponding value. This type of "
"data structure is known differently across different programming languages "
"such as maps, hash tables, associative arrays and many others."
msgstr ""

#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a "
"certain way for which using an `Array<T>` and indexing doesn't suffice. "
"Cairo dictionaries also allow the programmer to easily simulate the "
"existence of mutable memory when there is none."
msgstr ""

#: src/ch03-02-dictionaries.md:7
msgid "Basic Use of Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the "
"data types of both key and value. In Cairo, the key type is restricted to "
"`felt252`, leaving only the possibility to specify the value data type, "
"represented by `T` in `Felt252Dict<T>`."
msgstr ""

#: src/ch03-02-dictionaries.md:11
msgid ""
"The core functionality of a `Felt252Dict<T>` is implemented in the trait "
"`Felt252DictTrait` which includes all basic operations. Among them we can "
"find:"
msgstr ""

#: src/ch03-02-dictionaries.md:13
msgid "`insert(felt252, T) -> ()` to write values to a dictionary instance and"
msgstr ""

#: src/ch03-02-dictionaries.md:14
msgid "`get(felt252) -> T` to read values from it."
msgstr ""

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other "
"language. In the following example, we create a dictionary to represent a "
"mapping between individuals and their balance:"
msgstr ""

#: src/ch03-02-dictionaries.md:26
msgid "\"Balance is not 100\""
msgstr ""

#: src/ch03-02-dictionaries.md:29
msgid "\"Balance is not 200\""
msgstr ""

#: src/ch03-02-dictionaries.md:33
msgid ""
"We can create a new instance of `Felt252Dict<u64>` by using the `default` "
"method of the `Default` trait and add two individuals, each one with their "
"own balance, using the `insert` method. Finally, we check the balance of our "
"users with the `get` method. These methods are defined in the "
"`Felt252DictTrait` trait in the core library."
msgstr ""

#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, "
"meaning you can only write to a memory cell once but the `Felt252Dict<T>` "
"type represents a way to overcome this obstacle. We will explain how this is "
"implemented later on in [\"Dictionaries "
"Underneath\"](./ch03-02-dictionaries.md#dictionaries-underneath)."
msgstr ""

#: src/ch03-02-dictionaries.md:37
msgid ""
"Building upon our previous example, let us show a code example where the "
"balance of the same user changes:"
msgstr ""

#: src/ch03-02-dictionaries.md:43
msgid "// Insert Alex with 100 balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:45
msgid "// Check that Alex has indeed 100 associated with him\n"
msgstr ""

#: src/ch03-02-dictionaries.md:47
msgid "\"Alex balance is not 100\""
msgstr ""

#: src/ch03-02-dictionaries.md:49
msgid "// Insert Alex again, this time with 200 balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:51
msgid "// Check the new balance is correct\n"
msgstr ""

#: src/ch03-02-dictionaries.md:53
msgid "\"Alex balance is not 200\""
msgstr ""

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the 'Alex' individual twice, each time "
"using a different balance and each time that we checked for its balance it "
"had the last value inserted! `Felt252Dict<T>` effectively allows us to "
"\"rewrite\" the stored value for any given key."
msgstr ""

#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is "
"worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the "
"scenes all keys have their associated values initialized as zero. This means "
"that if for example, you tried to get the balance of an inexistent user you "
"will get 0 instead of an error or an undefined value. This also means there "
"is no way to delete data from a dictionary. Something to take into account "
"when incorporating this structure into your code."
msgstr ""

#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` "
"and how it mimics the same behavior as the corresponding data structures in "
"any other language, that is, externally of course. Cairo is at its core a "
"non-deterministic Turing-complete programming language, very different from "
"any other popular language in existence, which as a consequence means that "
"dictionaries are implemented very differently as well!"
msgstr ""

#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about "
"`Felt252Dict<T>` inner mechanisms and the compromises that were taken to "
"make them work. After that, we are going to take a look at how to use "
"dictionaries with other data structures as well as use the `entry` method as "
"another way to interact with them."
msgstr ""

#: src/ch03-02-dictionaries.md:67
msgid "Dictionaries Underneath"
msgstr ""

#: src/ch03-02-dictionaries.md:69
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its "
"memory system is immutable, so in order to simulate mutability, the language "
"implements `Felt252Dict<T>` as a list of entries. Each of the entries "
"represents a time when a dictionary was accessed for "
"reading/updating/writing purposes. An entry has three fields:"
msgstr ""

#: src/ch03-02-dictionaries.md:71
msgid ""
"A `key` field that identifies the key for this key-value pair of the "
"dictionary."
msgstr ""

#: src/ch03-02-dictionaries.md:72
msgid ""
"A `previous_value` field that indicates which previous value was held at "
"`key`."
msgstr ""

#: src/ch03-02-dictionaries.md:73
msgid "A `new_value` field that indicates the new value that is held at `key`."
msgstr ""

#: src/ch03-02-dictionaries.md:75
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would "
"internally define it as `Array<Entry<T>>` where each `Entry<T>` has "
"information about what key-value pair it represents and the previous and new "
"values it holds. The definition of `Entry<T>` would be:"
msgstr ""

#: src/ch03-02-dictionaries.md:85
msgid ""
"For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be "
"registered:"
msgstr ""

#: src/ch03-02-dictionaries.md:87
msgid ""
"A `get` would register an entry where there is no change in state, and "
"previous and new values are stored with the same value."
msgstr ""

#: src/ch03-02-dictionaries.md:88
msgid ""
"An `insert` would register a new `Entry<T>` where the `new_value` would be "
"the element being inserted, and the `previous_value` the last element "
"inserted before this. In case it is the first entry for a certain key, then "
"the previous value will be zero."
msgstr ""

#: src/ch03-02-dictionaries.md:90
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the "
"creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an "
"example of this using the `balances` dictionary from the previous section "
"and inserting the users 'Alex' and 'Maria':"
msgstr ""

#: src/ch03-02-dictionaries.md:108
msgid "These instructions would then produce the following list of entries:"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "key"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "previous"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "new"
msgstr ""

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:114
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:138
#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:141
#: src/ch03-02-dictionaries.md:147
msgid "Alex"
msgstr ""

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:135
#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:147
#: src/ch03-02-dictionaries.md:148 src/ch03-02-dictionaries.md:149
msgid "0"
msgstr ""

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:114
#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:137
msgid "100"
msgstr ""

#: src/ch03-02-dictionaries.md:113 src/ch03-02-dictionaries.md:115
#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:137
#: src/ch03-02-dictionaries.md:140 src/ch03-02-dictionaries.md:148
msgid "Maria"
msgstr ""

#: src/ch03-02-dictionaries.md:113 src/ch03-02-dictionaries.md:115
msgid "50"
msgstr ""

#: src/ch03-02-dictionaries.md:114
msgid "200"
msgstr ""

#: src/ch03-02-dictionaries.md:117
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the "
"`previous` and `current` values are set properly. Also reading from 'Maria' "
"registered an entry with no change from previous to current values."
msgstr ""

#: src/ch03-02-dictionaries.md:119
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each "
"read/write operation, there is a scan for the whole entry list in search of "
"the last entry with the same `key`. Once the entry has been found, its "
"`new_value` is extracted and used on the new entry to be added as the "
"`previous_value`. This means that interacting with `Felt252Dict<T>` has a "
"worst-case time complexity of `O(n)` where `n` is the number of entries in "
"the list."
msgstr ""

#: src/ch03-02-dictionaries.md:121
msgid ""
"If you pour some thought into alternate ways of implementing "
"`Felt252Dict<T>` you'd surely find them, probably even ditching completely "
"the need for a `previous_value` field, nonetheless, since Cairo is not your "
"normal language this won't work. One of the purposes of Cairo is, with the "
"STARK proof system, to generate proofs of computational integrity. This "
"means that you need to verify that program execution is correct and inside "
"the boundaries of Cairo restrictions. One of those boundary checks consists "
"of \"dictionary squashing\" and that requires information on both previous "
"and new values for every entry."
msgstr ""

#: src/ch03-02-dictionaries.md:124
msgid "Squashing Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:126
msgid ""
"To verify that the proof generated by a Cairo program execution that used a "
"`Felt252Dict<T>` is correct, we need to check that there wasn't any illegal "
"tampering with the dictionary. This is done through a method called "
"`squash_dict` that reviews each entry of the entry list and checks that "
"access to the dictionary remains coherent throughout the execution."
msgstr ""

#: src/ch03-02-dictionaries.md:128
msgid ""
"The process of squashing is as follows: given all entries with certain key "
"`k`, taken in the same order as they were inserted, verify that the ith "
"entry `new_value` is equal to the ith + 1 entry `previous_value`."
msgstr ""

#: src/ch03-02-dictionaries.md:130
msgid "For example, given the following entry list:"
msgstr ""

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:138
msgid "150"
msgstr ""

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:149
msgid "Charles"
msgstr ""

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:149
msgid "70"
msgstr ""

#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:140
msgid "250"
msgstr ""

#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:139
msgid "40"
msgstr ""

#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:141
msgid "300"
msgstr ""

#: src/ch03-02-dictionaries.md:140 src/ch03-02-dictionaries.md:148
msgid "190"
msgstr ""

#: src/ch03-02-dictionaries.md:141 src/ch03-02-dictionaries.md:147
msgid "90"
msgstr ""

#: src/ch03-02-dictionaries.md:143
msgid "After squashing, the entry list would be reduced to:"
msgstr ""

#: src/ch03-02-dictionaries.md:151
msgid ""
"In case of a change on any of the values of the first table, squashing would "
"have failed during runtime."
msgstr ""

#: src/ch03-02-dictionaries.md:153
msgid "Dictionary Destruction"
msgstr ""

#: src/ch03-02-dictionaries.md:155
msgid ""
"If you run the examples from [\"Basic Use of "
"Dictionaries\"](./ch03-02-dictionaries.md#basic-use-of-dictionaries) "
"section, you'd notice that there was never a call to squash dictionary, but "
"the program compiled successfully nonetheless. What happened behind the "
"scene was that squash was called automatically via the `Felt252Dict<T>` "
"implementation of the `Destruct<T>` trait. This call occurred just before "
"the `balance` dictionary went out of scope."
msgstr ""

#: src/ch03-02-dictionaries.md:157
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of "
"scope apart from `Drop<T>`. The main difference between these two is that "
"`Drop<T>` is treated as a no-op operation, meaning it does not generate new "
"CASM while `Destruct<T>` does not have this restriction. The only type which "
"actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other "
"type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these "
"traits in [Drop and "
"Destruct](./appendix-03-derivable-traits.md#drop-and-destruct) section of "
"Appendix C."
msgstr ""

#: src/ch03-02-dictionaries.md:159
msgid ""
"Later in [\"Dictionaries as Struct "
"Members\"](./ch11-01-custom-data-structures.html#dictionaries-as-struct-members) "
"section, we will have a hands-on example where we implement the "
"`Destruct<T>` trait for a custom type."
msgstr ""

#: src/ch03-02-dictionaries.md:165
msgid "More Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:167
msgid ""
"Up to this point, we have given a comprehensive overview of the "
"functionality of `Felt252Dict<T>` as well as how and why it is implemented "
"in a certain way. If you haven't understood all of it, don't worry because "
"in this section we will have some more examples using dictionaries."
msgstr ""

#: src/ch03-02-dictionaries.md:169
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary "
"basic functionality included in `Felt252DictTrait<T>` which we didn't "
"mention at the beginning. Soon after, we will see examples of how to use "
"`Felt252Dict<T>` with other [complex "
"types](./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively) "
"such as `Array<T>`."
msgstr ""

#: src/ch03-02-dictionaries.md:173
msgid "Entry and Finalize"
msgstr ""

#: src/ch03-02-dictionaries.md:175
msgid ""
"In the [\"Dictionaries "
"Underneath\"](./ch03-02-dictionaries.md#dictionaries-underneath) section, we "
"explained how `Felt252Dict<T>` internally worked. It was a list of entries "
"for each time the dictionary was accessed in any manner. It would first find "
"the last entry given a certain `key` and then update it accordingly to "
"whatever operation it was executing. The Cairo language gives us the tools "
"to replicate this ourselves through the `entry` and `finalize` methods."
msgstr ""

#: src/ch03-02-dictionaries.md:177
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose "
"of creating a new entry given a certain key. Once called, this method takes "
"ownership of the dictionary and returns the entry to update. The method "
"signature is as follows:"
msgstr ""

#: src/ch03-02-dictionaries.md:183
msgid ""
"The first input parameter takes ownership of the dictionary while the second "
"one is used to create the appropriate entry. It returns a tuple containing a "
"`Felt252DictEntry<T>`, which is the type used by Cairo to represent "
"dictionary entries, and a `T` representing the value held previously. The "
"`nopanic` notation simply indicates that the function is guaranteed to never "
"panic."
msgstr ""

#: src/ch03-02-dictionaries.md:186
msgid ""
"The next thing to do is to update the entry with the new value. For this, we "
"use the `finalize` method which inserts the entry and returns ownership of "
"the dictionary:"
msgstr ""

#: src/ch03-02-dictionaries.md:192
msgid ""
"This method receives the entry and the new value as parameters, and returns "
"the updated dictionary."
msgstr ""

#: src/ch03-02-dictionaries.md:194
msgid ""
"Let us see an example using `entry` and `finalize`. Imagine we would like to "
"implement our own version of the `get` method from a dictionary. We should "
"then do the following:"
msgstr ""

#: src/ch03-02-dictionaries.md:196
msgid "Create the new entry to add using the `entry` method."
msgstr ""

#: src/ch03-02-dictionaries.md:197
msgid "Insert back the entry where the `new_value` equals the `previous_value`."
msgstr ""

#: src/ch03-02-dictionaries.md:198
msgid "Return the value."
msgstr ""

#: src/ch03-02-dictionaries.md:200
msgid "Implementing our custom get would look like this:"
msgstr ""

#: src/ch03-02-dictionaries.md:208 src/ch03-02-dictionaries.md:252
msgid "// Get the new entry and the previous value held at `key`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:211 src/ch03-02-dictionaries.md:255
msgid "// Store the value to return\n"
msgstr ""

#: src/ch03-02-dictionaries.md:214 src/ch03-02-dictionaries.md:258
msgid ""
"// Update the entry with `prev_value` and get back ownership of the "
"dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:217 src/ch03-02-dictionaries.md:261
msgid "// Return the read value\n"
msgstr ""

#: src/ch03-02-dictionaries.md:222
msgid ""
"The `ref` keyword means that the ownership of the variable will be given "
"back at the end of the function. This concept will be explained in more "
"detail in the [\"References and "
"Snapshots\"](./ch04-02-references-and-snapshots.md) section."
msgstr ""

#: src/ch03-02-dictionaries.md:225
msgid ""
"Implementing the `insert` method would follow a similar workflow, except for "
"inserting a new value when finalizing. If we were to implement it, it would "
"look like the following:"
msgstr ""

#: src/ch03-02-dictionaries.md:233
msgid ""
"// Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exist, `_prev_value` will\n"
"    // be the default value of T.\n"
msgstr ""

#: src/ch03-02-dictionaries.md:238
msgid ""
"// Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:244
msgid ""
"As a finalizing note, these two methods are implemented in a similar way to "
"how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows "
"some example usage:"
msgstr ""

#: src/ch03-02-dictionaries.md:268
msgid "// Get the last entry associated with `key`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:269
msgid "// Notice that if `key` does not exist, `_prev_value` will\n"
msgstr ""

#: src/ch03-02-dictionaries.md:270
msgid "// be the default value of T.\n"
msgstr ""

#: src/ch03-02-dictionaries.md:273
msgid "// Insert `entry` back in the dictionary with the updated value,\n"
msgstr ""

#: src/ch03-02-dictionaries.md:274
msgid "// and receive ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:281 src/ch03-02-dictionaries.md:283
msgid "'0'"
msgstr ""

#: src/ch03-02-dictionaries.md:285
msgid "\"Expecting 100\""
msgstr ""

#: src/ch03-02-dictionaries.md:294
msgid "Dictionaries of Types not Supported Natively"
msgstr ""

#: src/ch03-02-dictionaries.md:296
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the "
"trait `Felt252DictValue<T>`. This trait defines the `zero_default` method "
"which is the one that gets called when a value does not exist in the "
"dictionary. This is implemented by some common data types, such as most "
"unsigned integers, `bool` and `felt252` - but it is not implemented for more "
"complex types such as arrays, structs (including `u256`), and other types "
"from the core library. This means that making a dictionary of types not "
"natively supported is not a straightforward task, because you would need to "
"write a couple of trait implementations in order to make the data type a "
"valid dictionary value type. To compensate this, you can wrap your type "
"inside a `Nullable<T>`."
msgstr ""

#: src/ch03-02-dictionaries.md:302
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be "
"`null` in the absence of value. It is usually used in Object Oriented "
"Programming Languages when a reference doesn't point anywhere. The "
"difference with `Option` is that the wrapped value is stored inside a "
"`Box<T>` data type. The `Box<T>` type is a smart pointer that allows us to "
"use a dedicated `boxed_segment` memory segment for our data, and access this "
"segment using a pointer that can only be manipulated in one place at a time. "
"See [Smart Pointers Chapter](./ch11-02-smart-pointers.md) for more "
"information."
msgstr ""

#: src/ch03-02-dictionaries.md:304
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a "
"dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are "
"storing a `Span<T>` and not an `Array<T>` because the latter does not "
"implement the `Copy<T>` trait which is required for reading from a "
"dictionary."
msgstr ""

#: src/ch03-02-dictionaries.md:310 src/ch03-02-dictionaries.md:359
msgid "// Create the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:313 src/ch03-02-dictionaries.md:362
msgid "// Create the array to insert\n"
msgstr ""

#: src/ch03-02-dictionaries.md:316 src/ch03-02-dictionaries.md:365
msgid "// Insert it as a `Span`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:318 src/ch03-02-dictionaries.md:329
msgid "//...\n"
msgstr ""

#: src/ch03-02-dictionaries.md:322
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary "
"`d`. We want it to hold a `Nullable<Span>`. After that, we created an array "
"and filled it with values."
msgstr ""

#: src/ch03-02-dictionaries.md:324
msgid ""
"The last step is inserting the array as a span inside the dictionary. Notice "
"that we do this using the `new` function of the `NullableTrait`."
msgstr ""

#: src/ch03-02-dictionaries.md:326
msgid ""
"Once the element is inside the dictionary, and we want to get it, we follow "
"the same steps but in reverse order. The following code shows how to achieve "
"that:"
msgstr ""

#: src/ch03-02-dictionaries.md:331 src/ch03-02-dictionaries.md:368
msgid "// Get value back\n"
msgstr ""

#: src/ch03-02-dictionaries.md:334 src/ch03-02-dictionaries.md:371
msgid "// Search the value and assert it is not null\n"
msgstr ""

#: src/ch03-02-dictionaries.md:336 src/ch03-02-dictionaries.md:373
msgid "\"No value found\""
msgstr ""

#: src/ch03-02-dictionaries.md:340 src/ch03-02-dictionaries.md:377
msgid "// Verify we are having the right values\n"
msgstr ""

#: src/ch03-02-dictionaries.md:341 src/ch03-02-dictionaries.md:378
msgid "\"Expecting 8\""
msgstr ""

#: src/ch03-02-dictionaries.md:342 src/ch03-02-dictionaries.md:379
msgid "\"Expecting 9\""
msgstr ""

#: src/ch03-02-dictionaries.md:343 src/ch03-02-dictionaries.md:380
msgid "\"Expecting 10\""
msgstr ""

#: src/ch03-02-dictionaries.md:347
msgid "Here we:"
msgstr ""

#: src/ch03-02-dictionaries.md:349
msgid "Read the value using `get`."
msgstr ""

#: src/ch03-02-dictionaries.md:350
msgid "Verified it is non-null using the `match_nullable` function."
msgstr ""

#: src/ch03-02-dictionaries.md:351
msgid "Unwrapped the value inside the box and asserted it was correct."
msgstr ""

#: src/ch03-02-dictionaries.md:353
msgid "The complete script would look like this:"
msgstr ""

#: src/ch03-02-dictionaries.md:385
msgid "Using Arrays inside Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:387
msgid ""
"In the previous section, we explored how to store and retrieve complex types "
"inside a dictionary using `Nullable<T>` and `Box<T>`. Now, let's take a look "
"at how to store an array inside a dictionary and dynamically modify its "
"contents."
msgstr ""

#: src/ch03-02-dictionaries.md:389
msgid ""
"Storing arrays in dictionaries in Cairo is slightly different from storing "
"other types. This is because arrays are more complex data structures that "
"require special handling to avoid issues with memory copying and references."
msgstr ""

#: src/ch03-02-dictionaries.md:391
msgid ""
"First, let's look at how to create a dictionary and insert an array into it. "
"This process is pretty straightforward and follows a similar pattern to "
"inserting other types of data:"
msgstr ""

#: src/ch03-02-dictionaries.md:398
msgid "\"Array inserted successfully.\""
msgstr ""

#: src/ch03-02-dictionaries.md:402
msgid ""
"However, attempting to read an array from the dictionary using the `get` "
"method will result in a compiler error. This is because `get` tries to copy "
"the array in memory, which is not possible for arrays (as we've already "
"mentioned in the [previous "
"section](./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively), "
"`Array<T>` does not implement the `Copy<T>` trait):"
msgstr ""

#: src/ch03-02-dictionaries.md:411
msgid "\"Array: {:?}\""
msgstr ""

#: src/ch03-02-dictionaries.md:415
msgid "// This will cause a compiler error\n"
msgstr ""

#: src/ch03-02-dictionaries.md:417
msgid "\"No value!\""
msgstr ""

#: src/ch03-02-dictionaries.md:424
msgid ""
"```shell\n"
"$ scarb cairo-run \n"
"   Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 "
"(listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)\n"
"error: Trait has no implementation in context: "
"core::traits::Copy::<core::nullable::Nullable::<core::array::Array::<core::integer::u8>>>\n"
" --> "
"listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:12:20\n"
"    let val = dict.get(0); // This will cause a compiler error\n"
"                   ^*^\n"
"\n"
"error: could not compile `no_listing_15_dict_of_array_attempt_get` due to "
"previous error\n"
"error: `scarb metadata` exited with error\n"
"\n"
"```"
msgstr ""

#: src/ch03-02-dictionaries.md:437
msgid ""
"To correctly read an array from the dictionary, we need to use dictionary "
"entries. This allows us to get a reference to the array value without "
"copying it:"
msgstr ""

#: src/ch03-02-dictionaries.md:449
msgid ""
"Note: We must convert the array to a `Span` before finalizing the entry, "
"because calling `NullableTrait::new(arr)` moves the array, thus making it "
"impossible to return it from the function."
msgstr ""

#: src/ch03-02-dictionaries.md:451
msgid ""
"To modify the stored array, such as appending a new value, we can use a "
"similar approach. The following `append_value` function demonstrates this:"
msgstr ""

#: src/ch03-02-dictionaries.md:462
msgid ""
"In the `append_value` function, we access the dictionary entry, dereference "
"the array, append the new value, and finalize the entry with the updated "
"array."
msgstr ""

#: src/ch03-02-dictionaries.md:464
msgid ""
"Note: Removing an item from a stored array can be implemented in a similar "
"manner."
msgstr ""

#: src/ch03-02-dictionaries.md:466
msgid ""
"Below is the complete example demonstrating the creation, insertion, "
"reading, and modification of an array in a dictionary:"
msgstr ""

#: src/ch03-02-dictionaries.md:491
msgid "\"Before insertion: {:?}\""
msgstr ""

#: src/ch03-02-dictionaries.md:495
msgid "\"After insertion: {:?}\""
msgstr ""

#: src/ch03-02-dictionaries.md:499
msgid "{{#quiz ../quizzes/ch03-02-dictionaries.toml}}"
msgstr ""

#: src/ch04-00-understanding-ownership.md
msgid "Understanding Cairo's Ownership system"
msgstr ""

#: src/ch04-00-understanding-ownership.md
msgid ""
"Cairo is a language built around a linear type system that allows us to "
"statically ensure that in every Cairo program, a value is used exactly once. "
"This linear type system helps prevent runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory "
"cell, are detected at compile time. This is achieved by implementing an "
"ownership system and forbidding copying and dropping values by default. In "
"this chapter, we’ll talk about Cairo's ownership system as well as "
"references and snapshots."
msgstr ""

#: src/ch04-01-what-is-ownership.md:1
msgid "Ownership Using a Linear Type System"
msgstr ""

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"Cairo uses a linear type system. In such a type system, any value (a basic "
"type, a struct, an enum) must be used and must only be used once. 'Used' "
"here means that the value is either _destroyed_ or _moved_."
msgstr ""

#: src/ch04-01-what-is-ownership.md:5
msgid "_Destruction_ can happen in several ways:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:7
msgid "a variable goes out of scope."
msgstr ""

#: src/ch04-01-what-is-ownership.md:8
msgid "a struct is destructured."
msgstr ""

#: src/ch04-01-what-is-ownership.md:9
msgid "explicit destruction using `destruct()`."
msgstr ""

#: src/ch04-01-what-is-ownership.md:11
msgid "_Moving_ a value simply means passing that value to another function."
msgstr ""

#: src/ch04-01-what-is-ownership.md:13
msgid ""
"This results in somewhat similar constraints to the Rust ownership model, "
"but there are some differences. In particular, the Rust ownership model "
"exists (in part) to avoid data races and concurrent mutable access to a "
"memory value. This is obviously impossible in Cairo since the memory is "
"immutable. Instead, Cairo leverages its linear type system for two main "
"purposes:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:17
msgid "Ensuring that all code is provable and thus verifiable."
msgstr ""

#: src/ch04-01-what-is-ownership.md:18
msgid "Abstracting away the immutable memory of the Cairo VM."
msgstr ""

#: src/ch04-01-what-is-ownership.md:20
msgid "Ownership"
msgstr ""

#: src/ch04-01-what-is-ownership.md:22
msgid ""
"In Cairo, ownership applies to _variables_ and not to _values_. A value can "
"safely be referred to by many different variables (even if they are mutable "
"variables), as the value itself is always immutable. Variables however can "
"be mutable, so the compiler must ensure that constant variables aren't "
"accidentally modified by the programmer. This makes it possible to talk "
"about ownership of a variable: the owner is the code that can read (and "
"write if mutable) the variable."
msgstr ""

#: src/ch04-01-what-is-ownership.md:26
msgid ""
"This means that variables (not values) follow similar rules to Rust values:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:28
msgid "Each variable in Cairo has an owner."
msgstr ""

#: src/ch04-01-what-is-ownership.md:29
msgid "There can only be one owner at a time."
msgstr ""

#: src/ch04-01-what-is-ownership.md:30
msgid "When the owner goes out of scope, the variable is destroyed."
msgstr ""

#: src/ch04-01-what-is-ownership.md:32
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() "
"{` code in examples, so if you’re following along, make sure to put the "
"following examples inside a main function manually. As a result, our "
"examples will be a bit more concise, letting us focus on the actual details "
"rather than boilerplate code."
msgstr ""

#: src/ch04-01-what-is-ownership.md:34
msgid "Variable Scope"
msgstr ""

#: src/ch04-01-what-is-ownership.md:36
msgid ""
"As a first example of the linear type system, we’ll look at the _scope_ of "
"some variables. A scope is the range within a program for which an item is "
"valid. Take the following variable:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:44
msgid ""
"The variable `s` refers to a short string. The variable is valid from the "
"point at which it’s declared until the end of the current _scope_. Listing "
"4-1 shows a program with comments annotating where the variable `s` would be "
"valid."
msgstr ""

#: src/ch04-01-what-is-ownership.md:49
msgid "//TAG: ignore_fmt\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:51
msgid "// s is not valid here, it’s not yet declared\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:52
msgid ""
"// s is valid from this point forward\n"
"    // do stuff with s\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:54
msgid "// this scope is now over, and s is no longer valid\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:58
msgid ""
"<span class=\"caption\">Listing 4-1: A variable and the scope in which it is "
"valid</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:60
msgid "In other words, there are two important points in time here:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:62
msgid "When `s` comes _into_ scope, it is valid."
msgstr ""

#: src/ch04-01-what-is-ownership.md:63
msgid "It remains valid until it goes _out of_ scope."
msgstr ""

#: src/ch04-01-what-is-ownership.md:65
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is similar to that in other programming languages. Now we’ll build on top of "
"this understanding by using the `Array` type we introduced in the previous "
"[\"Arrays\"](./ch03-01-arrays.md) section."
msgstr ""

#: src/ch04-01-what-is-ownership.md:69
msgid "Moving values"
msgstr ""

#: src/ch04-01-what-is-ownership.md:71
msgid ""
"As said earlier, _moving_ a value simply means passing that value to another "
"function. When that happens, the variable referring to that value in the "
"original scope is destroyed and can no longer be used, and a new variable is "
"created to hold the same value."
msgstr ""

#: src/ch04-01-what-is-ownership.md:73
msgid ""
"Arrays are an example of a complex type that is moved when passing it to "
"another function. Here is a short reminder of what an array looks like:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:84
msgid ""
"How does the type system ensure that the Cairo program never tries to write "
"to the same memory cell twice? Consider the following code, where we try to "
"remove the front of the array twice:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:99
msgid ""
"In this case, we try to pass the same value (the array in the `arr` "
"variable) to both function calls. This means our code tries to remove the "
"first element twice, which would try to write to the same memory cell twice "
"- which is forbidden by the Cairo VM, leading to a runtime error. "
"Thankfully, this code does not actually compile. Once we have passed the "
"array to the `foo` function, the variable `arr` is no longer usable. We get "
"this compile-time error, telling us that we would need Array to implement "
"the Copy Trait:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:125
msgid "The `Copy` Trait"
msgstr ""

#: src/ch04-01-what-is-ownership.md:127
msgid ""
"If a type implements the `Copy` trait, passing a value of that type to a "
"function does not move the value. Instead, a new variable is created, "
"referring to the same value. The important thing to note here is that this "
"is a completely free operation because variables are a Cairo abstraction "
"only and because _values_ in Cairo are always immutable. This, in "
"particular, conceptually differs from the Rust version of the `Copy` trait, "
"where the value is potentially copied in memory."
msgstr ""

#: src/ch04-01-what-is-ownership.md:130
msgid ""
"All basic types previously described in [\"Data "
"Types\"](./ch02-02-data-types.md) implement by default the `Copy` trait."
msgstr ""

#: src/ch04-01-what-is-ownership.md:132
msgid ""
"While Arrays and Dictionaries can't be copied, custom types that don't "
"contain either of them can be. You can implement the `Copy` trait on your "
"type by adding the `#[derive(Copy)]` annotation to your type definition. "
"However, Cairo won't allow a type to be annotated with Copy if the type "
"itself or any of its components doesn't implement the Copy trait."
msgstr ""

#: src/ch04-01-what-is-ownership.md:148
msgid "// do something with p\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:152
msgid ""
"In this example, we can pass `p1` twice to the foo function because the "
"`Point` type implements the `Copy` trait. This means that when we pass `p1` "
"to `foo`, we are actually passing a copy of `p1`, so `p1` remains valid. In "
"ownership terms, this means that the ownership of `p1` remains with the "
"`main` function. If you remove the `Copy` trait derivation from the `Point` "
"type, you will get a compile-time error when trying to compile the code."
msgstr ""

#: src/ch04-01-what-is-ownership.md:155
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter "
"5](./ch05-00-using-structs-to-structure-related-data.md)._"
msgstr ""

#: src/ch04-01-what-is-ownership.md:160
msgid "Destroying Values - Example with FeltDict"
msgstr ""

#: src/ch04-01-what-is-ownership.md:162
msgid ""
"The other way linear types can be _used_ is by being destroyed. Destruction "
"must ensure that the 'resource' is now correctly released. In Rust, for "
"example, this could be closing the access to a file, or locking a mutex. In "
"Cairo, one type that has such behaviour is `Felt252Dict`. For provability, "
"dicts must be 'squashed' when they are destructed. This would be very easy "
"to forget, so it is enforced by the type system and the compiler."
msgstr ""

#: src/ch04-01-what-is-ownership.md:166
msgid "No-op Destruction: the `Drop` Trait"
msgstr ""

#: src/ch04-01-what-is-ownership.md:168
msgid ""
"You may have noticed that the `Point` type in the previous example also "
"implements the `Drop` trait. For example, the following code will not "
"compile, because the struct `A` is not moved or destroyed before it goes out "
"of scope:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:175
msgid "// error: Variable not dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:179
msgid ""
"However, types that implement the `Drop` trait are automatically destroyed "
"when going out of scope. This destruction does nothing, it is a no-op - "
"simply a hint to the compiler that this type can safely be destroyed once "
"it's no longer useful. We call this \"dropping\" a value."
msgstr ""

#: src/ch04-01-what-is-ownership.md:181
msgid ""
"At the moment, the `Drop` implementation can be derived for all types, "
"allowing them to be dropped when going out of scope, except for dictionaries "
"(`Felt252Dict`) and types containing dictionaries. For example, the "
"following code compiles:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:189
msgid "// Now there is no error.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:193
msgid "Destruction with a Side-effect: the `Destruct` Trait"
msgstr ""

#: src/ch04-01-what-is-ownership.md:195
msgid ""
"When a value is destroyed, the compiler first tries to call the `drop` "
"method on that type. If it doesn't exist, then the compiler tries to call "
"`destruct` instead. This method is provided by the `Destruct` trait."
msgstr ""

#: src/ch04-01-what-is-ownership.md:197
msgid ""
"As said earlier, dictionaries in Cairo are types that must be \"squashed\" "
"when destructed, so that the sequence of access can be proven. This is easy "
"for developers to forget, so instead dictionaries implement the `Destruct` "
"trait to ensure that all dictionaries are _squashed_ when going out of "
"scope. As such, the following example will not compile:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:210
msgid "If you try to run this code, you will get a compile-time error:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:227
msgid ""
"When `A` goes out of scope, it can't be dropped as it implements neither the "
"`Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the "
"`Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:236
msgid "// No error here\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:240
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically "
"`squashed`, and the program will compile."
msgstr ""

#: src/ch04-01-what-is-ownership.md:242
msgid "Copy Array Data with `clone`"
msgstr ""

#: src/ch04-01-what-is-ownership.md:244
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common "
"method called `clone`. We’ll discuss method syntax in a dedicated section in "
"[Chapter 5](./ch05-03-method-syntax.md), but because methods are a common "
"feature in many programming languages, you’ve probably seen them before."
msgstr ""

#: src/ch04-01-what-is-ownership.md:246
msgid "Here’s an example of the `clone` method in action."
msgstr ""

#: src/ch04-01-what-is-ownership.md:255
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being "
"executed and that code may be expensive. It’s a visual indicator that "
"something different is going on. In this case, the _value_ `arr1` refers to "
"is being copied, resulting in new memory cells being used, and a new "
"_variable_ `arr2` is created, referring to the new copied value."
msgstr ""

#: src/ch04-01-what-is-ownership.md:260
msgid "Return Values and Scope"
msgstr ""

#: src/ch04-01-what-is-ownership.md:262
msgid ""
"Returning values is equivalent to _moving_ them. Listing 4-2 shows an "
"example of a function that returns some value, with similar annotations as "
"those in Listing 4-1."
msgstr ""

#: src/ch04-01-what-is-ownership.md:272
msgid ""
"// gives_ownership moves its return\n"
"                                          // value into a1\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:275
msgid "// a2 comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:277
msgid ""
"// a2 is moved into\n"
"                                          // takes_and_gives_back, which "
"also\n"
"                                          // moves its return value into a3\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:281
msgid ""
"// Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:284
msgid ""
"// gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:288 src/ch04-01-what-is-ownership.md:296
msgid "// some_a comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:290
msgid ""
"// some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:294
msgid "// This function takes an instance some_a of A and returns it\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:298
msgid ""
"// some_a is returned and \n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:304
msgid "<span class=\"caption\">Listing 4-2: Moving return values</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:306
msgid ""
"While this works, moving into and out of every function is a bit tedious. "
"What if we want to let a function use a value but not move the value? It’s "
"quite annoying that anything we pass in also needs to be passed back if we "
"want to use it again, in addition to any data resulting from the body of the "
"function that we might want to return as well."
msgstr ""

#: src/ch04-01-what-is-ownership.md:308
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing "
"4-3."
msgstr ""

#: src/ch04-01-what-is-ownership.md:320
msgid "// len() returns the length of an array\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:326
msgid "<span class=\"caption\">Listing 4-3: Returning many values</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:328
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be "
"common. Luckily for us, Cairo has two features for passing a value without "
"destroying or moving it, called _references_ and _snapshots_."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in previous Listing 4-3 is that we have to "
"return the `Array` to the calling function so we can still use the `Array` "
"after the call to `calculate_length`, because the `Array` was moved into "
"`calculate_length`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:8
msgid "Snapshots"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:10
msgid ""
"In the previous chapter, we talked about how Cairo's ownership system "
"prevents us from using a variable after we've moved it, protecting us from "
"potentially writing twice to the same memory cell. However, it's not very "
"convenient. Let's see how we can retain ownership of the variable in the "
"calling function using snapshots."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:15
msgid ""
"In Cairo, a snapshot is an immutable view of a value at a certain point in "
"time. Recall that memory is immutable, so modifying a value actually creates "
"a new memory cell. The old memory cell still exists, and snapshots are "
"variables that refer to that \"old\" value. In this sense, snapshots are a "
"view \"into the past\"."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:20
msgid ""
"Here is how you would define and use a `calculate_length` function that "
"takes a snapshot of an array as a parameter instead of taking ownership of "
"the underlying value. In this example, the `calculate_length` function "
"returns the length of the array passed as a parameter. As we're passing it "
"as a snapshot, which is an immutable view of the array, we can be sure that "
"the `calculate_length` function will not mutate the array, and ownership of "
"the array is kept in the `main` function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:31
msgid "// Take a snapshot of `arr1` at this point in time\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:32
msgid "// Mutate `arr1` by appending a value\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:35
msgid "// Calculate the length of the array when the snapshot was taken\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:36
#: src/ch04-02-references-and-snapshots.md:67
msgid "// Calculate the current length of the array\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:37
msgid "\"The length of the array when the snapshot was taken is {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:38
msgid "\"The current length of the array is {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:46
msgid ""
"Note: it is only possible to call the `len()` method on an array snapshot "
"because it is defined as such in the `ArrayTrait` trait. If you try to call "
"a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on "
"non-snapshot types."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:48
msgid "The output of this program is:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:61
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note that we pass `@arr1` into "
"`calculate_length` and, in its definition, we take `@Array<u128>` rather "
"than `Array<u128>`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:64
msgid "Let’s take a closer look at the function call here:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:70
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because "
"a snapshot is an immutable view of a value at a specific point in time, the "
"usual rules of the linear type system are not enforced. In particular, "
"snapshot variables always implement the `Drop` trait, never the `Destruct` "
"trait, even dictionary snapshots."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:72
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type "
"of the parameter `arr` is a snapshot. Let’s add some explanatory annotations:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:76
msgid "// array_snapshot is a snapshot of an Array\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:79
msgid ""
"// Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` "
"contains, the original `arr` can still be used.\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:83
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any "
"function parameter’s scope, but the underlying value of the snapshot is not "
"dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to "
"return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:85
msgid "Desnap Operator"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:87
msgid ""
"To convert a snapshot back into a regular variable, you can use the `desnap` "
"operator `*`, which serves as the opposite of the `@` operator."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:89
msgid ""
"Only `Copy` types can be desnapped. However, in the general case, because "
"the value is not modified, the new variable created by the `desnap` operator "
"reuses the old value, and so desnapping is a completely free operation, just "
"like `Copy`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:91
msgid ""
"In the following example, we want to calculate the area of a rectangle, but "
"we don't want to take ownership of the rectangle in the `calculate_area` "
"function, because we might want to use the rectangle again after the "
"function call. Since our function doesn't mutate the rectangle instance, we "
"can pass the snapshot of the rectangle to the function, and then transform "
"the snapshots back into values using the `desnap` operator `*`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:103
msgid "\"Area: {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:107
msgid ""
"// As rec is a snapshot to a Rectangle, its fields are also snapshots of the "
"fields types.\n"
"    // We need to transform the snapshots back into values using the desnap "
"operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for "
"u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for "
"desnapping the snapshots.\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:115
msgid ""
"But, what happens if we try to modify something we’re passing as a snapshot? "
"Try the code in Listing 4-4. Spoiler alert: it doesn’t work!"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:140
msgid ""
"<span class=\"caption\">Listing 4-4: Attempting to modify a snapshot "
"value</span>"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:142
msgid "Here’s the error:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:162
msgid "The compiler prevents us from modifying values associated to snapshots."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:164
msgid "Mutable References"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:166
msgid ""
"We can achieve the behavior we want in Listing 4-4 by using a _mutable "
"reference_ instead of a snapshot. Mutable references are actually mutable "
"values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they "
"allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution. In Cairo, a "
"parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:169
msgid ""
"**Note**: In Cairo, a parameter can only be passed as _mutable reference_ "
"using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:171
msgid ""
"In Listing 4-5, we use a mutable reference to modify the value of the "
"`height` and `width` fields of the `Rectangle` instance in the `flip` "
"function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:183
msgid "\"height: {}, width: {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:193
msgid ""
"<span class=\"caption\">Listing 4-5: Use of a mutable reference to modify a "
"value</span>"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:195
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of "
"`rec` into `flip` with `ref rec`, and update the function signature to "
"accept a mutable reference with `ref rec: Rectangle`. This makes it very "
"clear that the `flip` function will mutate the value of the `Rectangle` "
"instance passed as parameter."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:197
msgid "The output of the program is:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:209
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been "
"swapped."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:211
msgid "{{#quiz ../quizzes/ch04-02-references-and-snapshots.toml}}"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:213
msgid "Small Recap"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:215
msgid ""
"Let’s recap what we’ve discussed about the linear type system, ownership, "
"snapshots, and references:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:217
msgid "At any given time, a variable can only have one owner."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:218
msgid ""
"You can pass a variable by-value, by-snapshot, or by-reference to a function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:219
msgid ""
"If you pass-by-value, ownership of the variable is transferred to the "
"function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:220
msgid ""
"If you want to keep ownership of the variable and know that your function "
"won’t mutate it, you can pass it as a snapshot with `@`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:221
msgid ""
"If you want to keep ownership of the variable and know that your function "
"will mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""

#: src/ch05-00-using-structs-to-structure-related-data.md
msgid ""
"A struct, or structure, is a custom data type that lets you package together "
"and name multiple related values that make up a meaningful group. If you’re "
"familiar with an object-oriented language, a struct is like an object’s data "
"attributes. In this chapter, we’ll compare and contrast tuples with structs "
"to build on what you already know and demonstrate when structs are a better "
"way to group data."
msgstr ""

#: src/ch05-00-using-structs-to-structure-related-data.md
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called methods, to specify behavior associated with a struct type. Structs "
"and enums (discussed in the [next chapter](ch06-01-enums.md)) are the "
"building blocks for creating new types in your program’s domain to take full "
"advantage of Cairo's compile-time type checking."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in the [Data "
"Types](ch02-02-data-types.md) section, in that both hold multiple related "
"values. Like tuples, the pieces of a struct can be different types. Unlike "
"with tuples, in a struct you’ll name each piece of data so it’s clear what "
"the values mean. Adding these names means that structs are more flexible "
"than tuples: you don’t have to rely on the order of the data to specify or "
"access the values of an instance."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call fields. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:20
msgid "<span class=\"caption\">Listing 5-1: A `User` struct definition</span>"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:22
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for "
"the type, and instances fill in that template with particular data to create "
"values of the type."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:25
msgid "For example, we can declare two particular users as shown in Listing 5-2."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:40
#: src/ch05-01-defining-and-instantiating-structs.md:43
#: src/ch05-01-defining-and-instantiating-structs.md:65
#: src/ch05-01-defining-and-instantiating-structs.md:101
#: src/ch05-01-defining-and-instantiating-structs.md:137
#: src/ch05-01-defining-and-instantiating-structs.md:182
#: src/ch05-01-defining-and-instantiating-structs.md:219
msgid "\"someusername123\""
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:40
#: src/ch05-01-defining-and-instantiating-structs.md:43
#: src/ch05-01-defining-and-instantiating-structs.md:65
#: src/ch05-01-defining-and-instantiating-structs.md:101
#: src/ch05-01-defining-and-instantiating-structs.md:137
#: src/ch05-01-defining-and-instantiating-structs.md:182
#: src/ch05-01-defining-and-instantiating-structs.md:219
msgid "\"someone@example.com\""
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:49
msgid ""
"<span class=\"caption\">Listing 5-2: Creating two instances of the `User` "
"struct</span>"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:51
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access `user1`'s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email` "
"field of a mutable `User` instance."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:67
#: src/ch05-01-defining-and-instantiating-structs.md:103
#: src/ch05-01-defining-and-instantiating-structs.md:139
msgid "\"anotheremail@example.com\""
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:81
msgid ""
"<span class=\"caption\">Listing 5-3: Changing the value in the email field "
"of a `User` instance</span>"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:83
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to "
"mark only certain fields as mutable."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:85
msgid ""
"As with any expression, we can construct a new instance of the struct as the "
"last expression in the function body to implicitly return that new instance."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:87
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:117
msgid ""
"<span class=\"caption\">Listing 5-4: A `build_user` function that takes an "
"email and username and returns a `User` instance.</span>"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:119
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:121
msgid "Using the Field Init Shorthand"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:123
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the field init shorthand syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 5-5."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:153
msgid ""
"<span class=\"caption\">Listing 5-5: A `build_user` function that uses field "
"init shorthand because the `username` and `email` parameters have the same "
"name as struct fields.</span>"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:155
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:157
msgid "Creating Instances from Other Instances with Struct Update Syntax"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:159
msgid ""
"It’s often useful to create a new instance of a struct that includes most of "
"the values from another instance, but changes some. You can do this using "
"_struct update syntax_."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:163
msgid ""
"First, in Listing 5-6 we show how to create a new `User` instance in `user2` "
"regularly, without the update syntax. We set a new value for `email` but "
"otherwise use the same values from `user1` that we created in Listing 5-2."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:179
#: src/ch05-01-defining-and-instantiating-structs.md:216
msgid "// --snip--\n"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:188
#: src/ch05-01-defining-and-instantiating-structs.md:222
msgid "\"another@example.com\""
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:197
msgid ""
"<span class=\"caption\">Listing 5-6: Creating a new `User` instance using "
"all but one of the values from `user1`</span>"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:199
msgid ""
"Using struct update syntax, we can achieve the same effect with less code, "
"as shown in Listing 5-7. The syntax `..` specifies that the remaining fields "
"not explicitly set should have the same value as the fields in the given "
"instance."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:229
msgid ""
"<span class=\"caption\">Listing 5-7: Using struct update syntax to set a new "
"`email` value for a `User` instance but to use the rest of the values from "
"`user1`</span>"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:232
msgid ""
"The code in Listing 5-7 also creates an instance of `user2` that has a "
"different value for `email` but has the same values for the `username`, "
"`active`, and `sign_in_count` fields as `user1`. The `..user1` part must "
"come last to specify that any remaining fields should get their values from "
"the corresponding fields in `user1`, but we can choose to specify values for "
"as many fields as we want in any order, regardless of the order of the "
"fields in the struct’s definition."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:240
msgid ""
"Note that the struct update syntax uses `=` like an assignment; this is "
"because it moves the data, just as we saw in the [\"Moving "
"Values\"](ch04-01-what-is-ownership.md#moving-values)<!-- ignore --> "
"section. In this example, we can no longer use `user1` as a whole after "
"creating `user2` because the `ByteArray` in the `username` field of `user1` "
"was moved into `user2`. If we had given `user2` new `ByteArray` values for "
"both `email` and `username`, and thus only used the `active` and "
"`sign_in_count` values from `user1`, then `user1` would still be valid after "
"creating `user2`. Both `active` and `sign_in_count` are types that implement "
"the `Copy` trait, so the behavior we discussed in the [\"`Copy` "
"Trait\"](ch04-01-what-is-ownership.md#the-copy-trait)<!-- ignore --> section "
"would apply."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:249
msgid "{{#quiz ../quizzes/ch05-01-defining-and-instantiating-structs.toml}}"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the "
"width and height of a rectangle specified in pixels and calculate the area "
"of the rectangle. Listing 5-8 shows a short program with one way of doing "
"exactly that in our project’s _src/lib.cairo_."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:14
#: src/ch05-02-an-example-program-using-structs.md:56
#: src/ch05-02-an-example-program-using-structs.md:86
#: src/ch05-03-method-syntax.md:28 src/ch05-03-method-syntax.md:70
msgid "\"Area is {}\""
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:22
msgid ""
"<span class=\"caption\">Listing 5-8: Calculating the area of a rectangle "
"specified by separate width and height variables.</span>"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:24
msgid "Now run the program with `scarb cairo-run`:"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:36
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:38
msgid "The issue with this code is evident in the signature of `area`:"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:44
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our "
"program that the parameters are related. It would be more readable and more "
"manageable to group width and height together. We’ve already discussed one "
"way we might do that in the [Tuple Section of Chapter "
"2](ch02-02-data-types.html#the-tuple-type)."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:46
msgid "Refactoring with Tuples"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:48
msgid "Listing 5-9 shows another version of our program that uses tuples."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:65
msgid ""
"<span class=\"caption\">Listing 5-9: Specifying the width and height of the "
"rectangle with a tuple.</span>"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:67
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is "
"less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:69
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but "
"if we want to calculate the difference, it would matter! We would have to "
"keep in mind that `width` is the tuple index `0` and `height` is the tuple "
"index `1`. This would be even harder for someone else to figure out and keep "
"in mind if they were to use our code. Because we haven’t conveyed the "
"meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:71
msgid "Refactoring with Structs: Adding More Meaning"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:73
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:94
msgid ""
"<span class=\"caption\">Listing 5-10: Defining a `Rectangle` struct.</span>"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:96
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u64`. Then, in `main`, we created a particular instance of `Rectangle` "
"that has a width of `30` and a height of `10`. Our `area` function is now "
"defined with one parameter, which we’ve named `rectangle` which is of type "
"`Rectangle` struct. We can then access the fields of the instance with dot "
"notation, and it gives descriptive names to the values rather than using the "
"tuple index values of `0` and `1`."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:98
msgid "{{#quiz ../quizzes/ch05-02-an-example-program-using-structs.toml}}"
msgstr ""

#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a name, they can have parameters and a return value, and they contain "
"some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a struct (or an enum "
"which we cover in [Chapter 6](./ch06-01-enums.md)), and their first "
"parameter is always `self`, which represents the instance of the type the "
"method is being called on."
msgstr ""

#: src/ch05-03-method-syntax.md:5
msgid "Defining Methods"
msgstr ""

#: src/ch05-03-method-syntax.md:7
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter and instead make an `area` method defined on the `Rectangle` "
"struct, as shown in Listing 5-11"
msgstr ""

#: src/ch05-03-method-syntax.md:32
msgid "Listing 5-11: Defining an `area` method on the `Rectangle` struct."
msgstr ""

#: src/ch05-03-method-syntax.md:34
msgid ""
"To define the function within the context of `Rectangle`, we start an `impl` "
"(implementation) block for a trait `RectangleTrait` that defines the methods "
"that can be called on a `Rectangle` instance. As impl blocks can only be "
"defined for traits and not types, we need to define this trait first - but "
"it's not meant to be used for anything else."
msgstr ""

#: src/ch05-03-method-syntax.md:36
msgid ""
"Everything within this `impl` block will be associated with the `Rectangle` "
"type. Then we move the `area` function within the `impl` curly brackets and "
"change the first (and in this case, only) parameter to be `self` in the "
"signature and everywhere within the body. In `main`, where we called the "
"`area` function and passed `rect1` as an argument, we can instead use "
"_method syntax_ to call the `area` method on our `Rectangle` instance. The "
"method syntax goes after an instance: we add a dot followed by the method "
"name, parentheses, and any arguments."
msgstr ""

#: src/ch05-03-method-syntax.md:38
msgid ""
"In the signature for `area`, we use `self: @Rectangle` instead of "
"`rectangle: @Rectangle`. Methods must have a parameter named `self`, for "
"their first parameter, and the type of `self` indicates the type that method "
"can be called on. Methods can take ownership of `self`, but `self` can also "
"be passed by snapshot or by reference, just like any other parameter."
msgstr ""

#: src/ch05-03-method-syntax.md:41
msgid ""
"There is no direct link between a type and a trait. Only the type of the "
"`self` parameter of a method defines the type from which this method can be "
"called. That means, it is technically possible to define methods on multiple "
"types in a same trait (mixing `Rectangle` and `Circle` methods, for "
"example). But **this is not a recommended practice** as it can lead to "
"confusion."
msgstr ""

#: src/ch05-03-method-syntax.md:43
msgid ""
"The main reason for using methods instead of functions, in addition to "
"providing method syntax, is for organization. We’ve put all the things we "
"can do with an instance of a type in one `impl` block rather than making "
"future users of our code search for capabilities of `Rectangle` in various "
"places in the library we provide."
msgstr ""

#: src/ch05-03-method-syntax.md:45
msgid "The `generate_trait` Attribute"
msgstr ""

#: src/ch05-03-method-syntax.md:47
msgid ""
"If you are familiar with Rust, you may find Cairo's approach confusing "
"because methods cannot be defined directly on types. Instead, you must "
"define a [trait](./ch08-02-traits-in-cairo.md) and an implementation of this "
"trait associated with the type for which the method is intended. However, "
"defining a trait and then implementing it to define methods on a specific "
"type is verbose, and unnecessary: the trait itself will not be reused."
msgstr ""

#: src/ch05-03-method-syntax.md:50
msgid ""
"So, to avoid defining useless traits, Cairo provides the `#[generate_trait]` "
"attribute to add above a trait implementation, which tells to the compiler "
"to generate the corresponding trait definition for you, and let's you focus "
"on the implementation only. Both approaches are equivalent, but it's "
"considered a best practice to not explicitly define traits in this case."
msgstr ""

#: src/ch05-03-method-syntax.md:52
msgid "The previous example can also be written as follows:"
msgstr ""

#: src/ch05-03-method-syntax.md:75
msgid ""
"Let's use this `#[generate_trait]` in the following chapters to make our "
"code cleaner."
msgstr ""

#: src/ch05-03-method-syntax.md:77
msgid "Snapshots and References"
msgstr ""

#: src/ch05-03-method-syntax.md:79
msgid ""
"As the `area` method does not modify the calling instance, `self` is "
"declared as a snapshot of a `Rectangle` instance with the `@` snapshot "
"operator. But, of course, we can also define some methods receiving a "
"mutable reference of this instance, to be able to modify it."
msgstr ""

#: src/ch05-03-method-syntax.md:81
msgid ""
"Let's write a new method `scale` which resizes a rectangle of a `factor` "
"given as parameter:"
msgstr ""

#: src/ch05-03-method-syntax.md:98
msgid "\"The new size is (width: {}, height: {})\""
msgstr ""

#: src/ch05-03-method-syntax.md:102
msgid ""
"It is also possible to define a method which takes ownership of the instance "
"by using just `self` as the first parameter but it is rare. This technique "
"is usually used when the method transforms `self` into something else and "
"you want to prevent the caller from using the original instance after the "
"transformation."
msgstr ""

#: src/ch05-03-method-syntax.md:104
msgid ""
"Look at the [Understanding Ownership](ch04-00-understanding-ownership.md) "
"chapter for more details about these important notions."
msgstr ""

#: src/ch05-03-method-syntax.md:106
msgid "Methods with Several Parameters"
msgstr ""

#: src/ch05-03-method-syntax.md:108
msgid ""
"Let’s practice using methods by implementing another method on the "
"`Rectangle` struct. This time we want to write the method `can_hold` which "
"accepts another instance of `Rectangle` and returns `true` if this rectangle "
"can fit completely within self; otherwise, it should return false."
msgstr ""

#: src/ch05-03-method-syntax.md:132
msgid "\"Can rect1 hold rect2? {}\""
msgstr ""

#: src/ch05-03-method-syntax.md:133
msgid "\"Can rect1 hold rect3? {}\""
msgstr ""

#: src/ch05-03-method-syntax.md:137
msgid "Here, we expect that `rect1` can hold `rect2` but not `rect3`."
msgstr ""

#: src/ch05-03-method-syntax.md:139
msgid "Associated functions"
msgstr ""

#: src/ch05-03-method-syntax.md:141
msgid ""
"We call _associated functions_ all functions that are defined inside an "
"`impl` block that are associated to a specific type. While this is not "
"enforced by the compiler, it is a good practice to keep associated functions "
"related to the same type in the same `impl` block - for example, all "
"functions related to `Rectangle` will be grouped in the same `impl` block "
"for `RectangleTrait`."
msgstr ""

#: src/ch05-03-method-syntax.md:143
msgid ""
"Methods are a special kind of associated function, but we can also define "
"associated functions that don’t have `self` as their first parameter (and "
"thus are not methods) because they don’t need an instance of the type to "
"work with, but are still associated with that type."
msgstr ""

#: src/ch05-03-method-syntax.md:145
msgid ""
"Associated functions that aren’t methods are often used for constructors "
"that will return a new instance of the type. These are often called `new`, "
"but `new` isn’t a special name and isn’t built into the language. For "
"example, we could choose to provide an associated function named `square` "
"that would have one dimension parameter and use that as both width and "
"height, thus making it easier to create a square `Rectangle` rather than "
"having to specify the same value twice:"
msgstr ""

#: src/ch05-03-method-syntax.md:153
msgid ""
"Let's create the function `new` which creates a `Rectangle` from a `width` "
"and a `height`, `square` which creates a square `Rectangle` from a `size` "
"and `avg` which computes the average of two `Rectangle` instances:"
msgstr ""

#: src/ch05-03-method-syntax.md:182
msgid "\"The average Rectangle of {:?} and {:?} is {:?}\""
msgstr ""

#: src/ch05-03-method-syntax.md:190
msgid ""
"To call the `square` associated function, we use the `::` syntax with the "
"struct name; `let sq = Rectangle::square(3);` is an example. This function "
"is namespaced by the struct: the `::` syntax is used for both associated "
"functions and namespaces created by modules. We’ll discuss modules in "
"[Chapter 7](./ch07-02-defining-modules-to-control-scope.md)."
msgstr ""

#: src/ch05-03-method-syntax.md:196
msgid ""
"Note that the `avg` function could also be written as a method with `self` "
"as the first rectangle. In this case, instead of using the method with "
"`RectangleTrait::avg(@rect1, @rect2)`, it would be called with "
"`rect1.avg(rect2)`."
msgstr ""

#: src/ch05-03-method-syntax.md:198
msgid "Multiple Traits and `impl` Blocks"
msgstr ""

#: src/ch05-03-method-syntax.md:200
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For "
"example, the following code is equivalent to the code shown in the _Methods "
"with several parameters_ section, which has each method in its own `trait` "
"and `impl` blocks."
msgstr ""

#: src/ch05-03-method-syntax.md:219
msgid ""
"There’s no strong reason to separate these methods into multiple `trait` and "
"`impl` blocks here, but this is valid syntax."
msgstr ""

#: src/ch05-03-method-syntax.md:222
msgid "{{#quiz ../quizzes/ch05-03-method-syntax.toml}}"
msgstr ""

#: src/ch06-00-enums-and-pattern-matching.md
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. "
"Enums allow you to define a type by enumerating its possible _variants_. "
"First, we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called "
"`Option`, which expresses that a value can be either something or nothing. "
"Finally, we’ll look at how pattern matching in the `match` expression makes "
"it easy to run different code for different values of an enum."
msgstr ""

#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type "
"that consists of a fixed set of named values, called _variants_. Enums are "
"useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""

#: src/ch06-01-enums.md:5
msgid "Enum Variants and Values"
msgstr ""

#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr ""

#: src/ch06-01-enums.md:19
msgid ""
"In this example, we've defined an enum called `Direction` with four "
"variants: `North`, `East`, `South`, and `West`. The naming convention is to "
"use PascalCase for enum variants. Each variant represents a distinct value "
"of the `Direction` type. In this particular example, variants don't have any "
"associated value. One variant can be instantiated using this syntax:"
msgstr ""

#: src/ch06-01-enums.md:36
msgid ""
"Now let's imagine that our variants have associated values, that store the "
"exact degree of the direction. We can define a new `Direction` enum:"
msgstr ""

#: src/ch06-01-enums.md:52
msgid "and instantiate it as follows:"
msgstr ""

#: src/ch06-01-enums.md:68
msgid ""
"In this code, each variant is associated with a `u128` value, representing "
"the direction in degrees. In the next example, we will see that it is also "
"possible to associate different data types with each variant."
msgstr ""

#: src/ch06-01-enums.md:70
msgid ""
"It's easy to write code that acts differently depending on the variant of an "
"enum instance, in this example to run specific code according to a "
"direction. You can learn more about it in the [Match Control Flow "
"Construct](./ch06-02-the-match-control-flow-construct.md) section."
msgstr ""

#: src/ch06-01-enums.md:74
msgid "Enums Combined with Custom Types"
msgstr ""

#: src/ch06-01-enums.md:76
msgid ""
"Enums can also be used to store more interesting custom data associated with "
"each variant. For example:"
msgstr ""

#: src/ch06-01-enums.md:87
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo`, and "
"`Move`, all with different types:"
msgstr ""

#: src/ch06-01-enums.md:89
msgid "`Quit` doesn't have any associated value."
msgstr ""

#: src/ch06-01-enums.md:90
msgid "`Echo` is a single `felt252`."
msgstr ""

#: src/ch06-01-enums.md:91
msgid "`Move` is a tuple of two `u128` values."
msgstr ""

#: src/ch06-01-enums.md:93
msgid ""
"You could even use a Struct or another enum you defined inside one of your "
"enum variants."
msgstr ""

#: src/ch06-01-enums.md:95
msgid "Trait Implementations for Enums"
msgstr ""

#: src/ch06-01-enums.md:97
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. "
"This allows you to define methods and behaviors associated with the enum. "
"Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""

#: src/ch06-01-enums.md:107 src/ch06-01-enums.md:133
msgid "\"quitting\""
msgstr ""

#: src/ch06-01-enums.md:108 src/ch06-01-enums.md:134
msgid "\"echoing {}\""
msgstr ""

#: src/ch06-01-enums.md:109 src/ch06-01-enums.md:135
msgid "\"moving from {} to {}\""
msgstr ""

#: src/ch06-01-enums.md:115
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here "
"is how it could be used to process a Quit message:"
msgstr ""

#: src/ch06-01-enums.md:147
msgid "Running this code would print `quitting`."
msgstr ""

#: src/ch06-01-enums.md:149
msgid "The `Option` Enum and Its Advantages"
msgstr ""

#: src/ch06-01-enums.md:151
msgid ""
"The `Option` enum is a standard Cairo enum that represents the concept of an "
"optional value. It has two variants: `Some: T` and `None`. `Some: T` "
"indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr ""

#: src/ch06-01-enums.md:160
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent "
"the possibility of a value being absent, making your code more expressive "
"and easier to reason about. Using `Option` can also help prevent bugs caused "
"by using uninitialized or unexpected `null` values."
msgstr ""

#: src/ch06-01-enums.md:162
msgid ""
"To give you an example, here is a function which returns the index of the "
"first element of an array with a given value, or `None` if the element is "
"not present."
msgstr ""

#: src/ch06-01-enums.md:164
msgid "We are demonstrating two approaches for the above function:"
msgstr ""

#: src/ch06-01-enums.md:166
msgid "Recursive approach with `find_value_recursive`."
msgstr ""

#: src/ch06-01-enums.md:167
msgid "Iterative approach with `find_value_iterative`."
msgstr ""

#: src/ch06-01-enums.md:199
msgid ""
"Enums can be useful in many situations, especially when using the `match` "
"flow construct that we just used. We will describe it in the next section."
msgstr ""

#: src/ch06-01-enums.md:201
msgid ""
"Other enums are used very often, such as the `Result` enum, allowing to "
"handle errors gracefully. We will explain the `Result` enum in detail in the "
"[\"Error Handling\"](./ch09-02-recoverable-errors.md#the-result-enum) "
"chapter."
msgstr ""

#: src/ch06-01-enums.md:203
msgid "{{#quiz ../quizzes/ch06-01-enums.toml}}"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:3
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of "
"`match` comes from the expressiveness of the patterns and the fact that the "
"compiler confirms that all possible cases are handled."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Think of a `match` expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the "
"value “fits”, the value falls into the associated code block to be used "
"during execution."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Speaking of coins, let’s use them as an example using `match`! We can write "
"a function that takes an unknown US coin and, in a similar way as the "
"counting machine, determines which coin it is and returns its value in "
"cents, as shown in Listing 6-1."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:27
msgid ""
"<span class=\"caption\">Listing 6-1: An enum and a `match` expression that "
"has the variants of the enum as its patterns</span>"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:29
msgid ""
"Let’s break down the `match` expression in the `value_in_cents` function. "
"First, we list the `match` keyword followed by an expression, which in this "
"case is the value `coin`. This seems very similar to a conditional "
"expression used with the `if` statement, but there’s a big difference: with "
"`if`, the condition needs to evaluate to a boolean value, but here it can be "
"any type. The type of `coin` in this example is the `Coin` enum that we "
"defined on the first line."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with "
"a comma."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in the order they are given. If a pattern "
"matches the value, the code associated with that pattern is executed. If "
"that pattern doesn’t match the value, execution continues to the next arm, "
"much as in a coin-sorting machine. We can have as many arms as we need: in "
"the above example, our `match` has four arms."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire match expression."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:37
msgid ""
"We don’t typically use curly brackets if the `match` arm code is short, as "
"it is in our example where each arm just returns a value. If you want to run "
"multiple lines of code in a `match` arm, you must use curly brackets, with a "
"comma following the arm. For example, the following code prints “Lucky "
"penny!” every time the method is called with a `Coin::Penny`, but still "
"returns the last value of the block, `1`:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:43
msgid "\"Lucky penny!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:53
msgid "Patterns That Bind to Values"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:55
msgid ""
"Another useful feature of `match` arms is that they can bind to the parts of "
"the values that match the pattern. This is how we can extract values out of "
"enum variants."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:57
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. "
"From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information "
"to our `enum` by changing the `Quarter` variant to include a `UsState` value "
"stored inside it, which we’ve done in Listing 6-2."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:61
msgid "// Debug so we can inspect the state in a minute\n"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:76
msgid ""
"<span class=\"caption\">Listing 6-2: A `Coin` enum in which the `Quarter` "
"variant also holds a `UsState` value</span>"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:78
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of "
"the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:80
msgid ""
"In the `match` expression for this code, we add a variable called `state` to "
"the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that "
"quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:89
msgid "\"State quarter from {:?}!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:96
msgid ""
"Because `state` is an `UsState` enum which implements the `Debug` trait, we "
"can print `state` value with `println!` macro."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:98
msgid ""
"Note: `{:?}` is a special formatting syntax that allows to print a debug "
"form of the parameter passed to the `println!` macro. You can find more "
"information about it in [Appendix "
"C](./appendix-03-derivable-traits.html#debug-for-printing-and-debugging)."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:100
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` "
"would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with "
"each of the match arms, none of them match until we reach "
"`Coin::Quarter(state)`. At that point, the binding for `state` will be the "
"value `UsState::Alaska`. We can then use that binding in `println!` macro, "
"thus getting the inner state value out of the `Coin` enum variant for "
"`Quarter`."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:104
msgid "Matching with `Option<T>`"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:106
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:108
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if "
"there’s a value inside, adds `1` to that value. If there is no value inside, "
"the function should return the `None` value and not attempt to perform any "
"operations."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:110
msgid ""
"This function is very easy to write, thanks to `match`, and will look like "
"Listing 6-3."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:127
msgid ""
"<span class=\"caption\">Listing 6-3: A function that uses a `match` "
"expression on an `Option<u8>`</span>"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:129
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call "
"`plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each `match` arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:135
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! "
"We have the same variant. The `val` binds to the value contained in "
"`Option::Some`, so `val` takes the value `5`. The code in the `match` arm is "
"then executed, so we add `1` to the value of `val` and create a new "
"`Option::Some` value with our total `6` inside. Because the first arm "
"matched, no other arms are compared."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:137
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where "
"`x` is `Option::None`. We enter the `match` and compare to the first arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:143
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so "
"we continue to the next arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:149
msgid ""
"It matches! There’s no value to add to, so the matching construct ends and "
"returns the `Option::None` value on the right side of `=>`."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:151
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Cairo code: `match` against an enum, bind a variable to the "
"data inside, and then execute code based on it. It’s a bit tricky at first, "
"but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:153
msgid "Matches Are Exhaustive"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:155
msgid ""
"There’s one other aspect of `match` we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:165
msgid ""
"We didn’t handle the `None` case, so this code will cause a bug. Luckily, "
"it’s a bug Cairo knows how to catch. If we try to compile this code, we’ll "
"get this error:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:181
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the [billion-dollar "
"mistake](https://en.wikipedia.org/wiki/Null_pointer#History) discussed "
"earlier impossible."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:185
msgid "Catch-all with the `_` Placeholder"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:187
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. `_` is a special pattern "
"that matches any value and does not bind to that value. You can use it by "
"simply adding a new arm with `_` as the pattern for the last arm of the "
"`match` expression."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:191
msgid ""
"Imagine we have a vending machine that only accepts Dime coins. We want to "
"have a function that processes inserted coins and returns `true` only if the "
"coin is accepted."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:194
msgid "Here's a `vending_machine_accept` function that implements this logic:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:205
msgid ""
"This example also meets the exhaustiveness requirement because we’re "
"explicitly ignoring all other values in the last arm; we haven’t forgotten "
"anything."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:207
msgid ""
"There's no catch-all pattern in Cairo that allows you to use the value of "
"the pattern."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:213
msgid "Multiple Patterns with the `|` Operator"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:215
msgid ""
"In `match` expressions, you can match multiple patterns using the `|` "
"syntax, which is the pattern _or_ operator."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:217
msgid ""
"For example, in the following code we modified the `vending_machine_accept` "
"function to accept both `Dime` and `Quarter` coins in a single arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:228
msgid "Matching Tuples"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:230
msgid "It is possible to match tuples. Let's introduce a new `DayType` enum:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:242
msgid ""
"Now, let's suppose that our vending machine accepts any coin on weekdays, "
"but only accepts quarters and dimes on weekends and holidays. We can modify "
"the `vending_machine_accept` function to accept a tuple of a `Coin` and a "
"`Weekday` and return `true` only if the given coin is accepted on the "
"specified day:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:255
msgid ""
"Writing `(_, _)` for the last arm of a tuple matching pattern might feel "
"superfluous. Hence, we can use the `_ =>` syntax if we want, for example, "
"that our vending machine only accepts quarters on weekdays:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:266
msgid "Matching `felt252` and Integer Variables"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:268
msgid ""
"You can also match `felt252` and integer variables. This is useful when you "
"want to match against a range of values. However, there are some "
"restrictions:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:271
msgid ""
"Only integers that fit into a single `felt252` are supported (i.e. `u256` is "
"not supported)."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:272
msgid "The first arm must be 0."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:273
msgid "Each arm must cover a sequential segment, contiguously with other arms."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:275
msgid ""
"Imagine we’re implementing a game where you roll a six-sided die to get a "
"number between 0 and 5. If you have 0, 1 or 2 you win. If you have 3, you "
"can roll again. For all other values you lose."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:278
msgid "Here's a match that implements that logic:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:283
msgid "\"you won!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:284
msgid "\"you can roll again!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:285
msgid "\"you lost...\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:290
msgid "{{#quiz ../quizzes/ch06-02-match.toml}}"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:292
msgid "These restrictions are planned to be relaxed in future versions of Cairo."
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:3
msgid "`if let`"
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:5
msgid ""
"The `if let` syntax lets you combine `if` and `let` into a less verbose way "
"to handle values that match one pattern while ignoring the rest. Consider "
"the program in Listing 6-4 that matches on an `Option::Some<u8>` value in "
"the `config_max` variable but only wants to execute code if the value is "
"`Option::Some` variant."
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:11
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:33
msgid "\"The maximum is configured to be {}\""
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:17
msgid ""
"<span class=\"caption\">Listing 6-4: A `match` that only cares about "
"executing code when the value is `Option::Some`</span>"
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:20
msgid ""
"If the value is `Option::Some`, we print out the value in the `Option::Some` "
"variant by binding the value to the variable `max` in the pattern. We don’t "
"want to do anything with the `None` value. To satisfy the `match` "
"expression, we have to add `_ => ()` after processing just one variant, "
"which is annoying boilerplate code to add."
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:26
msgid ""
"Instead, we could write this in a shorter way using `if let`. The following "
"code behaves the same as the `match` in Listing 6-4:"
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:39
msgid ""
"The syntax `if let` takes a pattern and an expression separated by an equal "
"sign. It works the same way as a `match`, where the expression is given to "
"the `match` and the pattern is its first arm. In this case, the pattern is "
"`Option::Some(max)`, and `max` binds to the value inside `Option::Some`. We "
"can then use `max` in the body of the `if let` block in the same way we used "
"`max` in the corresponding `match` arm. The code in the `if let` block isn’t "
"run if the value doesn’t match the pattern."
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:47
msgid ""
"Using `if let` means less typing, less indentation, and less boilerplate "
"code. However, you lose the exhaustive checking that `match` enforces. "
"Choosing between `match` and `if let` depends on what you’re doing in your "
"particular situation and whether gaining conciseness is an appropriate "
"trade-off for losing exhaustive checking."
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:53
msgid ""
"In other words, you can think of `if let` as syntactic sugar for a `match` "
"that runs code when the value matches one pattern and then ignores all other "
"values."
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:56
msgid ""
"We can include an `else` with an `if let`. The block of code that goes with "
"`else` is the same as the block of code that would go with the `_` case in "
"the `match` expression. Recall the `Coin` enum definition in Listing 6-2, "
"where the `Quarter` variant also held a `UsState` value. If we wanted to "
"count all non-quarter coins we see while also announcing the state of the "
"quarters, we could do that with a `match` expression, like this:"
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:76
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:97
msgid "\"You got a quarter!\""
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:82
msgid "Or we could use an `if let` and `else` expression, like this:"
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:101
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:120
#: src/ch11-08-printing.md:59 src/ch11-08-printing.md:112
#: src/ch11-08-printing.md:130 src/ch11-08-printing.md:156
msgid "\"{}\""
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:106
msgid ""
"If you have a situation in which your program has logic that is too verbose "
"to express using `match`, remember that `if let` is in your Cairo toolbox as "
"well."
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:109
msgid "`while let`"
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:111
msgid ""
"The `while let` syntax is similar to the `if let` syntax, but it allows you "
"to loop over a collection of values and execute a block of code for each "
"value that matches a specified pattern. In the case below, the pattern is "
"`Option::Some(x)`, which matches any `Some` variant of the `Option` enum."
msgstr ""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:124
msgid ""
"Using `while let` provides a more concise and idiomatic way of writing this "
"loop compared to a traditional `while` loop with explicit pattern matching "
"or handling of the `Option` type. However, as with `if let`, you lose the "
"exhaustive checking that a `match` expression provides, so you need to be "
"careful to handle any remaining cases outside the `while let` loop if "
"necessary."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"As you write large programs, organizing your code will become increasingly "
"important. By grouping related functionality and separating code with "
"distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"The programs we’ve written so far have been in one module in one file. As a "
"project grows, you should organize code by splitting it into multiple "
"modules and then multiple files. As a package grows, you can extract parts "
"into separate crates that become external dependencies. This chapter covers "
"all these techniques."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse code at a higher level: once you’ve implemented an operation, other "
"code can call your code without having to know how the implementation works."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a set of names that are defined as “in scope”. When reading, writing, and "
"compiling code, programmers and compilers need to know whether a particular "
"name at a particular spot refers to a variable, function, struct, enum, "
"module, constant, or other item and what that item means. You can create "
"scopes and change which names are in or out of scope. You can’t have two "
"items with the same name in the same scope."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"Cairo has a number of features that allow you to manage your code’s "
"organization. These features, sometimes collectively referred to as the "
"_module system_, include:"
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Packages:** A Scarb feature that lets you build, test, and share crates."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Crates:** A tree of modules that corresponds to a single compilation unit. "
"It has a root directory, and a root module defined at the _lib.cairo_ file "
"under this directory."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Modules** and **use:** Let you control the organization and scope of items."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Paths:** A way of naming an item, such as a struct, function, or module."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and explain how to use them to manage scope. By the end, you should have a "
"solid understanding of the module system and be able to work with scopes "
"like a pro!"
msgstr ""

#: src/ch07-01-packages-and-crates.md:3
msgid "What is a Crate?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is a subset of a package that is used in the actual Cairo "
"compilation. This includes:"
msgstr ""

#: src/ch07-01-packages-and-crates.md:7
msgid ""
"The package source code, identified by the package name and the crate root, "
"which is the main entry point of the package."
msgstr ""

#: src/ch07-01-packages-and-crates.md:8
msgid ""
"A subset of the package metadata that identifies crate-level settings of the "
"Cairo compiler, for example, the `edition` field in the _Scarb.toml_ file."
msgstr ""

#: src/ch07-01-packages-and-crates.md:10
msgid ""
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as will be discussed in the subsequent "
"sections."
msgstr ""

#: src/ch07-01-packages-and-crates.md:12
msgid "What is the Crate Root?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:14
msgid ""
"The crate root is the _lib.cairo_ source file that the Cairo compiler starts "
"from and makes up the root module of your crate. We’ll explain modules in "
"depth in the [\"Defining Modules to Control "
"Scope\"](./ch07-02-defining-modules-to-control-scope.md) chapter."
msgstr ""

#: src/ch07-01-packages-and-crates.md:18
msgid "What is a Package?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:20
msgid "A Cairo package is a directory (or equivalent) containing:"
msgstr ""

#: src/ch07-01-packages-and-crates.md:22
msgid "A _Scarb.toml_ manifest file with a `[package]` section."
msgstr ""

#: src/ch07-01-packages-and-crates.md:23
msgid "Associated source code."
msgstr ""

#: src/ch07-01-packages-and-crates.md:25
msgid ""
"This definition implies that a package might contain other packages, with a "
"corresponding _Scarb.toml_ file for each package."
msgstr ""

#: src/ch07-01-packages-and-crates.md:27
msgid "Creating a Package with Scarb"
msgstr ""

#: src/ch07-01-packages-and-crates.md:29
msgid ""
"You can create a new Cairo package using the Scarb command-line tool. To "
"create a new package, run the following command:"
msgstr ""

#: src/ch07-01-packages-and-crates.md:35
msgid ""
"This command will generate a new package directory named _my_package_ with "
"the following structure:"
msgstr ""

#: src/ch07-01-packages-and-crates.md:44
msgid ""
"_src/_ is the main directory where all the Cairo source files for the "
"package will be stored."
msgstr ""

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"_lib.cairo_ is the default root module of the crate, which is also the main "
"entry point of the package."
msgstr ""

#: src/ch07-01-packages-and-crates.md:46
msgid ""
"_Scarb.toml_ is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, "
"version, and authors. You can find documentation about it on the [Scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""

#: src/ch07-01-packages-and-crates.md:48
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"edition = \"2023_11\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch07-01-packages-and-crates.md:58
msgid ""
"As you develop your package, you may want to organize your code into "
"multiple Cairo source files. You can do this by creating additional _.cairo_ "
"files within the _src_ directory or its subdirectories."
msgstr ""

#: src/ch07-01-packages-and-crates.md:60
msgid "{{#quiz ../quizzes/ch07-01-packages-crates.toml}}"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system, namely _paths_ that allow you to name items and the `use` keyword "
"that brings a path into scope."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when "
"you’re organizing your code in the future. Then we’ll explain each of the "
"rules in detail."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:11
msgid "Modules Cheat Sheet"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` "
"keyword work in the compiler, and how most developers organize their code. "
"We’ll be going through examples of each of these rules throughout this "
"chapter, but this is a great place to refer to as a reminder of how modules "
"work. You can create a new Scarb project with `scarb new backyard` to follow "
"along."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first "
"looks in the crate root file (_src/lib.cairo_) for code to compile."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:21
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; "
"say, you declare a “garden” module with `mod garden;`. The compiler will "
"look for the module’s code in these places:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:25
msgid ""
"Inline, within curly brackets that replace the semicolon following `mod "
"garden`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:28
msgid "// crate root file (src/lib.cairo)\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:30
msgid "// code defining the garden module goes here\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:34
msgid "In the file _src/garden.cairo_."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:36
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can "
"declare submodules. For example, you might declare `mod vegetables;` in "
"_src/garden.cairo_. The compiler will look for the submodule’s code within "
"the directory named for the parent module in these places:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:41
msgid ""
"Inline, directly following `mod vegetables`, within curly brackets instead "
"of the semicolon."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:45
msgid "// src/garden.cairo file\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:47
msgid "// code defining the vegetables submodule goes here\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:51
msgid "In the file _src/garden/vegetables.cairo_."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:53
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can "
"refer to code in that module from anywhere else in that same crate, using "
"the path to the code. For example, an `Asparagus` type in the `vegetables` "
"submodule would be found at `backyard::garden::vegetables::Asparagus`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:57
msgid ""
"**Private vs public**: Code within a module is private from its parent "
"modules by default. This means that it may only be accessed by the current "
"module and its descendants. To make a module public, declare it with `pub "
"mod` instead of `mod`. To make items within a public module public as well, "
"use `pub` before their declarations. Cairo also provides the `pub(crate)` "
"keyword, allowing an item or module to be only visible within the crate in "
"which the definition is included."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:59
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to items to reduce repetition of long paths. In any scope that can refer to "
"`backyard::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use backyard::garden::vegetables::Asparagus;` and from then on you only "
"need to write `Asparagus` to make use of that type in the scope."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:65
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The "
"crate’s directory, also named `backyard`, contains these files and "
"directories:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:78
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:88
msgid "\"I'm growing {:?}!\""
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:92
msgid ""
"The `pub mod garden;` line imports the `garden` module. Using `pub` to make "
"`garden` publicly accessible, or `pub(crate)` if you really want to make "
"`garden` only available for your crate, is optional to run our program here, "
"as the `main` function resides in the same module as `pub mod garden;` "
"declaration. Nevertheless, not declaring `garden` as `pub` will make it not "
"accessible from any other package. This line tells the compiler to include "
"the code it finds in _src/garden.cairo_, which is:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:95
msgid "<span class=\"filename\">Filename: src/garden.cairo</span>"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:101
msgid ""
"Here, `pub mod vegetables;` means the code "
"in _src/garden/vegetables.cairo_ is included too. That code is:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:108
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us bring the `Asparagus` "
"type into scope, so we can use it in the `main` function."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:111
msgid ""
"Now let’s get into the details of these rules and demonstrate them in action!"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:113
msgid "Grouping Related Code in Modules"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:115
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse. Modules also allow us to control the privacy of items, because code "
"within a module is private by default. Private items are internal "
"implementation details not available for outside use. We can choose to make "
"modules and the items within them public, which exposes them to allow "
"external code to use and depend on them."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:121
msgid ""
"As an example, let’s write a library crate that provides the functionality "
"of a restaurant. We’ll define the signatures of functions but leave their "
"bodies empty to concentrate on the organization of the code, rather than the "
"implementation of a restaurant."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:126
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as "
"_front of house_ and others as _back of house_. Front of house is where "
"customers are; this encompasses where the hosts seat customers, servers take "
"orders and payment, and bartenders make drinks. Back of house is where the "
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do "
"administrative work."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:133
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested modules. Create a new package named _restaurant_ by running `scarb "
"new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to "
"define some modules and function signatures. Here’s the front of house "
"section:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:157
msgid ""
"<span class=\"caption\">Listing 7-1: A `front_of_house` module containing "
"other modules that then contain functions</span>"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:159
msgid ""
"We define a module with the `mod` keyword followed by the name of the module "
"(in this case, `front_of_house`). The body of the module then goes inside "
"curly brackets. Inside modules, we can place other modules, as in this case "
"with the modules `hosting` and `serving`. Modules can also hold definitions "
"for other items, such as structs, enums, constants, traits, and functions."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:165
msgid ""
"By using modules, we can group related definitions together and name why "
"they’re related. Programmers using this code can navigate the code based on "
"the groups rather than having to read through all the definitions, making it "
"easier to find the definitions relevant to them. Programmers adding new "
"functionality to this code would know where to place the code to keep the "
"program organized."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:171
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The "
"reason for this name is that the content of this file forms a module named "
"after the crate name at the root of the crate’s module structure, known as "
"the _module tree_."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:174
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:188
msgid ""
"<span class=\"caption\">Listing 7-2: The module tree for the code in Listing "
"7-1</span>"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:190
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example, `hosting` nests inside `front_of_house`. The tree also shows that "
"some modules are _siblings_ to each other, meaning they’re defined in the "
"same module; `hosting` and `serving` are siblings defined within "
"`front_of_house`. If module A is contained inside module B, we say that "
"module A is the _child_ of module B and that module B is the _parent_ of "
"module A. Notice that the entire module tree is rooted under the explicit "
"name of the crate _restaurant_."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:198
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your "
"computer; this is a very apt comparison! Just like directories in a "
"filesystem, you use modules to organize your code. And just like files in a "
"directory, we need a way to find our modules."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:203
msgid "{{#quiz ../quizzes/ch07-02-defining-modules-to-control-scope.toml}}"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"An _absolute path_ is the full path starting from a crate root. The absolute "
"path begins with the crate name."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:8
msgid "A _relative path_ starts from the current module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:10
msgid ""
"Both absolute and relative paths are followed by one or more identifiers "
"separated by double colons (`::`)."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:12
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the "
"restaurant we used in the last chapter. We have a crate named _restaurant_ "
"in which we have a module named `front_of_house` that contains a module "
"named `hosting`. The `hosting` module contains a function named "
"`add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:35
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:100
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:126
msgid "// Absolute path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:38
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:103
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:129
msgid "// Relative path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:43
msgid ""
"<span class=\"caption\">Listing 7-3: Calling the `add_to_waitlist` function "
"using absolute and relative paths</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:45
msgid ""
"The `eat_at_restaurant` function is part of our library's public API, so we "
"mark it with the `pub` keyword. We’ll go into more detail about `pub` in "
"the [\"Exposing Paths with "
"the `pub` Keyword\"](./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#exposing-paths-with-the-pub-keyword) "
"section."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:47
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function "
"is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute "
"paths start from the crate root, which you need to refer to by using the "
"crate name. You can imagine a filesystem with the same structure: we’d "
"specify the path _/front_of_house/hosting/add_to_waitlist_ to run the "
"_add_to_waitlist_ program; using the crate name to start from the crate root "
"is like using a slash (`/`) to start from the filesystem root in your shell."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:51
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path "
"starts with `front_of_house`, the name of the module defined at the same "
"level of the module tree as `eat_at_restaurant`. Here the filesystem "
"equivalent would be using the path "
"_./front_of_house/hosting/add_to_waitlist_. Starting with a module name "
"means that the path is relative to the current module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:53
msgid ""
"Let’s try to compile Listing 7-3 and find out why it won’t compile yet! We "
"get the following error:"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:78
msgid ""
"The error messages say that module `hosting` and the `add_to_waitlist` "
"function are not visible. In other words, we have the correct paths for the "
"`hosting` module and the `add_to_waitlist` function, but Cairo won’t let us "
"use them because it doesn’t have access to them. In Cairo, all items "
"(functions, methods, structs, enums, modules, and constants) are private to "
"parent modules by default. If you want to make an item like a function or "
"struct private, you put it in a module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:80
msgid ""
"Items in a parent module can’t use the private items inside child modules, "
"but items in child modules can use the items in their ancestor modules. This "
"is because child modules wrap and hide their implementation details, but the "
"child modules can see the context in which they’re defined. To continue with "
"our metaphor, think of the privacy rules as being like the back office of a "
"restaurant: what goes on in there is private to restaurant customers, but "
"office managers can see and do everything in the restaurant they operate."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:82
msgid ""
"Cairo chose to have the module system function this way so that hiding inner "
"implementation details is the default. That way, you know which parts of the "
"inner code you can change without breaking outer code. However, Cairo does "
"give you the option to expose inner parts of child modules’ code to outer "
"ancestor modules by using the `pub` keyword to make an item public."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:86
msgid "Exposing Paths with the `pub` Keyword"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:88
msgid ""
"Let’s return to the previous error that told us the `hosting` module and the "
"`add_to_waitlist` function are not visible. We want the `eat_at_restaurant` "
"function in the parent module to have access to the `add_to_waitlist` "
"function in the child module, so we mark the `hosting` module with the `pub` "
"keyword, as shown in Listing 7-4."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:108
msgid ""
"<span class=\"caption\">Listing 7-4: Declaring the `hosting` module as `pub` "
"to use it from `eat_at_restaurant`</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:110
msgid "Unfortunately, the code in Listing 7-4 still results in an error."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:112
msgid ""
"What happened? Adding the `pub` keyword in front of `mod hosting;` makes the "
"module public. With this change, if we can access `front_of_house`, we can "
"access `hosting`. But the contents of `hosting` are still private; making "
"the module public doesn’t make its contents public. The `pub` keyword on a "
"module only lets code in its ancestor modules refer to it, not access its "
"inner code. Because modules are containers, there’s not much we can do by "
"only making the module public; we need to go further and choose to make one "
"or more of the items within the module public as well."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:114
msgid ""
"Let’s also make the `add_to_waitlist` function public by adding the `pub` "
"keyword before its definition, as in Listing 7-5."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:127
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:130
msgid "// ✅ Compiles\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:134
msgid ""
"<span class=\"caption\">Listing 7-5: Declaring the `hosting` module as `pub` "
"to use it from `eat_at_restaurant`</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:136
msgid ""
"Now the code will compile! To see why adding the `pub` keyword lets us use "
"these paths in `add_to_waitlist` with respect to the privacy rules, let’s "
"look at the absolute and the relative paths."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:138
msgid ""
"In the absolute path, we start with the crate root, the root of our crate’s "
"module tree. The `front_of_house` module is defined in the crate root. While "
"`front_of_house` isn’t public, because the `eat_at_restaurant` function is "
"defined in the same module as `front_of_house` (that is, `front_of_house` "
"and `eat_at_restaurant` are siblings), we can refer to `front_of_house` from "
"`eat_at_restaurant`. Next is the `hosting` module marked with `pub`. We can "
"access the parent module of `hosting`, so we can access `hosting` itself. "
"Finally, the `add_to_waitlist` function is marked with `pub` and we can "
"access its parent module, so this function call works!"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:140
msgid ""
"In the relative path, the logic is the same as the absolute path except for "
"the first step: rather than starting from the crate root, the path starts "
"from `front_of_house`. The `front_of_house` module is defined within the "
"same module as `eat_at_restaurant`, so the relative path starting from the "
"module in which `eat_at_restaurant` is defined works. Then, because "
"`hosting` and `add_to_waitlist` are marked with `pub`, the rest of the path "
"works, and this function call is valid!"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:142
msgid "{{#quiz ../quizzes/ch07-03-paths-in-module-tree-1.toml}}"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:144
msgid "Starting Relative Paths with `super`"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:146
msgid ""
"We can construct relative paths that begin in the parent module, rather than "
"the current module or the crate root, by using `super` at the start of the "
"path. This is like starting a filesystem path with the `..` syntax. Using "
"`super` allows us to reference an item that we know is in the parent module, "
"which can make rearranging the module tree easier when the module is closely "
"related to the parent, but the parent might be moved elsewhere in the module "
"tree someday."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:148
msgid ""
"Consider the code in Listing 7-6 that models the situation in which a chef "
"fixes an incorrect order and personally brings it out to the customer. The "
"function `fix_incorrect_order` defined in the `back_of_house` module calls "
"the function `deliver_order` defined in the parent module by specifying the "
"path to `deliver_order` starting with `super`:"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:165
msgid ""
"<span class=\"caption\">Listing 7-6: Calling a function using a relative "
"path starting with `super`</span>"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:167
msgid ""
"Here you can see directly that you access a parent's module easily using "
"`super`, which wasn't the case previously. Note that the `back_of_house` is "
"kept private, as external users are not supposed to interact with the back "
"of house directly."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:170
msgid "Making Structs and Enums Public"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:172
msgid ""
"We can also use `pub` to designate structs and enums as public, but there "
"are a few extra details to consider when using `pub` with structs and enums."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:174
msgid ""
"If we use `pub` before a struct definition, we make the struct public, but "
"the struct’s fields will still be private. We can make each field public or "
"not on a case-by-case basis."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:175
msgid ""
"In contrast, if we make an enum public, all of its variants are then public. "
"We only need the `pub` before the `enum` keyword."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:177
msgid ""
"There’s one more situation involving `pub` that we haven’t covered, and that "
"is our last module system feature: the `use` keyword. We’ll cover `use` by "
"itself first, and then we’ll show how to combine `pub` and `use`."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:179
msgid "{{#quiz ../quizzes/ch07-03-paths-in-module-tree-2.toml}}"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can "
"create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 7-7, we bring the `restaurant::front_of_house::hosting` module "
"into the scope of the `eat_at_restaurant` function so we only have to "
"specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in "
"`eat_at_restaurant`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:13
msgid ""
"// Assuming \"front_of_house\" module is contained in a crate called "
"\"restaurant\", as mentioned in the section \"Defining Modules to Control "
"Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in "
"the use statement\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:25
msgid "// ✅ Shorter path\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid ""
"<span class=\"caption\">Listing 7-7: Bringing a module into scope with "
"`use`</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:31
msgid ""
"Adding `use` and a path in a scope is similar to creating a symbolic link in "
"the filesystem. By adding `use restaurant::front_of_house::hosting;` in the "
"crate root, `hosting` is now a valid name in that scope, just as though the "
"`hosting` module had been defined in the crate root."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:33
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-8 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:54
msgid ""
"<span class=\"caption\">Listing 7-8: A `use` statement only applies in the "
"scope it’s in.</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:75
msgid "Creating Idiomatic `use` Paths"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
msgid ""
"In Listing 7-7, you might have wondered why we specified `use "
"restaurant::front_of_house::hosting` and then called "
"`hosting::add_to_waitlist` in `eat_at_restaurant` rather than specifying the "
"`use` path all the way out to the `add_to_waitlist` function to achieve the "
"same result, as in Listing 7-9."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:97
msgid ""
"<span class=\"caption\">Listing 7-9: Bringing the `add_to_waitlist` function "
"into scope with `use`, which is unidiomatic</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:99
msgid ""
"Although both Listing 7-7 and 7-9 accomplish the same task, Listing 7-7 is "
"the idiomatic way to bring a function into scope with `use`. Bringing the "
"function’s parent module into scope with `use` means we have to specify the "
"parent module when calling the function. Specifying the parent module when "
"calling the function makes it clear that the function isn’t locally defined "
"while still minimizing repetition of the full path. The code in Listing 7-9 "
"is unclear as to where `add_to_waitlist` is defined."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:107
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items "
"with `use`, it’s idiomatic to specify the full path. Listing 7-10 shows the "
"idiomatic way to bring the core library’s `BitSize` trait into the scope, "
"allowing to call `bits` method to retrieve the size in bits of a type."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:114
msgid "\"A u8 variable has {} bits\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"<span class=\"caption\">Listing 7-10: Bringing `BitSize` trait into scope in "
"an idiomatic way</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:120
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has emerged in the Rust community, and folks have gotten used to reading and "
"writing Rust code this way. As Cairo shares many idioms with Rust, we follow "
"this convention as well."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:124
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Cairo doesn’t allow that."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid "Providing New Names with the `as` Keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:129
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: after the path, we can specify `as` and "
"a new local name, or _alias_, for the type. Listing 7-11 shows how you can "
"rename an import with `as`:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:139
msgid "// ArrayTrait was renamed to Arr\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:144
msgid ""
"<span class=\"caption\">Listing 7-11: Renaming a trait when it’s brought "
"into scope with the `as` keyword</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:146
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now "
"access the trait's methods with the `Arr` identifier."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:148
msgid "Importing Multiple Items from the Same Module"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:150
msgid ""
"When you want to import multiple items (like functions, structs or enums) "
"from the same module in Cairo, you can use curly braces `{}` to list all of "
"the items that you want to import. This helps to keep your code clean and "
"easy to read by avoiding a long list of individual `use` statements."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:155
msgid "The general syntax for importing multiple items from the same module is:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:161
msgid "Here is an example where we import three structures from the same module:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:164
msgid ""
"// Assuming we have a module called `shapes` with the structures `Square`, "
"`Circle`, and `Triangle`.\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:182
msgid ""
"// We can import the structures `Square`, `Circle`, and `Triangle` from the "
"`shapes` module like this:\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:185
msgid ""
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:190
#: src/ch17-01-general-recommendations.md:143
#: src/ch17-01-general-recommendations.md:148
msgid "// ...\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:195
msgid ""
"<span class=\"caption\">Listing 7-12: Importing multiple items from the same "
"module</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:197
msgid "Re-exporting Names in Module Files"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:199
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in the new scope can be imported as if it had been defined in that code’s "
"scope. This technique is called _re-exporting_ because we’re bringing an "
"item into scope, but also making that item available for others to bring "
"into their scope, with the `pub` keyword."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:204
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the "
"restaurant example:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:222
msgid ""
"<span class=\"caption\">Listing 7-13: Making a name available for any code "
"to use from a new scope with `pub use`</span>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path "
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this `pub "
"use` has re-exported the `hosting` module from the root module, external "
"code can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:229
msgid ""
"Re-exporting is useful when the internal structure of your code is different "
"from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `pub use`, we can write our code with one structure but expose a "
"different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:238
msgid "Using External Packages in Cairo with Scarb"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:240
msgid ""
"You might need to use external packages to leverage the functionality "
"provided by the community. Scarb allows you to use dependencies by cloning "
"packages from their Git repositories. To use an external package in your "
"project with Scarb, simply declare the Git repository URL of the dependency "
"you want to add in a dedicated `[dependencies]` section in your _Scarb.toml_ "
"configuration file. Note that the URL might correspond to the main branch, "
"or any specific commit, branch or tag. For this, you will have to pass an "
"extra `rev`, `branch`, or `tag` field, respectively. For example, the "
"following code imports the main branch of _alexandria_math_ crate from "
"_alexandria_ package:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:244
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:251
msgid "\"https://github.com/keep-starknet-strange/alexandria.git\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:247
msgid ""
"while the following code imports a specific branch (which is deprecated and "
"should not be used):"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:251
msgid "\"cairo-v2.3.0-rc0\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:254
msgid ""
"If you want to import multiple packages in your project, you need to create "
"only one `[dependencies]` section and list all the desired packages beneath "
"it. You can also specify development dependencies by declaring a "
"`[dev-dependencies]` section."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:256
msgid ""
"After that, simply run `scarb build` to fetch all external dependencies and "
"compile your package with all the dependencies included."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:258
msgid ""
"Note that it is also possible to add dependencies with the `scarb add` "
"command, which will automatically edit the _Scarb.toml_ file for you. For "
"development dependencies, just use the `scarb add --dev` command."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:260
msgid ""
"To remove a dependency, simply remove the corresponding line from your "
"_Scarb.toml_ file, or use the `scarb rm` command."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:262
msgid "{{#quiz ../quizzes/ch07-04-bringing-paths-into-scope.toml}}"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file. When modules get large, you might want to move their definitions to a "
"separate file to make the code easier to navigate."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-7 that had multiple "
"restaurant modules. We’ll extract modules into files instead of having all "
"the modules defined in the crate root file. In this case, the crate root "
"file is _src/lib.cairo_."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the "
"code inside the curly brackets for the `front_of_house` module, leaving only "
"the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the "
"code shown in Listing 7-14. Note that this won’t compile until we create the "
"_src/front_of_house.cairo_ file."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:30
msgid ""
"<span class=\"caption\">Listing 7-14: Declaring the `front_of_house` module "
"whose body will be in _src/front_of_house.cairo_</span>"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:32
msgid ""
"Next, place the code that was in the curly brackets into a new file named "
"_src/front_of_house.cairo_, as shown in Listing 7-15. The compiler knows to "
"look in this file because it came across the module declaration in the crate "
"root with the name `front_of_house`."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:37
#: src/ch07-05-separating-modules-into-different-files.md:63
msgid "<span class=\"filename\">Filename: src/front_of_house.cairo</span>"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:45
msgid ""
"<span class=\"caption\">Listing 7-15: Definitions inside the "
"`front_of_house` module in _src/front_of_house.cairo_</span>"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:47
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your module tree. Once the compiler knows the file is part of the project "
"(and knows where in the module tree the code resides because of where you’ve "
"put the `mod` statement), other files in your project should refer to the "
"loaded file’s code using a path to where it was declared, as covered in the "
"[\"Paths for Referring to an Item in the Module "
"Tree\"](./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md) "
"chapter. In other words, `mod` is _not_ an “include” operation that you may "
"have seen in other programming languages."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:55
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit different because `hosting` is a child module of `front_of_house`, not "
"of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case "
"_src/front_of_house/_."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:60
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain "
"only the declaration of the `hosting` module:"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:69
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ "
"to contain the definitions made in the `hosting` module:"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:72
msgid ""
"<span class=\"filename\">Filename: src/front_of_house/hosting.cairo</span>"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:78
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would "
"expect the _hosting.cairo_ code to be in a `hosting` module declared in the "
"crate root, and not declared as a child of the `front_of_house` module. The "
"compiler’s rules for which files to check for which modules’ code means the "
"directories and files more closely match the module tree."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:84
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains the same. The function calls in `eat_at_restaurant` will work "
"without any modification, even though the definitions live in different "
"files. This technique lets you move modules to new files as they grow in "
"size."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:89
msgid ""
"Note that the `use restaurant::front_of_house::hosting;` statement in "
"_src/lib.cairo_ also hasn’t changed, nor does `use` have any impact on what "
"files are compiled as part of the crate. The `mod` keyword declares modules, "
"and Cairo looks in a file with the same name as the module for the code that "
"goes into that module."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:99
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules "
"so you can refer to items defined in one module from another module. You can "
"do this by specifying absolute or relative paths. These paths can be brought "
"into scope with a `use` statement so you can use a shorter path for multiple "
"uses of the item in that scope. Module code is **private** by default."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:105
msgid "{{#quiz ../quizzes/ch07-05-separate-modules.toml}}"
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Cairo, one such tool is generics: abstract "
"stand-ins for concrete types or other properties. We can express the "
"behavior of generics or how they relate to other generics without knowing "
"what will be in their place when compiling and running the code."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Functions can take parameters of some generic type, instead of a concrete "
"type like `u32` or `bool`, in the same way a function takes parameters with "
"unknown values to run the same code on multiple concrete values. In fact, "
"we’ve already used generics in [Chapter "
"6](./ch06-01-enums.html#the-option-enum-and-its-advantages) with `Option<T>`."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"In this chapter, you’ll explore how to define your own types, functions, and "
"traits with generics."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication. Upon compilation, the "
"compiler creates a new definition for each concrete type that replaces a "
"generic type, reducing development time for the programmer, but code "
"duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which "
"will cause contract size to increment."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You "
"can combine traits with generic types to constrain a generic type to accept "
"only those types that have a particular behavior, as opposed to just any "
"type."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid "Removing Duplication by Extracting a Function"
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication. Before diving into "
"generics syntax, let’s first look at how to remove duplication in a way that "
"doesn’t involve generic types by extracting a function that replaces "
"specific values with a placeholder that represents multiple values. Then "
"we’ll apply the same technique to extract a generic function! By learning "
"how to identify duplicated code that can be extracted into a function, "
"you'll start to recognize instances where generics can be used to reduce "
"duplication."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We begin with a short program that finds the largest number in an array of "
"`u8`:"
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid "\"The largest number is {}\""
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We store an array of `u8` in the variable `number_list` and extract the "
"first number in the array in a variable named `largest`. We then iterate "
"through all the numbers in the array, and if the current number is greater "
"than the number stored in `largest`, we update the value of `largest`. "
"However, if the current number is less than or equal to the largest number "
"seen so far, the variable doesn’t change, and the code moves on to the next "
"number in the list. After considering all the numbers in the array, "
"`largest` should contain the largest number, which in this case is 100."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We've now been tasked with finding the largest number in two different "
"arrays of numbers. To do so, we can choose to duplicate the previous code "
"and use the same logic at two different places in the program, as follows:"
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Although this code works, duplicating code is tedious and error-prone. We "
"also have to remember to update the code in multiple places when we want to "
"change it."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"To eliminate this duplication, we’ll create an abstraction by defining a "
"function that operates on any array of `u8` passed in a parameter. This "
"solution makes our code clearer and lets us express the concept of finding "
"the largest number in an array abstractly."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"To do that, we extract the code that finds the largest number into a "
"function named `largest`. Then we call the function to find the largest "
"number in the two arrays. We could also use the function on any other array "
"of `u8` values we might have in the future."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"The largest function has a parameter called `number_list`, passed by "
"reference, which represents any concrete array of `u8` values we might pass "
"into the function. As a result, when we call the function, the code runs on "
"the specific values that we pass in."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid "In summary, here are the steps we took to change the code:"
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid "Identify duplicate code."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Extract the duplicate code into the body of the function and specify the "
"inputs and return values of that code in the function signature."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid "Update the two instances of duplicated code to call the function instead."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Next, we’ll use these same steps with generics to reduce code duplication. "
"In the same way that the function body can operate on an abstract `Array<T>` "
"instead of specific `u8` values, generics allow code to operate on abstract "
"types."
msgstr ""

#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs "
"and functions, which we can then use with many different concrete data "
"types. In Cairo, we can use generics when defining functions, structs, "
"enums, traits, implementations and methods. In this chapter, we are going to "
"take a look at how to effectively use generic types with all of them."
msgstr ""

#: src/ch08-01-generic-data-types.md:5
msgid ""
"Generics allow us to write reusable code that works with many types, thus "
"avoiding code duplication, while enhancing code maintainability."
msgstr ""

#: src/ch08-01-generic-data-types.md:7
msgid "Generic Functions"
msgstr ""

#: src/ch08-01-generic-data-types.md:9
msgid ""
"Making a function generic means it can operate on different types, avoiding "
"the need for multiple, type-specific implementations. This leads to "
"significant code reduction and increases the flexibility of the code."
msgstr ""

#: src/ch08-01-generic-data-types.md:11
msgid ""
"When defining a function that uses generics, we place the generics in the "
"function signature, where we would usually specify the data types of the "
"parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If "
"we need to perform this operation for lists of different types, then we "
"would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr ""

#: src/ch08-01-generic-data-types.md:14
msgid "// Specify generic type T between the angulars\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:27
msgid ""
"// There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:33
msgid ""
"The `largest_list` function compares two lists of the same type and returns "
"the one with more elements and drops the other. If you compile the previous "
"code, you will notice that it will fail with an error saying that there are "
"no traits defined for dropping an array of a generic type. This happens "
"because the compiler has no way to guarantee that an `Array<T>` is droppable "
"when executing the `main` function. In order to drop an array of `T`, the "
"compiler must first know how to drop `T`. This can be fixed by specifying in "
"the function signature of `largest_list` that `T` must implement the `Drop` "
"trait. The correct function definition of `largest_list` is as follows:"
msgstr ""

#: src/ch08-01-generic-data-types.md:45
msgid ""
"The new `largest_list` function includes in its definition the requirement "
"that whatever generic type is placed there, it must be droppable. This is "
"what we call _trait bounds_. The `main` function remains unchanged, the "
"compiler is smart enough to deduce which concrete type is being used and if "
"it implements the `Drop` trait."
msgstr ""

#: src/ch08-01-generic-data-types.md:47
msgid "Constraints for Generic Types"
msgstr ""

#: src/ch08-01-generic-data-types.md:49
msgid ""
"When defining generic types, it is useful to have information about them. "
"Knowing which traits a generic type implements allows us to use it more "
"effectively in a function's logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this "
"previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compiler's requirements, we can also add constraints to benefit our function "
"logic."
msgstr ""

#: src/ch08-01-generic-data-types.md:51
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, to "
"find the smallest element among them. Initially, we know that for an element "
"of type `T` to be comparable, it must implement the `PartialOrd` trait. The "
"resulting function would be:"
msgstr ""

#: src/ch08-01-generic-data-types.md:54
msgid ""
"// Given a list of T get the smallest one\n"
"// The PartialOrd trait implements comparison operations for T\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:57
msgid ""
"// This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:61
msgid "// The index we will use to move through the list\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:64
msgid "// Iterate through the whole list storing the smallest\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:79
msgid ""
"// We need to specify that we are passing a snapshot of `list` as an "
"argument\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:85
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and "
"returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so "
"we are not required to implement the `Drop` trait for `T` as well. Why does "
"it not compile then?"
msgstr ""

#: src/ch08-01-generic-data-types.md:87
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element, "
"and unless `PartialOrd` is implemented for `@T` we need to desnap the "
"element using `*`. The `*` operation requires a copy from `@T` to `T`, which "
"means that `T` needs to implement the `Copy` trait. After copying an element "
"of type `@T` to `T`, there are now variables with type `T` that need to be "
"dropped, requiring `T` to implement the `Drop` trait as well. We must then "
"add both `Drop` and `Copy` traits implementation for the function to be "
"correct. After updating the `smallest_element` function the resulting code "
"would be:"
msgstr ""

#: src/ch08-01-generic-data-types.md:108
msgid "Anonymous Generic Implementation Parameter (`+` Operator)"
msgstr ""

#: src/ch08-01-generic-data-types.md:110
msgid ""
"Until now, we have always specified a name for each implementation of the "
"required generic trait: `TPartialOrd` for `PartialOrd<T>`, `TDrop` for "
"`Drop<T>`, and `TCopy` for `Copy<T>`."
msgstr ""

#: src/ch08-01-generic-data-types.md:112
msgid ""
"However, most of the time, we don't use the implementation in the function "
"body; we only use it as a constraint. In these cases, we can use the `+` "
"operator to specify that the generic type must implement a trait without "
"naming the implementation. This is referred to as an _anonymous generic "
"implementation parameter_."
msgstr ""

#: src/ch08-01-generic-data-types.md:114
msgid ""
"For example, `+PartialOrd<T>` is equivalent to `impl TPartialOrd: "
"PartialOrd<T>`."
msgstr ""

#: src/ch08-01-generic-data-types.md:116
msgid "We can rewrite the `smallest_element` function signature as follows:"
msgstr ""

#: src/ch08-01-generic-data-types.md:134
msgid "Structs"
msgstr ""

#: src/ch08-01-generic-data-types.md:136
msgid ""
"We can also define structs to use a generic type parameter for one or more "
"fields using the `<>` syntax, similar to function definitions. First, we "
"declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct "
"definition where we would otherwise specify concrete data types. The next "
"code example shows the definition `Wallet<T>` which has a `balance` field of "
"type `T`."
msgstr ""

#: src/ch08-01-generic-data-types.md:149
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically. "
"It is equivalent to writing the following code:"
msgstr ""

#: src/ch08-01-generic-data-types.md:163
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and "
"instead define our own `WalletDrop` implementation. Notice that we must "
"define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying "
"that the struct `Wallet<T>` is droppable as long as `T` is also droppable."
msgstr ""

#: src/ch08-01-generic-data-types.md:165
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and "
"we want that field to be different than `T` but generic as well, we can "
"simply add another generic type between the `<>`:"
msgstr ""

#: src/ch08-01-generic-data-types.md:179
msgid ""
"We add to the `Wallet` struct definition a new generic type `U` and then "
"assign this type to the new field member `address`. Notice that the `derive` "
"attribute for the `Drop` trait works for `U` as well."
msgstr ""

#: src/ch08-01-generic-data-types.md:183
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. For example the `Option<T>` enum provided by the Cairo core "
"library:"
msgstr ""

#: src/ch08-01-generic-data-types.md:192
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: "
"`Some`, which holds one value of type `T` and `None` that doesn't hold any "
"value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic "
"type `T` we can use this abstraction with any type."
msgstr ""

#: src/ch08-01-generic-data-types.md:194
msgid ""
"Enums can use multiple generic types as well, like the definition of the "
"`Result<T, E>` enum that the core library provides:"
msgstr ""

#: src/ch08-01-generic-data-types.md:203 src/ch09-02-recoverable-errors.md:16
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two "
"variants: `Ok` which holds the value of type `T` and `Err` which holds the "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (by returning a value "
"of type `T`) or fail (by returning a value of type `E`)."
msgstr ""

#: src/ch08-01-generic-data-types.md:205
msgid "Generic Methods"
msgstr ""

#: src/ch08-01-generic-data-types.md:207
msgid ""
"We can implement methods on structs and enums, and use the generic types in "
"their definitions, too. Using our previous definition of `Wallet<T>` struct, "
"we define a `balance` method for it:"
msgstr ""

#: src/ch08-01-generic-data-types.md:231
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which "
"defines a method that returns the value of the field `balance` from "
"`Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. "
"Note that you need to include a generic type in both definitions of the "
"trait and the implementation."
msgstr ""

#: src/ch08-01-generic-data-types.md:233
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only for `Wallet<u128>` "
"instances rather than `Wallet<T>`. In the code example, we define an "
"implementation for wallets which have a concrete type of `u128` for the "
"`balance` field."
msgstr ""

#: src/ch08-01-generic-data-types.md:240
msgid "/// Generic trait for wallets\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:251
msgid "/// Trait for wallets of type u128\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:272
msgid ""
"The new method `receive` increments the size of `balance` of any instance of "
"a `Wallet<u128>`. Notice that we changed the `main` function making `w` a "
"mutable variable in order for it to be able to update its balance. If we "
"were to change the initialization of `w` by changing the type of `balance` "
"the previous code wouldn't compile."
msgstr ""

#: src/ch08-01-generic-data-types.md:274
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. "
"Using the past implementation from `Wallet<U, V>` we are going to define a "
"trait that picks two wallets of different generic types and creates a new "
"one with a generic type of each. First, let's rewrite the struct definition:"
msgstr ""

#: src/ch08-01-generic-data-types.md:283
msgid "Next, we are going to naively define the mixup trait and implementation:"
msgstr ""

#: src/ch08-01-generic-data-types.md:286
msgid "// This does not compile!\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:299
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` "
"method which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` "
"creates a new `Wallet<T1, U2>`. As `mixup` signature specifies, both `self` "
"and `other` are getting dropped at the end of the function, which is why "
"this code does not compile. If you have been following from the start until "
"now you would know that we must add a requirement for all the generic types "
"specifying that they will implement the `Drop` trait for the compiler to "
"know how to drop instances of `Wallet<T, U>`. The updated implementation is "
"as follows:"
msgstr ""

#: src/ch08-01-generic-data-types.md:317
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` "
"declaration. Then we do the same for `T2` and `U2`, this time as part of "
"`mixup` signature. We can now try the `mixup` function:"
msgstr ""

#: src/ch08-01-generic-data-types.md:331
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, "
"u8>` instance."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"A trait defines a set of methods that can be implemented by a type. These "
"methods can be called on instances of the type when this trait is "
"implemented. A trait combined with a generic type defines functionality a "
"particular type has and can share with other types. We can use traits to "
"define shared behavior in an abstract way. We can use _trait bounds_ to "
"specify that a generic type can be any type that has certain behavior."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:7
msgid ""
"Note: Traits are similar to a feature often called interfaces in other "
"languages, although with some differences."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"While traits can be written to not accept generic types, they are most "
"useful when used with generic types. We already covered generics in the "
"[previous chapter](./ch08-01-generic-data-types.md), and we will use them in "
"this chapter to demonstrate how traits can be used to define shared behavior "
"for generic types."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:13
msgid "Defining a Trait"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:15
msgid ""
"A type’s behavior consists of the methods we can call on that type. "
"Different types share the same behavior if we can call the same methods on "
"all of those types. Trait definitions are a way to group method signatures "
"together to define a set of behaviors necessary to accomplish some purpose."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:17
msgid ""
"For example, let’s say we have a struct `NewsArticle` that holds a news "
"story in a particular location. We can define a trait `Summary` that "
"describes the behavior of something that can summarize the `NewsArticle` "
"type."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:34
msgid "\"{:?} by {:?} ({:?})\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:41
msgid ""
"Here, we declare a trait using the `trait` keyword and then the trait’s "
"name, which is `Summary` in this case. We’ve also declared the trait as "
"`pub` so that crates depending on this crate can make use of this trait too, "
"as we’ll see in a few examples."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:44
msgid ""
"Inside the curly brackets, we declare the method signatures that describe "
"the behaviors of the types that implement this trait, which in this case is "
"`fn summarize(self: @NewsArticle) -> ByteArray;`. After the method "
"signature, instead of providing an implementation within curly brackets, we "
"use a semicolon."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:46
msgid ""
"Note: the `ByteArray` type is the type used to represent strings in Cairo."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:48
msgid ""
"As the trait is not generic, the `self` parameter is not generic either and "
"is of type `@NewsArticle`. This means that the `summarize` method can only "
"be called on instances of `NewsArticle`."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:50
msgid ""
"Now, consider that we want to make a media aggregator library crate named "
"_aggregator_ that can display summaries of data that might be stored in a "
"`NewsArticle` or `Tweet` instance. To do this, we need a summary from each "
"type, and we’ll request that summary by calling a summarize method on an "
"instance of that type. By defining the `Summary` trait on generic type `T`, "
"we can implement the `summarize` method on any type we want to be able to "
"summarize."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:68 src/ch08-02-traits-in-cairo.md:145
#: src/ch08-02-traits-in-cairo.md:222
msgid "\"{} by {} ({})\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:82 src/ch08-02-traits-in-cairo.md:159
#: src/ch08-02-traits-in-cairo.md:236
msgid "\"{}: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:91 src/ch08-02-traits-in-cairo.md:168
#: src/ch08-02-traits-in-cairo.md:245
msgid "\"Cairo has become the most popular language for developers\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:92 src/ch08-02-traits-in-cairo.md:169
#: src/ch08-02-traits-in-cairo.md:246
msgid "\"Worldwide\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:93 src/ch08-02-traits-in-cairo.md:170
#: src/ch08-02-traits-in-cairo.md:247
msgid "\"Cairo Digger\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:94 src/ch08-02-traits-in-cairo.md:171
#: src/ch08-02-traits-in-cairo.md:248
msgid "\"Cairo is a new programming language for zero-knowledge proofs\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:98 src/ch08-02-traits-in-cairo.md:175
#: src/ch08-02-traits-in-cairo.md:252
msgid "\"EliBenSasson\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:99 src/ch08-02-traits-in-cairo.md:176
#: src/ch08-02-traits-in-cairo.md:253
msgid ""
"\"Crypto is full of short-term maximizing projects. \\n"
" @Starknet and @StarkWareLtd are about long-term vision maximization.\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:102 src/ch08-02-traits-in-cairo.md:179
#: src/ch08-02-traits-in-cairo.md:256
msgid "// Tweet instantiation\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:104 src/ch08-02-traits-in-cairo.md:181
#: src/ch08-02-traits-in-cairo.md:258
msgid "\"New article available! {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:105 src/ch08-02-traits-in-cairo.md:182
#: src/ch08-02-traits-in-cairo.md:259
msgid "\"New tweet! {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:111
msgid ""
"<span class=\"caption\">A `Summary` trait that consists of the behavior "
"provided by a `summarize` method</span>"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:113
msgid ""
"Each type implementing this trait must provide its own custom behavior for "
"the body of the method. The compiler will enforce that any type that "
"implements the `Summary` trait will have the method `summarize` defined with "
"this signature exactly."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:115
msgid ""
"A trait can have multiple methods in its body: the method signatures are "
"listed one per line and each line ends in a semicolon."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:117
msgid "Implementing a Trait on a Type"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:119
msgid ""
"Now that we’ve defined the desired signatures of the `Summary` trait’s "
"methods, we can implement it on the types in our media aggregator. The "
"following code shows an implementation of the `Summary` trait on the "
"`NewsArticle` struct that uses the headline, the author, and the location to "
"create the return value of `summarize`. For the `Tweet` struct, we define "
"`summarize` as the username followed by the entire text of the tweet, "
"assuming that tweet content is already limited to 280 characters."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:188
msgid ""
"Implementing a trait on a type is similar to implementing regular methods. "
"The difference is that after `impl`, we put a name for the implementation, "
"then use the `of` keyword, and then specify the name of the trait we are "
"writing the implementation for. If the implementation is for a generic type, "
"we place the generic type name in the angle brackets after the trait name."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:193
msgid ""
"Note that for the trait method to be accessible, there must be an "
"implementation of that trait visible from the scope where the method is "
"called. If the trait is `pub` and the implementation is not, and the "
"implementation is not visible in the scope where the trait method is called, "
"this will cause a compilation error."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:195
msgid ""
"Within the `impl` block, we put the method signatures that the trait "
"definition has defined. Instead of adding a semicolon after each signature, "
"we use curly brackets and fill in the method body with the specific behavior "
"that we want the methods of the trait to have for the particular type."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:200
msgid ""
"Now that the library has implemented the `Summary` trait on `NewsArticle` "
"and `Tweet`, users of the crate can call the trait methods on instances of "
"`NewsArticle` and `Tweet` in the same way we call regular methods. The only "
"difference is that the user must bring the trait into scope as well as the "
"types. Here’s an example of how a crate could use our `aggregator` crate:"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:265
msgid "This code prints the following:"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:279
msgid ""
"Other crates that depend on the _aggregator_ crate can also bring the "
"`Summary` trait into scope to implement `Summary` on their own types."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:304
msgid "Managing and Using External Trait"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:306
msgid ""
"To use traits methods, you need to make sure the correct "
"traits/implementation(s) are imported. In some cases you might need to "
"import not only the trait but also the implementation if they are declared "
"in separate modules. If `CircleGeometry` implementation was in a separate "
"module/file named _circle_, then to define `boundary` method on `Circle` "
"struct, we'd need to import `ShapeGeometry` trait in the _circle_ module."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:309
msgid ""
"If the code was organized into modules like this, where the implementation "
"of a trait was defined in a different module than the trait itself, "
"explicitly importing the relevant trait or implementation is required."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:312
msgid "// Here T is an alias type which will be provided during implementation\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:319
msgid ""
"// Importing ShapeGeometry is required to implement this trait for "
"Rectangle\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:328
msgid ""
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"    // to implement the trait for that type\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:341
msgid ""
"// Importing ShapeGeometry is required to implement this trait for Circle\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:349
msgid ""
"// Implementation CircleGeometry passes in <Circle>\n"
"    // to implement the imported trait for that type\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:366
msgid "\"Rectangle area: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:366
msgid "//35\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:367
msgid "\"Rectangle boundary: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:367
msgid "//24\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:370
msgid "\"Circle area: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:370
msgid "//78\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:371
msgid "\"Circle boundary: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:371
msgid "//31\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:375
msgid ""
"Note that in this example, `CircleGeometry` and `RectangleGeometry` "
"implementations don't need to be declared as `pub`. Indeed, `ShapeGeometry` "
"trait, which is public, is used to print the result in the `main` function. "
"The compiler will find the appropriate implementation for the "
"`ShapeGeometry` public trait, regardless of the implementation visibility."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:377
msgid "Impl Aliases"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:379
msgid ""
"Implementations can be aliased when imported. This is most useful when you "
"want to instantiate generic implementations with concrete types. For "
"example, let's say we define a trait `Two` that is used to return the value "
"`2` for a type `T`. We can write a trivial generic implementation of `Two` "
"for all types that implement the `One` trait, simply by adding twice the "
"value of `one` and returning it. However, in our public API, we may only "
"want to expose the `Two` implementation for the `u8` and `u128` types."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:400
msgid ""
"<span class=\"caption\"> Listing 8-1: Using impl aliases to instantiate "
"generic impls with concrete types</span>"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:402
msgid ""
"We can define the generic implementation in a private module, use an impl "
"alias to instantiate the generic implementation for these two concrete "
"types, and make these two implementations public, while keeping the generic "
"implementation private and unexposed. This way, we can avoid code "
"duplication using the generic implementation, while keeping the public API "
"clean and simple."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:404
msgid "Negative Impls"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:406
msgid ""
"Note: This is still an experimental feature and can only be used if "
"`experimental-features = [\"negative_impls\"]` is enabled in your "
"_Scarb.toml_ file, under the `[package]` section."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:408
msgid ""
"Negative implementations, also known as negative traits or negative bounds, "
"are a mechanism that allows you to express that a type does not implement a "
"certain trait when defining the implementation of a trait over a generic "
"type. Negative impls enable you to write implementations that are applicable "
"only when another implementation does not exist in the current scope."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:410
msgid ""
"For example, let's say we have a trait `Producer` and a trait `Consumer`, "
"and we want to define a generic behavior where all types implement the "
"`Consumer` trait by default. However, we want to ensure that no type can be "
"both a `Consumer` and a `Producer`. We can use negative impls to express "
"this restriction."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:412
msgid ""
"In Listing 8-2, we define a `ProducerType` that implements the `Producer` "
"trait, and two other types, `AnotherType` and `AThirdType`, which do not "
"implement the `Producer` trait. We then use negative impls to create a "
"default implementation of the `Consumer` trait for all types that do not "
"implement the `Producer` trait."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:440
msgid "\"{:?} consumed value: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:450
msgid ""
"// producer.consumer(production); Invalid: ProducerType does not implement "
"Consumer\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:456
msgid ""
"<span class=\"caption\"> Listing 8-2: Using negative impls to enforce that a "
"type cannot implement both `Producer` and `Consumer` traits "
"simultaneously</span>"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:458
msgid ""
"In the `main` function, we create instances of `ProducerType`, "
"`AnotherType`, and `AThirdType`. We then call the `produce` method on the "
"`producer` instance and pass the result to the `consume` method on the "
"`another_type` and `third_type` instances. Finally, we try to call the "
"`consume` method on the `producer` instance, which results in a compile-time "
"error because `ProducerType` does not implement the `Consumer` trait."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:460
msgid "{{#quiz ../quizzes/ch08-02-traits.toml}}"
msgstr ""

#: src/ch09-00-error-handling.md
msgid "Error handling"
msgstr ""

#: src/ch09-00-error-handling.md
msgid ""
"In this chapter, we will explore various error handling techniques provided "
"by Cairo, which not only allow you to address potential issues in your code, "
"but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as "
"pattern matching with the `Result` enum, using the `?` operator for more "
"ergonomic error propagation, and employing the `unwrap` or `expect` methods "
"for handling recoverable errors, you'll gain a deeper understanding of "
"Cairo's error handling features. These concepts are crucial for building "
"robust applications that can effectively handle unexpected situations, "
"ensuring your code is ready for production."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with `panic`"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in "
"runtime errors. While the `panic` function from the core library doesn't "
"provide a resolution for these errors, it does acknowledge their occurrence "
"and terminates the program. There are two primary ways that a panic can be "
"triggered in Cairo: inadvertently, through actions causing the code to panic "
"(e.g., accessing an array beyond its bounds), or deliberately, by invoking "
"the `panic` function."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The "
"`panic` function takes an array as an argument, which can be used to provide "
"an error message and performs an unwind process where all variables are "
"dropped and dictionaries squashed to ensure the soundness of the program to "
"safely terminate the execution."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:7
msgid ""
"Here is how we can call `panic` from inside a program and return the error "
"code `2`:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:18
#: src/ch09-01-unrecoverable-errors-with-panic.md:58
msgid "\"This line isn't reached\""
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:22
msgid "Running the program will produce the following output:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:33
msgid ""
"As you can notice in the output, the call to `println!` macro is never "
"reached, as the program terminates after encountering the `panic` statement."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:35
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use "
"the `panic_with_felt252` function. This function serves as an abstraction of "
"the array-defining process and is often preferred due to its clearer and "
"more concise expression of intent. By using `panic_with_felt252`, developers "
"can panic in a one-liner by providing a `felt252` error message as an "
"argument, making the code more readable and maintainable."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:37
msgid "Let's consider an example:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:47
msgid ""
"Executing this program will yield the same error message as before. In that "
"case, if there is no need for an array and multiple values to be returned "
"within the error, `panic_with_felt252` is a more succinct alternative."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:49 src/ch11-05-macros.md:29
msgid "`panic!` Macro"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:51
msgid ""
"`panic!` macro can be really helpful. The previous example returning the "
"error code `2` shows how convenient `panic!` macro is. There is no need to "
"create an array and pass it as an argument like with the `panic` function."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:56
msgid "\"2\""
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:62
msgid ""
"Unlike the `panic_with_felt252` function, using `panic!` allows the input, "
"which is ultimately the panic error, to be a literal longer than 31 bytes. "
"This is because `panic!` takes a string as a parameter. For example, the "
"following line of code will successfully compile:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:65
msgid "\"the error for panic! macro is not limited to 31 characters anymore\""
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:68
msgid "`nopanic` Notation"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:70
msgid ""
"You can use the `nopanic` notation to indicate that a function will never "
"panic. Only `nopanic` functions can be called in a function annotated as "
"`nopanic`."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:80
msgid ""
"This function will always return `42` and is guaranteed to never panic. "
"Conversely, the following function is not guaranteed to never panic:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:88
msgid ""
"If you try to compile this function that includes code that may panic, you "
"will get the following error:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:108
msgid ""
"Note that there are two functions that may panic here, `assert` and equality "
"with `==`. We usually don't use `assert` function in practice and use "
"`assert!` macro instead. We will discuss `assert!` macro in more detail in "
"the [Testing Cairo "
"Programs](./ch10-01-how-to-write-tests.md#checking-results-with-the-assert-macro) "
"chapter."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:112
msgid "`panic_with` Attribute"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:114
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an "
"`Option` or `Result`. This attribute takes two arguments, which are the data "
"that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will "
"panic if the function returns `None` or `Err`, with the given data as the "
"panic error."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:116
#: src/appendix-03-derivable-traits.md:38
msgid "Example:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:129
msgid "// this returns None\n"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:130
msgid "// this panics with 'value is 0'\n"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:134
msgid "{{#quiz ../quizzes/ch09-01-unrecoverable-errors-with-panic.toml}}"
msgstr ""

#: src/ch09-02-recoverable-errors.md:1
msgid "Recoverable Errors with `Result`"
msgstr ""

#: src/ch09-02-recoverable-errors.md:3
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to add two large integers "
"and the operation overflows because the sum exceeds the maximum "
"representable value, you might want to return an error or a wrapped result "
"instead of causing undefined behavior or terminating the process."
msgstr ""

#: src/ch09-02-recoverable-errors.md:5
msgid "The `Result` Enum"
msgstr ""

#: src/ch09-02-recoverable-errors.md:7
msgid ""
"Recall from [Generic data types](./ch08-01-generic-data-types.md#enums) "
"section in Chapter 8 that the `Result` enum is defined as having two "
"variants, `Ok` and `Err`, as follows:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:20
msgid "The `ResultTrait`"
msgstr ""

#: src/ch09-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>` "
"enum, such as unwrapping values, checking whether the `Result` is `Ok` or "
"`Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr ""

#: src/ch09-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to "
"extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` "
"variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior "
"when the `Result` is in the `Err` variant. The `expect` method allows you to "
"provide a custom error message (as a `felt252` value) that will be used when "
"panicking, giving you more control and context over the panic. On the other "
"hand, the `unwrap` method panics with a default error message, providing "
"less information about the cause of the panic."
msgstr ""

#: src/ch09-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` methods have the exact opposite behavior. "
"If the `Result` is `Err(x)`, both methods return the value `x`. However, the "
"key difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control "
"and context over the panic. On the other hand, the `unwrap_err` method "
"panics with a default error message, providing less information about the "
"cause of the panic."
msgstr ""

#: src/ch09-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the "
"first four methods signatures. This syntax represents generic type "
"constraints in the Cairo language, as seen in the previous chapter. These "
"constraints indicate that the associated functions require an implementation "
"of the `Drop` trait for the generic types `T` and `E`, respectively."
msgstr ""

#: src/ch09-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by "
"the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr ""

#: src/ch09-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the "
"`Result` is the `Ok` variant, meaning the operation was successful. If the "
"`Result` is the `Err` variant, it returns `false`."
msgstr ""

#: src/ch09-02-recoverable-errors.md:49
msgid ""
"`is_err` takes a snapshot of a `Result<T, E>` value and returns `true` if "
"the `Result` is the `Err` variant, meaning the operation encountered an "
"error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr ""

#: src/ch09-02-recoverable-errors.md:51
msgid ""
"These methods are helpful when you want to check the success or failure of "
"an operation without consuming the `Result` value, allowing you to perform "
"additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr ""

#: src/ch09-02-recoverable-errors.md:53
msgid ""
"You can find the implementation of the `ResultTrait` "
"[here](https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr ""

#: src/ch09-02-recoverable-errors.md:55
msgid ""
"It is always easier to understand with examples. Have a look at this "
"function signature:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:61
msgid ""
"It takes two `u128` integers, `a` and `b`, and returns a `Result<u128, "
"u128>` where the `Ok` variant holds the sum if the addition does not "
"overflow, and the `Err` variant holds the overflowed value if the addition "
"does overflow."
msgstr ""

#: src/ch09-02-recoverable-errors.md:63
msgid "Now, we can use this function elsewhere. For instance:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:75
msgid ""
"Here, it accepts two `u128` integers, `a` and `b`, and returns an "
"`Option<u128>`. It uses the `Result` returned by `u128_overflowing_add` to "
"determine the success or failure of the addition operation. The `match` "
"expression checks the `Result` from `u128_overflowing_add`. If the result is "
"`Ok(r)`, it returns `Option::Some(r)` containing the sum. If the result is "
"`Err(r)`, it returns `Option::None` to indicate that the operation has "
"failed due to overflow. The function does not panic in case of an overflow."
msgstr ""

#: src/ch09-02-recoverable-errors.md:77
msgid "Let's take another example:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:88
msgid ""
"In this example, the `parse_u8` function takes a `felt252` and tries to "
"convert it into a `u8` integer using the `try_into` method. If successful, "
"it returns `Result::Ok(value)`, otherwise it returns `Result::Err('Invalid "
"integer')`."
msgstr ""

#: src/ch09-02-recoverable-errors.md:90
msgid "Our two test cases are:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:107
msgid "// should not panic\n"
msgstr ""

#: src/ch09-02-recoverable-errors.md:115
msgid "// should panic\n"
msgstr ""

#: src/ch09-02-recoverable-errors.md:123
msgid ""
"Don't worry about the `#[cfg(test)]` attribute for now. We'll explain in "
"more detail its meaning in the next [Testing Cairo "
"Programs](./ch10-01-how-to-write-tests.md) chapter."
msgstr ""

#: src/ch09-02-recoverable-errors.md:125
msgid ""
"`#[test]` attribute means the function is a test function, and "
"`#[should_panic]` attribute means this test will pass if the test execution "
"panics."
msgstr ""

#: src/ch09-02-recoverable-errors.md:127
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the "
"`unwrap` method not to panic. The second test function attempts to convert a "
"value that is out of the `u8` range, expecting the `unwrap` method to panic "
"with the error message `Invalid integer`."
msgstr ""

#: src/ch09-02-recoverable-errors.md:132
msgid "The `?` Operator"
msgstr ""

#: src/ch09-02-recoverable-errors.md:134
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator "
"is used for more idiomatic and concise error handling. When you use the `?` "
"operator on a `Result` or `Option` type, it will do the following:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:136
msgid ""
"If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the "
"inner value `x` directly."
msgstr ""

#: src/ch09-02-recoverable-errors.md:137
msgid ""
"If the value is `Result::Err(e)` or `Option::None`, it will propagate the "
"error or `None` by immediately returning from the function."
msgstr ""

#: src/ch09-02-recoverable-errors.md:139
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let "
"the calling function deal with them."
msgstr ""

#: src/ch09-02-recoverable-errors.md:146 src/ch09-02-recoverable-errors.md:166
msgid "// DO SOMETHING\n"
msgstr ""

#: src/ch09-02-recoverable-errors.md:152
msgid ""
"We can see that `do_something_with_parse_u8` function takes a `felt252` "
"value as input and calls `parse_u8` function. The `?` operator is used to "
"propagate the error, if any, or unwrap the successful value."
msgstr ""

#: src/ch09-02-recoverable-errors.md:154
msgid "And with a little test case:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:178
msgid "\"Result: {}\""
msgstr ""

#: src/ch09-02-recoverable-errors.md:179
msgid "\"Error: {}\""
msgstr ""

#: src/ch09-02-recoverable-errors.md:186
msgid "The console will print the error `Invalid Integer`."
msgstr ""

#: src/ch09-02-recoverable-errors.md:190
msgid ""
"We saw that recoverable errors can be handled in Cairo using the `Result` "
"enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is "
"generic, with types `T` and `E` representing the successful and error "
"values, respectively. The `ResultTrait` provides methods for working with "
"`Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or "
"`Err`, and panicking with custom messages."
msgstr ""

#: src/ch09-02-recoverable-errors.md:192
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use "
"pattern matching to handle the success or failure of an operation. The `?` "
"operator can be used to implicitly handle errors by propagating the error or "
"unwrapping the successful value. This allows for more concise and clear "
"error handling, where the caller is responsible for managing errors raised "
"by the called function."
msgstr ""

#: src/ch09-02-recoverable-errors.md:194
msgid "{{#quiz ../quizzes/ch09-02-error-handling-result.toml}}"
msgstr ""

#: src/ch10-00-testing-cairo-programs.md
msgid ""
"Correctness in our programs is the extent to which our code does what we "
"intend it to do. Cairo is designed with a high degree of concern about the "
"correctness of programs, but correctness is complex and not easy to prove. "
"Cairo's linear type system shoulders a huge part of this burden, but the "
"type system cannot catch everything. As such, Cairo includes support for "
"writing tests."
msgstr ""

#: src/ch10-00-testing-cairo-programs.md
msgid ""
"Testing is a complex skill: although we can’t cover every detail about how "
"to write good tests in one chapter, we’ll discuss the mechanics of Cairo's "
"testing facilities. We’ll talk about the annotations and macros available to "
"you when writing your tests, the default behavior and options provided for "
"running your tests, and how to organize tests into unit tests and "
"integration tests."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:3 src/ch10-01-how-to-write-tests.md:17
msgid "The Anatomy of a Test Function"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these "
"three actions:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:7
msgid "Set up any needed data or state."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:8
msgid "Run the code you want to test."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:9
msgid "Assert the results are what you expect."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides for writing tests that take these "
"actions, which include:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:13
msgid "`#[test]` attribute."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:14
msgid ""
"`assert!`, `assert_eq!`, `assert_ne!`, `assert_lt!`, `assert_le!`, "
"`assert_gt!` and `assert_ge!` macros."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:15
msgid "`#[should_panic]` attribute."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:19
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the "
"`#[test]` attribute. Attributes are metadata about pieces of Cairo code; one "
"example is the `#[derive()]` attribute we used with structs in [Chapter "
"5](ch05-01-defining-and-instantiating-structs.md). To change a function into "
"a test function, add `#[test]` on the line before `fn`. When you run your "
"tests with the `scarb cairo-test` command, Scarb runs Cairo's test runner "
"binary that runs the annotated functions and reports on whether each test "
"function passes or fails."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:21
msgid ""
"Let's create a new project called _adder_ using Scarb with the command "
"`scarb new adder`:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:30
msgid ""
"In _lib.cairo_, let's remove the existing content and add a `tests` module "
"containing the first test, as shown in Listing 10-1."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:51
msgid "<span class=\"caption\">Listing 10-1: A simple test function</span>"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:53
msgid ""
"Note the `#[test]` annotation: this attribute indicates this is a test "
"function, so the test runner knows to treat this function as a test. We "
"might also have non-test functions to help set up common scenarios or "
"perform common operations, so we always need to indicate which functions are "
"tests."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:55
msgid ""
"We use the `#[cfg(test)]` attribute for the `tests` module, so that the "
"compiler knows the code it contains needs to be compiled only when running "
"tests. This is actually not an option: if you put a simple test with the "
"`#[test]` attribute in a _lib.cairo_ file, it will not compile. We will talk "
"more about the `#[cfg(test)]` attribute in the next [Testing "
"Organization](ch10-02-test-organization.md) section."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:57
msgid ""
"The example function body uses the `assert!` macro, which contains the "
"result of adding 2 and 2, which equals 4. This assertion serves as an "
"example of the format for a typical test. We'll explain in more detail how "
"`assert!` works later in this chapter. Let’s run it to see that this test "
"passes."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:59
msgid ""
"The `scarb cairo-test` command runs all tests found in our project, and "
"shows the following output:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:69
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 "
"test`. The next line shows the name of the test function, called `it_works`, "
"and that the result of running that test is `ok`. The test runner also "
"provides an estimation of the gas consumption. The overall summary `test "
"result: ok.` means that all the tests passed, and the portion that reads `1 "
"passed; 0 failed` totals the number of tests that passed or failed."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:71
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically "
"Requested](#ignoring-some-tests-unless-specifically-requested) section later "
"in this chapter. Because we haven’t done that here, the summary shows `0 "
"ignored`. We can also pass an argument to the `scarb cairo-test` command to "
"run only a test whose name matches a string; this is called filtering and "
"we’ll cover that in the [Running Single Tests](#running-single-tests) "
"section. Since we haven’t filtered the tests being run, the end of the "
"summary shows `0 filtered out`."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:73
msgid ""
"Let’s start to customize the test to our own needs. First change the name of "
"the `it_works` function to a different name, such as `exploration`, like so:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:83
msgid ""
"Then run `scarb cairo-test` again. The output now shows `exploration` "
"instead of `it_works`:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:93
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a "
"new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. Enter the new test as a function named `another`, "
"so your _src/lib.cairo_ file looks like in Listing 10-2."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:109
msgid "\"Make this test fail\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:115
msgid ""
"<span class=\"caption\">Listing 10-2: Adding a second test in _lib.cairo_ "
"that will fail</span>"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:117
msgid "Run `scarb cairo-test` and you will see the following output:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:119
msgid ""
"```shell\n"
"$ scarb cairo-test \n"
"     Running cairo-test listing_08_03\n"
"   Compiling "
"test(listings/ch10-testing-cairo-programs/listing_10_02/Scarb.toml)\n"
"    Finished release target(s) in 1 second\n"
"testing listing_08_03 ...\n"
"running 2 tests\n"
"test listing_08_03::tests::exploration ... ok (gas usage est.: 127300)\n"
"test listing_08_03::tests::another ... fail (gas usage est.: 24810)\n"
"failures:\n"
"   listing_08_03::tests::another - Panicked with \"Make this test fail\".\n"
"\n"
"\n"
"```"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:134
msgid ""
"Instead of `ok`, the line `adder::another` shows `fail`. A new section "
"appears between the individual results and the summary. It displays the "
"detailed reason for each test failure. In this case, we get the details that "
"`another` failed because it panicked with `\"Make this test fail\"` error."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:136
msgid ""
"The summary line is displayed at the end: overall, our test result is "
"`FAILED`. We had one test pass and one test fail."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:138
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, "
"let’s look at some functions that are useful in tests."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:140
msgid "Checking Results with the `assert!` Macro"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:142
msgid ""
"The `assert!` macro, provided by Cairo, is useful when you want to ensure "
"that some condition in a test evaluates to `true`. We give the `assert!` "
"macro the first argument that evaluates to a boolean. If the value is "
"`true`, nothing happens and the test passes. If the value is `false`, the "
"`assert!` macro calls `panic()` to cause the test to fail with a message we "
"defined as the second argument. Using the `assert!` macro helps us check "
"that our code is functioning in the way we intended."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:144
msgid ""
"Remember in [Chapter 5](./ch05-03-method-syntax.md), we used a `Rectangle` "
"struct and a `can_hold` method, which are repeated here in Listing 10-3. "
"Let’s put this code in the _src/lib.cairo_ file, then write some tests for "
"it using the `assert!` macro."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:166
msgid ""
"<span class=\"caption\">Listing 10-3: Using the `Rectangle` struct and its "
"`can_hold` method from Chapter 5</span>"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:168
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case "
"for the `assert!` macro. We can write a test that exercises the `can_hold` "
"method by creating a `Rectangle` instance that has a width of `8` and a "
"height of `7` and asserting that it can hold another `Rectangle` instance "
"that has a width of `5` and a height of `1`."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:197 src/ch10-01-how-to-write-tests.md:210
#: src/ch10-01-how-to-write-tests.md:257 src/ch10-01-how-to-write-tests.md:270
msgid "\"rectangle cannot hold\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:216
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the `assert!` macro and "
"passed it the result of calling `larger.can_hold(@smaller)`. This expression "
"is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:226
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:276
msgid ""
"<span class=\"caption\">Listing 10-4: Adding another test in _lib.cairo_ "
"that will pass</span>"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:278
msgid ""
"Because the correct result of the `can_hold` method, in this case, is "
"`false`, we need to negate that result before we pass it to the `assert!` "
"macro. As a result, our test will pass if `can_hold` returns `false`:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:294
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the `>` sign with a `<` sign when it compares "
"the widths:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:304
msgid "Running the tests now produces the following:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:306
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 2 tests\n"
"test adder::tests::larger_can_hold_smaller ... fail (gas usage est.: 57610)\n"
"test adder::tests::smaller_cannot_hold_larger ... ok (gas usage est.: "
"55140)\n"
"failures:\n"
"   adder::larger_can_hold_smaller - Panicked with \"rectangle cannot "
"hold\".\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:318
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false` (`8` "
"is not less than `5`) in the `larger_can_hold_smaller` test. Notice that the "
"`smaller_cannot_hold_larger` test still passes: to make this test fail, the "
"height comparison should also be modified in `can_hold` method, replacing "
"the `>` sign with a `<` sign."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:322
msgid "Testing Equality and Comparisons with the `assert_xx!` Macros"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:324
msgid "`assert_eq!` and `assert_ne!` Macros"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:326
msgid ""
"A common way to verify functionality is to test for equality between the "
"result of the code under test and the value you expect the code to return. "
"You could do this using the `assert!` macro and passing it an expression "
"using the `==` operator. However, this is such a common test that the "
"standard library provides a pair of macros — `assert_eq!` and `assert_ne!` — "
"to perform this test more conveniently. These macros compare two arguments "
"for equality or inequality, respectively. They’ll also print the two values "
"if the assertion fails, which makes it easier to see _why_ the test failed; "
"conversely, the `assert!` macro only indicates that it got a `false` value "
"for the `==` expression, without printing the values that led to the `false` "
"value."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:337
msgid ""
"In Listing 10-5, we write a function named `add_two` that adds `2` to its "
"parameter, then we test this function using `assert_eq!` and `assert_ne!` "
"macros."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:363
msgid ""
"<span class=\"caption\">Listing 10-5: Testing the function `add_two` using "
"`assert_eq!` and `assert_ne!` macros</span>"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:365
msgid "Let’s check that it passes!"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:376
msgid ""
"In the `it_adds_two` test, we pass `4` as argument to `assert_eq!` macro, "
"which is equal to the result of calling `add_two(2)`. The line for this test "
"is `test adder::tests::it_adds_two ... ok`, and the `ok` text indicates that "
"our test passed."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:379
msgid ""
"In the `wrong_check` test, we pass `0` as argument to `assert_ne!` macro, "
"which is not equal to the result of calling `add_two(2)`. Tests that use the "
"`assert_ne!` macro will pass if the two values we give it are _not_ equal "
"and fail if they’re equal. This macro is most useful for cases when we’re "
"not sure what a value _will_ be, but we know what the value definitely "
"_shouldn’t_ be. For example, if we’re testing a function that is guaranteed "
"to change its input in some way, but how the input is changed depends on the "
"day of the week that we run our tests, the best thing to assert might be "
"that the output of the function is not equal to the input."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:388
msgid ""
"Let’s introduce a bug into our code to see what `assert_eq!` looks like when "
"it fails. Change the implementation of the `add_two` function to instead add "
"`3`:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:397
msgid "Run the tests again:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:399
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 2 tests\n"
"test adder::tests::wrong_check ... ok (gas usage est.: 132000)\n"
"test adder::tests::it_adds_two ... fail (gas usage est.: 166800)\n"
"failures:\n"
"   adder::tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` "
"failed.\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:413
msgid ""
"Our test caught the bug! The `it_adds_two` test failed with the following "
"message: ``Panicked with \"assertion `4 == add_two(2)` failed``. It tells us "
"that the assertion that failed was `` \"assertion `left == right` failed`` "
"and the `left` and `right` values are printed on the next lines as `left: "
"left_value` and `right: right_value`. This helps us start debugging: the "
"`left` argument was `4` but the `right` argument, where we had `add_two(2)`, "
"was `5`. You can imagine that this would be especially helpful when we have "
"a lot of tests going on."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:421
msgid ""
"Note that in some languages and test frameworks, the parameters for equality "
"assertion functions are called `expected` and `actual`, and the order in "
"which we specify the arguments matters. However, in Cairo, they’re called "
"`left` and `right`, and the order in which we specify the value we expect "
"and the value the code produces doesn’t matter. We could write the assertion "
"in this test as `assert_eq!(add_two(2), 4)`, which would result in the same "
"failure message that displays `` assertion failed: `(left == right)` ``."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:429
msgid ""
"Here is a simple example comparing two structs, showing how to use "
"`assert_eq!` and `assert_ne!` macros:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:446
msgid "\"{:?},{:?} should be equal\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:448
msgid "\"{:?},{:?} should not be equal\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:452
msgid ""
"Under the surface, `assert_eq!` and `assert_ne!` macros use the operators "
"`==` and `!=`, respectively. They both take snapshots of values as "
"arguments. When the assertions fail, these macros print their arguments "
"using debug formatting (`{:?}` syntax), which means the values being "
"compared must implement `PartialEq` and `Debug` traits. All primitive types "
"and most of the core library types implement these traits. For structs and "
"enums that you define yourself, you’ll need to implement `PartialEq` to "
"assert equality of those types. You’ll also need to implement `Debug` to "
"print the values when the assertion fails. Because both traits are "
"derivable, this is usually as straightforward as adding the `#[derive(Drop, "
"Debug, PartialEq)]` annotation to your struct or enum definition. See "
"[Appendix C](./appendix-03-derivable-traits.md) for more details about these "
"and other derivable traits."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:463
msgid "`assert_lt!`, `assert_le!`, `assert_gt!` and `assert_ge!` Macros"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:465
msgid "Comparisons in tests can be done using the `assert_xx!` macros:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:467
msgid ""
"`assert_lt!` checks if a given value is lower than another value, and "
"reverts otherwise."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:468
msgid ""
"`assert_le!` checks if a given value is lower or equal than another value, "
"and reverts otherwise."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:469
msgid ""
"`assert_gt!` checks if a given value is greater than another value, and "
"reverts otherwise."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:470
msgid ""
"`assert_ge!` checks if a given value is greater or equal than another value, "
"and reverts otherwise."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:472
msgid "Listing 10-6 demonstrates how to use these macros:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:510
msgid "\"{:?},{:?} should be lower or equal\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:515
msgid ""
"<span class=\"caption\">Listing 10-6: Example of tests that use the "
"`assert_xx!` macros for comparisons</span>"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:517
msgid ""
"In this example, we roll a `Dice` struct multiple times and compare the "
"results. We need to manually implement the `PartialOrd` trait for our struct "
"so that we can compare `Dice` instances with `lt`, `le`, `gt` and `ge` "
"functions, which are used by `assert_lt!`, `assert_le!`, `assert_gt!` and "
"`assert_ge!` macros, respectively. We also need to derive the `Copy` trait "
"on our `Dice` struct to use the instantiated structs multiple times, as the "
"comparison functions take ownership of the variables."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:519
msgid "Adding Custom Failure Messages"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:521
msgid ""
"You can also add a custom message to be printed with the failure message as "
"optional arguments to `assert!`, `assert_eq!`, and `assert_ne!` macros. Any "
"arguments specified after the required arguments are passed along to the "
"`format!` macro (discussed in the "
"[Printing](./ch11-08-printing.md#formatting) chapter), so you can pass a "
"format string that contains `{}` placeholders and values to go in those "
"placeholders. Custom messages are useful for documenting what an assertion "
"means; when a test fails, you’ll have a better idea of what the problem is "
"with the code."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:529
msgid ""
"Let’s add a custom failure message composed of a format string with a "
"placeholder filled in with the actual value we got from the `add_two` "
"function:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:536
msgid "\"Expected {}, got add_two(2)={}\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:540
msgid "Now when we run the test, we’ll get a more informative error message:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:542
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 1 test\n"
"test adder::tests::it_adds_two ... fail (gas usage est.: 590230)\n"
"failures:\n"
"   adder::tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` "
"failed: Expected 4, got add_two(2)=5\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:555
msgid ""
"We can see the value we actually got in the test output, which would help us "
"debug what happened instead of what we were expecting to happen."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:560
msgid "Checking for panics with `should_panic`"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:562
msgid ""
"In addition to checking return values, it’s important to check that our code "
"handles error conditions as we expect. For example, consider the `Guess` "
"type in Listing 10-7:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:579 src/ch10-01-how-to-write-tests.md:631
msgid "\"Guess must be >= 1 and <= 100\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:587
msgid ""
"<span class=\"caption\">Listing 10-7: `Guess` struct and its `new` "
"method</span>"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:589
msgid ""
"Other code that uses `Guess` depends on the guarantee that `Guess` instances "
"will contain only values between `1` and `100`. We can write a test that "
"ensures that attempting to create a `Guess` instance with a value outside "
"that range panics."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:591
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:606
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result to see that "
"this test passes:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:616
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the `new` function will panic if the value is greater than `100`:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:641
msgid "When we run the test, it will fail:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:654
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]` attribute. "
"The failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:656
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional "
"`expected` parameter to the `#[should_panic]` attribute. The test harness "
"will make sure that the failure message contains the provided text. For "
"example, consider the modified code for `GuessImpl` in Listing 10-8 where "
"the `new` function panics with different messages depending on whether the "
"value is too small or too large:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:673 src/ch10-01-how-to-write-tests.md:708
msgid "\"Guess must be >= 1\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:675 src/ch10-01-how-to-write-tests.md:687
#: src/ch10-01-how-to-write-tests.md:706 src/ch10-01-how-to-write-tests.md:720
msgid "\"Guess must be <= 100\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:696
msgid ""
"<span class=\"caption\">Listing 10-8: `new` implementation that panics with "
"different error messages</span>"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:698
msgid ""
"The test will pass because the value we put in the `should_panic` "
"attribute’s `expected` parameter is the string that the `Guess::new` method "
"panics with. We need to specify the entire panic message that we expect."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:700
msgid ""
"To see what happens when a `should_panic` test with an expected message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the `if value < 1` and the `else if value > 100` blocks:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:727
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:729
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing guess ...\n"
"running 1 test\n"
"test guess::tests::greater_than_100 ... fail (gas usage est.: 26690)\n"
"failures:\n"
"   guess::tests::greater_than_100 - Panicked with \"Guess must be >= 1\".\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:739
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string. The "
"panic message that we did get in this case was `Guess must be >= 1`. Now we "
"can start figuring out where our bug is!"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:741
msgid "Running Single Tests"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:743
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working "
"on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing `scarb "
"cairo-test` an option `-f` (for \"filter\"), followed by the name of the "
"test you want to run as an argument."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:745
msgid ""
"To demonstrate how to run a single test, we’ll first create two test "
"functions, as shown in Listing 10-9, and choose which ones to run."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:761
msgid "\"result is not 5\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:766
msgid ""
"<span class=\"caption\">Listing 10-9: Two tests with two different "
"names</span>"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:768
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that "
"test using the `-f` flag:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:778
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t "
"match that name. The test output lets us know we had one more test that "
"didn’t run by displaying `1 filtered out;` at the end."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:780
msgid ""
"We can also specify part of a test name, and any test whose name contains "
"that value will be run."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:782
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:784
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you "
"might want to exclude them during most runs of `scarb cairo-test`. Rather "
"than listing as arguments all tests you do want to run, you can instead "
"annotate the time-consuming tests using the `#[ignore]` attribute to exclude "
"them, as shown here:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:803
msgid "// code that takes an hour to run\n"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:808
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:819
msgid "The `expensive_test` function is listed as ignored."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:821
msgid ""
"When you’re at a point where it makes sense to check the results of the "
"ignored tests and you have time to wait for the results, you can run `scarb "
"cairo-test --include-ignored` to run all tests, whether they’re ignored or "
"not."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:823
msgid "Testing Recursive Functions or Loops"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:825
msgid ""
"When testing recursive functions or loops, the test is instantiated by "
"default with a maximum amount of gas that it can consume. This prevents "
"running infinite loops or consuming too much gas, and can help you benchmark "
"the efficiency of your implementations. This value is assumed reasonably "
"large enough, but you can override it by adding the "
"`#[available_gas(<Number>)]` attribute to the test function. The following "
"example shows how to use it:"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:846
msgid "\"result is not 55\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:851
msgid "Benchmarking the Gas Usage of a Specific Operation"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:853
msgid ""
"When you want to benchmark the gas usage of a specific operation, you can "
"use the following pattern in your test function."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:858 src/ch10-01-how-to-write-tests.md:885
msgid "/// code we want to bench.\n"
msgstr ""

#: src/ch10-01-how-to-write-tests.md:859
msgid "\"{}\\n\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:862
msgid ""
"The following example shows how to use it to test the gas function of the "
"`sum_n` function above."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:887
msgid "\"consumed gas: {}\\n\""
msgstr ""

#: src/ch10-01-how-to-write-tests.md:892
msgid ""
"The value printed when running `scarb cairo-test` is the amount of gas that "
"was consumed by the benchmarked operation."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:904
msgid ""
"Here, the gas usage of the `sum_n` function is `80690` (decimal "
"representation of the hex number). The total amount consumed by the test is "
"slightly higher at `140100`, due to some extra steps required to run the "
"entire test function."
msgstr ""

#: src/ch10-01-how-to-write-tests.md:906
msgid "{{#quiz ../quizzes/ch10-01-how_to_write_tests.toml}}"
msgstr ""

#: src/ch10-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and "
"integration tests. Unit tests are small and more focused, testing one module "
"in isolation at a time, and can test private functions. Integration tests "
"use your code in the same way any other external code would, using only the "
"public interface and potentially exercising multiple modules per test."
msgstr ""

#: src/ch10-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr ""

#: src/ch10-02-test-organization.md:7
msgid "Unit Tests"
msgstr ""

#: src/ch10-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the "
"rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the `src` directory in each file with the "
"code that they’re testing."
msgstr ""

#: src/ch10-02-test-organization.md:11
msgid ""
"The convention is to create a module named `tests` in each file to contain "
"the test functions and to annotate the module with `#[cfg(test)]` attribute."
msgstr ""

#: src/ch10-02-test-organization.md:13
msgid "The Tests Module and `#[cfg(test)]`"
msgstr ""

#: src/ch10-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and "
"run the test code only when you run `scarb test`, not when you run `scarb "
"build`. This saves compile time when you only want to build the project and "
"saves space in the resulting compiled artifact because the tests are not "
"included. You’ll see that because integration tests go in a different "
"directory, they don’t need the `#[cfg(test)]` annotation. However, because "
"unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to "
"specify that they shouldn’t be included in the compiled result."
msgstr ""

#: src/ch10-02-test-organization.md:17
msgid ""
"Recall that when we created the new `adder` project in the first section of "
"this chapter, we wrote this first test:"
msgstr ""

#: src/ch10-02-test-organization.md:36
msgid ""
"The attribute `cfg` stands for _configuration_ and tells Cairo that the "
"following item should only be included given a certain configuration option. "
"In this case, the configuration option is `test`, which is provided by Cairo "
"for compiling and running tests. By using the `cfg` attribute, Cairo "
"compiles our test code only if we actively run the tests with `scarb test`. "
"This includes any helper functions that might be within this module, in "
"addition to the functions annotated with `#[test]`."
msgstr ""

#: src/ch10-02-test-organization.md:38
msgid "Testing Private Functions"
msgstr ""

#: src/ch10-02-test-organization.md:40
msgid ""
"There’s debate within the testing community about whether or not private "
"functions should be tested directly, and other languages make it difficult "
"or impossible to test private functions. Regardless of which testing "
"ideology you adhere to, Cairo's privacy rules do allow you to test private "
"functions. Consider the code below with the private function "
"`internal_adder`."
msgstr ""

#: src/ch10-02-test-organization.md:42 src/ch10-02-test-organization.md:178
msgid "<span class=\"caption\">Filename: src/lib.cairo</span>"
msgstr ""

#: src/ch10-02-test-organization.md:64
msgid "<span class=\"caption\">Listing 10-10: Testing a private function</span>"
msgstr ""

#: src/ch10-02-test-organization.md:66
msgid ""
"Note that the `internal_adder` function is not marked as `pub`. Tests are "
"just Cairo code, and the tests module is just another module. As we "
"discussed in the [\"Paths for Referring to an Item in the Module "
"Tree\"](ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md) "
"section, items in child modules can use the items in their ancestor modules. "
"In this test, we bring the `tests` module’s parent `internal_adder` into "
"scope with `use super::internal_adder;` and then the test can call "
"`internal_adder`. If you don’t think private functions should be tested, "
"there’s nothing in Cairo that will compel you to do so."
msgstr ""

#: src/ch10-02-test-organization.md:68
msgid "Integration Tests"
msgstr ""

#: src/ch10-02-test-organization.md:70
msgid ""
"Integration tests use your library in the same way any other code would. "
"Their purpose is to test whether many parts of your library work together "
"correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is "
"important as well. To create integration tests, you first need a _tests_ "
"directory."
msgstr ""

#: src/ch10-02-test-organization.md:72
msgid "The _tests_ Directory"
msgstr ""

#: src/ch10-02-test-organization.md:74
msgid ""
"We create a _tests_ directory at the top level of our project directory, "
"next to _src_. Scarb knows to look for integration test files in this "
"directory. We can then make as many test files as we want, and Scarb will "
"compile each of the files as an individual crate."
msgstr ""

#: src/ch10-02-test-organization.md:76
msgid ""
"Let’s create an integration test. With the code in Listing 10-10 still in "
"the _src/lib.cairo_ file, make a _tests_ directory, and create a new file "
"named _tests/integration_test.cairo_. Your directory structure should look "
"like this:"
msgstr ""

#: src/ch10-02-test-organization.md:89
msgid ""
"Enter the code in Listing 10-11 into the _tests/integration_test.cairo_ file:"
msgstr ""

#: src/ch10-02-test-organization.md:91 src/ch10-02-test-organization.md:167
msgid "<span class=\"caption\">Filename: tests/integration_tests.cairo</span>"
msgstr ""

#: src/ch10-02-test-organization.md:102
msgid ""
"<span class=\"caption\">Listing 10-11: An integration test of a function in "
"the `adder` crate</span>"
msgstr ""

#: src/ch10-02-test-organization.md:104
msgid ""
"Each file in the `tests` directory is a separate crate, so we need to bring "
"our library into each test crate’s scope. For that reason we add `use "
"adder::add_two` at the top of the code, which we didn’t need in the unit "
"tests."
msgstr ""

#: src/ch10-02-test-organization.md:106
msgid ""
"We don’t need to annotate any code in _tests/integration_test.cairo_ with "
"`#[cfg(test)]`. Scarb treats the tests directory specially and compiles "
"files in this directory only when we run `scarb test`. Run `scarb test` now:"
msgstr ""

#: src/ch10-02-test-organization.md:124
msgid ""
"The two sections of output include the unit tests and the integration tests. "
"Note that if any test in a section fails, the following sections will not be "
"run. For example, if a unit test fails, there won’t be any output for "
"integration tests because those tests will only be run if all unit tests are "
"passing."
msgstr ""

#: src/ch10-02-test-organization.md:126
msgid ""
"The first displayed section is for the integration tests. Each integration "
"test file has its own section, so if we add more files in the _tests_ "
"directory, there will be more integration test sections."
msgstr ""

#: src/ch10-02-test-organization.md:129
msgid ""
"The second displayed section is the same as we’ve been seeing: one line for "
"each unit test (one named add that we added just above) and then a summary "
"line for the unit tests."
msgstr ""

#: src/ch10-02-test-organization.md:131
msgid ""
"We can still run a particular integration test function by specifying the "
"test function’s name as an argument of the option -f to `scarb test` like "
"for instance `scarb test -f integration_tests::internal`. To run all the "
"tests in a particular integration test file, we use the same option of "
"`scarb test` but using only the name of the file."
msgstr ""

#: src/ch10-02-test-organization.md:133
msgid ""
"Then, to run all of our integration tests, we can just add a filter to only "
"run tests whose path contains _integration_tests_."
msgstr ""

#: src/ch10-02-test-organization.md:151
msgid ""
"We see that in the second section for the unit tests, 1 has been filtered "
"out because it is not in the _integration_tests_ file."
msgstr ""

#: src/ch10-02-test-organization.md:153
msgid "Submodules in Integration Tests"
msgstr ""

#: src/ch10-02-test-organization.md:155
msgid ""
"As you add more integration tests, you might want to make more files in the "
"_tests_ directory to help organize them; for example, you can group the test "
"functions by the functionality they’re testing. As mentioned earlier, each "
"file in the tests directory is compiled as its own separate crate, which is "
"useful for creating separate scopes to more closely imitate the way end "
"users will be using your crate. However, this means files in the tests "
"directory don’t share the same behavior as files in _src_ do, as you learned "
"in Chapter 7 regarding how to separate code into modules and files."
msgstr ""

#: src/ch10-02-test-organization.md:157
msgid ""
"The different behavior of tests directory files is most noticeable when you "
"have a set of helper functions to use in multiple integration test files and "
"you try to follow the steps in the [Separating Modules into Different "
"Files](ch07-05-separating-modules-into-different-files.md) section of "
"Chapter 7 to extract them into a common module. For example, if we create "
"_tests/common.cairo_ and place a function named `setup` in it, we can add "
"some code to `setup` that we want to call from multiple test functions in "
"multiple test files:"
msgstr ""

#: src/ch10-02-test-organization.md:159
msgid "<span class=\"caption\">Filename: tests/common.cairo</span>"
msgstr ""

#: src/ch10-02-test-organization.md:163
msgid "\"Setting up tests...\""
msgstr ""

#: src/ch10-02-test-organization.md:174
msgid "\"internal_adder failed\""
msgstr ""

#: src/ch10-02-test-organization.md:194
msgid ""
"When we run the tests with `scarb test`, we’ll see a new section in the test "
"output for the _common.cairo_ file, even though this file doesn’t contain "
"any test functions nor did we call the setup function from anywhere:"
msgstr ""

#: src/ch10-02-test-organization.md:218
msgid ""
"To avoid systematically getting a section for each file of the _tests_ "
"folder, we also have the option of making the `tests/` directory behave like "
"a regular crate, by adding a `tests/lib.cairo` file. In that case, the "
"`tests` directory will no longer compile as one crate per file, but as one "
"crate for the whole directory."
msgstr ""

#: src/ch10-02-test-organization.md:220
msgid "Let's create this _tests/lib.cairo_ file :"
msgstr ""

#: src/ch10-02-test-organization.md:222
msgid "<span class=\"caption\">Filename: tests/lib.cairo</span>"
msgstr ""

#: src/ch10-02-test-organization.md:229
msgid "The project directory will now look like this :"
msgstr ""

#: src/ch10-02-test-organization.md:243
msgid "When we run the `scarb test` command again, here is the output :"
msgstr ""

#: src/ch10-02-test-organization.md:263
msgid ""
"This way, only the test functions will be tested and the `setup` function "
"can be imported without being tested."
msgstr ""

#: src/ch10-02-test-organization.md:267
msgid ""
"Cairo's testing features provide a way to specify how code should function "
"to ensure it continues to work as you expect, even as you make changes. Unit "
"tests exercise different parts of a library separately and can test private "
"implementation details. Integration tests check that many parts of the "
"library work together correctly, and they use the library’s public API to "
"test the code in the same way external code will use it. Even though Cairo's "
"type system and ownership rules help prevent some kinds of bugs, tests are "
"still important to reduce logic bugs having to do with how your code is "
"expected to behave."
msgstr ""

#: src/ch10-02-test-organization.md:269
msgid "{{#quiz ../quizzes/ch10-02-testing-organization.toml}}"
msgstr ""

#: src/ch11-00-advanced-features.md
msgid "Advanced Features"
msgstr ""

#: src/ch11-00-advanced-features.md
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr ""

#: src/ch11-01-custom-data-structures.md:3
msgid ""
"When you first start programming in Cairo, you'll likely want to use arrays "
"(`Array<T>`) to store collections of data. However, you will quickly realize "
"that arrays have one big limitation - the data stored in them is immutable. "
"Once you append a value to an array, you can't modify it."
msgstr ""

#: src/ch11-01-custom-data-structures.md:8
msgid ""
"This can be frustrating when you want to use a mutable data structure. For "
"example, say you're making a game where the players have a level, and they "
"can level up. You might try to store the level of the players in an array:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:16
msgid ""
"But then you realize you can't increase the level at a specific index once "
"it's set. If a player dies, you cannot remove it from the array unless he "
"happens to be in the first position."
msgstr ""

#: src/ch11-01-custom-data-structures.md:20
msgid ""
"Fortunately, Cairo provides a handy built-in [dictionary "
"type](./ch03-02-dictionaries.md) called `Felt252Dict<T>` that allows us to "
"simulate the behavior of mutable data structures. Let's first explore how to "
"create a struct that contains, among others, a `Felt252Dict<T>`."
msgstr ""

#: src/ch11-01-custom-data-structures.md:23
msgid ""
"Note: Several concepts used in this chapter were already presented earlier "
"in the book. We recommend checking out the following chapters if you need to "
"revise them: [Structs](ch05-00-using-structs-to-structure-related-data.md), "
"[Methods](./ch05-03-method-syntax.md), [Generic "
"types](./ch08-00-generic-types-and-traits.md), "
"[Traits](./ch08-02-traits-in-cairo.md)."
msgstr ""

#: src/ch11-01-custom-data-structures.md:29
msgid "Dictionaries as Struct Members"
msgstr ""

#: src/ch11-01-custom-data-structures.md:31
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly "
"interacting with them may not be entirely seamless. Let's try implementing a "
"custom _user database_ that will allow us to add users and query them. We "
"will need to define a struct to represent the new type and a trait to define "
"its functionality:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:46
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic "
"over the balances of the users, giving major flexibility to whoever uses our "
"data type. Its two members are:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:48
msgid "`users_updates`, the number of users updates in the dictionary."
msgstr ""

#: src/ch11-01-custom-data-structures.md:49
msgid "`balances`, a mapping of each user to its balance."
msgstr ""

#: src/ch11-01-custom-data-structures.md:51
msgid ""
"The database core functionality is defined by `UserDatabaseTrait`. The "
"following methods are defined:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:53
msgid "`new` for easily creating new `UserDatabase` types."
msgstr ""

#: src/ch11-01-custom-data-structures.md:54
msgid "`update_user` to update the balance of users in the database."
msgstr ""

#: src/ch11-01-custom-data-structures.md:55
msgid "`get_balance` to find user's balance in the database."
msgstr ""

#: src/ch11-01-custom-data-structures.md:57
msgid ""
"The only remaining step is to implement each of the methods in "
"`UserDatabaseTrait`, but since we are working with [Generic "
"types](./ch08-00-generic-types-and-traits.md) we also need to correctly "
"establish the requirements of `T` so it can be a valid `Felt252Dict<T>` "
"value type:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:59
msgid ""
"`T` should implement the `Copy<T>` since it's required for getting values "
"from a `Felt252Dict<T>`."
msgstr ""

#: src/ch11-01-custom-data-structures.md:60
msgid ""
"All value types of a dictionary implement the `Felt252DictValue<T>`, our "
"generic type should do as well."
msgstr ""

#: src/ch11-01-custom-data-structures.md:61
msgid ""
"To insert values, `Felt252DictTrait<T>` requires all value types to be "
"droppable (implement the `Drop<T>` trait)."
msgstr ""

#: src/ch11-01-custom-data-structures.md:63
msgid "The implementation, with all restrictions in place, would be as follows:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:67
#: src/ch11-01-custom-data-structures.md:112
msgid "// Creates a database\n"
msgstr ""

#: src/ch11-01-custom-data-structures.md:72
#: src/ch11-01-custom-data-structures.md:117
msgid "// Get the user's balance\n"
msgstr ""

#: src/ch11-01-custom-data-structures.md:77
#: src/ch11-01-custom-data-structures.md:122
msgid "// Add a user\n"
msgstr ""

#: src/ch11-01-custom-data-structures.md:85
msgid ""
"Our database implementation is almost complete, except for one thing: the "
"compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since "
"it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait. Since "
"it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are "
"forced to implement the `Destruct<T>` trait manually (refer to the "
"[Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for more "
"information). Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` "
"definition won't work because of the use of [Generic "
"types](./ch08-00-generic-types-and-traits.md) in the struct definition. We "
"need to code the `Destruct<T>` trait implementation by ourselves:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:97
msgid ""
"Implementing `Destruct<T>` for `UserDatabase` was our last step to get a "
"fully functional database. We can now try it out:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:147
msgid "\"Expected 40\""
msgstr ""

#: src/ch11-01-custom-data-structures.md:148
msgid "\"Expected 0\""
msgstr ""

#: src/ch11-01-custom-data-structures.md:156
msgid "Simulating a Dynamic Array with Dicts"
msgstr ""

#: src/ch11-01-custom-data-structures.md:158
msgid ""
"First, let's think about how we want our mutable dynamic array to behave. "
"What operations should it support?"
msgstr ""

#: src/ch11-01-custom-data-structures.md:161
msgid "It should:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:163
msgid "Allow us to append items at the end."
msgstr ""

#: src/ch11-01-custom-data-structures.md:164
msgid "Let us access any item by index."
msgstr ""

#: src/ch11-01-custom-data-structures.md:165
msgid "Allow setting the value of an item at a specific index."
msgstr ""

#: src/ch11-01-custom-data-structures.md:166
msgid "Return the current length."
msgstr ""

#: src/ch11-01-custom-data-structures.md:168
msgid "We can define this interface in Cairo like:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:181
msgid ""
"This provides a blueprint for the implementation of our dynamic array. We "
"named it _Vec_ as it is similar to the `Vec<T>` data structure in Rust."
msgstr ""

#: src/ch11-01-custom-data-structures.md:184
msgid "Implementing a Dynamic Array in Cairo"
msgstr ""

#: src/ch11-01-custom-data-structures.md:186
msgid ""
"To store our data, we'll use a `Felt252Dict<T>` which maps index numbers "
"(felts) to values. We'll also store a separate `len` field to track the "
"length."
msgstr ""

#: src/ch11-01-custom-data-structures.md:189
msgid ""
"Here is what our struct looks like. We wrap the type `T` inside `Nullable` "
"pointer to allow using any type `T` in our data structure, as explained in "
"the "
"[Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively) "
"section:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:200
msgid ""
"Since we again have `Felt252Dict<T>` as a struct member, we need to "
"implement the `Destruct<T>` trait to tell the compiler how to make "
"`NullableVec<T>` go out of scope."
msgstr ""

#: src/ch11-01-custom-data-structures.md:210
msgid ""
"The key thing that makes this vector mutable is that we can insert values "
"into the dictionary to set or update values in our data structure. For "
"example, to update a value at a specific index, we do:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:216
#: src/ch11-01-custom-data-structures.md:245
#: src/ch11-01-custom-data-structures.md:254
msgid "\"Index out of bounds\""
msgstr ""

#: src/ch11-01-custom-data-structures.md:221
msgid ""
"This overwrites the previously existing value at that index in the "
"dictionary."
msgstr ""

#: src/ch11-01-custom-data-structures.md:223
msgid ""
"While arrays are immutable, dictionaries provide the flexibility we need for "
"modifiable data structures like vectors."
msgstr ""

#: src/ch11-01-custom-data-structures.md:226
msgid ""
"The implementation of the rest of the interface is straightforward. The "
"implementation of all the methods defined in our interface can be done as "
"follow :"
msgstr ""

#: src/ch11-01-custom-data-structures.md:263
msgid ""
"The full implementation of the `Vec` structure can be found in the "
"community-maintained library "
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/packages/data_structures/src)."
msgstr ""

#: src/ch11-01-custom-data-structures.md:268
msgid "Simulating a Stack with Dicts"
msgstr ""

#: src/ch11-01-custom-data-structures.md:270
msgid ""
"We will now look at a second example and its implementation details: a Stack."
msgstr ""

#: src/ch11-01-custom-data-structures.md:272
msgid ""
"A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new "
"element and removal of an existing element takes place at the same end, "
"represented as the top of the stack."
msgstr ""

#: src/ch11-01-custom-data-structures.md:276
msgid "Let us define what operations we need to create a stack:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:278
msgid "Push an item to the top of the stack."
msgstr ""

#: src/ch11-01-custom-data-structures.md:279
msgid "Pop an item from the top of the stack."
msgstr ""

#: src/ch11-01-custom-data-structures.md:280
msgid "Check whether there are still any elements in the stack."
msgstr ""

#: src/ch11-01-custom-data-structures.md:282
msgid "From these specifications we can define the following interface :"
msgstr ""

#: src/ch11-01-custom-data-structures.md:292
msgid "Implementing a Mutable Stack in Cairo"
msgstr ""

#: src/ch11-01-custom-data-structures.md:294
msgid ""
"To create a stack data structure in Cairo, we can again use a "
"`Felt252Dict<T>` to store the values of the stack along with a `usize` field "
"to keep track of the length of the stack to iterate over it."
msgstr ""

#: src/ch11-01-custom-data-structures.md:298
msgid "The Stack struct is defined as:"
msgstr ""

#: src/ch11-01-custom-data-structures.md:307
msgid "Next, let's see how our main functions `push` and `pop` are implemented."
msgstr ""

#: src/ch11-01-custom-data-structures.md:330
msgid ""
"The code uses the `insert` and `get` methods to access the values in the "
"`Felt252Dict<T>`. To push an element to the top of the stack, the `push` "
"function inserts the element in the dict at index `len` and increases the "
"`len` field of the stack to keep track of the position of the stack top. To "
"remove a value, the `pop` function decreases the value of `len` to update "
"the position of the stack top and then retrieves the last value at position "
"`len`."
msgstr ""

#: src/ch11-01-custom-data-structures.md:337
msgid ""
"The full implementation of the Stack, along with more data structures that "
"you can use in your code, can be found in the community-maintained "
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/packages/data_structures/src) "
"library, in the \"data_structures\" crate."
msgstr ""

#: src/ch11-01-custom-data-structures.md:343
msgid "{{#quiz ../quizzes/ch11-01-custom-structs.toml}}"
msgstr ""

#: src/ch11-01-custom-data-structures.md:347
msgid ""
"Well done! Now you have knowledge of arrays, dictionaries and even custom "
"data structures. While Cairo's memory model is immutable and can make it "
"difficult to implement mutable data structures, we can fortunately use the "
"`Felt252Dict<T>` type to simulate mutable data structures. This allows us to "
"implement a wide range of data structures that are useful for many "
"applications, effectively hiding the complexity of the underlying memory "
"model."
msgstr ""

#: src/ch11-02-smart-pointers.md:3
msgid ""
"A pointer is a general concept for a variable that contains a memory "
"address. This address refers to, or “points at,” some other data. While "
"pointers are a powerful feature, they can also be a source of bugs and "
"security vulnerabilities. For example, a pointer can reference an unassigned "
"memory cell, which means that attempting to access the data at that address "
"would cause the program to crash, making it unprovable. To prevent such "
"issues, Cairo uses _Smart Pointers_."
msgstr ""

#: src/ch11-02-smart-pointers.md:5
msgid ""
"Smart pointers are data structures that act like a pointer, but also have "
"additional metadata and capabilities. The concept of smart pointers isn’t "
"unique to Cairo: smart pointers originated in C++ and exist in other "
"languages like Rust as well. In the specific case of Cairo, smart pointers "
"ensure that memory is not addressed in an unsafe way that could cause a "
"program to be unprovable, by providing a safe way to access memory through "
"strict type checking and ownership rules."
msgstr ""

#: src/ch11-02-smart-pointers.md:7
msgid ""
"Though we didn’t call them as such at the time, we’ve already encountered a "
"few smart pointers in this book, including `Felt252Dict<T>` and `Array<T>` "
"in Chapter 3. Both these types count as smart pointers because they own a "
"memory segment and allow you to manipulate it. They also have metadata and "
"extra capabilities or guarantees. Arrays keep track of their current length "
"to ensure that existing elements are not overwritten, and that new elements "
"are only appended to the end."
msgstr ""

#: src/ch11-02-smart-pointers.md:9
msgid ""
"The Cairo VM memory is composed by multiple segments that can store data, "
"each identified by a unique index. When you create an array, you allocate a "
"new segment in the memory to store the future elements. The array itself is "
"just a pointer to that segment where the elements are stored."
msgstr ""

#: src/ch11-02-smart-pointers.md:11
msgid "The `Box<T>` Type to Manipulate Pointers"
msgstr ""

#: src/ch11-02-smart-pointers.md:13
msgid ""
"The principal smart pointer type in Cairo is a _box_, denoted as `Box<T>`. "
"Manually defining boxes allow you to store data in a specific memory segment "
"of the Cairo VM called the _boxed segment_. This segment is dedicated to "
"store all boxed values, and what remains in the execution segment is only a "
"pointer to the boxed segment. Whenever you instantiate a new pointer "
"variable of type `Box<T>`, you append the data of type `T` to the boxed "
"segment."
msgstr ""

#: src/ch11-02-smart-pointers.md:15
msgid ""
"Boxes have very little performance overhead, other than writing their inner "
"values to the boxed segment. But they don’t have many extra capabilities "
"either. You’ll use them most often in these situations:"
msgstr ""

#: src/ch11-02-smart-pointers.md:17
msgid ""
"When you have a type whose size can’t be known at compile time and you want "
"to use a value of that type in a context that requires an exact size"
msgstr ""

#: src/ch11-02-smart-pointers.md:18
msgid ""
"When you have a large amount of data and you want to transfer ownership but "
"ensure the data won’t be copied when you do so"
msgstr ""

#: src/ch11-02-smart-pointers.md:20
msgid ""
"We’ll demonstrate the first situation in the [“Enabling Recursive Types with "
"Boxes”](./ch11-02-smart-pointers.md#enabling-recursive-types-with-nullable-boxes) "
"section. In the second case, transferring ownership of a large amount of "
"data can take a long time because the data is copied around in memory. To "
"improve performance in this situation, we can store the large amount of data "
"in the boxed segment using a box type. Then, only the small amount of "
"pointer data is copied around in memory, while the data it references stays "
"in one place on the boxed segment."
msgstr ""

#: src/ch11-02-smart-pointers.md:25
msgid "Using a `Box<T>` to Store Data in the Boxed Segment"
msgstr ""

#: src/ch11-02-smart-pointers.md:27
msgid ""
"Before we discuss the boxed segment storage use cases for `Box<T>`, we’ll "
"cover the syntax and how to interact with values stored within a `Box<T>`."
msgstr ""

#: src/ch11-02-smart-pointers.md:29
msgid ""
"Listing 11-1 shows how to use a box to store a value in the boxed segment:"
msgstr ""

#: src/ch11-02-smart-pointers.md:34
msgid "\"b = {}\""
msgstr ""

#: src/ch11-02-smart-pointers.md:38
msgid ""
"<span class=\"caption\">Listing 11-1: Storing a `u128` value in the boxed "
"segment using a box</span>"
msgstr ""

#: src/ch11-02-smart-pointers.md:40
msgid ""
"We define the variable `b` to have the value of a `Box` that points to the "
"value `5`, which is stored in the boxed segment. This program will print `b "
"= 5`; in this case, we can access the data in the box similar to how we "
"would if this data was simply in the execution memory. Putting a single "
"value in a box isn’t very useful, so you won’t use boxes by themselves in "
"this way very often. Having values like a single `u128` in the execution "
"memory, where they’re stored by default, is more appropriate in the majority "
"of situations. Let’s look at a case where boxes allow us to define types "
"that we wouldn’t be allowed to if we didn’t have boxes."
msgstr ""

#: src/ch11-02-smart-pointers.md:42
msgid "Enabling Recursive Types with Nullable Boxes"
msgstr ""

#: src/ch11-02-smart-pointers.md:46
msgid "Using Boxes to Improve Performance"
msgstr ""

#: src/ch11-02-smart-pointers.md:48
msgid ""
"Passing pointers between functions allows you to reference data without "
"copying the data itself. Using boxes can improve performance as it allows "
"you to pass a pointer to some data from one function to another, without the "
"need to copy the entire data in memory before performing the function call. "
"Instead of having to write `n` values into memory before calling a function, "
"only a single value is written, corresponding to the pointer to the data. If "
"the data stored in the box is very large, the performance improvement can be "
"significant, as you would save `n-1` memory operations before each function "
"call."
msgstr ""

#: src/ch11-02-smart-pointers.md:50
msgid ""
"Let's take a look at the code in Listing 11-2, which shows two ways of "
"passing data to a function: by value and by pointer."
msgstr ""

#: src/ch11-02-smart-pointers.md:61 src/ch11-02-smart-pointers.md:66
msgid "\"{} is shopping today and bought {} items\""
msgstr ""

#: src/ch11-02-smart-pointers.md:70
msgid "\"Eli\""
msgstr ""

#: src/ch11-02-smart-pointers.md:73
msgid "\"Uri\""
msgstr ""

#: src/ch11-02-smart-pointers.md:78
msgid ""
"<span class=\"caption\">Listing 11-2: Storing large amounts of data in a box "
"for performance.</span>"
msgstr ""

#: src/ch11-02-smart-pointers.md:80
msgid "The `main` function includes 2 function calls:"
msgstr ""

#: src/ch11-02-smart-pointers.md:82
msgid "`pass_data` that takes a variable of type `Cart`."
msgstr ""

#: src/ch11-02-smart-pointers.md:83
msgid "`pass_pointer` that takes a pointer of type `Box<Cart>`."
msgstr ""

#: src/ch11-02-smart-pointers.md:85
msgid ""
"When passing data to a function, the entire data is copied into the last "
"available memory cells right before the function call. Calling `pass_data` "
"will copy all 3 fields of `Cart` to memory, while `pass_pointer` only "
"requires the copy of the `new_box` pointer which is of size 1."
msgstr ""

#: src/ch11-02-smart-pointers.md:94
msgid ""
"The illustration above demonstrates how the memory behaves in both cases. "
"The first instance of `Cart` is stored in the execution segment, and we need "
"to copy all its fields to memory before calling the `pass_data` function. "
"The second instance of `Cart` is stored in the boxed segment, and the "
"pointer to it is stored in the execution segment. When calling the "
"`pass_pointer` function, only the pointer to the struct is copied to memory "
"right before the function call. In both cases, however, instantiating the "
"struct will store all its values in the execution segment: the boxed segment "
"can only be filled with data taken from the execution segment."
msgstr ""

#: src/ch11-02-smart-pointers.md:96
msgid "The `Nullable<T>` Type for Dictionaries"
msgstr ""

#: src/ch11-02-smart-pointers.md:98
msgid ""
"`Nullable<T>` is another type of smart pointer that can either point to a "
"value or be `null` in the absence of value. It is defined at the Sierra "
"level. This type is mainly used in dictionaries that contain types that "
"don't implement the `zero_default` method of the `Felt252DictValue<T>` trait "
"(i.e., arrays and structs)."
msgstr ""

#: src/ch11-02-smart-pointers.md:100
msgid ""
"If we try to access an element that does not exist in a dictionary, the code "
"will fail if the `zero_default` method cannot be called."
msgstr ""

#: src/ch11-02-smart-pointers.md:102
msgid ""
"[Chapter "
"3.2](/ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively) "
"about dictionaries thoroughly explains how to store a `Span<felt252>` "
"variable inside a dictionary using the `Nullable<T>` type. Please refer to "
"it for further information."
msgstr ""

#: src/ch11-02-smart-pointers.md:106
msgid "{{#quiz ../quizzes/ch11-02-smart_pointers.toml}}"
msgstr ""

#: src/ch11-03-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows "
"the redefinition of standard operators, such as addition (`+`), subtraction "
"(`-`), multiplication (`*`), and division (`/`), to work with user-defined "
"types. This can make the syntax of the code more intuitive, by enabling "
"operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr ""

#: src/ch11-03-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of "
"specific traits. Each operator has an associated trait, and overloading that "
"operator involves providing an implementation of that trait for a custom "
"type. However, it's essential to use operator overloading judiciously. "
"Misuse can lead to confusion, making the code more difficult to maintain, "
"for example when there is no semantic meaning to the operator being "
"overloaded."
msgstr ""

#: src/ch11-03-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have "
"two data fields, mana and health. Combining two `Potions` should add their "
"respective fields."
msgstr ""

#: src/ch11-03-operator-overloading.md:26
msgid "// Both potions were combined with the `+` operator.\n"
msgstr ""

#: src/ch11-03-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type. "
"The add function takes two arguments: `lhs` and `rhs` (left and right-hand "
"side). The function body returns a new `Potion` instance, its field values "
"being a combination of `lhs` and `rhs`."
msgstr ""

#: src/ch11-03-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires "
"specification of the concrete type being overloaded. The overloaded generic "
"trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr ""

#: src/ch11-03-operator-overloading.md:36
msgid "{{#quiz ../quizzes/ch11-03-operator-overloading.toml}}"
msgstr ""

#: src/ch11-04-hash.md:1
msgid "Hashes"
msgstr ""

#: src/ch11-04-hash.md:3
msgid ""
"At its essence, hashing is a process of converting input data (often called "
"a message) of any length into a fixed-size value, typically referred to as a "
"\"hash.\" This transformation is deterministic, meaning that the same input "
"will always produce the same hash value. Hash functions are a fundamental "
"component in various fields, including data storage, cryptography and data "
"integrity verification. They are very often used when developing smart "
"contracts, especially when working with [Merkle "
"trees](https://en.wikipedia.org/wiki/Merkle_tree#Uses)."
msgstr ""

#: src/ch11-04-hash.md:5
msgid ""
"In this chapter, we will present the two hash functions implemented natively "
"in the Cairo core library: `Poseidon` and `Pedersen`. We will discuss when "
"and how to use them, and see examples with Cairo programs."
msgstr ""

#: src/ch11-04-hash.md:9
msgid "Hash Functions in Cairo"
msgstr ""

#: src/ch11-04-hash.md:11
msgid ""
"The Cairo core library provides two hash functions: Pedersen and Poseidon."
msgstr ""

#: src/ch11-04-hash.md:13
msgid ""
"Pedersen hash functions are cryptographic algorithms that rely on [elliptic "
"curve "
"cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography). "
"These functions perform operations on points along an elliptic curve — "
"essentially, doing math with the locations of these points — which are easy "
"to do in one direction and hard to undo. This one-way difficulty is based on "
"the Elliptic Curve Discrete Logarithm Problem (ECDLP), which is a problem so "
"hard to solve that it ensures the security of the hash function. The "
"difficulty of reversing these operations is what makes the Pedersen hash "
"function secure and reliable for cryptographic purposes."
msgstr ""

#: src/ch11-04-hash.md:15
msgid ""
"Poseidon is a family of hash functions designed to be very efficient as "
"algebraic circuits. Its design is particularly efficient for Zero-Knowledge "
"proof systems, including STARKs (so, Cairo). Poseidon uses a method called a "
"'sponge construction,' which soaks up data and transforms it securely using "
"a process known as the Hades permutation. Cairo's version of Poseidon is "
"based on a three-element state permutation with [specific "
"parameters](https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt)."
msgstr ""

#: src/ch11-04-hash.md:20
msgid "When to Use Them?"
msgstr ""

#: src/ch11-04-hash.md:22
msgid ""
"Pedersen was the first hash function used on Starknet, and is still used to "
"compute the addresses of variables in storage (for example, `LegacyMap` uses "
"Pedersen to hash the keys of a storage mapping on Starknet). However, as "
"Poseidon is cheaper and faster than Pedersen when working with STARK proofs "
"system, it's now the recommended hash function to use in Cairo programs."
msgstr ""

#: src/ch11-04-hash.md:26
msgid ""
"The core library makes it easy to work with hashes. The `Hash` trait is "
"implemented for all types that can be converted to `felt252`, including "
"`felt252` itself. For more complex types like structs, deriving `Hash` "
"allows them to be hashed easily using the hash function of your choice - "
"given that all of the struct's fields are themselves hashable. You cannot "
"derive the `Hash` trait on a struct that contains un-hashable values, such "
"as `Array<T>` or `Felt252Dict<T>`, even if `T` itself is hashable."
msgstr ""

#: src/ch11-04-hash.md:28
msgid ""
"The `Hash` trait is accompanied by the `HashStateTrait` and "
"`HashStateExTrait` that define the basic methods to work with hashes. They "
"allow you to initialize a hash state that will contain the temporary values "
"of the hash after each application of the hash function, update the hash "
"state and finalize it when the computation is completed. `HashStateTrait` "
"and `HashStateExTrait` are defined as follows:"
msgstr ""

#: src/ch11-04-hash.md:31
msgid "/// A trait for hash state accumulators.\n"
msgstr ""

#: src/ch11-04-hash.md:36
msgid "/// Extension trait for hash state accumulators.\n"
msgstr ""

#: src/ch11-04-hash.md:39 src/ch11-04-hash.md:45
msgid "/// Updates the hash state with the given value.\n"
msgstr ""

#: src/ch11-04-hash.md:42
msgid "/// A trait for values that can be hashed.\n"
msgstr ""

#: src/ch11-04-hash.md:50
msgid ""
"To use hashes in your code, you must first import the relevant traits and "
"functions. In the following example, we will demonstrate how to hash a "
"struct using both the Pedersen and Poseidon hash functions."
msgstr ""

#: src/ch11-04-hash.md:52
msgid ""
"The first step is to initialize the hash with either `PoseidonTrait::new() "
"-> HashState` or `PedersenTrait::new(base: felt252) -> HashState` depending "
"on which hash function we want to work with. Then the hash state can be "
"updated with the `update(self: HashState, value: felt252) -> HashState` or "
"`update_with(self: S, value: T) -> S` functions as many times as required. "
"Then the function `finalize(self: HashState) -> felt252` is called on the "
"hash state and it returns the value of the hash as a `felt252`."
msgstr ""

#: src/ch11-04-hash.md:74
msgid ""
"Pedersen is different from Poseidon, as it starts with a base state. This "
"base state must be of `felt252` type, which forces us to either hash the "
"struct with an arbitrary base state using the `update_with` method, or "
"serialize the struct into an array to loop through all of its fields and "
"hash its elements together."
msgstr ""

#: src/ch11-04-hash.md:76
msgid "Here is a short example of Pedersen hashing:"
msgstr ""

#: src/ch11-04-hash.md:93
msgid "// hash1 is the result of hashing a struct with a base state of 0\n"
msgstr ""

#: src/ch11-04-hash.md:105
msgid "// hash2 is the result of hashing only the fields of the struct\n"
msgstr ""

#: src/ch11-04-hash.md:114
msgid "Advanced Hashing: Hashing Arrays with Poseidon"
msgstr ""

#: src/ch11-04-hash.md:116
msgid ""
"Let us look at an example of hashing a struct that contains a "
"`Span<felt252>`. To hash a `Span<felt252>` or a struct that contains a "
"`Span<felt252>` you can use the built-in function `poseidon_hash_span(mut "
"span: Span<felt252>) -> felt252`. Similarly, you can hash `Array<felt252>` "
"by calling `poseidon_hash_span` on its span."
msgstr ""

#: src/ch11-04-hash.md:119
msgid "First, let us import the following traits and function:"
msgstr ""

#: src/ch11-04-hash.md:127
msgid ""
"Now we define the struct. As you might have noticed, we didn't derive the "
"`Hash` trait. If you attempt to derive the `Hash` trait for this struct, it "
"will result in an error because the structure contains a field that is not "
"hashable."
msgstr ""

#: src/ch11-04-hash.md:138
msgid ""
"In this example, we initialized a `HashState` (`hash`), updated it and then "
"called the function `finalize()` on the `HashState` to get the computed hash "
"`hash_felt252`. We used `poseidon_hash_span` on the `Span` of the "
"`Array<felt252>` to compute its hash."
msgstr ""

#: src/ch11-05-macros.md:3
msgid ""
"The Cairo language has some plugins that allow developers to simplify their "
"code. They are called `inline_macros` and are a way of writing code that "
"generates other code."
msgstr ""

#: src/ch11-05-macros.md:5
msgid "`consteval_int!` Macro"
msgstr ""

#: src/ch11-05-macros.md:7
msgid ""
"In some situations, a developer might need to declare a constant that is the "
"result of a computation of integers. To compute a constant expression and "
"use its result at compile time, it is required to use the `consteval_int!` "
"macro."
msgstr ""

#: src/ch11-05-macros.md:9
msgid "Here is an example of `consteval_int!`:"
msgstr ""

#: src/ch11-05-macros.md:15
msgid "This will be interpreted as `const a: felt252 = 8;` by the compiler."
msgstr ""

#: src/ch11-05-macros.md:17
msgid "`selector!` Macro"
msgstr ""

#: src/ch11-05-macros.md:19
msgid ""
"See [Entry Point "
"Selector](./ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md#entry-point-selector)."
msgstr ""

#: src/ch11-05-macros.md:21
msgid "`print!` and `println!` Macros"
msgstr ""

#: src/ch11-05-macros.md:23
msgid "Please refer to the [Printing](./ch11-08-printing.md) page."
msgstr ""

#: src/ch11-05-macros.md:27
msgid "Please refer to the [Arrays](./ch03-01-arrays.md) page."
msgstr ""

#: src/ch11-05-macros.md:31
msgid ""
"See [Unrecoverable Errors with "
"panic](./ch09-01-unrecoverable-errors-with-panic.html#panic-macro) page."
msgstr ""

#: src/ch11-05-macros.md:33
msgid "`assert!` and `assert_xx!` Macros"
msgstr ""

#: src/ch11-05-macros.md:35
msgid "See [How to Write Tests](./ch10-01-how-to-write-tests.md) page."
msgstr ""

#: src/ch11-05-macros.md:37
msgid "`format!` Macro"
msgstr ""

#: src/ch11-05-macros.md:39
msgid "See [Printing](./ch11-08-printing.html#formatting) page."
msgstr ""

#: src/ch11-05-macros.md:41
msgid "`write!` and `writeln!` Macros"
msgstr ""

#: src/ch11-05-macros.md:43
msgid "See [Printing](./ch11-08-printing.html#printing-custom-data-types) page."
msgstr ""

#: src/ch11-05-macros.md:45
msgid "`get_dep_component!`, `get_dep_component_mut` and `component!` Macros"
msgstr ""

#: src/ch11-05-macros.md:47
msgid ""
"Please refer to the [Composability and "
"Components](./ch16-02-00-composability-and-components.md) chapter."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:3
msgid ""
"Inlining is a common code optimization technique supported by most "
"compilers. It involves replacing a function call at the call site with the "
"actual code of the called function, eliminating the overhead associated with "
"the function call itself. This can improve performance by reducing the "
"number of instructions executed, but may increase the total size of the "
"program. When you're thinking about whether to inline a function, take into "
"account things like how big it is, what parameters it has, how often it gets "
"called, and how it might affect the size of your compiled code."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:5
msgid "The `inline` Attribute"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:7
msgid ""
"In Cairo, the `inline` attribute suggests whether or not the Sierra code "
"corresponding to the attributed function should be directly injected in the "
"caller function's context, rather than using a `function_call` libfunc to "
"execute that code."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:9
msgid "There are three variants of the `inline` attribute that one can use:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:11
msgid "`#[inline]` suggests performing an inline expansion."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:12
msgid ""
"`#[inline(always)]` suggests that an inline expansion should always be "
"performed."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:13
msgid ""
"`#[inline(never)]` suggests that an inline expansion should never be "
"performed."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:15
msgid ""
"Note: the `inline` attribute in every form is a hint, with no requirements "
"on the language to place a copy of the attributed function in the caller. "
"This means that the attribute may be ignored by the compiler. In practice, "
"`#[inline(always)]` will cause inlining in all but the most exceptional "
"cases."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:17
msgid ""
"Many of the Cairo corelib functions are inlined. User-defined functions may "
"also be annotated with the `inline` attribute. Annoting functions with the "
"`#[inline(always)]` attribute reduces the total number of steps required "
"when calling these attributed functions. Indeed, injecting the Sierra code "
"at the caller site avoids the step-cost involved in calling functions and "
"obtaining their arguments."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:19
msgid ""
"However, inlining can also lead to increased code size. Whenever a function "
"is inlined, the call site contains a copy of the function's Sierra code, "
"potentially leading to duplication of code across the compiled code."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:21
msgid ""
"Therefore, inlining should be applied with caution. Using `#[inline]` or "
"`#[inline(always)]` indiscriminately will lead to increased compile time. It "
"is particularly useful to inline small functions, ideally with many "
"arguments. This is because inlining large functions will increase the code "
"length of the program, and handling many arguments will increase the number "
"of steps to execute these functions."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:23
msgid ""
"The more frequently a function is called, the more beneficial inlining "
"becomes in terms of performance. By doing so, the number of steps for the "
"execution will be lower, while the code length will not grow that much or "
"might even decrease in terms of total number of instructions."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:25
msgid ""
"Inlining is often a tradeoff between number of steps and code length. Use "
"the `inline` attribute cautiously where it is appropriate."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:27
msgid "Inlining Example"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:29
msgid ""
"Let's introduce a short example to illustrate the mechanisms of inlining in "
"Cairo. Listing 11-3 shows a basic program allowing comparison between "
"inlined and non-inlined functions."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:47
msgid ""
"<span class=\"caption\">Listing 11-3: A small Cairo program that adds the "
"return value of 2 functions, with one of them being inlined</span>"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:49
msgid ""
"Let's take a look at the corresponding Sierra code to see how inlining works "
"under the hood:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:52 src/ch11-06-inlining-in-cairo.md:215
msgid "// type declarations\n"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:54 src/ch11-06-inlining-in-cairo.md:218
msgid "// libfunc declarations\n"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:61 src/ch11-06-inlining-in-cairo.md:226
msgid "// statements\n"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:75 src/ch11-06-inlining-in-cairo.md:238
msgid "// funcs\n"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:82
msgid "The Sierra file is structured in three parts:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:84
msgid "Type and libfunc declarations."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:85
msgid "Statements that constitute the program."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:86
msgid "Declaration of the functions of the program."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:88
msgid ""
"The Sierra code statements always match the order of function declarations "
"in the Cairo program. Indeed, the declaration of the functions of the "
"program tells us that:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:90
msgid "`main` function starts at line 0, and returns a `felt252` on line 5."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:91
msgid "`inlined` function starts at line 6, and returns a `felt252` on line 8."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:92
msgid ""
"`not_inlined` function starts at line 9, and returns a `felt252` on line 11."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:94
msgid ""
"All statements corresponding to the `main` function are located between "
"lines 0 and 5:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:105
msgid ""
"The `function_call` libfunc is called on line 0 to execute the `not_inlined` "
"function. This will execute the code from lines 9 to 10 and store the return "
"value in the variable with id `0`."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:112
msgid ""
"This code uses a single data type, `felt252`. It uses two library functions "
"- `felt_const<2>`, which returns the constant `felt252` 2, "
"and `store_temp<felt252>`, which pushes a constant value to memory. The "
"first line calls the `felt_const<2>` libfunc to create a variable with "
"id `0`. Then, the second line pushes this variable to memory for later use."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:114
msgid ""
"After that, Sierra statements from line 1 to 2 are the actual body of the "
"`inlined` function:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:121
msgid ""
"The only difference is that the inlined code will store the `felt252_const` "
"value in a variable with id `1`, because `[0]` refers to a variable "
"previously assigned:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:128
msgid ""
"Note: in both cases (inlined or not), the `return` instruction of the "
"function being called is not executed, as this would lead to prematurely end "
"the execution of the `main` function. Instead, return values of `inlined` "
"and `not_inlined` will be added and the result will be returned."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:130
msgid ""
"Lines 3 to 5 contain the Sierra statements that will add the values "
"contained in variables with ids `0` and `1`, store the result in memory and "
"return it:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:138
msgid ""
"Now, let's take a look at the Casm code corresponding to this program to "
"really understand the benefits of inlining."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:140
msgid "Casm Code Explanations"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:142
msgid "Here is the Casm code for our previous program example:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:158
msgid ""
"Don't hesitate to use [cairovm.codes](https://cairovm.codes/) playground to "
"follow along and see all the execution trace."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:160
msgid ""
"Each instruction and each argument for any instruction increment the Program "
"Counter (known as PC) by 1. This means that `ret` on line 2 is actually the "
"instruction at `PC = 3`, as the argument `3` corresponds to `PC = 2`."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:162
msgid ""
"The `call` and `ret` instructions allow implementation of a function stack:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:164
msgid ""
"`call` instruction acts like a jump instruction, updating the PC to a given "
"value, whether relatively to the current value using `rel` or absolutely "
"using `abs`."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:165
msgid ""
"`ret` instruction jumps back right after the `call` instruction and "
"continues the execution of the code."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:167
msgid ""
"We can now decompose how these instructions are executed to understand what "
"this code does:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:169
msgid ""
"`call rel 3`: this instruction increments the PC by 3 and executes the "
"instruction at this location, which is `call rel 9` at `PC = 4`."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:170
msgid ""
"`call rel 9` increments the PC by 9 and executes the instruction at `PC = "
"13`, which is actually line 9."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:171
msgid ""
"`[ap + 0] = 2, ap++`: `ap` stands for Allocation Pointer, which points to "
"the first memory cell that has not been used by the program so far. This "
"means we store the value `2` in the next free memory cell indicated by the "
"current value of `ap`, after which we increment `ap` by 1. Then, we go to "
"the next line which is `ret`."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:172
msgid "`ret`: jumps back to the line after `call rel 9`, so we go to line 4."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:173
msgid ""
"`[ap + 0] = 1, ap++` : we store the value `1` in `[ap]` and we apply `ap++` "
"so that `[ap - 1] = 1`. This means we now have `[ap-1] = 1, [ap-2] = 2` and "
"we go to the next line."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:174
msgid ""
"`[ap + 0] = [ap + -1] + [ap + -2], ap++`: we sum the values `1` and `2` and "
"store the result in `[ap]`, and we apply `ap++` so the result is `[ap-1] = "
"3, [ap-2] = 1, [ap-3]=2`."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:175
msgid "`ret`: jumps back to the line after `call rel 3`, so we go to line 2."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:176
msgid ""
"`ret`: last instruction executed as there is no more `call` instruction "
"where to jump right after. This is the actual return instruction of the "
"Cairo `main` function."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:178
msgid "To summarize:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:180
msgid ""
"`call rel 3` corresponds to the `main` function, which is obviously not "
"inlined."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:181
msgid ""
"`call rel 9` triggers the call the `not_inlined` function, which returns `2` "
"and stores it at the final location `[ap-3]`."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:182
msgid ""
"The line 4 is the inlined code of the `inlined` function, which returns `1` "
"and stores it at the final location `[ap-2]`. We clearly see that there is "
"no `call` instruction in this case, because the body of the function is "
"inserted and directly executed."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:183
msgid ""
"After that, the sum is computed and we ultimately go back to the line 2 "
"which contains the final `ret` instruction that returns the sum, "
"corresponding to the return value of the `main` function."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:185
msgid ""
"It is interesting to note that in both Sierra code and Casm code, the "
"`not_inlined` function will be called and executed before the body of the "
"`inlined` function, even though the Cairo program executes `inlined() + "
"not_inlined()`."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:187
msgid ""
"The Casm code of our program clearly shows that there is a function call for "
"the `not_inlined` function, while the `inlined` function is correctly "
"inlined."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:189
msgid "Additional Optimizations"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:191
msgid ""
"Let's study another program that shows other benefits that inlining may "
"sometimes provide. Listing 11-4 shows a Cairo program that calls 2 functions "
"and doesn't return anything:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:210
msgid ""
"<span class=\"caption\">Listing 11-4: A small Cairo program that calls "
"`inlined` and `not_inlined` and doesn't return any value.</span>"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:212
msgid "Here is the corresponding Sierra code:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:245
msgid ""
"In this specific case, we can observe that the compiler has applied "
"additional optimizations to the `main` function of our code : the code of "
"the `inlined` function, which is annotated with the `#[inline(always)]` "
"attribute, is actually not copied in the `main` function. Instead, the "
"`main` function starts with the `function_call` libfunc to call the "
"`not_inlined` function, entirely omitting the code of the `inlined` function."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:247
msgid ""
"Because `inlined` return value is never used, the compiler optimizes the "
"`main` function by skipping the `inlined` function code. This will actually "
"reduce the code length while reducing the number of steps required to "
"execute `main`."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:249
msgid ""
"In contrast, line 0 uses the `function_call` libfunc to execute the "
"`not_inlined` function normally. This means that all the code from lines 7 "
"to 8 will be executed:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:256
msgid ""
"This value stored in the variable with id `0` is then dropped on line 1, as "
"it is not used in the `main` function:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:262
msgid ""
"Finally, as the `main` function doesn't return any value, a variable of unit "
"type `()` is created and returned:"
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:271
msgid ""
"Inlining is a compiler optimization technique that can be very useful in "
"various situations. Inlining a function allows to get rid of the overhead of "
"calling a function with the `function_call` libfunc by injecting the Sierra "
"code directly in the caller function's context, while potentially optimizing "
"the Sierra code executed to reduce the number of steps. If used effectively, "
"inlining can even reduce code length as shown in the previous example."
msgstr ""

#: src/ch11-06-inlining-in-cairo.md:273
msgid ""
"Nevertheless, applying the `inline` attribute to a function with a lot of "
"code and few parameters might result in an increased code size, especially "
"if the inlined function is used many times in the codebase. Use inlining "
"only where it makes sense, and be aware that the compiler handles inlining "
"by default. Therefore, manually applying inlining is not recommended in most "
"situations, but can help improve and fine-tune your code's behavior."
msgstr ""

#: src/ch11-08-printing.md:3
msgid ""
"When writing a program, it is quite common to print some data to the "
"console, either for the normal process of the program or for debugging "
"purpose. In this chapter, we describe the options you have to print simple "
"and complex data types."
msgstr ""

#: src/ch11-08-printing.md:5
msgid "Printing Standard Data Types"
msgstr ""

#: src/ch11-08-printing.md:7
msgid "Cairo provides two macros to print standard data types:"
msgstr ""

#: src/ch11-08-printing.md:9
msgid "`println!` which prints on a new line"
msgstr ""

#: src/ch11-08-printing.md:10
msgid "`print!` with inline printing"
msgstr ""

#: src/ch11-08-printing.md:12
msgid ""
"Both take a `ByteArray` string as first parameter (see [Data "
"Types](./ch02-02-data-types.md#byte-array-strings)), which can be a simple "
"string to print a message or a string with placeholders to format the way "
"values are printed."
msgstr ""

#: src/ch11-08-printing.md:14
msgid "There are two ways to use these placeholders and both can be mixed:"
msgstr ""

#: src/ch11-08-printing.md:16
msgid ""
"empty curly brackets `{}` are replaced by values given as parameters to the "
"`print!` macro, in the same order."
msgstr ""

#: src/ch11-08-printing.md:17
msgid ""
"curly brackets with variable names are directly replaced by the variable "
"value."
msgstr ""

#: src/ch11-08-printing.md:19
msgid "Here are some examples:"
msgstr ""

#: src/ch11-08-printing.md:27
msgid "\"Hello world!\""
msgstr ""

#: src/ch11-08-printing.md:28
msgid "\"{} {} {}\""
msgstr ""

#: src/ch11-08-printing.md:28
msgid "// 10 20 30\n"
msgstr ""

#: src/ch11-08-printing.md:29
msgid "\"{c} {a} {}\""
msgstr ""

#: src/ch11-08-printing.md:29
msgid "// 30 10 20\n"
msgstr ""

#: src/ch11-08-printing.md:33
msgid ""
"`print!` and `println!` macros use the `Display` trait under the hood, and "
"are therefore used to print the value of types that implement it. This is "
"the case for basic data types, but not for more complex ones. If you try to "
"print complex data type values with these macros, e.g. for debugging "
"purposes, you will get an error. In that case, you can either [manually "
"implement](./ch11-08-printing.md#printing-custom-data-types) the `Display` "
"trait for your type or use the `Debug` trait (see "
"[below](./ch11-08-printing.md#print-debug-traces))."
msgstr ""

#: src/ch11-08-printing.md:39
msgid "Formatting"
msgstr ""

#: src/ch11-08-printing.md:41
msgid ""
"Cairo also provides a useful macro to handle string formatting: `format!`. "
"This macro works like `println!`, but instead of printing the output to the "
"screen, it returns a `ByteArray` with the contents. In the following "
"example, we perform string concatenation using either the `+` operator or "
"the `format!` macro. The version of the code using `format!` is much easier "
"to read, and the code generated by the `format!` macro uses snapshots, so "
"that this call doesn’t take ownership of any of its parameters."
msgstr ""

#: src/ch11-08-printing.md:46 src/ch11-08-printing.md:52
msgid "\"tic\""
msgstr ""

#: src/ch11-08-printing.md:47 src/ch11-08-printing.md:53
msgid "\"tac\""
msgstr ""

#: src/ch11-08-printing.md:48 src/ch11-08-printing.md:54
msgid "\"toe\""
msgstr ""

#: src/ch11-08-printing.md:49
msgid "\"-\""
msgstr ""

#: src/ch11-08-printing.md:50
msgid "// using + operator consumes the strings, so they can't be used again!\n"
msgstr ""

#: src/ch11-08-printing.md:55
msgid "\"{s1}-{s2}-{s3}\""
msgstr ""

#: src/ch11-08-printing.md:55
msgid ""
"// s1, s2, s3 are not consumed by format!\n"
"    // or\n"
msgstr ""

#: src/ch11-08-printing.md:57
msgid "\"{}-{}-{}\""
msgstr ""

#: src/ch11-08-printing.md:63
msgid "Printing Custom Data Types"
msgstr ""

#: src/ch11-08-printing.md:65
msgid ""
"As previously explained, if you try to print the value of a custom data type "
"with `print!` or `println!` macros, you'll get an error telling you that the "
"`Display` trait is not implemented for your custom type:"
msgstr ""

#: src/ch11-08-printing.md:71
msgid ""
"The `println!` macro can do many kinds of formatting, and by default, the "
"curly brackets tell `println!` to use formatting known as `Display` - output "
"intended for direct end user consumption. The primitive types we’ve seen so "
"far implement `Display` by default because there’s only one way you’d want "
"to show a `1` or any other primitive type to a user. But with structs, the "
"way `println!` should format the output is less clear because there are more "
"display possibilities: Do we want commas or not? Do we want to print the "
"curly brackets? Should all the fields be shown? Due to this ambiguity, Cairo "
"doesn’t try to guess what we want, and structs don’t have a provided "
"implementation of `Display` to use with `println!` and the `{}` placeholder."
msgstr ""

#: src/ch11-08-printing.md:73
msgid "Here is the `Display` trait to implement:"
msgstr ""

#: src/ch11-08-printing.md:81
msgid ""
"The second parameter `f` is of type `Formatter`, which is just a struct "
"containing a `ByteArray`, representing the pending result of formatting:"
msgstr ""

#: src/ch11-08-printing.md:86
msgid "/// The pending result of formatting.\n"
msgstr ""

#: src/ch11-08-printing.md:91
msgid ""
"Knowing this, here is an example of how to implement the `Display` trait for "
"a custom `Point` struct:"
msgstr ""

#: src/ch11-08-printing.md:104
msgid "\"Point ({}, {})\""
msgstr ""

#: src/ch11-08-printing.md:112 src/ch11-08-printing.md:156
msgid "// Point: (1, 3)\n"
msgstr ""

#: src/ch11-08-printing.md:116
msgid ""
"Cairo also provides the `write!` and `writeln!` macros to write formatted "
"strings in a formatter. Here is a short example using `write!` macro to "
"concatenate multiple strings on the same line and then print the result:"
msgstr ""

#: src/ch11-08-printing.md:126
msgid "\"hello\""
msgstr ""

#: src/ch11-08-printing.md:127
msgid "\"world\""
msgstr ""

#: src/ch11-08-printing.md:128
msgid "\" {a} {b}\""
msgstr ""

#: src/ch11-08-printing.md:130
msgid "// helloworld 10 20\n"
msgstr ""

#: src/ch11-08-printing.md:134
msgid ""
"It is also possible to implement the `Display` trait for the `Point` struct "
"using these macros, as shown here:"
msgstr ""

#: src/ch11-08-printing.md:150
msgid "\"Point ({x}, {y})\""
msgstr ""

#: src/ch11-08-printing.md:160
msgid ""
"Printing complex data types this way might not be ideal as it requires "
"additional steps to use the `print!` and `println!` macros. If you need to "
"print complex data types, especially when debugging, use the `Debug` trait "
"described below instead."
msgstr ""

#: src/ch11-08-printing.md:162
msgid "Print Debug Traces"
msgstr ""

#: src/ch11-08-printing.md:164
msgid ""
"Cairo provides the `Debug` trait, which can be derived to print the value of "
"variables when debugging. Simply add `:?` within the curly brackets `{}` "
"placeholders in a `print!` or `println!` macro string."
msgstr ""

#: src/ch11-08-printing.md:166
msgid ""
"This trait is very useful and is implemented by default for basic data "
"types. It can also be simply derived for complex data types using the "
"`#[derive(Debug)]` attribute, as long as all types they contain implement "
"it. This eliminates the need to manually implement extra code to print "
"complex data types."
msgstr ""

#: src/ch11-08-printing.md:168
msgid ""
"Note that `assert_xx!` macros used in tests require the provided values to "
"implement the `Debug` trait, as they also print the result in case of "
"assertion failure."
msgstr ""

#: src/ch11-08-printing.md:170
msgid ""
"For more details about the `Debug` trait and its usage for printing values "
"when debugging, please refer to the [Derivable "
"Traits](./appendix-03-derivable-traits.md#debug-trait-for-printing-and-debugging) "
"appendix."
msgstr ""

#: src/appendix-00.md
msgid ""
"The following sections contain reference material you may find useful in "
"your Cairo journey."
msgstr ""

#: src/appendix-01-keywords.md:1
msgid "Appendix A - Keywords"
msgstr ""

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or future "
"use by the Cairo language."
msgstr ""

#: src/appendix-01-keywords.md:5
msgid "There are three keyword categories:"
msgstr ""

#: src/appendix-01-keywords.md:7
msgid "strict"
msgstr ""

#: src/appendix-01-keywords.md:8
msgid "loose"
msgstr ""

#: src/appendix-01-keywords.md:9
msgid "reserved"
msgstr ""

#: src/appendix-01-keywords.md:11
msgid ""
"There is a fourth category, which are functions from the core library. While "
"their names are not reserved, they are not recommended to be used as names "
"of any items to follow good practices."
msgstr ""

#: src/appendix-01-keywords.md:16
msgid "Strict keywords"
msgstr ""

#: src/appendix-01-keywords.md:18
msgid ""
"These keywords can only be used in their correct contexts. They cannot be "
"used as names of any items."
msgstr ""

#: src/appendix-01-keywords.md:21
msgid "`as` - Rename import"
msgstr ""

#: src/appendix-01-keywords.md:22
msgid "`break` - Exit a loop immediately"
msgstr ""

#: src/appendix-01-keywords.md:23
msgid "`const` - Define constant items"
msgstr ""

#: src/appendix-01-keywords.md:24
msgid "`continue` - Continue to the next loop iteration"
msgstr ""

#: src/appendix-01-keywords.md:25
msgid "`else` - Fallback for `if` and `if let` control flow constructs"
msgstr ""

#: src/appendix-01-keywords.md:26
msgid "`enum` - Define an enumeration"
msgstr ""

#: src/appendix-01-keywords.md:27
msgid ""
"`extern` - Function defined at the compiler level that can be compiled to "
"CASM"
msgstr ""

#: src/appendix-01-keywords.md:28
msgid "`false` - Boolean false literal"
msgstr ""

#: src/appendix-01-keywords.md:29
msgid "`fn` - Define a function"
msgstr ""

#: src/appendix-01-keywords.md:30
msgid "`if` - Branch based on the result of a conditional expression"
msgstr ""

#: src/appendix-01-keywords.md:31
msgid "`impl` - Implement inherent or trait functionality"
msgstr ""

#: src/appendix-01-keywords.md:32
msgid ""
"`implicits` - Special kind of function parameters that are required to "
"perform certain actions"
msgstr ""

#: src/appendix-01-keywords.md:33
msgid "`let` - Bind a variable"
msgstr ""

#: src/appendix-01-keywords.md:34
msgid "`loop` - Loop unconditionally"
msgstr ""

#: src/appendix-01-keywords.md:35
msgid "`match` - Match a value to patterns"
msgstr ""

#: src/appendix-01-keywords.md:36
msgid "`mod` - Define a module"
msgstr ""

#: src/appendix-01-keywords.md:37
msgid "`mut` - Denote variable mutability"
msgstr ""

#: src/appendix-01-keywords.md:38
msgid ""
"`nopanic` - Functions marked with this notation mean that the function will "
"never panic."
msgstr ""

#: src/appendix-01-keywords.md:39
msgid "`of` - Implement a trait"
msgstr ""

#: src/appendix-01-keywords.md:40
msgid ""
"`pub` - Denote public visibility in items, such as struct and struct fields, "
"enums, consts, traits and impl blocks, or modules"
msgstr ""

#: src/appendix-01-keywords.md:41
msgid "`ref` - Parameter passed implicitly returned at the end of a function"
msgstr ""

#: src/appendix-01-keywords.md:42
msgid "`return` - Return from function"
msgstr ""

#: src/appendix-01-keywords.md:43
msgid "`struct` - Define a structure"
msgstr ""

#: src/appendix-01-keywords.md:44
msgid "`trait` - Define a trait"
msgstr ""

#: src/appendix-01-keywords.md:45
msgid "`true` - Boolean true literal"
msgstr ""

#: src/appendix-01-keywords.md:46
msgid "`type` - Define a type alias"
msgstr ""

#: src/appendix-01-keywords.md:47
msgid "`use` - Bring symbols into scope"
msgstr ""

#: src/appendix-01-keywords.md:48
msgid "`while` - loop conditionally based on the result of an expression"
msgstr ""

#: src/appendix-01-keywords.md:52
msgid "Loose Keywords"
msgstr ""

#: src/appendix-01-keywords.md:54
msgid ""
"These keywords are associated with a specific behaviour, but can also be "
"used to define items."
msgstr ""

#: src/appendix-01-keywords.md:56
msgid "`self` - Method subject"
msgstr ""

#: src/appendix-01-keywords.md:57
msgid "`super` - Parent module of the current module"
msgstr ""

#: src/appendix-01-keywords.md:61
msgid "Reserved Keywords"
msgstr ""

#: src/appendix-01-keywords.md:63
msgid ""
"These keywords aren't used yet, but they are reserved for future use. For "
"now, it is possible to use them to define items, although it is highly "
"recommended not to do so. The reasoning behind this recommendation is to "
"make current programs forward compatible with future versions of Cairo by "
"forbidding them to use these keywords."
msgstr ""

#: src/appendix-01-keywords.md:68
msgid "`Self`"
msgstr ""

#: src/appendix-01-keywords.md:69
msgid "`do`"
msgstr ""

#: src/appendix-01-keywords.md:70
msgid "`dyn`"
msgstr ""

#: src/appendix-01-keywords.md:71
msgid "`for`"
msgstr ""

#: src/appendix-01-keywords.md:72
msgid "`hint`"
msgstr ""

#: src/appendix-01-keywords.md:73
msgid "`in`"
msgstr ""

#: src/appendix-01-keywords.md:74
msgid "`macro`"
msgstr ""

#: src/appendix-01-keywords.md:75
msgid "`move`"
msgstr ""

#: src/appendix-01-keywords.md:76
msgid "`static_assert`"
msgstr ""

#: src/appendix-01-keywords.md:77
msgid "`static`"
msgstr ""

#: src/appendix-01-keywords.md:78
msgid "`try`"
msgstr ""

#: src/appendix-01-keywords.md:79
msgid "`typeof`"
msgstr ""

#: src/appendix-01-keywords.md:80
msgid "`unsafe`"
msgstr ""

#: src/appendix-01-keywords.md:81
msgid "`where`"
msgstr ""

#: src/appendix-01-keywords.md:82
msgid "`with`"
msgstr ""

#: src/appendix-01-keywords.md:83
msgid "`yield`"
msgstr ""

#: src/appendix-01-keywords.md:87
msgid "Built-in Functions"
msgstr ""

#: src/appendix-01-keywords.md:89
msgid ""
"The Cairo programming language provides several specific functions that "
"serve a special purpose. We will not cover all of them in this book, but "
"using the names of these functions as names of other items is not "
"recommended."
msgstr ""

#: src/appendix-01-keywords.md:91
msgid ""
"`assert` - This function checks a boolean expression, and if it evaluates to "
"false, it triggers the panic function."
msgstr ""

#: src/appendix-01-keywords.md:92
msgid ""
"`panic` - This function acknowledges the occurrence of an error and "
"terminates the program."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:1
msgid "Appendix B - Operators and Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:3
msgid ""
"This appendix contains a glossary of Cairo's syntax, including operators and "
"other symbols that appear by themselves or in the context of paths, "
"generics, macros, attributes, comments, tuples, and brackets."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:5
msgid "Operators"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:9
msgid "Operator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:9
#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:66
#: src/appendix-02-operators-and-symbols.md:76
#: src/appendix-02-operators-and-symbols.md:89
#: src/appendix-02-operators-and-symbols.md:120
#: src/appendix-02-operators-and-symbols.md:146
#: src/appendix-02-operators-and-symbols.md:154
#: src/appendix-02-operators-and-symbols.md:168
msgid "Explanation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:9
msgid "Overloadable?"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "`!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "`!expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "Logical complement"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "`Not`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:12
msgid "`~`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:12
msgid "`~expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:12
msgid "Bitwise NOT"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:12
msgid "`BitNot`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`expr != expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "Non-equality comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
#: src/appendix-02-operators-and-symbols.md:38
msgid "`PartialEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`%`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`expr % expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "Arithmetic remainder"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`Rem`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`%=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`var %= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "Arithmetic remainder and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`RemEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`expr & expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "Bitwise AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`BitAnd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`&&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`expr && expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "Short-circuiting logical AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
#: src/appendix-02-operators-and-symbols.md:21
msgid "`*`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`expr * expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "Arithmetic multiplication"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`Mul`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`*=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`var *= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "Arithmetic multiplication and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`MulEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`@`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`@var`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "Snapshot"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`*var`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "Desnap"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "`+`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "`expr + expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "Arithmetic addition"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "`Add`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`+=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`var += expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "Arithmetic addition and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`AddEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`,`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`expr, expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "Argument and element separator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
#: src/appendix-02-operators-and-symbols.md:26
msgid "`-`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`-expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "Arithmetic negation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`Neg`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`expr - expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "Arithmetic subtraction"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`Sub`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`-=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`var -= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "Arithmetic subtraction and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`SubEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`->`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`fn(...) -> type`, <code>\\|...\\| -> type</code>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "Function and closure return type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`.`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`expr.ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "Member access"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`/`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`expr / expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "Arithmetic division"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`Div`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`/=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`var /= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "Arithmetic division and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`DivEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
#: src/appendix-02-operators-and-symbols.md:33
msgid "`:`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`pat: type`, `ident: type`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "Constraints"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "`ident: expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "Struct field initializer"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "`;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "`expr;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "Statement and item terminator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "`<`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "`expr < expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "Less than comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
#: src/appendix-02-operators-and-symbols.md:36
#: src/appendix-02-operators-and-symbols.md:40
#: src/appendix-02-operators-and-symbols.md:41
msgid "`PartialOrd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`<=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`expr <= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "Less than or equal to comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`var = expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "Assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "`==`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "`expr == expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "Equality comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`=>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`pat => expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "Part of match arm syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "`>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "`expr > expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "Greater than comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`>=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`expr >= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "Greater than or equal to comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`^`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`expr ^ expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "Bitwise exclusive OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`BitXor`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "<code>\\|</code>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "<code>expr \\| expr</code>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "Bitwise OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`BitOr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "<code>\\|\\|</code>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "<code>expr \\|\\| expr</code>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "Short-circuiting logical OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "`?`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "expr?"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "Error propagation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
msgid "<span class=\"caption\">Table B-1: Operators</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:49
msgid "Non Operator Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:51
msgid ""
"The following list contains all symbols that are not used as operators; that "
"is, they do not have the same behavior as a function or method call."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:53
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:66
#: src/appendix-02-operators-and-symbols.md:76
#: src/appendix-02-operators-and-symbols.md:89
#: src/appendix-02-operators-and-symbols.md:120
#: src/appendix-02-operators-and-symbols.md:146
#: src/appendix-02-operators-and-symbols.md:154
msgid "Symbol"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:57
msgid "`..._u8`, `..._usize`, `..._bool`, etc."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:57
msgid "Numeric literal of specific type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:58
msgid "`\"...\"`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:58
msgid "String literal"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "`'...'`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "Short string, 31 ASCII characters maximum"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:60
msgid "`_`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:60
msgid "“Ignored” pattern binding"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:62
msgid "<span class=\"caption\">Table B-2: Stand-Alone Syntax</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:64
msgid ""
"Table B-3 shows symbols that are used within the context of a module "
"hierarchy path to access an item."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:68
msgid "`ident::ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:68
msgid "Namespace path"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid "`super::path`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid "Path relative to the parent of the current module"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:70
msgid "`trait::method(...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:70
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:72
msgid "<span class=\"caption\">Table B-3: Path-Related Syntax</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:74
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:78
msgid "`path<...>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:78
msgid "Specifies parameters to generic type in a type (e.g., `Array<u8>`)"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
msgid "`path::<...>`, `method::<...>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
msgid ""
"Specifies parameters to a generic type, function, or method in an "
"expression; often referred to as turbofish"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:80
msgid "`fn ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:80
msgid "Define generic function"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "`struct ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "Define generic structure"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "`enum ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "Define generic enumeration"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:83
msgid "`impl<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:83
msgid "Define generic implementation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:85
msgid "<span class=\"caption\">Table B-4: Generics</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:87
msgid ""
"Table B-5 shows symbols that appear in the context of specifying attributes "
"on an item."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:91
msgid "`#[derive(...)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:91
msgid "Automatically implements a trait for a type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:92
msgid "`#[inline]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:92
msgid "Hint to the compiler to allow inlining of annotated function"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:93
msgid "`#[inline(always)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:93
msgid "Hint to the compiler to systematically inline annotated function"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:94
msgid "`#[inline(never)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:94
msgid "Hint to the compiler to never inline annotated function"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:95
msgid "`#[must_use]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:95
msgid ""
"Hint to the compiler that the return value of a function or a specific "
"returned type must be used"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:96
msgid "`#[generate_trait]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:96
msgid "Automatically generates a trait for an impl"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:97
msgid "`#[available_gas(...)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:97
msgid "Set the maximum amount of gas available to execute a function"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:98
msgid "`#[panic_with('...', wrapper_name)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:98
msgid ""
"Creates a wrapper for the annotated function which will panic if the "
"function returns `None` or `Err`, with the given data as the panic error"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:99
msgid "`#[test]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:99
msgid "Describe a function as a test function"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:100
msgid "`#[cfg(...)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:100
msgid ""
"Configuration attribute, especially used to configure a `tests` module with "
"`#[cfg(test)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:101
msgid "`#[should_panic]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:101
msgid "Specifies that a test function should necessarily panic"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:102
msgid "`#[starknet::contract]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:102
msgid "Defines a Starknet smart contract"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:103
msgid "`#[starknet::interface]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:103
msgid "Defines a Starknet interface"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:104
msgid "`#[starknet::component]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:104
msgid "Defines a Starknet component"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:105
msgid "`#[starknet::embeddable]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:105
msgid ""
"Defines an isolated embeddable implementation that can be injected in any "
"smart contract"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:106
msgid "`#[embeddable_as(...)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:106
msgid "Defines an embeddable implementation inside a component"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:107
msgid "`#[storage]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:107
msgid "Defines the storage of a smart contract"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
msgid "`#[event]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
msgid "Defines an event in a smart contract"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:109
msgid "`#[constructor]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:109
msgid "Defines the constructor in a smart contract"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "`#[abi(embed_v0)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid ""
"Defines an implementation of a trait, exposing the functions of the impl as "
"entrypoints of a contract"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid "`#[abi(per_item)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid ""
"Allows individual definition of the entrypoint type of functions inside an "
"impl"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
msgid "`#[external(v0)]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
msgid "Defines an external function when `#[abi(per_item)]` is used"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid "`#[flat]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid ""
"Defines a enum variant of the `Event` enum that is not nested, ignoring the "
"variant name in the serialization process, very useful for composability "
"when using Starknet components"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:114
msgid "`#[key]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:114
msgid ""
"Defines an indexed `Event` enum field, allowing for more efficient queries "
"and filtering of events"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:116
msgid "<span class=\"caption\">Table B-5: Attributes</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:118
msgid ""
"Table B-6 shows symbols that appear in the context of calling or defining "
"macros."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "`print!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "Inline printing"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:123
msgid "`println!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:123
msgid "Print on a new line"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:124
msgid "`consteval_int!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:124
msgid "Declare a constant that is the result of a computation of integers"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:125
msgid "`array!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:125
msgid "Instantiate and fill arrays"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:126
msgid "`panic!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:126
msgid ""
"Calls `panic` function and allows to provide a message error longer than 31 "
"characters"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:127
msgid "`assert!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:127
msgid "Evaluates a Boolean and panics if `false`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:128
msgid "`assert_eq!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:128
msgid "Evaluates an equality, and panics if not equal"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:129
msgid "`assert_ne!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:129
msgid "Evaluates an equality, and panics if equal"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:130
msgid "`assert_lt!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:130
msgid "Evaluates a comparison, and panics if greater or equal"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:131
msgid "`assert_le!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:131
msgid "Evaluates a comparison, and panics if greater"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:132
msgid "`assert_gt!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:132
msgid "Evaluates a comparison, and panics if lower or equal"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:133
msgid "`assert_ge!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:133
msgid "Evaluates a comparison, and panics if lower"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:134
msgid "`format!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:134
msgid "Format a string and returns a `ByteArray` with the contents"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:135
msgid "`write!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:135
msgid "Write formatted strings in a formatter"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:136
msgid "`writeln!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:136
msgid "Write formatted strings in a formatter on a new line"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:137
msgid "`get_dep_component!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:137
msgid ""
"Returns the requested component state from a snapshot of the state inside a "
"component"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:138
msgid "`get_dep_component_mut!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:138
msgid ""
"Returns the requested component state from a reference of the state inside a "
"component"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:139
msgid "`component!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:139
msgid "Macro used in Starknet contracts to embed a component inside a contract"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:142
msgid "<span class=\"caption\">Table B-6: Macros</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:144
msgid "Table B-7 shows symbols that create comments."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:148
msgid "`//`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:148
msgid "Line comment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:150
msgid "<span class=\"caption\">Table B-7: Comments</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:152
msgid "Table B-8 shows symbols that appear in the context of using tuples."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:156
msgid "`()`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:156
msgid "Empty tuple (aka unit), both literal and type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:157
msgid "`(expr)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:157
msgid "Parenthesized expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:158
msgid "`(expr,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:158
msgid "Single-element tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:159
msgid "`(type,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:159
msgid "Single-element tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:160
msgid "`(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:160
msgid "Tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:161
msgid "`(type, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:161
msgid "Tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:162
msgid "`expr(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:162
msgid ""
"Function call expression; also used to initialize tuple `struct`s and tuple "
"`enum` variants"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:164
msgid "<span class=\"caption\">Table B-8: Tuples</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:166
msgid "Table B-9 shows the contexts in which curly braces are used."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:168
msgid "Context"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:170
msgid "`{...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:170
msgid "Block expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:171
msgid "`Type {...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:171
msgid "`struct` literal"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:173
msgid "<span class=\"caption\">Table B-9: Curly Braces</span>"
msgstr ""

#: src/appendix-03-derivable-traits.md:1
msgid "Appendix C - Derivable Traits"
msgstr ""

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which "
"you can apply to a struct or enum definition. The `derive` attribute "
"generates code to implement a default trait on the type you’ve annotated "
"with the `derive` syntax."
msgstr ""

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the "
"traits in the standard library compatible with the `derive` attribute."
msgstr ""

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that "
"can be implemented on your types using `derive`. Other traits defined in the "
"standard library don’t have sensible default behavior, so it’s up to you to "
"implement them in a way that makes sense for what you’re trying to "
"accomplish."
msgstr ""

#: src/appendix-03-derivable-traits.md:9
msgid "Drop and Destruct"
msgstr ""

#: src/appendix-03-derivable-traits.md:11
msgid ""
"When moving out of scope, variables need to be moved first. This is where "
"the `Drop` trait intervenes. You can find more details about its usage "
"[here](ch04-01-what-is-ownership.md#no-op-destruction-the-drop-trait)."
msgstr ""

#: src/appendix-03-derivable-traits.md:13
msgid ""
"Moreover, Dictionaries need to be squashed before going out of scope. "
"Calling the `squash` method on each of them manually can quickly become "
"redundant. `Destruct` trait allows Dictionaries to be automatically squashed "
"when they get out of scope. You can also find more information about "
"`Destruct` "
"[here](ch04-01-what-is-ownership.md#destruction-with-a-side-effect-the-destruct-trait)."
msgstr ""

#: src/appendix-03-derivable-traits.md:15
msgid "`Clone` and `Copy` for Duplicating Values"
msgstr ""

#: src/appendix-03-derivable-traits.md:17
msgid ""
"The `Clone` trait provides the functionality to explicitly create a deep "
"copy of a value."
msgstr ""

#: src/appendix-03-derivable-traits.md:19
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone "
"on each of the type's components. This means all the fields or values in the "
"type must also implement `Clone` to derive `Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:21
msgid "Here is a simple example:"
msgstr ""

#: src/appendix-03-derivable-traits.md:32
#: src/appendix-03-derivable-traits.md:50
msgid "\"Not equal\""
msgstr ""

#: src/appendix-03-derivable-traits.md:36
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy` "
"on any type whose parts all implement `Copy`."
msgstr ""

#: src/appendix-03-derivable-traits.md:49
msgid "// Copy Trait prevents first_struct from moving into second_struct\n"
msgstr ""

#: src/appendix-03-derivable-traits.md:51
msgid "\"Not Equal\""
msgstr ""

#: src/appendix-03-derivable-traits.md:55
msgid "`Debug` for Printing and Debugging"
msgstr ""

#: src/appendix-03-derivable-traits.md:57
msgid ""
"The `Debug` trait enables debug formatting in format strings, which you "
"indicate by adding `:?` within `{}` placeholders."
msgstr ""

#: src/appendix-03-derivable-traits.md:59
msgid ""
"It allows you to print instances of a type for debugging purposes, so you "
"and other programmers using this type can inspect an instance at a "
"particular point in a program’s execution."
msgstr ""

#: src/appendix-03-derivable-traits.md:61
msgid ""
"For example, if you want to print the value of a variable of type `Point`, "
"you can do it as follows:"
msgstr ""

#: src/appendix-03-derivable-traits.md:72
msgid "\"{:?}\""
msgstr ""

#: src/appendix-03-derivable-traits.md:81
msgid ""
"The `Debug` trait is required, for example, when using the `assert_xx!` "
"macros in tests. Theses macros print the values of instances given as "
"arguments if the equality or comparison assertion fails so programmers can "
"see why the two instances weren’t equal."
msgstr ""

#: src/appendix-03-derivable-traits.md:83
msgid "`Default` for Default Values"
msgstr ""

#: src/appendix-03-derivable-traits.md:85
msgid ""
"The `Default` trait allows creation of a default value of a type. The most "
"common default value is zero. All primitive types in the standard library "
"implement `Default`."
msgstr ""

#: src/appendix-03-derivable-traits.md:87
msgid ""
"If you want to derive `Default` on a composite type, each of its elements "
"must already implement `Default`. If you have an [`enum`](ch06-01-enums.md) "
"type, you must declare its default value by using the `#[default]` attribute "
"on one of its variants."
msgstr ""

#: src/appendix-03-derivable-traits.md:89
msgid "An example:"
msgstr ""

#: src/appendix-03-derivable-traits.md:108
msgid "\"item1 mismatch\""
msgstr ""

#: src/appendix-03-derivable-traits.md:109
msgid "\"item2 mismatch\""
msgstr ""

#: src/appendix-03-derivable-traits.md:112
msgid "\"case mismatch\""
msgstr ""

#: src/appendix-03-derivable-traits.md:116
msgid "`PartialEq` for Equality Comparisons"
msgstr ""

#: src/appendix-03-derivable-traits.md:118
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for "
"equality, thereby enabling the `==` and `!=` operators."
msgstr ""

#: src/appendix-03-derivable-traits.md:120
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all "
"their fields are equal; they are not equal if any field is different. When "
"derived for enums, each variant is equal to itself and not equal to the "
"other variants."
msgstr ""

#: src/appendix-03-derivable-traits.md:122
msgid ""
"You can write your own implementation of the `PartialEq` trait for your "
"type, if you can't derive it or if you want to implement your custom rules. "
"In the following example, we write an implementation for `PartialEq` in "
"which we consider that two rectangles are equal if they have the same area:"
msgstr ""

#: src/appendix-03-derivable-traits.md:145
msgid "\"Are rect1 and rect2 equal? {}\""
msgstr ""

#: src/appendix-03-derivable-traits.md:149
msgid ""
"The `PartialEq` trait is required when using the `assert_eq!` macro in "
"tests, which needs to be able to compare two instances of a type for "
"equality."
msgstr ""

#: src/appendix-03-derivable-traits.md:162
msgid "\"Structs are different\""
msgstr ""

#: src/appendix-03-derivable-traits.md:166
msgid "Serializing with `Serde`"
msgstr ""

#: src/appendix-03-derivable-traits.md:168
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` "
"functions for data structures defined in your crate. It allows you to "
"transform your structure into an array (or the opposite)."
msgstr ""

#: src/appendix-03-derivable-traits.md:170
msgid ""
"**[Serialization](https://en.wikipedia.org/wiki/Serialization)** is a "
"process of transforming data structures into a format that can be easily "
"stored or transmitted. Let's say you are running a program and would like to "
"persist its state to be able to resume it later. To do this, you could take "
"each of the objects your program is using and save their information, for "
"example in a file. This is a simplified version of serialization. Now if you "
"want to resume your program with this saved state, you would perform "
"**deserialization**, which means loading the state of the objects from the "
"saved source."
msgstr ""

#: src/appendix-03-derivable-traits.md:172
msgid "For example:"
msgstr ""

#: src/appendix-03-derivable-traits.md:190
msgid "If you run the `main` function, the output will be:"
msgstr ""

#: src/appendix-03-derivable-traits.md:196
msgid ""
"We can see here that our struct `A` has been serialized into the output "
"array. Note that the `serialize` function takes as argument a snapshot of "
"the type you want to convert into an array. This is why deriving `Drop` for "
"`A` is required here, as the `main` function keeps ownership of the "
"`first_struct` struct."
msgstr ""

#: src/appendix-03-derivable-traits.md:198
msgid ""
"Also, we can use the `deserialize` function to convert the serialized array "
"back into our `A` struct."
msgstr ""

#: src/appendix-03-derivable-traits.md:218
msgid ""
"Here we are converting a serialized array span back to the struct `A`. "
"`deserialize` returns an `Option` so we need to unwrap it. When using "
"`deserialize` we also need to specify the type we want to deserialize into."
msgstr ""

#: src/appendix-03-derivable-traits.md:220
msgid "Hashing with `Hash`"
msgstr ""

#: src/appendix-03-derivable-traits.md:222
msgid ""
"It is possible to derive the `Hash` trait on structs and enums. This allows "
"them to be hashed easily using any available hash function. For a struct or "
"an enum to derive the `Hash` attribute, all fields or variants need to be "
"hashable themselves."
msgstr ""

#: src/appendix-03-derivable-traits.md:224
msgid ""
"You can refer to the [Hashes section](ch11-04-hash.md) to get more "
"information about how to hash complex data types."
msgstr ""

#: src/appendix-03-derivable-traits.md:226
msgid "Starknet Storage with `starknet::Store`"
msgstr ""

#: src/appendix-03-derivable-traits.md:228
msgid ""
"The `starknet::Store` trait is relevant only when building on "
"[Starknet](ch13-00-introduction-to-starknet-smart-contracts.md). It allows "
"for a type to be used in smart contract storage by automatically "
"implementing the necessary read and write functions."
msgstr ""

#: src/appendix-03-derivable-traits.md:230
msgid ""
"You can find detailed information about the inner workings of Starknet "
"storage in the [Contract storage section](ch14-01-contract-storage.md)."
msgstr ""

#: src/appendix-04-cairo-prelude.md:1
msgid "Appendix D - The Cairo Prelude"
msgstr ""

#: src/appendix-04-cairo-prelude.md:3
msgid "Prelude"
msgstr ""

#: src/appendix-04-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data "
"types, and traits that are automatically brought into scope of every module "
"in a Cairo crate without needing explicit import statements. Cairo's prelude "
"provides the basic building blocks developers need to start Cairo programs "
"and writing smart contracts."
msgstr ""

#: src/appendix-04-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the "
"_[lib.cairo](https://github.com/starkware-libs/cairo/blob/main/corelib/src/lib.cairo)_ "
"file of the corelib crate and contains Cairo's primitive data types, traits, "
"operators, and utility functions. This includes:"
msgstr ""

#: src/appendix-04-cairo-prelude.md:15
msgid "Data types: integers, bools, arrays, dicts, etc."
msgstr ""

#: src/appendix-04-cairo-prelude.md:16
msgid ""
"Traits: behaviors for arithmetic, comparison, and serialization operations"
msgstr ""

#: src/appendix-04-cairo-prelude.md:17
msgid "Operators: arithmetic, logical, bitwise"
msgstr ""

#: src/appendix-04-cairo-prelude.md:18
msgid "Utility functions - helpers for arrays, maps, boxing, etc."
msgstr ""

#: src/appendix-04-cairo-prelude.md:20
msgid ""
"The core library prelude delivers the fundamental programming constructs and "
"operations needed for basic Cairo programs, without requiring the explicit "
"import of elements. Since the core library prelude is automatically "
"imported, its contents are available for use in any Cairo crate without "
"explicit imports. This prevents repetition and provides a better devX. This "
"is what allows you to use `ArrayTrait::append()` or the `Default` trait "
"without bringing them explicitly into scope."
msgstr ""

#: src/appendix-04-cairo-prelude.md:28
msgid ""
"You can choose which prelude to use. For example, adding `edition = "
"\"2023_11\"` in the _Scarb.toml_ configuration file will load the prelude "
"from November 2023. Note that when you create a new project using `scarb "
"new` command, the _Scarb.toml_ file will automatically include `edition = "
"\"2023_11\"`."
msgstr ""

#: src/appendix-04-cairo-prelude.md:30
msgid "The compiler currently exposes 2 different versions of the prelude:"
msgstr ""

#: src/appendix-04-cairo-prelude.md:32
msgid ""
"A general version, with a lot of traits that are made available, "
"corresponding to `edition = \"2023_01\"`."
msgstr ""

#: src/appendix-04-cairo-prelude.md:33
msgid ""
"A restricted version, including the most essential traits needed for general "
"Cairo programming, corresponding to `edition = 2023_11`."
msgstr ""

#: src/appendix-05-common-error-messages.md:1
msgid "Appendix E - Common Error Messages"
msgstr ""

#: src/appendix-05-common-error-messages.md:3
msgid ""
"You might encounter error messages when writing Cairo code. Some of them "
"occur very frequently, which is why we will be listing the most common error "
"messages in this appendix to help you resolve common issues."
msgstr ""

#: src/appendix-05-common-error-messages.md:5
msgid ""
"`Variable not dropped.`: this error message means that you are trying to "
"make a variable with a type that do not implement the `Drop` trait go out of "
"scope, withtout destroying it. Make sure that variables that need to be "
"dropped at the end of the execution of a function implement the `Drop` trait "
"or the `Destruct` trait. See "
"[Ownership](ch04-01-what-is-ownership.md#destroying-values---example-with-feltdict) "
"section."
msgstr ""

#: src/appendix-05-common-error-messages.md:7
msgid ""
"`Variable was previously moved.`: this error message means that you are "
"trying to use a variable whose ownership has already been transferred to "
"another function. When a variable doesn't implement the `Copy` trait, it is "
"passed by value to functions, and ownership of the variable is transferred "
"to the function. Such a variable cannot be used anymore in the current "
"context after its ownership has been transferred. It is often useful to use "
"the `clone` method in this situation."
msgstr ""

#: src/appendix-05-common-error-messages.md:9
msgid ""
"`error: Trait has no implementation in context: "
"core::fmt::Display::<package_name::struct_name>`: this error message is "
"encountered if you try to print an instance of a custom data type with `{}` "
"placeholders in a `print!` or `println!` macro. To mitigate this issue, you "
"need to either manually implement the `Display` trait for your type, or use "
"the `Debug` trait by applying `derive(Debug)` to your type, allowing to "
"print your instance by adding `:?` in `{}` placeholders."
msgstr ""

#: src/appendix-05-common-error-messages.md:11
msgid ""
"`Got an exception while executing a hint: Hint Error: Failed to deserialize "
"param #x.`: this error means that the execution failed because an entrypoint "
"was called without the expected arguments. Make sure that the arguments you "
"provide when calling an entrypoint are correct. There is a classic issue "
"with `u256` variables, which are actually structs of 2 `u128`. Therefore, "
"when calling a function that takes a `u256` as argument, you need to pass 2 "
"values."
msgstr ""

#: src/appendix-05-common-error-messages.md:13
msgid ""
"`Item path::item is not visible in this context.`: this error message lets "
"us know that the path to bring an item into scope is correct, but there is a "
"vibility issue. In cairo, all items are private to parent modules by "
"default. To resolve this issue, make sure that all the modules on the path "
"to items and items themselves are declared with `pub(crate)` or `pub` to "
"have access to them."
msgstr ""

#: src/appendix-05-common-error-messages.md:15
msgid ""
"`Identifier not found.`: this error message is a bit aspecific but might "
"indicate that:"
msgstr ""

#: src/appendix-05-common-error-messages.md:16
msgid ""
"A variable is being used before it has been declared. Make sure to declare "
"variables with the `let` keyword."
msgstr ""

#: src/appendix-05-common-error-messages.md:17
msgid ""
"The path to bring an item into scope is wrongly defined. Make sure to use "
"valid paths."
msgstr ""

#: src/appendix-05-common-error-messages.md:19
msgid "Starknet Components Related Error Messages"
msgstr ""

#: src/appendix-05-common-error-messages.md:21
msgid ""
"You might encounter some errors when trying to implement components. "
"Unfortunately, some of them lack meaningful error messages to help debug. "
"This section aims to provide you with some pointers to help you debug your "
"code."
msgstr ""

#: src/appendix-05-common-error-messages.md:25
msgid ""
"`Trait not found. Not a trait.`: this error can occur when you're not "
"importing the component's impl block correctly in your contract. Make sure "
"to respect the following syntax:"
msgstr ""

#: src/appendix-05-common-error-messages.md:33
msgid ""
"`Plugin diagnostic: name is not a substorage member in the contract's "
"Storage. Consider adding to Storage: (...)`: the compiler helps you a lot "
"debugging this by giving you recommendation on the action to take. "
"Basically, you forgot to add the component's storage to your contract's "
"storage. Make sure to add the path to the component's storage annotated with "
"the `#[substorage(v0)]` attribute to your contract's storage."
msgstr ""

#: src/appendix-05-common-error-messages.md:35
msgid ""
"`Plugin diagnostic: name is not a nested event in the contract's Event enum. "
"Consider adding to the Event enum:` similar to the previous error, the "
"compiler tells you that you forgot to add the component's events to your "
"contract's events. Make sure to add the path to the component's events to "
"your contract's events."
msgstr ""

#: src/appendix-06-useful-development-tools.md:1
msgid "Appendix F - Useful Development Tools"
msgstr ""

#: src/appendix-06-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo "
"project provides. We’ll look at automatic formatting, quick ways to apply "
"warning fixes, a linter, and integrating with IDEs."
msgstr ""

#: src/appendix-06-useful-development-tools.md:7
msgid "Automatic Formatting with `scarb fmt`"
msgstr ""

#: src/appendix-06-useful-development-tools.md:9
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command. If you're "
"using the Cairo binaries directly, you can run `cairo-format` instead. Many "
"collaborative projects use `scarb fmt` to prevent arguments about which "
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""

#: src/appendix-06-useful-development-tools.md:14
msgid ""
"To format any Cairo project, enter the following inside the project "
"directory:"
msgstr ""

#: src/appendix-06-useful-development-tools.md:20
msgid "IDE Integration Using `cairo-language-server`"
msgstr ""

#: src/appendix-06-useful-development-tools.md:22
msgid ""
"To help IDE integration, the Cairo community recommends using the "
"[`cairo-language-server`](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-language-server)<!-- "
"ignore -->. This tool is a set of compiler-centric utilities that speaks the "
"[Language Server Protocol](http://langserver.org/)<!--\n"
"ignore -->, which is a specification for IDEs and programming languages to "
"communicate with each other. Different clients can use "
"`cairo-language-server`, such as [the Cairo extension for Visual Studio "
"Code](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)."
msgstr ""

#: src/appendix-06-useful-development-tools.md:32
msgid ""
"Visit the `vscode-cairo` "
"[page](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)<!-- "
"ignore --> to install it on VSCode. You will get abilities such as "
"autocompletion, jump to definition, and inline errors."
msgstr ""

#: src/appendix-06-useful-development-tools.md:38
msgid ""
"Note: If you have Scarb installed, it should work out of the box with the "
"Cairo VSCode extension, without a manual installation of the language server."
msgstr ""

#: src/appendix-07-cairo-binaries.md:1
msgid "Appendix G - Installing the Cairo Binaries"
msgstr ""

#: src/appendix-07-cairo-binaries.md:3
msgid ""
"If you want to have access to the Cairo binaries, for anything that you "
"could not achieve by purely using Scarb you can install them by following "
"the instructions below."
msgstr ""

#: src/appendix-07-cairo-binaries.md:5
msgid "Prerequisites"
msgstr ""

#: src/appendix-07-cairo-binaries.md:7
msgid ""
"You will need to have [Rust](https://www.rust-lang.org) and "
"[Git](https://git-scm.com/) installed."
msgstr ""

#: src/appendix-07-cairo-binaries.md:9
msgid ""
"To install Rust, you first need the "
"[`rustup`](https://www.rust-lang.org/tools/install) tool. It allows you to "
"install Rust using the following command:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:11
msgid "# Install stable Rust\n"
msgstr ""

#: src/appendix-07-cairo-binaries.md:15
msgid ""
"Follow the link for information on how to install "
"[Git](https://git-scm.com/downloads)."
msgstr ""

#: src/appendix-07-cairo-binaries.md:17
msgid ""
"The next step is to install Cairo. We will download Cairo manually, using "
"Cairo repository or with an installation script. You’ll need an internet "
"connection for the download."
msgstr ""

#: src/appendix-07-cairo-binaries.md:19
msgid ""
"Installing Cairo with a Script "
"([Installer](https://github.com/franalgaba/cairo-installer) by "
"[Fran](https://github.com/franalgaba))"
msgstr ""

#: src/appendix-07-cairo-binaries.md:21
msgid "Install"
msgstr ""

#: src/appendix-07-cairo-binaries.md:23
msgid ""
"If you wish to install a specific release of Cairo rather than the latest "
"head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export "
"CAIRO_GIT_TAG=v2.5.1`)."
msgstr ""

#: src/appendix-07-cairo-binaries.md:29
msgid ""
"After installing, follow [these "
"instructions](#set-up-your-shell-environment-for-cairo) to set up your shell "
"environment."
msgstr ""

#: src/appendix-07-cairo-binaries.md:31
msgid "Update"
msgstr ""

#: src/appendix-07-cairo-binaries.md:33
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L "
"https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | "
"bash\n"
"```"
msgstr ""

#: src/appendix-07-cairo-binaries.md:38
msgid "Uninstall"
msgstr ""

#: src/appendix-07-cairo-binaries.md:40
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, "
"just remove it:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:46
msgid "then remove these three lines from .bashrc:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:49
msgid "\"$HOME/.cairo/target/release:$PATH\""
msgstr ""

#: src/appendix-07-cairo-binaries.md:52
msgid "and finally, restart your shell:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:58
msgid "Set Up your Shell Environment for Cairo"
msgstr ""

#: src/appendix-07-cairo-binaries.md:60
msgid ""
"Define environment variable `CAIRO_ROOT` to point to the path where Cairo "
"will store its data. `$HOME/.cairo` is the default. If you installed Cairo "
"via Git checkout, we recommend to set it to the same location as where you "
"cloned it."
msgstr ""

#: src/appendix-07-cairo-binaries.md:64
msgid "Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr ""

#: src/appendix-07-cairo-binaries.md:66
msgid ""
"The below setup should work for the vast majority of users for common use "
"cases."
msgstr ""

#: src/appendix-07-cairo-binaries.md:68
msgid "For **bash**:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:70
msgid ""
"Stock Bash startup files vary widely between distributions in which of them "
"source which, under what circumstances, in what order and what additional "
"configuration they perform. As such, the most reliable way to get Cairo in "
"all environments is to append Cairo configuration commands to both `.bashrc` "
"(for interactive shells) and the profile file that Bash would use (for login "
"shells)."
msgstr ""

#: src/appendix-07-cairo-binaries.md:76
msgid ""
"First, add the commands to `~/.bashrc` by running the following in your "
"terminal:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:79 src/appendix-07-cairo-binaries.md:89
#: src/appendix-07-cairo-binaries.md:95 src/appendix-07-cairo-binaries.md:102
msgid "'export CAIRO_ROOT=\"$HOME/.cairo\"'"
msgstr ""

#: src/appendix-07-cairo-binaries.md:80 src/appendix-07-cairo-binaries.md:90
#: src/appendix-07-cairo-binaries.md:96 src/appendix-07-cairo-binaries.md:103
msgid ""
"'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"'"
msgstr ""

#: src/appendix-07-cairo-binaries.md:83
msgid ""
"Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add "
"the commands there as well. If you have none of these, add them to "
"`~/.profile`."
msgstr ""

#: src/appendix-07-cairo-binaries.md:86
msgid "to add to `~/.profile`:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:93
msgid "to add to `~/.bash_profile`:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:99
msgid "For **Zsh**:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:106
msgid ""
"If you wish to get Cairo in non-interactive login shells as well, also add "
"the commands to `~/.zprofile` or `~/.zlogin`."
msgstr ""

#: src/appendix-07-cairo-binaries.md:108
msgid "For **Fish shell**:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:110
msgid "If you have Fish 3.2.0 or newer, execute this interactively:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:117
msgid "Otherwise, execute the snippet below:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:124
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which "
"provides alternative shell completions for many command line tools with an "
"IDE-like popup interface in the terminal window. (Note that their "
"completions are independent of Cairo's codebase so they might be slightly "
"out of sync for bleeding-edge interface changes.)"
msgstr ""

#: src/appendix-07-cairo-binaries.md:130
msgid "Restart your Shell"
msgstr ""

#: src/appendix-07-cairo-binaries.md:132
msgid "for the `PATH` changes to take effect."
msgstr ""

#: src/appendix-07-cairo-binaries.md:135
msgid "\"$SHELL\""
msgstr ""

#: src/appendix-07-cairo-binaries.md:138
msgid ""
"Installing Cairo Manually "
"([Guide](https://github.com/auditless/cairo-template) by "
"[Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""

#: src/appendix-07-cairo-binaries.md:140
msgid "Step 1: Install Cairo 1.0"
msgstr ""

#: src/appendix-07-cairo-binaries.md:142
msgid ""
"If you are using an x86 Linux system and can use the release binary, "
"download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""

#: src/appendix-07-cairo-binaries.md:144
msgid "For everyone else, we recommend compiling Cairo from source as follows:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:147
msgid "# Start by defining environment variable CAIRO_ROOT\n"
msgstr ""

#: src/appendix-07-cairo-binaries.md:148
msgid "\"${HOME}/.cairo\""
msgstr ""

#: src/appendix-07-cairo-binaries.md:149
msgid "# Create .cairo folder if it doesn't exist yet\n"
msgstr ""

#: src/appendix-07-cairo-binaries.md:152
msgid "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
msgstr ""

#: src/appendix-07-cairo-binaries.md:155
msgid ""
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the "
"compiler\n"
"# Fetch all tags (versions)\n"
msgstr ""

#: src/appendix-07-cairo-binaries.md:158
msgid "# View tags (you can also do this in the Cairo compiler repository)\n"
msgstr ""

#: src/appendix-07-cairo-binaries.md:160
msgid "# Checkout the version you want\n"
msgstr ""

#: src/appendix-07-cairo-binaries.md:163
msgid "# Generate release binaries\n"
msgstr ""

#: src/appendix-07-cairo-binaries.md:168
msgid "."
msgstr ""

#: src/appendix-07-cairo-binaries.md:170
msgid "**NOTE: Keeping Cairo up to date**"
msgstr ""

#: src/appendix-07-cairo-binaries.md:172
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to "
"do is pull the latest changes and rebuild as follows:"
msgstr ""

#: src/appendix-07-cairo-binaries.md:179
msgid "Step 2: Add Cairo 1.0 Executables to Your Path"
msgstr ""

#: src/appendix-07-cairo-binaries.md:182
msgid "\"$CAIRO_ROOT/target/release:$PATH\""
msgstr ""

#: src/appendix-07-cairo-binaries.md:185
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path "
"accordingly.**"
msgstr ""

#: src/appendix-07-cairo-binaries.md:187
msgid "Step 3: Setup Language Server"
msgstr ""

#: src/appendix-07-cairo-binaries.md:189
msgid "VS Code Extension"
msgstr ""

#: src/appendix-07-cairo-binaries.md:191
msgid ""
"If you have the previous Cairo 0 extension installed, you can "
"disable/uninstall it."
msgstr ""

#: src/appendix-07-cairo-binaries.md:192
msgid ""
"Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation. You can find the link to the extension "
"[here](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false), "
"or just search for \"Cairo 1.0\" in the VS Code marketplace."
msgstr ""

#: src/appendix-07-cairo-binaries.md:193
msgid ""
"The extension will work out of the box once you will have "
"[Scarb](./ch01-03-hello-scarb.md) installed."
msgstr ""

#: src/appendix-07-cairo-binaries.md:195
msgid "Cairo Language Server without Scarb"
msgstr ""

#: src/appendix-07-cairo-binaries.md:197
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language "
"Server with the compiler binary. From [Step "
"1](#installing-cairo-with-a-script-installer-by-fran), the "
"`cairo-language-server` binary should be built and executing this command "
"will copy its path into your clipboard."
msgstr ""

#: src/appendix-07-cairo-binaries.md:204
msgid ""
"Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting "
"the path."
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"All through the previous sections, you've mostly written programs with a "
"`main` entrypoint. In the coming sections, you will learn to write and "
"deploy Starknet contracts."
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"One of the key applications of the Cairo language is writing smart contracts "
"for the Starknet network. Starknet is a permissionless decentralized network "
"that leverages zk-STARKs technology for scalability. As a Layer 2 (L2) "
"scalability solution for Ethereum, Starknet aims to provide fast, secure, "
"and low-cost transactions. It operates as a validity rollup, commonly known "
"as a zero-knowledge rollup, and is built on top of the Cairo VM."
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Starknet contracts are programs specifically designed to run within the "
"Starknet OS. The Starknet OS is a Cairo program itself, which means that any "
"operation executed by the Starknet OS can be proven and succinctly verified. "
"Smart contracts can access Starknet's persistent state through the OS, "
"enabling them to read or modify variables in Starknet’s state, communicate "
"with other contracts, and interact seamlessly with the underlying Layer 1 "
"(L1) network."
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"If you want to learn more about the Starknet network itself, its "
"architecture and the tooling available, you should read the [Starknet "
"Book](https://book.starknet.io/). In this book, we will only focus on "
"writing smart contracts in Cairo."
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Scarb"
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Scarb facilitates smart contract development for Starknet. To enable this "
"feature, you'll need to make some configurations in your _Scarb.toml_ file "
"(see [Installation](./ch01-01-installation.md) for how to install Scarb)."
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"First, add the `starknet` dependency to your _Scarb.toml_ file. Next, enable "
"the Starknet contract compilation of the package by adding a "
"`[[target.starknet-contract]]` section. By default, specifying this target "
"will build a Sierra Contract Class file, which can be deployed on Starknet. "
"If you omit to specify the target, your package will compile but will not "
"produce an output that you can use with Starknet."
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Below is the minimal _Scarb.toml_ file required to compile a crate "
"containing Starknet contracts:"
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.6.3\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"To compile contracts defined in your package's dependencies, please refer to "
"the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-target.html#compiling-external-contracts)."
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Starknet Foundry"
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Starknet Foundry is a tool chain for Starknet smart contract development. It "
"supports many features, including writing and running tests with advanced "
"features, deploying contracts, interacting with the Starknet network, and "
"more."
msgstr ""

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"We'll describe Starknet Foundry in more detail in [Chapter "
"17](./ch17-02-testing-smart-contracts.md#testing-smart-contracts-with-starknet-foundry) "
"when discussing Starknet smart contract testing and security."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart contracts "
"are, what they are used for, and why blockchain developers would use Cairo "
"and Starknet. If you are already familiar with blockchain programming, feel "
"free to skip this chapter. The last part might still be interesting though."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:6
msgid "Smart Contracts"
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth "
"of Ethereum. Smart contracts are essentially programs deployed on a "
"blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that "
"are executed based on specific inputs. They primarily consist of two "
"components: storage and functions. Once deployed, users can interact with "
"smart contracts by initiating blockchain transactions containing execution "
"data (which function to call and with what input). Smart contracts can "
"modify and read the storage of the underlying blockchain. A smart contract "
"has its own address and is considered a blockchain account, meaning it can "
"hold tokens."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on "
"the blockchain. For example, on Ethereum and the [EVM-compatible "
"ecosystem](https://ethereum.org/en/developers/docs/evm/), the most commonly "
"used language is Solidity, while on Starknet, it is Cairo. The way the code "
"is compiled also differs based on the blockchain. On Ethereum, Solidity is "
"compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then "
"into Cairo Assembly (CASM)."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are "
"**permissionless**, meaning anyone can deploy a smart contract on the "
"network (within the context of a decentralized blockchain, of course). Smart "
"contracts are also **transparent**; the data stored by the smart contract is "
"accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write "
"smart contracts that use other smart contracts. Smart contracts can only "
"access and interact with data from the blockchain they are deployed on. They "
"require third-party software (called _oracles_) to access external data (the "
"price of a token for instance)."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, "
"it is required to know what the other contracts look like. Hence, Ethereum "
"developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to "
"build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs "
"(Non-Fungible Tokens) like `CryptoPunks` or `Everai`."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:18
msgid "Use Cases"
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:20
msgid ""
"There are many possible use cases for smart contracts. The only limits are "
"the technical constraints of the blockchain and the creativity of developers."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:22
msgid "DeFi"
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:24
msgid ""
"For now, the principal use case for smart contracts is similar to that of "
"Ethereum or Bitcoin, which is essentially handling money. In the context of "
"the alternative payment system promised by Bitcoin, smart contracts on "
"Ethereum enable the creation of decentralized financial applications that no "
"longer rely on traditional financial intermediaries. This is what we call "
"DeFi (decentralized finance). DeFi consists of various projects such as "
"lending/borrowing applications, decentralized exchanges (DEX), on-chain "
"derivatives, stablecoins, decentralized hedge funds, insurance, and many "
"more."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:26
msgid "Tokenization"
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:28
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such "
"as real estate, art, or precious metals. Tokenization divides an asset into "
"digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and "
"simplify the buying and selling process."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:30
msgid "Voting"
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:32
msgid ""
"Smart contracts can be used to create secure and transparent voting systems. "
"Votes can be recorded on the blockchain, ensuring immutability and "
"transparency. The smart contract can then automatically tally the votes and "
"declare the results, minimizing the potential for fraud or manipulation."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:34
msgid "Royalties"
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:36
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and "
"other content creators. When a piece of content is consumed or sold, the "
"smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for "
"intermediaries."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:38
msgid "Decentralized Identities DIDs"
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:40
msgid ""
"Smart contracts can be used to create and manage digital identities, "
"allowing individuals to control their personal information and share it with "
"third parties securely. The smart contract could verify the authenticity of "
"a user's identity and automatically grant or revoke access to specific "
"services based on the user's credentials."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:46
msgid "The Rise of Starknet and Cairo"
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:48
msgid ""
"Ethereum, being the most widely used and resilient smart contract platform, "
"became a victim of its own success. With the rapid adoption of some "
"previously mentioned use cases, mainly DeFi, the cost of performing "
"transactions became extremely high, rendering the network almost unusable. "
"Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:50
msgid ""
"A famous trilemma called The Blockchain Trilemma in the blockchain space "
"states that it is hard to achieve a high level of scalability, "
"decentralization, and security simultaneously; trade-offs must be made. "
"Ethereum is at the intersection of decentralization and security. "
"Eventually, it was decided that Ethereum's purpose would be to serve as a "
"secure settlement layer, while complex computations would be offloaded to "
"other networks built on top of Ethereum. These are called Layer 2s (L2s)."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:52
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. "
"Both approaches involve compressing and batching numerous transactions "
"together, computing the new state, and settling the result on Ethereum (L1). "
"The difference lies in the way the result is settled on L1. For optimistic "
"rollups, the new state is considered valid by default, but there is a 7-day "
"window for nodes to identify malicious transactions."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:54
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove "
"that the new state has been correctly computed. This is the purpose of "
"STARKs, this cryptographic technology could permit validity rollups to scale "
"significantly more than optimistic rollups. You can learn more about STARKs "
"from Starkware's Medium "
"[article](https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a), "
"which serves as a good primer."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:56
msgid ""
"Starknet's architecture is thoroughly described in the [Starknet "
"Book](https://book.starknet.io/ch03-00-architecture.html), which is a great "
"resource to learn more about the Starknet network."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:58
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work "
"with STARKs and make them general-purpose. With Cairo, we can write "
"**provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:60
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM "
"(either as-is or adapted) as a base layer, Starknet employs its own VM. This "
"frees developers from the constraints of the EVM, opening up a broader range "
"of possibilities. Coupled with decreased transaction costs, the combination "
"of Starknet and Cairo creates an exciting playground for developers. Native "
"account abstraction enables more complex logic for accounts, that we call "
"\"Smart Accounts\", and transaction flows. Emerging use cases include "
"**transparent AI** and machine learning applications. Finally, **blockchain "
"games** can be developed entirely **on-chain**. Starknet has been "
"specifically designed to maximize the capabilities of STARK proofs for "
"optimal scalability."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:62
msgid ""
"Learn more about Account Abstraction in the [Starknet "
"Book](https://book.starknet.io/ch04-00-account-abstraction.html)."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:68
msgid "Cairo Programs and Starknet Contracts: What Is the Difference?"
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:70
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts "
"previously learned in this book are still applicable to write Starknet "
"contracts. As you may have already noticed, a Cairo program must always have "
"a `main` function that serves as the entry point for this program:"
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:77
msgid ""
"Contracts deployed on the Starknet network are essentially programs that are "
"run by the sequencer, and as such, have access to Starknet's state. "
"Contracts do not have a `main` function but one or multiple functions that "
"can serve as entry points."
msgstr ""

#: src/ch13-01-general-introduction-to-smart-contracts.md:79
msgid ""
"Starknet contracts are defined within "
"[modules](./ch07-02-defining-modules-to-control-scope.md). For a module to "
"be handled as a contract by the compiler, it must be annotated with the "
"`#[starknet::contract]` attribute."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts using a "
"very simple smart contract as example. You will learn how to write a "
"contract that allows anyone to store a single number on the Starknet "
"blockchain."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:5
msgid ""
"Let's consider the following contract for the whole chapter. It might not be "
"easy to understand it all at once, but we will go through it step by step:"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:34
msgid "<span class=\"caption\">Listing 13-1: A simple storage contract</span>"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:36
msgid "What Is this Contract?"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:38
msgid ""
"Contracts are defined by encapsulating state and logic within a module "
"annotated with the `#[starknet::contract]` attribute."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:40
msgid ""
"The state is defined within the `Storage` struct, and is always initialized "
"empty. Here, our struct contains a single a field called `stored_data` of "
"type `u128` (unsigned integer of 128 bits), indicating that our contract can "
"store any number between 0 and \\\\( {2^{128}} - 1 \\\\)."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:42
msgid ""
"The logic is defined by functions that interact with the state. Here, our "
"contract defines and publicly exposes the functions `set` and `get` that can "
"be used to modify or retrieve the value of the stored variable. You can "
"think of it as a single slot in a database that you can query and modify by "
"calling functions of the code that manages the database."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:45
msgid "The Interface: the Contract's Blueprint"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:55
msgid "<span class=\"caption\">Listing 13-2: A basic contract interface</span>"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:58
msgid ""
"Interfaces represent the blueprint of the contract. They define the "
"functions that the contract exposes to the outside world. In Cairo, they're "
"defined by annotating a trait with the `#[starknet::interface]` attribute. "
"All functions of the trait are considered public functions of any contract "
"that implements this trait, and are callable from the outside world."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:60
msgid ""
"All contract interfaces use a generic type for the `self` parameter, "
"representing the contract state. We chose to name this generic parameter "
"`TContractState` in our interface, but this is not enforced and any name can "
"be chosen."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:62
msgid ""
"In our interface, note the generic type `TContractState` of the `self` "
"argument which is passed by reference to the `set` function. Seeing the "
"`self` argument passed in a contract function tells us that this function "
"can access the state of the contract. The `ref` modifier implies that `self` "
"may be modified, meaning that the storage variables of the contract may be "
"modified inside the `set` function."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:64
msgid ""
"On the other hand, the `get` function takes a snapshot of `TContractState`, "
"which immediately tells us that it does not modify the state (and indeed, "
"the compiler will complain if we try to modify storage inside the `get` "
"function)."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:66
msgid ""
"By leveraging the [traits & impls](./ch08-02-traits-in-cairo.md) mechanism "
"from Cairo, we can make sure that the actual implementation of the contract "
"matches its interface. In fact, you will get a compilation error if your "
"contract doesn’t conform with the declared interface. For example, Listing "
"13-3 shows a wrong implementation of the `ISimpleStorage` interface, "
"containing a slightly different `set` function that doesn't have the same "
"signature."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:78
msgid ""
"<span class=\"caption\">Listing 13-3: A wrong implementation of the "
"interface of the contract. This does not compile, as the signature of `set` "
"doesn't match the trait's.</span>"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:80
msgid ""
"Trying to compile a contract using this implementation will result in the "
"following error:"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:100
msgid "Public Functions Defined in an Implementation Block"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:102
msgid "Before we explore things further down, let's define some terminology."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:104
msgid ""
"In the context of Starknet, a _public function_ is a function that is "
"exposed to the outside world. A public function can be called by anyone, "
"either from outside the contract or from within the contract itself. In the "
"example above, `set` and `get` are public functions."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:106
msgid ""
"What we call an _external_ function is a public function that can be "
"directly invoked through a Starknet transaction and that can mutate the "
"state of the contract. `set` is an external function."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:108
msgid ""
"A _view_ function is a public function that is typically read-only and "
"cannot mutate the state of the contract. However, this limitation is only "
"enforced by the compiler, and not by Starknet itself. We will discuss the "
"implications of this in a later section. `get` is a view function."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:123
msgid ""
"<span class=\"caption\">Listing 13-4: `SimpleStorage` implementation</span>"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:125
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in "
"order to match the interface, the public functions of the contract must be "
"defined in an implementation of this trait — which allows us to make sure "
"that the implementation of the contract matches its interface."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:127
msgid ""
"However, simply defining the functions in the implementation block is not "
"enough. The implementation block must be annotated with the "
"`#[abi(embed_v0)]` attribute. This attribute exposes the functions defined "
"in this implementation to the outside world — forget to add it and your "
"functions will not be callable from the outside. All functions defined in a "
"block marked as `#[abi(embed_v0)]` are consequently _public functions_."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:129
msgid ""
"Because the `SimpleStorage` contract is defined as a module, we need to "
"access the interface defined in the parent module. We can either bring it to "
"the current scope with the `use` keyword, or refer to it directly using "
"`super`."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:131
msgid ""
"When writing the implementation of an interface, the `self` parameter in the "
"trait methods **must** be of type `ContractState`. The `ContractState` type "
"is generated by the compiler, and gives access to the storage variables "
"defined in the `Storage` struct. Additionally, `ContractState` gives us the "
"ability to emit events. The name `ContractState` is not surprising, as it’s "
"a representation of the contract’s state, which is what we think of `self` "
"in the contract interface trait. When `self` is a snapshot of "
"`ContractState`, only read access is allowed, and emitting events is not "
"possible."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:135
msgid "Accessing and Modifying the Contract's State"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:137
msgid ""
"Two methods are commonly used to access or modify the state of a contract:"
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:138
msgid ""
"`read`, which returns the value of a storage variable. This method is called "
"on the variable itself and does not take any argument."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:144
msgid ""
"`write`, which allows to write a new value in a storage slot. This method is "
"also called on the variable itself and takes one argument, which is the "
"value to be written. Note that `write` may take more than one argument, "
"depending on the type of the storage variable. For example, writing on a "
"mapping requires 2 arguments: the key and the value to be written."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:150
msgid ""
"Reminder: if the contract state is passed as a snapshot with `@` instead of "
"passed by reference with `ref`, attempting to modify the contract state will "
"result in a compilation error."
msgstr ""

#: src/ch13-02-anatomy-of-a-simple-contract.md:152
msgid ""
"This contract does not do much apart from allowing anyone to store a single "
"number that is accessible by anyone in the world. Anyone could call `set` "
"again with a different value and overwrite the current number. Nevertheless, "
"each value stored in the storage of the contract will still be stored in the "
"history of the blockchain. Later in this book, you will see how you can "
"impose access restrictions so that only you can alter the number."
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"In the previous section, we gave an introductory example of a smart contract "
"written in Cairo, describing the basic blocks to build smart contracts on "
"Starknet. In this section, we'll be taking a deeper look at all the "
"components of a smart contract, step by step."
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"When we discussed "
"[_interfaces_](./ch13-02-anatomy-of-a-simple-contract.md#the-interface-the-contracts-blueprint), "
"we specified the difference between the two types of _public functions_, "
"i.e., _external functions_ and _view functions_, and we mentioned how to "
"interact with the _storage_ of a contract."
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "At this point, you should have multiple questions that come to mind:"
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How can I store more complex data types?"
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How do I define internal/private functions?"
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How can I emit events? How can I index them?"
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "Is there a way to reduce the boilerplate?"
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"Luckily, we'll be answering all these questions in this chapter. Let's "
"consider the `NameRegistry` contract in Listing 14-1 that we'll be using "
"throughout this chapter:"
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:62 src/ch14-01-contract-storage.md:184
#: src/ch14-01-contract-storage.md:297 src/ch14-01-contract-storage.md:403
#: src/ch14-01-contract-storage.md:509 src/ch14-01-contract-storage.md:615
#: src/ch14-01-contract-storage.md:727 src/ch14-01-contract-storage.md:833
#: src/ch14-02-contract-functions.md:38
msgid "// Public functions inside an impl block\n"
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:79 src/ch14-01-contract-storage.md:201
#: src/ch14-01-contract-storage.md:314 src/ch14-01-contract-storage.md:420
#: src/ch14-01-contract-storage.md:526 src/ch14-01-contract-storage.md:632
#: src/ch14-01-contract-storage.md:744 src/ch14-01-contract-storage.md:850
#: src/ch14-02-contract-functions.md:97
msgid "// Standalone public function\n"
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:85 src/ch14-01-contract-storage.md:207
#: src/ch14-01-contract-storage.md:320 src/ch14-01-contract-storage.md:426
#: src/ch14-01-contract-storage.md:532 src/ch14-01-contract-storage.md:638
#: src/ch14-01-contract-storage.md:750 src/ch14-01-contract-storage.md:856
#: src/ch14-02-contract-functions.md:112
msgid "// Could be a group of functions about a same topic\n"
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:102 src/ch14-01-contract-storage.md:224
#: src/ch14-01-contract-storage.md:337 src/ch14-01-contract-storage.md:443
#: src/ch14-01-contract-storage.md:549 src/ch14-01-contract-storage.md:655
#: src/ch14-01-contract-storage.md:767 src/ch14-01-contract-storage.md:873
#: src/ch14-02-contract-functions.md:129
msgid "// Free function\n"
msgstr ""

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"<span class=\"caption\">Listing 14-1: Our reference contract for this "
"chapter</span>"
msgstr ""

#: src/ch14-01-contract-storage.md:3
msgid ""
"The most common way for interacting with a contract’s storage is through "
"storage variables. As stated previously, storage variables allow you to "
"store data that will be stored in the contract's storage that is itself "
"stored on the blockchain. These data are persistent and can be accessed and "
"potentially modified anytime once the contract is deployed."
msgstr ""

#: src/ch14-01-contract-storage.md:5
msgid ""
"Storage variables in Starknet contracts are stored in a special struct "
"called `Storage`:"
msgstr ""

#: src/ch14-01-contract-storage.md:111
msgid ""
"The `Storage` struct is a "
"[struct](./ch05-00-using-structs-to-structure-related-data.md) like any "
"other, except that it **must** be annotated with the `#[storage]` attribute. "
"This annotation tells the compiler to generate the required code to interact "
"with the blockchain state, and allows you to read and write data from and to "
"storage. Moreover, this allows you to define storage mappings using the "
"dedicated `LegacyMap` type."
msgstr ""

#: src/ch14-01-contract-storage.md:113
msgid ""
"Variables declared in the `Storage` struct are not stored contiguously but "
"in different locations in the contract's storage. The storage address of a "
"particular variable is determined by the variable's name, and the eventual "
"keys of the variable if it is a mapping."
msgstr ""

#: src/ch14-01-contract-storage.md:117
msgid "Addresses of Storage Variables"
msgstr ""

#: src/ch14-01-contract-storage.md:119
msgid "The address of a storage variable is computed as follows:"
msgstr ""

#: src/ch14-01-contract-storage.md:121
msgid ""
"If the variable is a single value, the address is the `sn_keccak` hash of "
"the ASCII encoding of the variable's name. `sn_keccak` is Starknet's version "
"of the Keccak256 hash function, whose output is truncated to 250 bits."
msgstr ""

#: src/ch14-01-contract-storage.md:123
msgid ""
"If the variable is composed of multiple values (i.e., a tuple, a struct or "
"an enum), we also use the `sn_keccak` hash of the ASCII encoding of the "
"variable's name to determine the base address in storage. Then, depending on "
"the type, the storage layout will differ. See the [\"Storing Custom "
"Types\"](./ch14-01-contract-storage.md#storing-custom-types) section."
msgstr ""

#: src/ch14-01-contract-storage.md:125
msgid ""
"If the variable is a "
"[mapping](./ch14-01-contract-storage.html#storage-mappings) with a key `k`, "
"the address of the value at key `k` is `h(sn_keccak(variable_name),k)`, "
"where ℎ is the Pedersen hash and the final value is taken modulo \\\\( "
"{2^{251}} - 256\\\\). If the key is composed of more than one `felt252`, the "
"address of the value will be "
"`h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)`, with `k_1,...,k_n` "
"being all `felt252` that constitute the key. In the case of mappings to "
"complex values (e.g., tuples or structs), then this complex value lies in a "
"continuous segment starting from the address calculated with the previous "
"formula. Note that 256 field elements is the current limitation on the "
"maximal size of a complex storage value."
msgstr ""

#: src/ch14-01-contract-storage.md:127
msgid ""
"You can access the address of a storage variable by calling the `address` "
"function on the variable, which returns a `StorageBaseAddress` value."
msgstr ""

#: src/ch14-01-contract-storage.md:236
msgid "Interacting with Storage Variables"
msgstr ""

#: src/ch14-01-contract-storage.md:238
msgid ""
"Variables stored in the `Storage` struct can be accessed and modified using "
"the `read` and `write` functions, respectively. As previously mentioned, you "
"can get their address in storage using the `address` function. All these "
"functions are automatically generated by the compiler for each storage "
"variable."
msgstr ""

#: src/ch14-01-contract-storage.md:240
msgid ""
"To read the value of the `owner` storage variable, which is a single value, "
"we call the `read` function on the `owner` variable, passing in no "
"parameters."
msgstr ""

#: src/ch14-01-contract-storage.md:346
msgid ""
"To read the value of the storage variable `names`, which is a mapping from "
"`ContractAddress` to `felt252`, we call the `read` function on the `names` "
"variable, passing in the key `address` as a parameter. If the mapping had "
"more than one key, we would pass in the other keys as parameters as well."
msgstr ""

#: src/ch14-01-contract-storage.md:452
msgid ""
"To write a new value to the storage slot of a storage variable, we call the "
"`write` function passing in the eventual keys and the value as arguments. As "
"with the `read` function, the number of arguments depends on the storage "
"variable type. Here, we only pass in the value to write to the `owner` "
"variable as it is a simple variable."
msgstr ""

#: src/ch14-01-contract-storage.md:558
msgid ""
"In this second example, we need to pass `user` and `name` as arguments, "
"because `names` is a mapping, with `user` as key and `name` as value."
msgstr ""

#: src/ch14-01-contract-storage.md:664
msgid "Storing Custom Types"
msgstr ""

#: src/ch14-01-contract-storage.md:666
msgid ""
"The `Store` trait, defined in the `starknet::storage_access` module, is used "
"to specify how a type should be stored in storage. In order for a type to be "
"stored in storage, it **must** implement the `Store` trait. Most types from "
"the core library, such as unsigned integers (`u8`, `u128`, `u256`...), "
"`felt252`, `bool`, `ByteArray`, `ContractAddress`, etc. implement the "
"`Store` trait and can thus be stored without further action."
msgstr ""

#: src/ch14-01-contract-storage.md:668
msgid ""
"But what if you wanted to store a type that you defined yourself, such as an "
"enum or a struct? In that case, you have to explicitly tell the compiler how "
"to store this type."
msgstr ""

#: src/ch14-01-contract-storage.md:670
msgid ""
"In our example, we want to store a `Person` struct in storage, which is only "
"possible by implementing the `Store` trait for the `Person` type. This can "
"be simply achieved by adding a `#[derive(starknet::Store)]` attribute on top "
"of our struct definition. Note that all the members of the struct need to "
"implement the `Store` trait."
msgstr ""

#: src/ch14-01-contract-storage.md:776
msgid ""
"Similarly, Enums can only be written to storage if they implement the "
"`Store` trait, which can be trivially derived as long as all associated "
"types implement the `Store` trait."
msgstr ""

#: src/ch14-01-contract-storage.md:882
msgid ""
"You might have noticed that we also derived `Drop` and `Serde` on our custom "
"types. Both of them are required for properly serializing arguments passed "
"to entrypoints and deserializing their outputs."
msgstr ""

#: src/ch14-01-contract-storage.md:884
msgid "Structs Storage Layout"
msgstr ""

#: src/ch14-01-contract-storage.md:886
msgid ""
"On Starknet, structs are stored in storage as a sequence of primitive types. "
"The elements of the struct are stored in the same order as they are defined "
"in the struct definition. The first element of the struct is stored at the "
"base address of the struct, which is computed as specified in [\"Addresses "
"of Storage "
"Variables\"](./ch14-01-contract-storage.html#addresses-of-storage-variables) "
"section and can be obtained by calling `var.address()`, and subsequent "
"elements are stored at addresses contiguous to the first element. For "
"example, the storage layout for the `owner` variable of type `Person` will "
"result in the following layout:"
msgstr ""

#: src/ch14-01-contract-storage.md:890
msgid "Fields"
msgstr ""

#: src/ch14-01-contract-storage.md:890 src/ch14-01-contract-storage.md:905
#: src/ch14-01-contract-storage.md:912
msgid "Address"
msgstr ""

#: src/ch14-01-contract-storage.md:892
msgid "name"
msgstr ""

#: src/ch14-01-contract-storage.md:892
msgid "owner.address()"
msgstr ""

#: src/ch14-01-contract-storage.md:893
msgid "address"
msgstr ""

#: src/ch14-01-contract-storage.md:893
msgid "owner.address() +1"
msgstr ""

#: src/ch14-01-contract-storage.md:895
msgid ""
"Note that tuples are similarly stored in contract's storage, with the first "
"element of the tuple being stored at the base address, and subsequent "
"elements stored contiguously."
msgstr ""

#: src/ch14-01-contract-storage.md:899
msgid "Enums Storage Layout"
msgstr ""

#: src/ch14-01-contract-storage.md:901
msgid ""
"When you store an enum variant, what you're essentially storing is the "
"variant's index and eventual associated values. This index starts at 0 for "
"the first variant of your enum and increments by 1 for each subsequent "
"variant. If your variant has an associated value, this value is stored "
"starting from the address immediately following the address of the index of "
"the variant. For example, suppose we have the `RegistrationType` enum with "
"the `finite` variant that carries an associated limit date, and the "
"`infinite` variant without associated data. The storage layout for the "
"`finite` variant would look like this:"
msgstr ""

#: src/ch14-01-contract-storage.md:905 src/ch14-01-contract-storage.md:912
msgid "Element"
msgstr ""

#: src/ch14-01-contract-storage.md:907
msgid "Variant index (0 for finite)"
msgstr ""

#: src/ch14-01-contract-storage.md:907 src/ch14-01-contract-storage.md:914
msgid "registration_type.address()"
msgstr ""

#: src/ch14-01-contract-storage.md:908
msgid "Associated limit date"
msgstr ""

#: src/ch14-01-contract-storage.md:908
msgid "registration_type.address() + 1"
msgstr ""

#: src/ch14-01-contract-storage.md:910
msgid "while the storage layout for the `infinite` would be as follows:"
msgstr ""

#: src/ch14-01-contract-storage.md:914
msgid "Variant index (1 for infinite)"
msgstr ""

#: src/ch14-01-contract-storage.md:916
msgid "Storage Mappings"
msgstr ""

#: src/ch14-01-contract-storage.md:918
msgid ""
"Storage mappings are similar to hash tables in that they allow mapping keys "
"to values. However, unlike a typical hash table, the key data itself is not "
"stored - only its hash is used to look up the associated value in the "
"contract's storage. Mappings do not have a concept of length or whether a "
"key/value pair is set. All values are by default set to 0. The only way to "
"remove an entry from a mapping is to set its value to the default zero value."
msgstr ""

#: src/ch14-01-contract-storage.md:921
msgid ""
"Mappings are only used to compute the location of data in the storage of a "
"contract given certain keys. They are thus **only allowed as storage "
"variables**. They cannot be used as parameters or return parameters of "
"contract functions, and cannot be used as types inside structs."
msgstr ""

#: src/ch14-01-contract-storage.md:933
msgid ""
"To declare a mapping, use the `LegacyMap` type enclosed in angle brackets "
"`<>`, specifying the key and value types."
msgstr ""

#: src/ch14-01-contract-storage.md:936
msgid ""
"You can also create more complex mappings with multiple keys. You can find "
"in Listing 14-2 the popular `allowances` storage variable of the ERC20 "
"Standard which maps an `owner` and an allowed `spender` to their `allowance` "
"amount using multiple keys passed inside a tuple:"
msgstr ""

#: src/ch14-01-contract-storage.md:945
msgid ""
"<span class=\"caption\">Listing 14-2: Storing a mapping with multiple keys "
"inside a tuple</span>"
msgstr ""

#: src/ch14-01-contract-storage.md:947
msgid ""
"The address in storage of a variable stored in a mapping is computed "
"according to the description in the [\"Addresses of Storage "
"Variables\"](./ch14-01-contract-storage.html#addresses-of-storage-variables) "
"section."
msgstr ""

#: src/ch14-01-contract-storage.md:949
msgid ""
"If the key of a mapping is a struct, each element of the struct constitutes "
"a key. Moreover, the struct should implement the `Hash` trait, which can be "
"derived with the `#[derive(Hash)]` attribute. For example, if you have a "
"struct with two fields, the address will be "
"`h(h(sn_keccak(variable_name),k_1),k_2)` modulo \\\\( {2^{251}} - 256\\\\), "
"where `k_1` and `k_2` are the values of the two fields of the struct."
msgstr ""

#: src/ch14-01-contract-storage.md:951
msgid ""
"Similarly, in the case of a nested mapping using a tuple as key, such as "
"`LegacyMap::<(ContractAddress, ContractAddress), u8>`, the address will be "
"computed in the same way, with each element of the tuple being a key: "
"`h(h(sn_keccak(variable_name),k_1),k_2)`."
msgstr ""

#: src/ch14-02-contract-functions.md:3
msgid ""
"In this section, we are going to be looking at the different types of "
"functions you could encounter in Starknet smart contracts."
msgstr ""

#: src/ch14-02-contract-functions.md:5
msgid ""
"Functions can access the contract's state easily via `self: ContractState`, "
"which abstracts away the complexity of underlying system calls "
"(`storage_read_syscall` and `storage_write_syscall`). The compiler provides "
"two modifiers: `ref` and `@` to decorate `self`, which intends to "
"distinguish view and external functions."
msgstr ""

#: src/ch14-02-contract-functions.md:7
msgid "1. Constructors"
msgstr ""

#: src/ch14-02-contract-functions.md:9
msgid ""
"Constructors are a special type of function that only runs once when "
"deploying a contract, and can be used to initialize the state of a contract."
msgstr ""

#: src/ch14-02-contract-functions.md:20
msgid "Some important rules to note:"
msgstr ""

#: src/ch14-02-contract-functions.md:22
msgid "A contract can't have more than one constructor."
msgstr ""

#: src/ch14-02-contract-functions.md:23
msgid ""
"The constructor function must be named `constructor`, and must be annotated "
"with the `#[constructor]` attribute."
msgstr ""

#: src/ch14-02-contract-functions.md:25
msgid ""
"The `constructor` function might take arguments, which are passed when "
"deploying the contract. In our example, we pass some value corresponding to "
"a `Person` type as argument in order to store the `owner` information "
"(address and name) in the contract."
msgstr ""

#: src/ch14-02-contract-functions.md:27
msgid ""
"Note that the `constructor` function **must** take `self` as a first "
"argument, corresponding to the state of the contract, generally passed by "
"reference with the `ref` keyword to be able to modify the contract's state. "
"We will explain `self` and its type shortly."
msgstr ""

#: src/ch14-02-contract-functions.md:29
msgid "2. Public Functions"
msgstr ""

#: src/ch14-02-contract-functions.md:31
msgid ""
"As stated previously, public functions are accessible from outside of the "
"contract. They are usually defined inside an implementation block annotated "
"with the `#[abi(embed_v0)]` attribute, but might also be defined "
"independently under the `#[external(v0)]` attribute."
msgstr ""

#: src/ch14-02-contract-functions.md:33
msgid ""
"The `#[abi(embed_v0)]` attribute means that all functions embedded inside it "
"are implementations of the Starknet interface of the contract, and therefore "
"potential entry points."
msgstr ""

#: src/ch14-02-contract-functions.md:35
msgid ""
"Annotating an impl block with the `#[abi(embed_v0)]` attribute only affects "
"the visibility (i.e., public vs private/internal) of the functions it "
"contains, but it doesn't inform us on the ability of these functions to "
"modify the state of the contract."
msgstr ""

#: src/ch14-02-contract-functions.md:56
msgid ""
"Similarly to the `constructor` function, all public functions, either "
"standalone functions annotated with the `#[external(v0)]` or functions "
"within an impl block annotated with the `#[abi(embed_v0)]` attribute, "
"**must** take `self` as a first argument. This is not the case for private "
"functions."
msgstr ""

#: src/ch14-02-contract-functions.md:58
msgid "External Functions"
msgstr ""

#: src/ch14-02-contract-functions.md:60
msgid ""
"External functions are _public_ functions where the `self: ContractState` "
"argument is passed by reference with the `ref` keyword, which exposes both "
"the `read` and `write` access to storage variables. This allows modifying "
"the state of the contract via `self` directly."
msgstr ""

#: src/ch14-02-contract-functions.md:69
msgid "View Functions"
msgstr ""

#: src/ch14-02-contract-functions.md:71
msgid ""
"View functions are _public_ functions where the `self: ContractState` "
"argument is passed as snapshot, which only allows the `read` access to "
"storage variables, and restricts writes to storage made via `self` by "
"causing compilation errors. The compiler will mark their `state_mutability` "
"to `view`, preventing any state modification through `self` directly."
msgstr ""

#: src/ch14-02-contract-functions.md:80
msgid "State Mutability of Public Functions"
msgstr ""

#: src/ch14-02-contract-functions.md:82
msgid ""
"However, as you may have noticed, passing `self` as a snapshot only "
"restricts the storage write access via `self` at compile time. It does not "
"prevent state modification via direct system calls, nor calling another "
"contract that would modify the state."
msgstr ""

#: src/ch14-02-contract-functions.md:84
msgid ""
"The read-only property of view functions is not enforced on Starknet, and "
"sending a transaction targeting a view function _could_  change the state."
msgstr ""

#: src/ch14-02-contract-functions.md:86
msgid ""
"In conclusion, even though external and view functions are distinguished by "
"the Cairo compiler, **all public functions** can be called through an invoke "
"transaction and have the potential to modify states on Starknet. Also, all "
"public functions can be queried via `starknet_call` on Starknet, which will "
"not create a transaction and hence will not change the state."
msgstr ""

#: src/ch14-02-contract-functions.md:88
msgid ""
"**Warning:** This is different from the EVM where a `staticcall` opcode is "
"provided, which prevents storage modifications in the current context and "
"subcontexts. Hence developers **should not** have the assumption that "
"calling a view function on another contract cannot modify the state."
msgstr ""

#: src/ch14-02-contract-functions.md:90
msgid "Standalone Public Functions"
msgstr ""

#: src/ch14-02-contract-functions.md:92
msgid ""
"It is also possible to define public functions outside of an implementation "
"of a trait, using the `#[external(v0)]` attribute. Doing this will "
"automatically generate the corresponding ABI, allowing these standalone "
"public functions to be callable by anyone from the outside. These functions "
"can also be called from within the contract just like any function in "
"Starknet contracts. The first parameter must be `self`."
msgstr ""

#: src/ch14-02-contract-functions.md:94
msgid ""
"Here, we define a standalone `get_contract_name` function outside of an impl "
"block:"
msgstr ""

#: src/ch14-02-contract-functions.md:104
msgid "3. Private Functions"
msgstr ""

#: src/ch14-02-contract-functions.md:106
msgid ""
"Functions that are not defined with the `#[external(v0)]` attribute or "
"inside a block annotated with the `#[abi(embed_v0)]` attribute are private "
"functions (also called internal functions). They can only be called from "
"within the contract."
msgstr ""

#: src/ch14-02-contract-functions.md:108
msgid ""
"They can be grouped in a dedicated impl block (e.g., in components, to "
"easily import internal functions all at once in the embedding contracts) or "
"just be added as free functions inside the contract module. Note that these "
"2 methods are equivalent. Just choose the one that makes your code more "
"readable and easy to use."
msgstr ""

#: src/ch14-02-contract-functions.md:135
msgid ""
"Wait, what is this `#[generate_trait]` attribute? Where is the trait "
"definition for this implementation? Well, the `#[generate_trait]` attribute "
"is a special attribute that tells the compiler to generate a trait "
"definition for the implementation block. This allows you to get rid of the "
"boilerplate code of defining a trait with generic parameters and "
"implementing it for the implementation block. With this attribute, we can "
"simply define the implementation block directly, without any generic "
"parameter, and use `self: ContractState` in our functions."
msgstr ""

#: src/ch14-02-contract-functions.md:137
msgid ""
"The `#[generate_trait]` attribute is mostly used to define private impl "
"blocks. It might also be used in addition to `#[abi(per_item)]` to define "
"the various entrypoints of a contract (see [next "
"section](./ch14-02-contract-functions.md#4-abiper_item-attribute))."
msgstr ""

#: src/ch14-02-contract-functions.md:139
msgid ""
"Note: using `#[generate_trait]` in addition to the `#[abi(embed_v0)]` "
"attribute for a public impl block is not recommended, as it will result in a "
"failure to generate the corresponding ABI. Public functions should only be "
"defined in an impl block annotated with `#[generate_trait]` if this block is "
"also annotated with the `#[abi(per_item)]` attribute."
msgstr ""

#: src/ch14-02-contract-functions.md:144
msgid "`[abi(per_item)]` Attribute"
msgstr ""

#: src/ch14-02-contract-functions.md:146
msgid ""
"You can also define the entrypoint type of functions individually inside an "
"impl block using the`#[abi(per_item)]` attribute on top of your impl. It is "
"often used with the `#[generate_trait]` attribute, as it allows you to "
"define entrypoints without an explicit interface. In this case, the "
"functions will not be grouped under an impl in the ABI. Note that when using "
"`#[abi(per_item)]` attribute, public functions need to be annotated with the "
"`#[external(v0)]` attribute - otherwise, they will not be exposed and will "
"be considered as private functions."
msgstr ""

#: src/ch14-02-contract-functions.md:148
msgid "Here is a short example:"
msgstr ""

#: src/ch14-02-contract-functions.md:160
msgid "// this is a constructor function\n"
msgstr ""

#: src/ch14-02-contract-functions.md:164
msgid "// this is a public function\n"
msgstr ""

#: src/ch14-02-contract-functions.md:168
msgid "// this is a l1_handler function\n"
msgstr ""

#: src/ch14-02-contract-functions.md:171
msgid "// this is an internal function\n"
msgstr ""

#: src/ch14-02-contract-functions.md:177
msgid ""
"In the case of `#[abi(per_item)]` attribute usage without "
"`#[generate_trait]`, it will only be possible to include `constructor`, "
"`l1-handler` and `internal` functions in the trait implementation. Indeed, "
"`#[abi(per_item)]` only works with a trait that is not defined as a Starknet "
"interface. Hence, it will be mandatory to create another trait defined as "
"interface to implement public functions."
msgstr ""

#: src/ch14-03-contract-events.md:3
msgid ""
"Events are custom data structures that are emitted by smart contracts during "
"execution. They provide a way for smart contracts to communicate with the "
"external world by logging information about specific occurrences in a "
"contract."
msgstr ""

#: src/ch14-03-contract-events.md:5
msgid ""
"Events play a crucial role in the integration of smart contracts in "
"real-world applications. Take, for instance, the Non-Fungible Tokens (NFTs) "
"minted on Starknet. An event is emitted each time a token is minted. This "
"event is indexed and stored in some database, allowing applications to "
"display almost instantaneously useful information to users. If the contract "
"doesn't emit an event when minting a new token, it would be less practical, "
"with the need of querying the state of the blockchain to get the data needed."
msgstr ""

#: src/ch14-03-contract-events.md:7
msgid "Defining Events"
msgstr ""

#: src/ch14-03-contract-events.md:9
msgid ""
"All the different events in a contract are defined under the `Event` enum, "
"which must implement the `starknet::Event` trait. This trait is defined in "
"the core library as follows:"
msgstr ""

#: src/ch14-03-contract-events.md:18
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate "
"an implementation for the above trait, instantiated with the `Event` type, "
"which in our example is the following enum:"
msgstr ""

#: src/ch14-03-contract-events.md:29
msgid ""
"Each variant of the `Event` enum has to be a struct or an enum, and each "
"variant needs to implement the `starknet::Event` trait itself. Moreover, the "
"members of these variants must implement the `Serde` trait (_c.f._ [Appendix "
"C: Serializing with "
"Serde](./appendix-03-derivable-traits.html#serializing-with-serde)), as "
"keys/data are added to the event using a serialization process."
msgstr ""

#: src/ch14-03-contract-events.md:31
msgid ""
"The auto-implementation of the `starknet::Event` trait will implement the "
"`append_keys_and_data` function for each variant of our `Event` enum. The "
"generated implementation will append a single key based on the variant name "
"(`StoredName`), and then recursively call `append_keys_and_data` in the impl "
"of the `Event` trait for the variant’s type."
msgstr ""

#: src/ch14-03-contract-events.md:33
msgid ""
"In our example, the `Event` enum contains only one variant, which is a "
"struct named `StoredName`. We chose to name our variant with the same name "
"as the struct name, but this is not enforced."
msgstr ""

#: src/ch14-03-contract-events.md:44
msgid ""
"Whenever an enum that derives the `starknet::Event` trait has an enum "
"variant, this enum is nested by default. Therefore, the list of keys "
"corresponding to the variant’s name will include the `sn_keccak` hash of the "
"variant's name itself. This can be superfluous, typically when using "
"embedded components in contracts. Indeed, in such cases, we might want the "
"events defined in the components to be emitted without any additional data, "
"and it could be useful to annotate the enum variant with the `#[flat]` "
"attribute. By doing so, we allow to opt out of the nested behavior and "
"ignore the variant name in the serialization process. On the other hand, "
"nested events have the benefit of distinguishing between the main contract "
"event and different components events, which might be helpful."
msgstr ""

#: src/ch14-03-contract-events.md:46
msgid ""
"In our contract, we defined an event named `StoredName` that emits the "
"contract address of the caller and the name stored within the contract, "
"where the `user` field is serialized as a key and the `name` field is "
"serialized as data."
msgstr ""

#: src/ch14-03-contract-events.md:48
msgid ""
"Indexing events fields allows for more efficient queries and filtering of "
"events. To index a field as a key of an event, simply annotate it with the "
"`#[key]` attribute as demonstrated in the example for the `user` key. By "
"doing so, any indexed field will allow queries of events that contain a "
"given value for that field with \\\\( O(log(n)) \\\\) time complexity, while "
"non indexed fields require any query to iterate over all events, providing "
"\\\\( O(n) \\\\) time complexity."
msgstr ""

#: src/ch14-03-contract-events.md:50
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: name "
"})`, a key corresponding to the name ` StoredName`, specifically "
"`sn_keccak(StoredName)`, is appended to the keys list. `user`is serialized "
"as key, thanks to the `#[key]` attribute, while address is serialized as "
"data. After everything is processed, we end up with the following keys and "
"data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [name]`."
msgstr ""

#: src/ch14-03-contract-events.md:54
msgid "Emitting Events"
msgstr ""

#: src/ch14-03-contract-events.md:56
msgid ""
"After defining events, we can emit them using `self.emit`, with the "
"following syntax:"
msgstr ""

#: src/ch14-03-contract-events.md:62
msgid ""
"The `emit` function is called on `self` and takes a reference to `self`, "
"i.e., state modification capabilities are required. Therefore, it is not "
"possible to emit events in view functions."
msgstr ""

#: src/ch15-00-starknet-cross-contract-interactions.md
msgid ""
"Interactions between smart contracts are an important feature when creating "
"complex decentralized applications, as it allows for composability and "
"separation of concerns. This chapter sheds light on how to make contracts "
"interact with each other."
msgstr ""

#: src/ch15-00-starknet-cross-contract-interactions.md
msgid ""
"Specifically, you'll learn about ABIs, contract interfaces, the contract and "
"library dispatchers and their low-level system call equivalents!"
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a "
"common practice which enables us to build flexible contracts that can speak "
"with each other."
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:7
msgid "ABI - Application Binary Interface"
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the "
"contract's functions and structures, giving anyone (or any other contract) "
"the ability to form encoded calls to it. It is a blueprint that instructs "
"how functions should be called, what input parameters they expect, and in "
"what format."
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:11
msgid ""
"While we write our smart contract logics in high-level Cairo, they are "
"stored on the VM as executable bytecodes which are in binary formats. Since "
"this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods "
"which can be called to a smart contract for execution. Without an ABI, it "
"becomes practically impossible for external actors to understand how to "
"interact with a contract."
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data "
"correctly, making it understandable by the smart contract and vice versa. "
"When you interact with a smart contract through a block explorer like "
"[Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), "
"they use the contract's ABI to format the data you send to the contract and "
"the data it returns."
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:15
#: src/ch16-05-02-randomness.md:25
msgid "Interface"
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:17
msgid ""
"The interface of a contract is a list of the functions it exposes publicly. "
"It specifies the function signatures (name, parameters, visibility and "
"return value) contained in a smart contract without including the function "
"body."
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:20
msgid ""
"Contract interfaces in Cairo are traits annotated with the "
"`#[starknet::interface]` attribute. If you are new to traits, check out the "
"dedicated chapter on [traits](./ch08-02-traits-in-cairo.md)."
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the "
"`TContractState` type. This is required for functions to access the "
"contract's storage, so that they can read and write to it."
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:24
msgid ""
"Note: The contract constructor is not part of the interface. Nor are "
"internal functions part of the interface."
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's "
"a generic trait over the `TContractState` type. `view` functions have a self "
"parameter of type `@TContractState`, while `external` functions have a self "
"parameter of type passed by reference `ref self: TContractState`."
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:55
msgid "<span class=\"caption\">Listing 15-1: A simple ERC20 Interface.</span>"
msgstr ""

#: src/ch15-01-abis-and-contract-interfaces.md:57
msgid ""
"In the next chapter, we will see how we can call contracts from other smart "
"contracts using _dispatchers_ and _syscalls_ ."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:3
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically "
"created and exported by the compiler. Let's consider an interface that we "
"named IERC20, these would be:"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:5
msgid "The Contract Dispatcher `IERC20Dispatcher`"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:6
msgid "The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:8
msgid ""
"The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to "
"call the functions defined in the interface on the dispatcher struct."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:10
msgid ""
"In this chapter, we are going to discuss what these are, how they work and "
"how to use them."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:12
msgid ""
"To effectively break down the concepts in this chapter, we are going to be "
"using the IERC20 interface from the previous chapter (refer to Listing 15-1)."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:14
msgid "Contract Dispatcher"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` "
"attribute automatically generate a dispatcher and a trait on compilation. "
"Our `IERC20` interface is expanded into something like this:"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:19
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to "
"keep this chapter concise and straight to the point, we focused on one view "
"function `name`, and one external function `transfer`."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:37
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:41
msgid "// starknet::call_contract_syscall is called in here\n"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:46
msgid ""
"<span class=\"caption\">Listing 15-2: An expanded form of the "
"IERC20Dispatcher trait.</span>"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a "
"contract address and implements the `DispatcherTrait` generated by the "
"compiler, allowing us to call functions from another contract. This means "
"that we can instantiate a struct with the address of the contract we want to "
"call, and then simply call the functions defined in the interface on the "
"dispatcher struct as if they were methods of that type."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:50
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes "
"thanks to the power of Cairo plugins."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:52
msgid "Calling Contracts using the Contract Dispatcher"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:54
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to "
"call functions defined on an ERC-20 token. Calling `transfer_token` will "
"modify the state of the contract deployed at `contract_address`."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:94
msgid "//**** Specify interface here ****//\n"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:125
msgid ""
"<span class=\"caption\">Listing 15-3: A sample contract which uses the "
"Contract Dispatcher.</span>"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:127
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` generated by the compiler, which allows us to make calls "
"to the methods implemented for the `IERC20Dispatcher` struct (`name`, "
"`transfer`, etc), passing in the `contract_address` of the contract we want "
"to call in the `IERC20Dispatcher` struct."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:129
msgid "Library Dispatcher"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library "
"dispatcher lies in the execution context of the logic defined in the class. "
"While regular dispatchers are used to call functions from **contracts** "
"(with an associated state), library dispatchers are used to call **classes** "
"(stateless)."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the "
"execution context of the logic defined in B is that of B. This means that "
"the value returned by `get_caller_address()` in B will return the address of "
"A, and updating a storage variable in B will update the storage of B."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B, "
"the execution context of the logic defined in B's class is that of A. This "
"means that the value returned by `get_caller_address()` variable in B will "
"return the address of the caller of A, and updating a storage variable in "
"B's class will update the storage of A (remember that the **class** of B is "
"stateless; there is no state that can be updated!)"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:139
msgid ""
"The expanded form of the struct and trait generated by the compiler look "
"like:"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:157
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:161
msgid "// starknet::syscalls::library_call_syscall  is called in here\n"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:166
msgid ""
"<span class=\"caption\">Listing 15-4: An expanded form of the IERC20 "
"trait.</span>"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:168
msgid ""
"Notice that the main difference between the regular contract dispatcher and "
"the library dispatcher is that the former uses `call_contract_syscall` while "
"the latter uses `library_call_syscall`."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:170
msgid "Calling Contracts using the Library Dispatcher"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:172
msgid "Below's a sample code for calling contracts using the Library Dispatcher."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:208
msgid ""
"<span class=\"caption\">Listing 15-5: A sample contract using the Library "
"Dispatcher.</span>"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:210
msgid ""
"As you can see, we had to first import in our contract the "
"`IContractADispatcherTrait` and `IContractALibraryDispatcher` which were "
"generated from our interface by the compiler. Then, we can create an "
"instance of `IContractALibraryDispatcher` passing in the `class_hash` of the "
"class we want to make library calls to. From there, we can call the "
"functions defined in that class, executing its logic in the context of our "
"contract. When we call `set_value` on ContractA, it will make a library call "
"to the `set_value` function in IContractA, updating the value of the storage "
"variable `value` in ContractA."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:212
msgid "Using low-level syscalls"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:214
msgid ""
"Another way to call other contracts and classes is to use the "
"`starknet::call_contract_syscall`and `starknet::library_call_syscall` system "
"calls. The dispatchers we described in the previous sections are high-level "
"syntaxes for these low-level system calls."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:216
msgid ""
"Using these syscalls can be handy for customized error handling or to get "
"more control over the serialization/deserialization of the call data and the "
"returned data. Here's an example demonstrating how to use a "
"`call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:254
msgid "\"transferFrom\""
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:265
msgid ""
"<span class=\"caption\">Listing 15-6: A sample contract using "
"syscalls.</span>"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:267
msgid ""
"To use this syscall, we passed in the contract address, the selector of the "
"function we want to call (see next section), and the call arguments."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:269
msgid ""
"The call arguments must be provided as an array of `felt252`. To build this "
"array, we serialize the expected function parameters into an "
"`Array<felt252>` using the `Serde` trait, and then pass this array as "
"calldata. At the end, we are returned a serialized value which we'll need to "
"deserialize ourselves!"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:271
msgid "Entry Point Selector"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:273
msgid ""
"In the context of a smart contract, a selector is a unique identifier for a "
"specific entrypoint of a contract. When a transaction is sent to a contract, "
"it includes the selector in the calldata to specify which function should be "
"executed."
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:275
msgid ""
"On Starknet, the selector is computed by applying the `sn_keccak` hash "
"function to the string representation of the function name. If the function "
"name is `transfer`, the selector can be computed with "
"`selector!(\"transfer\")`"
msgstr ""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:277
msgid ""
"Note that in `starknet::call_contract_syscall`, we didn't specify the "
"function name as a string, but rather used the `selector!` macro, which "
"computes the `sn_keccak` hash of the provided function signature."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:3
msgid ""
"Bit-packing is a simple concept: use as few bits as possible to store a "
"piece of data. When done well, it can significantly reduce the size of the "
"data you need to store. This is especially important in smart contracts, "
"where storage is expensive."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage "
"usage to reduce gas costs. Indeed, most of the cost associated with a "
"transaction is related to storage updates; and each storage slot costs gas "
"to write to. This means that by packing multiple values into fewer slots, "
"you can decrease the gas cost incurred by the users of your smart contract."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:8
msgid "Integer Structure and Bitwise Operators"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:10
msgid ""
"An integer is coded on a certain number of bits, depending on its size (For "
"example, a `u8` integer is coded on 8 bits)."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:19
msgid ""
"Intuitively, several integers can be combined into a single integer if the "
"size of this single integer is greater than or equal to the sum of the sizes "
"of the integers (For example, two `u8` and one `u16` in one `u32`)."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:21
msgid "But, to do that, we need some bitwise operators:"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:23
msgid ""
"multiplying or dividing an integer by a power of 2 shifts the integer value "
"to the left or to the right respectively"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:32
msgid ""
"applying a mask (`AND` operator) on an integer value isolates some bits of "
"this integer"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:41
msgid ""
"adding (`OR` operator) two integers will combine both values into a single "
"one."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:50
msgid ""
"With these bitwise operators, let's see how to combine two `u8` integers "
"into a single `u16` integer (called `packing`) and reversely (called "
"`unpacking`) in the following example:"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:59
msgid "Bit-packing in Cairo"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:61
msgid ""
"The storage of a Starknet smart contract is a map with 2<sup>251</sup> "
"slots, where each slot is a `felt252` which is initialized to 0."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:63
msgid ""
"As we saw earlier, to reduce gas costs due to storage updates, we have to "
"use as few bits as possible, so we have to organize stored variables by "
"packing them."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:65
msgid ""
"For example, consider the following `Sizes` struct with 3 fields of "
"different types: one `u8`, one `u32` and one `u64`. The total size is 8 + 32 "
"+ 64 = 104 bits. This is less than a slot size (i.e 251 bits) so we can pack "
"them together to be stored into a single slot."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:67
msgid ""
"Note that, as it also fits in a `u128`, it's a good practice to use the "
"smallest type to pack all your variables, so here a `u128` should be used."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:77
msgid ""
"To pack these 3 variables into a `u128` we have to successively shift them "
"to the left, and finally sum them."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:86
msgid ""
"To unpack these 3 variables from a `u128` we have to successively shift them "
"to the right and use a mask to isolate them."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:95
msgid "The `StorePacking` Trait"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:97
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into "
"fewer storage slots. `StorePacking<T, PackedT>` is a generic trait taking "
"the type you want to pack (`T`) and the destination type (`PackedT`) as "
"parameters. It provides two functions to implement: `pack` and `unpack`."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:99
msgid "Here is the implementation of the example of the previous chapter:"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:138
msgid "//don't forget to import it!\n"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:147
msgid ""
"// This will automatically pack the\n"
"        // struct into a single u128\n"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:155
msgid ""
"// this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:166
msgid "In this code snippet, you see that:"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:168
msgid ""
"`TWO_POW_8` and `TWO_POW_40` are used to shift left in the `pack` function "
"and shift right in the `unpack`function,"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:169
msgid ""
"`MASK_8` and `MASK_32` are used to isolate a variable in the `unpack` "
"function,"
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:170
msgid ""
"all the variables from the storage are converted to `u128` to be able to use "
"bitwise operators."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:172
msgid ""
"This technique can be used for any group of fields that fit within the bit "
"size of the packed storage type. For example, if you have a struct with "
"multiple fields whose bit sizes add up to 256 bits, you can pack them into a "
"single `u256` variable. If the bit sizes add up to 512 bits, you can pack "
"them into a single `u512` variable, and so on. You can define your own "
"structs and logic to pack and unpack them."
msgstr ""

#: src/ch16-01-optimizing-storage-costs.md:174
msgid ""
"The rest of the work is done magically by the compiler - if a type "
"implements the `StorePacking` trait, then the compiler will know it can use "
"the `StoreUsingPacking` implementation of the `Store` trait in order to pack "
"before writing and unpack after reading from storage. One important detail, "
"however, is that the type that `StorePacking::pack` spits out also has to "
"implement `Store` for `StoreUsingPacking` to work. Most of the time, we will "
"want to pack into a felt252 or u256 - but if you want to pack into a type of "
"your own, make sure that this one implements the `Store` trait."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:1
msgid "Components: Lego-Like Building Blocks for Smart Contracts"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and "
"bug-prone, as this logic can hardly be reused and needs to be reimplemented "
"in each contract. But what if there was a way to snap in just the extra "
"functionality you need inside your contract, separating the core logic of "
"your contract from the rest?"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating "
"reusable logic, storage, and events that can be incorporated into multiple "
"contracts. They can be used to extend a contract's functionality, without "
"having to reimplement the same logic over and over again."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts "
"by plugging in a module that you or someone else wrote. This module can be a "
"simple one, like an ownership component, or more complex like a full-fledged "
"ERC20 token."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and "
"functions. Unlike a contract, a component cannot be declared or deployed. "
"Its logic will eventually be part of the contract’s bytecode it has been "
"embedded in."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:24
msgid "What's in a Component?"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:28
msgid "Storage variables"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:29
msgid "Events"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:30
msgid "External and internal functions"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The "
"component's code becomes part of the contract it's embedded to."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:35
msgid "Creating Components"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a "
"`#[starknet::component]` attribute. Within this module, you can declare a ` "
"Storage` struct and `Event` enum, as usually done in "
"[contracts](./ch13-02-anatomy-of-a-simple-contract.md)."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:41
msgid ""
"The next step is to define the component interface, containing the "
"signatures of the functions that will allow external access to the "
"component's logic. You can define the interface of the component by "
"declaring a trait with the `#[starknet::interface]` attribute, just as you "
"would with contracts. This interface will be used to enable external access "
"to the component's functions using the "
"[dispatcher](./ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md) "
"pattern."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:48
msgid ""
"The actual implementation of the component's external logic is done in an "
"`impl` block marked as `#[embeddable_as(name)]`. Usually, this `impl` block "
"will be an implementation of the trait defining the interface of the "
"component."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:52
msgid ""
"Note: `name` is the name that we’ll be using in the contract to refer to the "
"component. It is different than the name of your impl."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:55
msgid ""
"You can also define internal functions that will not be accessible "
"externally, by simply omitting the `#[embeddable_as(name)]` attribute above "
"the internal `impl` block. You will be able to use these internal functions "
"inside the contract you embed the component in, but not interact with it "
"from outside, as they're not a part of the abi of the contract."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:61
msgid ""
"Functions within these `impl` block expect arguments like `ref self: "
"ComponentState<TContractState>` (for state-modifying functions) or `self: "
"@ComponentState<TContractState>` (for view functions). This makes the impl "
"generic over `TContractState`, allowing us to use this component in any "
"contract."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:70
msgid "Example: an Ownable Component"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:72
msgid ""
"⚠️ The example shown below has not been audited and is not intended for "
"production use. The authors are not responsible for any damages caused by "
"the use of this code."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available "
"externally to manage ownership of a contract, would look like this:"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:88
msgid "The component itself is defined as:"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:166
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The "
"only differences relate to the `#[embeddable_as]` attribute above the impl "
"and the genericity of the impl block that we will dissect in details."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:170
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to "
"the implementation of the interface trait, and one containing methods that "
"should not be exposed externally and are only meant for internal use. "
"Exposing the `assert_only_owner` as part of the interface wouldn't make "
"sense, as it's only meant to be used internally by a contract embedding the "
"component."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:176
msgid "A Closer Look at the `impl` Block"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:185
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable "
"inside a contract. It allows us to specify the name of the impl that will be "
"used in the contract to refer to this component. In this case, the component "
"will be referred to as `Ownable` in contracts embedding it."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:190
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, "
"with the added restriction that `TContractState` must implement the "
"`HasComponent<T>` trait. This allows us to use the component in any "
"contract, as long as the contract implements the `HasComponent` trait. "
"Understanding this mechanism in details is not required to use components, "
"but if you're curious about the inner workings, you can read more in the "
"[\"Components Under the Hood\"](./ch16-02-01-under-the-hood.md) section."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:197
msgid ""
"One of the major differences from a regular smart contract is that access to "
"storage and events is done via the generic `ComponentState<TContractState>` "
"type and not `ContractState`. Note that while the type is different, "
"accessing storage or emitting events is done similarly via "
"`self.storage_var_name.read()` or `self.emit(...).`"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:203
msgid ""
"Note: To avoid the confusion between the embeddable name and the impl name, "
"we recommend keeping the suffix `Impl` in the impl name."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:208
msgid "Migrating a Contract to a Component"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:210
msgid ""
"Since both contracts and components share a lot of similarities, it's "
"actually very easy to migrate from a contract to a component. The only "
"changes required are:"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:214
msgid "Adding the `#[starknet::component]` attribute to the module."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:215
msgid ""
"Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will "
"be embedded in another contract."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:217
msgid "Adding generic parameters to the `impl` block:"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:218
msgid "Adding `TContractState` as a generic parameter."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:219
msgid "Adding `+HasComponent<TContractState>` as an impl restriction."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:220
msgid ""
"Changing the type of the `self` argument in the functions inside the `impl` "
"block to `ComponentState<TContractState>` instead of `ContractState`."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:223
msgid ""
"For traits that do not have an explicit definition and are generated using "
"`#[generate_trait]`, the logic is the same - but the trait is generic over "
"`TContractState` instead of `ComponentState<TContractState>`, as "
"demonstrated in the example with the `InternalTrait`."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:228
msgid "Using Components Inside a Contract"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:230
msgid ""
"The major strength of components is how it allows reusing already built "
"primitives inside your contracts with a restricted amount of boilerplate. To "
"integrate a component into your contract, you need to:"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:234
msgid "Declare it with the `component!()` macro, specifying"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:236
msgid "The path to the component `path::to::component`."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:237
msgid ""
"The name of the variable in your contract's storage referring to this "
"component's storage (e.g. `ownable`)."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:239
msgid ""
"The name of the variant in your contract's event enum referring to this "
"component's events (e.g. `OwnableEvent`)."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:242
msgid ""
"Add the path to the component's storage and events to the contract's "
"`Storage` and `Event`. They must match the names provided in step 1 (e.g. "
"`ownable: ownable_component::Storage` and `OwnableEvent: "
"ownable_component::Event`)."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:247
msgid ""
"The storage variable **MUST** be annotated with the `#[substorage(v0)]` "
"attribute."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:250
msgid ""
"Embed the component's logic defined inside your contract, by instantiating "
"the component's generic impl with a concrete `ContractState` using an impl "
"alias. This alias must be annotated with `#[abi(embed_v0)]` to externally "
"expose the component's functions."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:255
msgid ""
"As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`. "
"Indeed, we don't want to expose externally the functions defined in this "
"impl. However, we might still want to access them internally."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:259
msgid ""
"For example, to embed the `Ownable` component defined above, we would do the "
"following:"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:297
msgid ""
"The component's logic is now seamlessly part of the contract! We can "
"interact with the components functions externally by calling them using the "
"`IOwnableDispatcher` instantiated with the contract's address."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:310
msgid "Stacking Components for Maximum Composability"
msgstr ""

#: src/ch16-02-00-composability-and-components.md:312
msgid ""
"The composability of components really shines when combining multiple of "
"them together. Each adds its features onto the contract. You can rely on "
"[Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) "
"implementation of components to quickly plug-in all the common "
"functionalities you need a contract to have."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:318
msgid ""
"Developers can focus on their core contract logic while relying on "
"battle-tested and audited components for everything else."
msgstr ""

#: src/ch16-02-00-composability-and-components.md:321
msgid ""
"Components can even [depend](./ch16-02-02-component-dependencies.md) on "
"other components by restricting the `TContractstate` they're generic on to "
"implement the trait of another component. Before we dive into this "
"mechanism, let's first look at [how components work under the "
"hood](./ch16-02-01-under-the-hood.md)."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:1
msgid "Components: Under the Hood"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to Starknet contracts. But how does "
"this magic actually happen behind the scenes?"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the "
"mechanisms that enable component composability."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:9
msgid "A Primer on Embeddable Impls"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:11
msgid "Before digging into components, we need to understand _embeddable impls_."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`) "
"can be made embeddable. Embeddable impls can be injected into any contract, "
"adding new entry points and modifying the ABI of the contract."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:17
msgid "Let's look at an example to see this in action:"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:42
msgid ""
"By embedding `SimpleImpl`, we externally expose `ret4` in the contract's ABI."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:44
msgid ""
"Now that we’re more familiar with the embedding mechanism, we can now see "
"how components build on this."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:47
msgid "Inside Components: Generic Impls"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:58
msgid "The key points:"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:60
msgid ""
"`OwnableImpl` requires the implementation of the "
"`HasComponent<TContractState>` trait by the underlying contract, which is "
"automatically generated with the `component!()` macro when using a component "
"inside a contract."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:65
msgid ""
"The compiler will generate an impl that wraps any function in `OwnableImpl`, "
"replacing the `self: ComponentState<TContractState>` argument with `self: "
"TContractState`, where access to the component state is made via the "
"`get_component` function in the `HasComponent<TContractState>` trait."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:70
msgid ""
"For each component, the compiler generates a `HasComponent` trait. This "
"trait defines the interface to bridge between the actual `TContractState` of "
"a generic contract, and `ComponentState<TContractState>`."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:75
msgid "// generated per component\n"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:85
msgid ""
"In our context `ComponentState<TContractState>` is a type specific to the "
"ownable component, i.e. it has members based on the storage variables "
"defined in `ownable_component::Storage`. Moving from the generic "
"`TContractState` to `ComponentState<TContractState>` will allow us to embed "
"`Ownable` in any contract that wants to use it. The opposite direction "
"(`ComponentState<TContractState>` to `ContractState`) is useful for "
"dependencies (see the `Upgradeable` component depending on an `IOwnable` "
"implementation example in the [Components dependencies "
"](./ch16-02-02-component-dependencies.md) section)."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:94
msgid ""
"To put it briefly, one should think of an implementation of the above "
"`HasComponent<T>` as saying: **“Contract whose state T has the upgradeable "
"component”.**"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:98
msgid "`Ownable` is annotated with the `embeddable_as(<name>)` attribute:"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:100
msgid ""
"`embeddable_as` is similar to `embeddable`; it only applies to impls of "
"`starknet::interface` traits and allows embedding this impl in a contract "
"module. That said, `embeddable_as(<name>)` has another role in the context "
"of components. Eventually, when embedding `OwnableImpl` in some contract, we "
"expect to get an impl with the following functions:"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:112
msgid ""
"Note that while starting with a function receiving the generic type "
"`ComponentState<TContractState>`, we want to end up with a function "
"receiving `ContractState`. This is where `embeddable_as(<name>)` comes in. "
"To see the full picture, we need to see what is the impl generated by the "
"compiler due to the `embeddable_as(Ownable)` annotation:"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:140
msgid ""
"Note that thanks to having an impl of `HasComponent<TContractState>`, the "
"compiler was able to wrap our functions in a new impl that doesn’t directly "
"know about the `ComponentState` type. `Ownable`, whose name we chose when "
"writing `embeddable_as(Ownable)`, is the impl that we will embed in a "
"contract that wants ownership."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:146
msgid "Contract Integration"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:148
msgid ""
"We've seen how generic impls enable component reusability. Next let's see "
"how a contract integrates a component."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:151
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic "
"impl with the concrete `ContractState` of the contract."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:161
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl "
"alias syntax. We’re instantiating the generic `OwnableImpl<TContractState>` "
"with the concrete type `ContractState`. Recall that "
"`OwnableImpl<TContractState>` has the `HasComponent<TContractState>` generic "
"impl parameter. An implementation of this trait is generated by the "
"`component!` macro."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:167
msgid ""
"Note that only the using contract could have implemented this trait since "
"only it knows about both the contract state and the component state."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:171
msgid ""
"This glues everything together to inject the component logic into the "
"contract."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:173
msgid "Key Takeaways"
msgstr ""

#: src/ch16-02-01-under-the-hood.md:175
msgid ""
"Embeddable impls allow injecting components logic into contracts by adding "
"entry points and modifying the contract ABI."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:177
msgid ""
"The compiler automatically generates a `HasComponent` trait implementation "
"when a component is used in a contract. This creates a bridge between the "
"contract's state and the component's state, enabling interaction between the "
"two."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:181
msgid ""
"Components encapsulate reusable logic in a generic, contract-agnostic way. "
"Contracts integrate components through impl aliases and access them via the "
"generated `HasComponent` trait."
msgstr ""

#: src/ch16-02-01-under-the-hood.md:184
msgid ""
"Components build on embeddable impls by defining generic component logic "
"that can be integrated into any contract wanting to use that component. Impl "
"aliases instantiate these generic impls with the contract's concrete storage "
"types."
msgstr ""

#: src/ch16-02-02-component-dependencies.md:3
msgid ""
"Working with components becomes more complex when we try to use one "
"component inside another. As mentioned earlier, a component can only be "
"embedded within a contract, meaning that it's not possible to embed a "
"component within another component. However, this doesn't mean that we can't "
"use one component inside another. In this section, we will see how to use a "
"component as a dependency of another component."
msgstr ""

#: src/ch16-02-02-component-dependencies.md:5
msgid ""
"Consider a component called `OwnableCounter` whose purpose is to create a "
"counter that can only be incremented by its owner. This component can be "
"embedded in any contract, so that any contract that uses it will have a "
"counter that can only be incremented by its owner."
msgstr ""

#: src/ch16-02-02-component-dependencies.md:7
msgid ""
"The first way to implement this is to create a single component that "
"contains both counter and ownership features from within a single component. "
"However, this approach is not recommended: our goal is to minimize the "
"amount of code duplication and take advantage of component reusability. "
"Instead, we can create a new component that _depends_ on the `Ownable` "
"component for the ownership features, and internally defines the logic for "
"the counter."
msgstr ""

#: src/ch16-02-02-component-dependencies.md:9
msgid ""
"Listing 16-1 shows the complete implementation, which we'll break down right "
"after:"
msgstr ""

#: src/ch16-02-02-component-dependencies.md:58
msgid "<span class=\"caption\">Listing 16-1: An OwnableCounter Component</span>"
msgstr ""

#: src/ch16-02-02-component-dependencies.md:60
msgid "Specificities"
msgstr ""

#: src/ch16-02-02-component-dependencies.md:62
msgid "Specifying Dependencies on Another Component"
msgstr ""

#: src/ch16-02-02-component-dependencies.md:73
msgid ""
"In [chapter 8](./ch08-02-traits-in-cairo.md), we introduced trait bounds, "
"which are used to specify that a generic type must implement a certain "
"trait. In the same way, we can specify that a component depends on another "
"component by restricting the `impl` block to be available only for contracts "
"that contain the required component. In our case, this is done by adding a "
"restriction `impl Owner: ownable_component::HasComponent<TContractState>`, "
"which indicates that this `impl` block is only available for contracts that "
"contain an implementation of the `ownable_component::HasComponent` trait. "
"This essentially means that the \\`TContractState' type has access to the "
"ownable component. See [Components under the "
"hood](ch16-02-01-under-the-hood.md#inside-components-generic-impls) for more "
"information."
msgstr ""

#: src/ch16-02-02-component-dependencies.md:76
msgid ""
"Although most of the trait bounds were defined using \\[anonymous "
"parameters\\]\\[anonymous generic impl operator\\], the dependency on the "
"`Ownable` component is defined using a named parameter (here, `Owner`). We "
"will need to use this explicit name when accessing the `Ownable`component "
"within the`impl` block."
msgstr ""

#: src/ch16-02-02-component-dependencies.md:78
msgid ""
"While this mechanism is verbose and may not be easy to approach at first, it "
"is a powerful leverage of the trait system in Cairo. The inner workings of "
"this mechanism are abstracted away from the user, and all you need to know "
"is that when you embed a component in a contract, all other components in "
"the same contract can access it."
msgstr ""

#: src/ch16-02-02-component-dependencies.md:82
msgid ""
"\\[anonymous generic impl operator\\]: ./ch08-01-generic-data-types "
"md#anonymous-generic-implementation-parameter--operator"
msgstr ""

#: src/ch16-02-02-component-dependencies.md:84
msgid "Using the Dependency"
msgstr ""

#: src/ch16-02-02-component-dependencies.md:86
msgid ""
"Now that we have made our `impl` depend on the `Ownable` component, we can "
"access its functions, storage, and events within the implementation block. "
"To bring the `Ownable` component into scope, we have two choices, depending "
"on whether we intend to mutate the state of the `Ownable` component or not. "
"If we want to access the state of the `Ownable` component without mutating "
"it, we use the `get_dep_component!` macro. If we want to mutate the state of "
"the `Ownable` component (for example, change the current owner), we use the "
"`get_dep_component_mut!` macro. Both macros take two arguments: the first is "
"`self`, either as a snapshot or by reference depending on mutability, "
"representing the state of the component using the dependency, and the second "
"is the component to access."
msgstr ""

#: src/ch16-02-02-component-dependencies.md:98
msgid ""
"In this function, we want to make sure that only the owner can call the "
"`increment` function. We need to use the `assert_only_owner` function from "
"the `Ownable` component. We'll use the `get_dep_component!` macro which will "
"return a snapshot of the requested component state, and call "
"`assert_only_owner` on it, as a method of that component."
msgstr ""

#: src/ch16-02-02-component-dependencies.md:101
msgid ""
"For the `transfer_ownership` function, we want to mutate that state to "
"change the current owner. We need to use the `get_dep_component_mut!` macro, "
"which will return the requested component state as a mutable reference, and "
"call `transfer_ownership` on it."
msgstr ""

#: src/ch16-02-02-component-dependencies.md:112
msgid ""
"It works exactly the same as `get_dep_component!` except that we need to "
"pass the state as a `ref` so we can mutate it to transfer the ownership."
msgstr ""

#: src/ch16-02-03-testing-components.md:3
msgid ""
"Testing components is a bit different than testing contracts. Contracts need "
"to be tested against a specific state, which can be achieved by either "
"deploying the contract in a test, or by simply getting the `ContractState` "
"object and modifying it in the context of your tests."
msgstr ""

#: src/ch16-02-03-testing-components.md:6
msgid ""
"Components are a generic construct, meant to be integrated in contracts, "
"that can't be deployed on their own and don't have a `ContractState` object "
"that we could use. So how do we test them?"
msgstr ""

#: src/ch16-02-03-testing-components.md:8
msgid ""
"Let's consider that we want to test a very simple component called "
"\"Counter\", that will allow each contract to have a counter that can be "
"incremented. The component is defined in Listing 16-2:"
msgstr ""

#: src/ch16-02-03-testing-components.md:33
msgid "<span class=\"caption\">Listing 16-2: A simple Counter component</span>"
msgstr ""

#: src/ch16-02-03-testing-components.md:35
msgid "Testing the Component by Deploying a Mock Contract"
msgstr ""

#: src/ch16-02-03-testing-components.md:37
msgid ""
"The easiest way to test a component is to integrate it within a mock "
"contract. This mock contract is only used for testing purposes, and only "
"integrates the component you want to test. This allows you to test the "
"component in the context of a contract, and to use a Dispatcher to call the "
"component's entry points."
msgstr ""

#: src/ch16-02-03-testing-components.md:39
msgid "We can define such a mock contract as follows:"
msgstr ""

#: src/ch16-02-03-testing-components.md:65
msgid ""
"This contract is entirely dedicated to testing the `Counter` component. It "
"embeds the component with the `component!` macro, exposes the component's "
"entry points by annotating the impl aliases with `#[abi(embed_v0)]`."
msgstr ""

#: src/ch16-02-03-testing-components.md:67
msgid ""
"We also need to define an interface that will be required to interact "
"externally with this mock contract."
msgstr ""

#: src/ch16-02-03-testing-components.md:77
msgid ""
"We can now write tests for the component by deploying this mock contract and "
"calling its entry points, as we would with a typical contract."
msgstr ""

#: src/ch16-02-03-testing-components.md:107
msgid "Testing Components Without Deploying a Contract"
msgstr ""

#: src/ch16-02-03-testing-components.md:109
msgid ""
"In [Components under the hood](./ch16-02-01-under-the-hood.md), we saw that "
"components leveraged genericity to define storage and logic that could be "
"embedded in multiple contracts. If a contract embeds a component, a "
"`HasComponent` trait is created in this contract, and the component methods "
"are made available."
msgstr ""

#: src/ch16-02-03-testing-components.md:111
msgid ""
"This informs us that if we can provide a concrete `TContractState` that "
"implements the `HasComponent` trait to the `ComponentState` struct, should "
"be able to directly invoke the methods of the component using this concrete "
"`ComponentState` object, without having to deploy a mock."
msgstr ""

#: src/ch16-02-03-testing-components.md:113
msgid ""
"Let's see how we can do that by using type aliases. We still need to define "
"a mock contract - let's use the same as above - but this time, we won't need "
"to deploy it."
msgstr ""

#: src/ch16-02-03-testing-components.md:115
msgid ""
"First, we need to define a concrete implementation of the generic "
"`ComponentState` type using a type alias. We will use the "
"`MockContract::ContractState` type to do so."
msgstr ""

#: src/ch16-02-03-testing-components.md:123
#: src/ch16-02-03-testing-components.md:167
msgid "// You can derive even `Default` on this type alias\n"
msgstr ""

#: src/ch16-02-03-testing-components.md:144
msgid ""
"We defined the `TestingState` type as an alias of the "
"`CounterComponent::ComponentState<MockContract::ContractState>` type. By "
"passing the `MockContract::ContractState` type as a concrete type for "
"`ComponentState`, we aliased a concrete implementation of the "
"`ComponentState` struct to `TestingState`."
msgstr ""

#: src/ch16-02-03-testing-components.md:146
msgid ""
"Because `MockContract` embeds `CounterComponent`, the methods of "
"`CounterComponent` defined in the `CounterImpl` block can now be used on a "
"`TestingState` object."
msgstr ""

#: src/ch16-02-03-testing-components.md:148
msgid ""
"Now that we have made these methods available, we need to instantiate an "
"object of type `TestingState`, that we will use to test the component. We "
"can do so by calling the `component_state_for_testing` function, which "
"automatically infers that it should return an object of type `TestingState`."
msgstr ""

#: src/ch16-02-03-testing-components.md:150
msgid ""
"We can even implement this as part of the `Default` trait, which allows us "
"to return an empty `TestingState` with the `Default::default()` syntax."
msgstr ""

#: src/ch16-02-03-testing-components.md:152
msgid "Let's summarize what we've done so far:"
msgstr ""

#: src/ch16-02-03-testing-components.md:154
msgid "We defined a mock contract that embeds the component we want to test."
msgstr ""

#: src/ch16-02-03-testing-components.md:155
msgid ""
"We defined a concrete implementation of `ComponentState<TContractState>` "
"using a type alias with `MockContract::ContractState`, that we named "
"`TestingState`."
msgstr ""

#: src/ch16-02-03-testing-components.md:156
msgid ""
"We defined a function that uses `component_state_for_testing` to return a "
"`TestingState` object."
msgstr ""

#: src/ch16-02-03-testing-components.md:158
msgid ""
"We can now write tests for the component by calling its functions directly, "
"without having to deploy a mock contract. This approach is more lightweight "
"than the previous one, and it allows testing internal functions of the "
"component that are not exposed to the outside world trivially."
msgstr ""

#: src/ch16-03-upgradeability.md:1
msgid "Upgradeable Contracts"
msgstr ""

#: src/ch16-03-upgradeability.md:3
msgid ""
"Starknet separates contracts into classes and instances, making it simple to "
"upgrade a contract's logic without affecting its state."
msgstr ""

#: src/ch16-03-upgradeability.md:5
msgid ""
"A contract class is the definition of the semantics of a contract. It "
"includes the entire logic of a contract: the name of the entry points, the "
"addresses of the storage variables, the events that can be emitted, etc. "
"Each class is uniquely identified by its class hash. A class does not have "
"its own storage: it's only a definition of logic."
msgstr ""

#: src/ch16-03-upgradeability.md:7
msgid ""
"Classes are typically identified by a [class "
"hash](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash). "
"When declaring a class, the network registers it and assigns a unique hash "
"used to identify the class and deploy contract instances from it."
msgstr ""

#: src/ch16-03-upgradeability.md:9
msgid ""
"A contract instance is a deployed contract corresponding to a class, with "
"its own storage."
msgstr ""

#: src/ch16-03-upgradeability.md:11
msgid ""
"Starknet natively supports upgradeable contracts through the "
"`replace_class_syscall` [system "
"call](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/), "
"enabling simple contract upgrades without affecting the contract's state."
msgstr ""

#: src/ch16-03-upgradeability.md:16
msgid "Upgrading Contracts"
msgstr ""

#: src/ch16-03-upgradeability.md:18
msgid ""
"To upgrade a contract, expose an entry point that executes "
"`replace_class_syscall` with the new class hash as an argument:"
msgstr ""

#: src/ch16-03-upgradeability.md:31
msgid ""
"<span class=\"caption\">Listing 16-3: Exposing `replace_class_syscall` to "
"update the contract's class</span>"
msgstr ""

#: src/ch16-03-upgradeability.md:33
msgid ""
"Note: Thoroughly review changes and potential impacts before upgrading, as "
"it's a delicate procedure with security implications. Don't allow arbitrary "
"addresses to upgrade your contract."
msgstr ""

#: src/ch16-03-upgradeability.md:35
msgid "Upgradeable Component"
msgstr ""

#: src/ch16-03-upgradeability.md:37
msgid ""
"OpenZeppelin Contracts for Cairo provides the `Upgradeable` component that "
"can be embedded into your contract to make it upgradeable. This component is "
"a simple way to add upgradeability to your contract while relying on an "
"audited library. It can be combined with the `Ownable` component to restrict "
"the upgradeability to a single address, so that the contract owner has the "
"exclusive right to upgrade the contract."
msgstr ""

#: src/ch16-03-upgradeability.md:51
msgid "/// Ownable\n"
msgstr ""

#: src/ch16-03-upgradeability.md:56
msgid "/// Upgradeable\n"
msgstr ""

#: src/ch16-03-upgradeability.md:84
msgid "// This function can only be called by the owner\n"
msgstr ""

#: src/ch16-03-upgradeability.md:87
msgid "// Replace the class hash upgrading the contract\n"
msgstr ""

#: src/ch16-03-upgradeability.md:94
msgid ""
"<span class=\"caption\">Listing 16-4 Integrating OpenZeppelin's Upgradeable "
"component in a contract</span>"
msgstr ""

#: src/ch16-03-upgradeability.md:96
msgid ""
"For more information, please refer to the [OpenZeppelin docs API "
"reference](https://docs.openzeppelin.com/contracts-cairo/0.9.0/api/upgrades)."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:1
msgid "L1-L2 Messaging"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:3
msgid "A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` messaging system, which is different from its "
"consensus mechanism and the submission of state updates on L1. Messaging is "
"a way for smart-contracts on L1 to interact with smart-contracts on L2 (or "
"the other way around), allowing us to do \"cross-chain\" transactions. For "
"example, we can do some computations on a chain and use the result of this "
"computation on the other chain."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to "
"bridge tokens from Ethereum to Starknet. You will simply have to deposit "
"your tokens in the L1 bridge contract, which will automatically trigger the "
"minting of the same token on L2. Another good use case for `L1-L2` messaging "
"would be [DeFi pooling](https://starkware.co/resource/defi-pooling/)."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:9
msgid ""
"On Starknet, it's important to note that the messaging system is "
"**asynchronous** and **asymmetric**."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:11
msgid ""
"**Asynchronous**: this means that in your contract code (being Solidity or "
"Cairo), you can't wait the result of the message being sent on the other "
"chain within your contract code execution."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:12
msgid ""
"**Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is "
"fully automated by the Starknet sequencer, which means that the message is "
"being automatically delivered to the target contract on L2. However, when "
"sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the "
"message is sent on L1 by the Starknet sequencer. You must then consume the "
"message manually via a transaction on L1."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:18
msgid "The StarknetMessaging Contract"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:20
msgid ""
"The crucial component of the `L1-L2` Messaging system is the "
"[`StarknetCore`](https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4) "
"contract. It is a set of Solidity contracts deployed on Ethereum that allows "
"Starknet to function properly. One of the contracts of `StarknetCore` is "
"called `StarknetMessaging` and it is the contract responsible for passing "
"messages between Starknet and Ethereum. `StarknetMessaging` follows an "
"[interface](https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6) "
"with functions allowing to send message to L2, receiving messages on L1 from "
"L2 and canceling messages."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:51
msgid "<span class=\"caption\"> Starknet messaging contract interface</span>"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:53
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly "
"listening to the logs emitted by the `StarknetMessaging` contract on "
"Ethereum. Once a message is detected in a log, the sequencer prepares and "
"executes a `L1HandlerTransaction` to call the function on the target L2 "
"contract. This takes up to 1-2 minutes to be done (few seconds for ethereum "
"block to be mined, and then the sequencer must build and execute the "
"transaction)."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:56
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of "
"the block produced. When the sequencer produces a block, it sends the hash "
"of each message prepared by contracts execution to the `StarknetCore` "
"contract on L1, where they can then be consumed once the block they belong "
"to is proven and verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:62
msgid "Sending Messages from Ethereum to Starknet"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:64
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity "
"contracts must call the `sendMessageToL2` function of the "
"`StarknetMessaging` contract. To receive these messages on Starknet, you "
"will need to annotate functions that can be called from L1 with the "
"`#[l1_handler]` attribute."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:66
msgid ""
"Let's take a simple contract taken from [this "
"tutorial](https://github.com/glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol) "
"where we want to send a message to Starknet. The `_snMessaging` is a state "
"variable already initialized with the address of the `StarknetMessaging` "
"contract. You can check all Starknet contract and sequencer addresses "
"[here](https://docs.starknet.io/documentation/tools/important_addresses/)."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:70
msgid "// Sends a message on Starknet with a single felt.\n"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:79
msgid ""
"// We \"serialize\" here the felt into a payload, which is an array of "
"uint256.\n"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:83
msgid "// msg.value must always be >= 20_000 wei.\n"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:92
msgid ""
"The function sends a message with a single felt value to the "
"`StarknetMessaging` contract. Please note that if you want to send more "
"complex data you can. Just be aware that your Cairo contract will only "
"understand `felt252` data type. So you must ensure that the serialization of "
"your data into the `uint256` array follow the Cairo serialization scheme."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:95
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the "
"minimum value we've to send here is `20k wei`, due to the fact that the "
"`StarknetMessaging` contract will register the hash of our message in the "
"storage of Ethereum."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:98
msgid ""
"In addition to those `20k wei`, since the `L1HandlerTransaction` executed by "
"the sequencer is not tied to any account (the message originates from L1), "
"you must also ensure that you pay enough fees on L1 for your message to be "
"deserialized and processed on L2."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:101
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as "
"it would be done for an `Invoke` transaction. For this, you can profile the "
"gas consumption using `starkli` or `snforge` to estimate the cost of your "
"message execution."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:104
msgid "The signature of the `sendMessageToL2` is:"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:114
msgid "The parameters are as follows:"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:116
msgid "`toAddress`: The contract address on L2 that will be called."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:117
msgid ""
"`selector`: The selector of the function of this contract at `toAddress`. "
"This selector (function) must have the `#[l1_handler]` attribute to be "
"callable."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:118
msgid ""
"`payload`: The payload is always an array of `felt252` (which are "
"represented by `uint256` in Solidity). For this reason we've inserted the "
"input `myFelt` into the array. This is why we need to insert the input data "
"into an array."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:121
msgid "On the Starknet side, to receive this message, we have:"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:128
msgid ""
"// You can now use the data, automatically deserialized from the message "
"payload.\n"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:133
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers "
"are special functions that can only be executed by a `L1HandlerTransaction`. "
"There is nothing particular to do to receive transactions from L1, as the "
"message is relayed by the sequencer automatically. In your `#[l1_handler]` "
"functions, it is important to verify the sender of the L1 message to ensure "
"that our contract can only receive messages from a trusted L1 contract."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:138
msgid "Sending Messages from Starknet to Ethereum"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:140
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the "
"`send_message_to_l1` syscall in your Cairo contracts. This syscall allows "
"you to send messages to the `StarknetMessaging` contract on L1. Unlike "
"`L1->L2` messages, `L2->L1` messages must be consumed manually, which means "
"that you will need your Solidity contract to call the `consumeMessageFromL2` "
"function of the `StarknetMessaging` contract explicitly in order to consume "
"the message."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:142
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:146
msgid ""
"// Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:153
msgid ""
"We simply build the payload and pass it, along with the L1 contract address, "
"to the syscall function."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:155
msgid ""
"On L1, the important part is to build the same payload sent by the L2. Then "
"you call `consumeMessageFromL2` in you Solidity contract by passing the L2 "
"contract address and the payload. Please be aware that the L2 contract "
"address expected by the `consumeMessageFromL2` is the address of the "
"contract that sends the message on the L2 by calling "
"`send_message_to_l1_syscall`."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:166
msgid "// You can use the message hash if you want here.\n"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:168
msgid ""
"// We expect the payload to contain only a felt252 value (which is a uint256 "
"in Solidity).\n"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:169
msgid "\"Invalid payload\""
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:173
msgid ""
"// From here, you can safely use `my_felt` as the message has been verified "
"by StarknetMessaging.\n"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:174
msgid "\"Invalid value\""
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:178
msgid ""
"As you can see, in this context we don't have to verify which contract from "
"L2 is sending the message (as we do on the L2 to verify which contract from "
"L1 is sending the message). But we are actually using the "
"`consumeMessageFromL2` of the `StarknetCore` contract to validate the inputs "
"(the contract address on L2 and the payload) to ensure we are only consuming "
"valid messages."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:180
msgid ""
"**Note:** The `consumeMessageFromL2` function of the `StarknetCore` contract "
"is expected to be called from a Solidity contract, and not directly on the "
"`StarknetCore` contract. The reason of that is because the `StarknetCore` "
"contract is using `msg.sender` to actually compute the hash of the message. "
"And this `msg.sender` must correspond to the `to_address` field that is "
"given to the function `send_message_to_l1_syscall` that is called on "
"Starknet."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:182
msgid ""
"It is important to remember that on L1 we are sending a payload of "
"`uint256`, but the basic data type on Starknet is `felt252`; however, "
"`felt252` are approximately 4 bits smaller than `uint256`. So we have to pay "
"attention to the values contained in the payload of the messages we are "
"sending. If, on L1, we build a message with values above the maximum "
"`felt252`, the message will be stuck and never consumed on L2."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:184
msgid "Cairo Serde"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:186
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet "
"contracts, written in Cairo, can only understand serialized data. And "
"serialized data is always an array of `felt252`. In Solidity we have "
"`uint256` type, and `felt252` are approximately 4 bits smaller than "
"`uint256`. So we have to pay attention to the values contained in the "
"payload of the messages we are sending. If, on L1, we build a message with "
"values above the maximum `felt252`, the message will be stuck and never "
"consumed on L2."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:190
msgid ""
"So for instance, an actual `uint256` value in Cairo is represented by a "
"struct like:"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:199
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for "
"the `high`. This means that to send only one `u256` to Cairo, you'll need to "
"send a payload from L1 with **TWO** values."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:202
msgid "// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:208
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the "
"[Starknet "
"documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/)."
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:210
msgid ""
"You can also find a [detailed guide "
"here](https://github.com/glihm/starknet-messaging-dev) to test the messaging "
"system locally."
msgstr ""

#: src/ch16-05-oracle-interactions.md:3
msgid ""
"This section focuses on the concept of bringing off-chain data to the "
"Starknet blockchain using oracles. Oracles are third-party services that "
"serve as intermediaries, securely transmitting external data, such as asset "
"prices, weather information, or other real-world data, to blockchains and "
"smart contracts. It also provides practical examples and code snippets "
"demonstrating how developers can interact with a specific oracle named "
"Pragma on Starknet network, covering topics like querying and handling price "
"data, and verifiable random function (VRF) to generate random numbers."
msgstr ""

#: src/ch16-05-01-price-feeds.md:3
msgid ""
"Price feeds enabled by an oracle serve as a bridge between real-world data "
"feed and the blockchain. They provide real time pricing data that is "
"aggregated from multiple trusted external sources ( e.g. crypto exchanges, "
"financial data providers, etc. ) to the blockchain network."
msgstr ""

#: src/ch16-05-01-price-feeds.md:5
msgid ""
"For the example in this book section, we will use Pragma Oracle to read the "
"price feed for `ETH/USD` asset pair and also showcase a mini application "
"that utilizes this feed."
msgstr ""

#: src/ch16-05-01-price-feeds.md:7
msgid ""
"[Pragma Oracle](https://www.pragma.build/) is a leading zero knowledge "
"oracle that provides access to off-chain data on Starknet blockchain in a "
"verifiable way."
msgstr ""

#: src/ch16-05-01-price-feeds.md:9
msgid "Add Pragma as a Project Dependency"
msgstr ""

#: src/ch16-05-01-price-feeds.md:11
msgid ""
"To get started with integrating Pragma on your Cairo smart contract for "
"price feed data, edit your project's `Scarb.toml` file to include the path "
"to use Pragma."
msgstr ""

#: src/ch16-05-01-price-feeds.md:13 src/ch16-05-02-randomness.md:20
msgid ""
"```toml\n"
"[dependencies]\n"
"pragma_lib = { git = \"https://github.com/astraly-labs/pragma-lib\" }\n"
"```"
msgstr ""

#: src/ch16-05-01-price-feeds.md:18
msgid "Creating a Price Feed Contract"
msgstr ""

#: src/ch16-05-01-price-feeds.md:20
msgid ""
"After adding the required dependencies for your project, you'll need to "
"define a contract interface that includes the required pragma price feed "
"entry point."
msgstr ""

#: src/ch16-05-01-price-feeds.md:22
msgid "Contract Interface"
msgstr ""

#: src/ch16-05-01-price-feeds.md:32
msgid ""
"Of the two public functions exposed in the `IPriceFeedExample`, the one "
"necessary to interact with the pragma price feed oracle is the "
"`get_asset_price` function, a view function that takes in the `asset_id` "
"argument and returns a `u128` value."
msgstr ""

#: src/ch16-05-01-price-feeds.md:34
msgid "Pragma Dependency Import to Contract"
msgstr ""

#: src/ch16-05-01-price-feeds.md:41
msgid ""
"The snippet above shows the necessary imports you need to add to your "
"contract module in order to interact with the Pragma oracle."
msgstr ""

#: src/ch16-05-01-price-feeds.md:43
msgid "Required Price Feed Function Impl in Contract"
msgstr ""

#: src/ch16-05-01-price-feeds.md:47 src/ch16-05-01-price-feeds.md:117
msgid "// Retrieve the oracle dispatcher\n"
msgstr ""

#: src/ch16-05-01-price-feeds.md:52 src/ch16-05-01-price-feeds.md:122
msgid "// Call the Oracle contract, for a spot entry\n"
msgstr ""

#: src/ch16-05-01-price-feeds.md:60
msgid ""
"The `get_asset_price` function is responsible for retrieving the price of "
"the asset specified by the `asset_id` argument from Pragma Oracle. The "
"`get_data_median` method is called from the `IPragmaDispatcher` instance by "
"passing the `DataType::SpotEntry(asset_id)` as an argument and its output is "
"assigned to a variable named `output` of type `PragmaPricesResponse`. "
"Finally, the function returns the price of the requested asset as a `u128`."
msgstr ""

#: src/ch16-05-01-price-feeds.md:62
msgid "Example Application Using Pragma Price Feed"
msgstr ""

#: src/ch16-05-01-price-feeds.md:96
msgid "// Calculate the amount of ETH needed\n"
msgstr ""

#: src/ch16-05-01-price-feeds.md:102 src/ch16-05-02-randomness.md:228
msgid "// ETH Contract Address\n"
msgstr ""

#: src/ch16-05-01-price-feeds.md:105
msgid "// Transfer the ETH to the caller\n"
msgstr ""

#: src/ch16-05-01-price-feeds.md:132
msgid ""
"Note: Pragma returns the value of different token pairs using the decimal "
"factor of 6 or 8. You can convert the value to the required decimal factor "
"by dividing the value by \\\\( {10^{n}} \\\\), where `n` is the decimal "
"factor."
msgstr ""

#: src/ch16-05-01-price-feeds.md:134
msgid ""
"The code above is an example implementation of an applications consuming a "
"price feed from the Pragma oracle. The contract imports necessary modules "
"and interfaces, including the `IPragmaABIDispatcher` for interacting with "
"the Pragma oracle contract and the `ERC20ABIDispatcher` for interacting with "
"the ETH ERC20 token contract."
msgstr ""

#: src/ch16-05-01-price-feeds.md:136
msgid ""
"The contract has a `const` that stores the token pair ID of `ETH/USD`, and a "
"`Storage` struct that holds two fields `pragma_contract` and "
"`product_price_in_usd`. The constructor function initializes the "
"`pragma_contract` address and sets the `product_price_in_usd` to 100."
msgstr ""

#: src/ch16-05-01-price-feeds.md:138
msgid ""
"The `buy_item` function is the main entry point for a user to purchase an "
"item. It retrieves the caller's address. It calls the `get_asset_price` "
"function to get the current price of ETH in USD using the `ETH_USD` asset "
"ID. It calculates the amount of ETH needed to buy the product based on the "
"product price in USD at the corresponding ETH price. It then checks if the "
"caller has enough ETH by calling the `balance_of` method on the ERC20 ETH "
"contract. If the caller has enough ETH, it calls the `transfer_from` method "
"of the `eth_dispatcher` instance to transfer the required amount of ETH from "
"the caller to another contract address."
msgstr ""

#: src/ch16-05-01-price-feeds.md:140
msgid ""
"The `get_asset_price` function is the entry point to interact with the "
"Pragma oracle and has been explained in the section above."
msgstr ""

#: src/ch16-05-01-price-feeds.md:142
msgid ""
"You can get a detailed guide on consuming data using Pragma price feeds "
"[here](https://docs.pragma.build/Resources/Cairo%201/data-feeds/consuming-data)."
msgstr ""

#: src/ch16-05-02-randomness.md:3
msgid ""
"Since all blockchains are fundamentally deterministic and most are public "
"ledgers, generating truly unpredictatable randomness on-chain presents a "
"challenge. This randomness is crucial for fair outcomes in gaming, "
"lotteries, and unique generation of NFTs. To address this, verifiable random "
"functions (VRFs) provided by oracles offer a solution. VRFs guarantee that "
"the randomness can't be predicted or tampered with, ensuring trust and "
"transparency in these applications."
msgstr ""

#: src/ch16-05-02-randomness.md:5
msgid "Overview on VRFs"
msgstr ""

#: src/ch16-05-02-randomness.md:7
msgid ""
"Pseudo-random but secure: VRFs use a secret key and a nonce (a unique input) "
"to generate an output that appears random. While technically "
"'pseudo-random', it's practically impossible for another party to predict "
"the outcome without knowing the secret key."
msgstr ""

#: src/ch16-05-02-randomness.md:9
msgid ""
"Verifiable output: VRFs produce not only the random number but also a proof "
"that anyone can use to independently verify that the result was generated "
"correctly according to the function's parameters."
msgstr ""

#: src/ch16-05-02-randomness.md:11
msgid "Generating Randomness with Pragma"
msgstr ""

#: src/ch16-05-02-randomness.md:13
msgid ""
"[Pragma](https://www.pragma.build/), an oracle on Starknet provides a "
"solution for generating random numbers using VRFs. Let's dive into how to "
"use Pragma VRF to generate a random number in a simple dice game contract."
msgstr ""

#: src/ch16-05-02-randomness.md:16
msgid "Add Pragma as a Dependency"
msgstr ""

#: src/ch16-05-02-randomness.md:18
msgid ""
"Edit your cairo project's `Scarb.toml` file to include the path to use "
"Pragma."
msgstr ""

#: src/ch16-05-02-randomness.md:61
msgid ""
"<span class=\"caption\">Listing 16-5 shows a contract interfaces for Pragma "
"VRF and a simple dice game.</span>"
msgstr ""

#: src/ch16-05-02-randomness.md:63
msgid "Description of Key IPragmaVRF Entrypoints and Their Inputs"
msgstr ""

#: src/ch16-05-02-randomness.md:65
msgid ""
"The function `request_randomness_from_pragma` initiates a request for "
"verifiable randomness from the Pragma oracle. It does this by emitting an "
"event that triggers the following actions off-chain:"
msgstr ""

#: src/ch16-05-02-randomness.md:67
msgid ""
"Randomness generation: The oracle generates random values and a "
"corresponding proof."
msgstr ""

#: src/ch16-05-02-randomness.md:68
msgid ""
"On-chain submission: The oracle submits the generated randomness and proof "
"back to the blockchain via the `receive_random_words` callback function."
msgstr ""

#: src/ch16-05-02-randomness.md:70
msgid "`request_randomness_from_pragma` Inputs"
msgstr ""

#: src/ch16-05-02-randomness.md:72
msgid ""
"`seed`: A value used to initialize the randomness generation process. This "
"should be unique to ensure unpredictable results."
msgstr ""

#: src/ch16-05-02-randomness.md:73
msgid ""
"`callback_address`: The contract address where the `receive_random_words` "
"function will be called to deliver the generated randomness. It is typically "
"the address of your deployed contract implementing Pragma VRF."
msgstr ""

#: src/ch16-05-02-randomness.md:74
msgid ""
"`callback_fee_limit`: The maximum amount of gas you're willing to spend on "
"executing the `receive_random_words` callback function."
msgstr ""

#: src/ch16-05-02-randomness.md:75
msgid ""
"`publish_delay`: The minimum delay (in blocks) between requesting randomness "
"and the oracle fulfilling the request."
msgstr ""

#: src/ch16-05-02-randomness.md:76
msgid ""
"`num_words`: The number of random values (each represented as a `felt252`) "
"you want to receive in a single callback."
msgstr ""

#: src/ch16-05-02-randomness.md:77
msgid ""
"`calldata`: Additional data you want to pass to the `receive_random_words` "
"callback function."
msgstr ""

#: src/ch16-05-02-randomness.md:79
msgid "`receive_randomn_words` Inputs"
msgstr ""

#: src/ch16-05-02-randomness.md:81
msgid ""
"`requester_address`: The contract address that initiated the randomness "
"request."
msgstr ""

#: src/ch16-05-02-randomness.md:82
msgid "`request_id`: A unique identifier assigned to the randomness request."
msgstr ""

#: src/ch16-05-02-randomness.md:83
msgid ""
"`random_words`:  An array (span) of the generated random values (represented "
"as `felt252`)."
msgstr ""

#: src/ch16-05-02-randomness.md:84
msgid ""
"`calldata`:  Additional data passed along with the initial randomness "
"request."
msgstr ""

#: src/ch16-05-02-randomness.md:86
msgid "Dice Game Contract"
msgstr ""

#: src/ch16-05-02-randomness.md:88
msgid ""
"This dice game contract allows players to guess a number between 1 & 6 "
"during an active game window. The contract owner then has the ability to "
"toggle the game window to disable new guesses from players. To determine the "
"winning number, the contract owner calls the "
"`request_randomness_from_pragma` function to request a random number from "
"the Pragma VRF oracle. Once the random number is received through the "
"`receive_random_words` callback function, it is stored in the "
"`last_random_number` storage variable. Each player has to call "
"`process_game_winners` function to determine if they have won or lost. The "
"`last_random_number` generated is then reduced to a number between 1 & 6, "
"and compared to the guesses of the players stored in the `user_guesses` "
"mapping, which leads to the emission of an event `GameWinner` or `GameLost`."
msgstr ""

#: src/ch16-05-02-randomness.md:223
msgid ""
"// Approve the randomness contract to transfer the callback fee\n"
"            // You would need to send some ETH to this contract first to "
"cover the fees\n"
msgstr ""

#: src/ch16-05-02-randomness.md:236
msgid "// Request the randomness\n"
msgstr ""

#: src/ch16-05-02-randomness.md:253
msgid ""
"// Have to make sure that the caller is the Pragma Randomness Oracle "
"contract\n"
msgstr ""

#: src/ch16-05-02-randomness.md:259
msgid ""
"// and that the current block is within publish_delay of the request block\n"
msgstr ""

#: src/ch16-05-02-randomness.md:273
msgid "// ETH Contract Address            \n"
msgstr ""

#: src/ch16-05-02-randomness.md:282
msgid ""
"<span class=\"caption\">Listing 16-6: Simple Dice Game Contract using Pragma "
"VRF.</span>"
msgstr ""

#: src/ch16-05-02-randomness.md:284
msgid "NB: Fund Your Contract After Deployment to Utilize Pragma VRF"
msgstr ""

#: src/ch16-05-02-randomness.md:286
msgid ""
"After deploying your contract that includes Pragma VRF functionalities, "
"ensure it holds sufficient ETH to cover the expenses related to requesting "
"random values. Pragma VRF requires payment for both generating the random "
"numbers and executing the callback function defined in your contract."
msgstr ""

#: src/ch16-05-02-randomness.md:288
msgid ""
"For more information, please refer to the "
"[Pragma](https://docs.pragma.build/Resources/Cairo%201/randomness/randomness) "
"docs."
msgstr ""

#: src/ch16-06-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, "
"utilizing various features of the Cairo programming language. Your "
"contributions are welcome and encouraged, as we aim to gather as many "
"diverse examples as possible."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:1
msgid "Deploying and Interacting with a Voting contract"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the "
"contract's constructor. Three voters are initialized at this stage, and "
"their addresses are passed to an internal function **`_register_voters`**. "
"This function adds the voters to the contract's state, marking them as "
"registered and eligible to vote."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to "
"represent the voting options (1 and 0, respectively). These constants "
"facilitate the voting process by standardizing the input values."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** "
"function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting, "
"the state of the contract is updated, recording the vote and marking the "
"voter as having voted. This ensures that the voter is not able to cast a "
"vote again within the same proposal. The casting of a vote triggers the "
"**`VoteCast`** event, logging the action."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized "
"action is detected, such as a non-registered user attempting to vote or a "
"user trying to vote again, the **`UnauthorizedAttempt`** event is emitted."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured "
"voting system, managing the lifecycle of a vote from registration to "
"casting, event logging, and result retrieval within the Starknet "
"environment. Constants like **`YES`** and **`NO`** help streamline the "
"voting process, while events play a vital role in ensuring transparency and "
"traceability."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:13
msgid "Listing 16-7 shows the `Vote` contract in detail:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:16
msgid ""
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:18
msgid ""
"/// @dev Trait defining the functions that can be implemented or called by "
"the Starknet Contract\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:22
msgid "/// @dev Function that returns the current vote status\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:24
msgid ""
"/// @dev Function that checks if the user at the specified address is "
"allowed to vote\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:26
msgid ""
"/// @dev Function that checks if the specified address is registered as a "
"voter\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:28
msgid "/// @dev Function that allows a user to vote\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:31
msgid ""
"/// @dev Starknet Contract allowing three registered voters to vote on a "
"proposal\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:41
msgid "/// @dev Structure that stores vote counts and voter states\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:50
msgid ""
"/// @dev Contract constructor initializing the contract with a list of "
"registered voters and 0 vote count\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:58
msgid "// Register all voters by calling the _register_voters function\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:61
msgid "// Initialize the vote count to 0\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:66
msgid "/// @dev Event that gets emitted when a vote is cast\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:74
msgid "/// @dev Represents a vote that was cast\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:81
msgid "/// @dev Represents an unauthorized attempt to vote\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:87
msgid "/// @dev Implementation of VoteTrait for ContractState\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:90
msgid "/// @dev Returns the voting results\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:97
msgid "/// @dev Check whether a voter is allowed to vote\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:102
msgid "/// @dev Check whether an address is registered as a voter\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:107
msgid "/// @dev Submit a vote\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:109
msgid "\"VOTE_0_OR_1\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:125
msgid "/// @dev Internal Functions implementation for the Vote contract\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:128
msgid ""
"/// @dev Registers the voters and initializes their voting status to true "
"(can vote)\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:146
msgid "/// @dev Asserts implementation for the Vote contract\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:149
msgid "// @dev Internal function that checks if an address is allowed to vote\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:158
msgid "\"USER_NOT_REGISTERED\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:159
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:440
msgid "\"USER_ALREADY_VOTED\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:163
msgid "/// @dev Implement the VotingResultTrait for the Vote contract\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:166
msgid ""
"// @dev Internal function to get the voting results (yes and no vote "
"counts)\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:174
msgid "// @dev Internal function to calculate the voting results in percentage\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:192
msgid "<span class=\"caption\">Listing 16-7: A voting smart contract</span>"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:194
msgid "Deploying, Calling and Invoking the Voting Contract"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:196
msgid ""
"Part of the Starknet experience is deploying and interacting with smart "
"contracts."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:198
msgid ""
"Once the contract is deployed, we can interact with it by calling and "
"invoking its functions:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:200
msgid ""
"Calling contracts: Interacting with external functions that only read from "
"the state. These functions do not alter the state of the network, so they "
"don't require fees or signing."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:201
msgid ""
"Invoking contracts: Interacting with external functions that can write to "
"the state. These functions do alter the state of the network and require "
"fees and signing."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:203
msgid ""
"We will setup a local development node using `katana` to deploy the voting "
"contract. Then, we'll interact with the contract by calling and invoking its "
"functions. You can also use the Goerli Testnet instead of `katana`. However, "
"we recommend using `katana` for local development and testing. You can find "
"the complete tutorial for `katana` in the [\"Katana: A Local "
"Node\"](https://book.starknet.io/ch02-04-katana.html) chapter of the "
"Starknet Book."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:207
msgid "The `katana` Local Starknet Node"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:209
msgid ""
"`katana` is designed to support local development by the [Dojo "
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana). It will "
"allow you to do everything you need to do with Starknet, but locally. It is "
"a great tool for development and testing."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:211
msgid ""
"To install `katana` from the source code, please refer to the [\"Basic "
"Installation\"](https://book.starknet.io/ch02-01-basic-installation.html#katana-node-installation) "
"chapter of the Starknet Book."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:213
msgid ""
"Note: Please verify that the version of `katana` match the specified version "
"provided below."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:220
msgid ""
"To upgrade `katana` version, refer to the [\"Basic "
"Installation\"](https://book.starknet.io/ch02-01-basic-installation.html#katana-node-installation) "
"chapter of the Starknet Book."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:222
msgid ""
"Once you have `katana` installed, you can start the local Starknet node with:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:228
msgid ""
"This command will start a local Starknet node with 3 deployed accounts. We "
"will use these accounts to deploy and interact with the voting contract:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:233
msgid "================="
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:249
msgid ""
"Before we can interact with the voting contract, we need to prepare the "
"voter and admin accounts on Starknet. Each voter account must be registered "
"and sufficiently funded for voting. For a more detailed understanding of how "
"accounts operate with Account Abstraction, refer to the [\"Account "
"Abstraction\"](https://book.starknet.io/ch04-00-account-abstraction.html) "
"chapter of the Starknet Book."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:255
msgid "Smart Wallets for Voting"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:257
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a "
"command line tool that allows you to interact with Starknet. You can find "
"the installation instructions in the \\[\"Basic Installation\"\\]\\[starkli "
"installation\\] chapter of the Starknet Book."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:259
msgid ""
"Note: Please verify that the version of `starkli` match the specified "
"version provided below."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:266
msgid ""
"To upgrade `starkli` to `0.2.9`, use the `starkliup -v 0.2.9` command, or "
"simply `starkliup` which installed the latest stable version."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:268
msgid ""
"For each smart wallet we'll use, we must create a Signer within the "
"encrypted keystore and an Account Descriptor. This process is also detailed "
"in the \\[\"Testnet Deployment\"\\]\\[signer creation\\] chapter of the "
"Starknet Book."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:270
msgid ""
"We can create Signers and Account Descriptors for the accounts we want to "
"use for voting. Let's create a smart wallet for voting in our smart contract."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:272
msgid "Firstly, we create a signer from a private key:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:278
msgid ""
"Then, we create the Account Descriptor by fetching the katana account we "
"want to use:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:284
msgid ""
"This command will create a new `account0_account.json` file containing the "
"following details:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:288
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:291
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:401
msgid "\"version\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:289
msgid "\"variant\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:290
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:407
msgid "\"type\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:290
msgid "\"open_zeppelin\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:292
msgid "\"public_key\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:292
msgid "\"<SMART_WALLET_PUBLIC_KEY>\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:294
msgid "\"deployment\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:295
msgid "\"status\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:295
msgid "\"deployed\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:296
msgid "\"class_hash\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:296
msgid "\"<SMART_WALLET_CLASS_HASH>\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:297
msgid "\"address\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:297
msgid "\"<SMART_WALLET_ADDRESS>\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:302
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all "
"your smart wallets) with the following command. Notice the use of the "
"`--rpc` flag and the RPC endpoint provided by `katana`:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:304
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:308
msgid ""
"For the public key, you can use the `starkli signer keystore inspect` "
"command with the directory of the keystore json file:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:314
msgid ""
"This process is identical for `account_1` and `account_2` in case you want "
"to have a second and a third voter."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:316
msgid ""
"\\[starkli installation\\]: "
"https://book.starknet.io/ch02-01-basic-installation.html#starkli-installation) "
"\\[signer creation\\]: "
"https://book.starknet.io/ch02-05-testnet-deployment.html?highlight=signer#creating-a-signer"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:319
msgid "Contract Deployment"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:321
msgid ""
"Before deploying, we need to declare the contract. We can do this with the "
"`starkli declare` command:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:327
msgid ""
"If the compiler version you're using is older than the one used by Starkli "
"and you encounter a `compiler-version` error while using the command above, "
"you can specify a compiler version to use in the command by adding the "
"`--compiler-version x.y.z` flag."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:329
msgid ""
"If you're still encountering issues with the compiler version, try upgrading "
"Starkli using the command: `starkliup` to make sure you're using the latest "
"version of starkli."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:331
msgid ""
"The class hash of the contract is: "
"`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You "
"can declare this contract on Sepolia testnet and see that the class hash "
"will correspond."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:333
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by "
"`katana`). The `--account` flag specifies the account to use for signing the "
"transaction. The account we use here is the one we created in the previous "
"step. The `--keystore` flag specifies the keystore file to use for signing "
"the transaction."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:335
msgid ""
"Since we are using a local node, the transaction will achieve finality "
"immediately. If you are using the Goerli Testnet, you will need to wait for "
"the transaction to be final, which usually takes a few seconds."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:337
msgid ""
"The following command deploys the voting contract and registers voter_0, "
"voter_1, and voter_2 as eligible voters. These are the constructor "
"arguments, so add a voter account that you can later vote with."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:343
msgid "An example command:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:349
msgid ""
"In this case, the contract has been deployed at an specific address: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This "
"address will be different for you. We will use this address to interact with "
"the contract."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:351
msgid "Voter Eligibility Verification"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:353
msgid ""
"In our voting contract, we have two functions to validate voter eligibility, "
"`voter_can_vote` and `is_voter_registered`. These are external read "
"functions, which mean they don't alter the state of the contract but only "
"read the current state."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:355
msgid ""
"The `is_voter_registered` function checks whether a particular address is "
"registered as an eligible voter in the contract. The `voter_can_vote` "
"function, on the other hand, checks whether the voter at a specific address "
"is currently eligible to vote, i.e., they are registered and haven't voted "
"already."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:357
msgid ""
"You can call these functions using the `starkli call` command. Note that the "
"`call` command is used for read functions, while the `invoke` command is "
"used for functions that can also write to storage. The `call` command does "
"not require signing, while the `invoke` command does."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:359
msgid ""
"```bash+\n"
"starkli call "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 "
"voter_can_vote "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc "
"http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:363
msgid ""
"First we added the address of the contract, then the function we want to "
"call, and finally the input for the function. In this case, we are checking "
"whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can "
"vote."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:365
msgid ""
"Since we provided a registered voter address as an input, the result is 1 "
"(boolean true), indicating the voter is eligible to vote."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:367
msgid ""
"Next, let's call the `is_voter_registered` function using an unregistered "
"account address to observe the output:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:373
msgid ""
"With an unregistered account address, the terminal output is 0 (i.e., "
"false), confirming that the account is not eligible to vote."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:375
msgid "Casting a Vote"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:377
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! "
"To vote, we interact with the `vote` function, which is flagged as external, "
"necessitating the use of the `starknet invoke` command."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:379
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we "
"submit either `1` (for Yes) or `0` (for No) as our input. When we invoke the "
"`vote` function, we are charged a fee, and the transaction must be signed by "
"the voter; we are writing to the contract's storage."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:389
msgid ""
"You will be prompted to enter the password for the signer. Once you enter "
"the password, the transaction will be signed and submitted to the Starknet "
"network. You will receive the transaction hash as output. With the starkli "
"transaction command, you can get more details about the transaction:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:395
msgid "This returns:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:399
msgid "\"transaction_hash\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:399
msgid "\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:400
msgid "\"max_fee\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:400
msgid "\"0x430e81\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:401
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:410
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:414
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:415
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:416
msgid "\"0x1\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:402
msgid "\"signature\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:403
msgid "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:404
msgid "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:406
msgid "\"nonce\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:406
msgid "\"0x3\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:407
msgid "\"INVOKE\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:408
msgid "\"sender_address\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:408
msgid "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:409
msgid "\"calldata\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:411
msgid "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:412
msgid "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:413
msgid "\"0x0\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:421
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:424
msgid "\"Contract error\""
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:427
msgid ""
"The error is not very informative, but you can get more details when looking "
"at the output in the terminal where you started `katana` (our local Starknet "
"node):"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:431
msgid ""
"\"Error in the called contract "
"(0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution "
"failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:437
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:443
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the "
"accounts we want to use for voting. Remember that each Signer must be "
"created from a private key, and each Account Descriptor must be created from "
"a public key, a smart wallet address, and the smart wallet class hash (which "
"is the same for each voter)."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:451
msgid "Visualizing Vote Outcomes"
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:453
msgid ""
"To examine the voting results, we invoke the `get_vote_status` function, "
"another view function, through the `starknet call` command."
msgstr ""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:459
msgid ""
"The output reveals the tally of \"Yes\" and \"No\" votes along with their "
"relative percentages."
msgstr ""

#: src/ch17-01-general-recommendations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually "
"straightforward. However, preventing unintended usage and vulnerabilities "
"can be more challenging."
msgstr ""

#: src/ch17-01-general-recommendations.md:5
msgid ""
"In smart contract development, security is very important. A single error "
"can result in the loss of valuable assets or the improper functioning of "
"certain features."
msgstr ""

#: src/ch17-01-general-recommendations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can "
"examine the code and interact with it. Any errors or vulnerabilities in the "
"code can be exploited by malicious actors."
msgstr ""

#: src/ch17-01-general-recommendations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart "
"contracts. By incorporating these concepts during development, you can "
"create robust and reliable smart contracts. This reduces the chance of "
"unexpected behavior or vulnerabilities."
msgstr ""

#: src/ch17-01-general-recommendations.md:11
msgid "Disclaimer"
msgstr ""

#: src/ch17-01-general-recommendations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security "
"issues, and it does not guarantee that your contracts will be completely "
"secure."
msgstr ""

#: src/ch17-01-general-recommendations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly "
"recommended to conduct external audits performed by security experts."
msgstr ""

#: src/ch17-01-general-recommendations.md:17
msgid "Mindset"
msgstr ""

#: src/ch17-01-general-recommendations.md:19
msgid ""
"Cairo is a highly safe language inspired by Rust. It is designed in a way "
"that forces you to cover all possible cases. Security issues on Starknet "
"mostly arise from the way smart contract flows are designed, not much from "
"the language itself."
msgstr ""

#: src/ch17-01-general-recommendations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart "
"contracts. Try to always consider all possible scenarios when writing code."
msgstr ""

#: src/ch17-01-general-recommendations.md:23
msgid "Viewing Smart Contracts as Finite State Machines"
msgstr ""

#: src/ch17-01-general-recommendations.md:25
msgid ""
"Transactions in smart contracts are atomic, meaning they either succeed or "
"fail without making any changes."
msgstr ""

#: src/ch17-01-general-recommendations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial "
"states defined by the constructor constraints, and external functions "
"represent a set of possible state transitions. A transaction is nothing more "
"than a state transition."
msgstr ""

#: src/ch17-01-general-recommendations.md:29
msgid ""
"The `assert!` or `panic!` macros can be used to validate conditions before "
"performing specific actions. You can learn more about these on the "
"[Unrecoverable Errors with "
"panic](./ch09-01-unrecoverable-errors-with-panic.md) page."
msgstr ""

#: src/ch17-01-general-recommendations.md:31
msgid "These validations can include:"
msgstr ""

#: src/ch17-01-general-recommendations.md:33
msgid "Inputs provided by the caller"
msgstr ""

#: src/ch17-01-general-recommendations.md:34
msgid "Execution requirements"
msgstr ""

#: src/ch17-01-general-recommendations.md:35
msgid "Invariants (conditions that must always be true)"
msgstr ""

#: src/ch17-01-general-recommendations.md:36
msgid "Return values from other function calls"
msgstr ""

#: src/ch17-01-general-recommendations.md:38
msgid ""
"For example, you could use the `assert!` macro to validate that a user has "
"enough funds to perform a withdraw transaction. If the condition is not met, "
"the transaction will fail and the state of the contract will not change."
msgstr ""

#: src/ch17-01-general-recommendations.md:45
msgid "\"Insufficient funds\""
msgstr ""

#: src/ch17-01-general-recommendations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly "
"define the boundaries of possible state transitions for each function in "
"your smart contract. These checks ensure that the behavior of the contract "
"stays within the expected limits."
msgstr ""

#: src/ch17-01-general-recommendations.md:53
msgid "Recommendations"
msgstr ""

#: src/ch17-01-general-recommendations.md:55
msgid "Checks Effects Interactions Pattern"
msgstr ""

#: src/ch17-01-general-recommendations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to "
"prevent reentrancy attacks on Ethereum. While reentrancy is harder to "
"achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""

#: src/ch17-01-general-recommendations.md:61
msgid ""
"The pattern consists of following a specific order of operations in your "
"functions:"
msgstr ""

#: src/ch17-01-general-recommendations.md:63
msgid ""
"**Checks**: Validate all conditions and inputs before performing any state "
"changes."
msgstr ""

#: src/ch17-01-general-recommendations.md:64
msgid "**Effects**: Perform all state changes."
msgstr ""

#: src/ch17-01-general-recommendations.md:65
msgid ""
"**Interactions**: All external calls to other contracts should be made at "
"the end of the function."
msgstr ""

#: src/ch17-01-general-recommendations.md:67
msgid "Access Control"
msgstr ""

#: src/ch17-01-general-recommendations.md:69
msgid ""
"Access control is the process of restricting access to certain features or "
"resources. It is a common security mechanism used to prevent unauthorized "
"access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""

#: src/ch17-01-general-recommendations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. "
"This pattern consists of defining a set of roles and assigning them to "
"specific users. Each function can then be restricted to specific roles."
msgstr ""

#: src/ch17-01-general-recommendations.md:92
msgid "// Role 'owner': only one address\n"
msgstr ""

#: src/ch17-01-general-recommendations.md:94
msgid "// Role 'role_a': a set of addresses\n"
msgstr ""

#: src/ch17-01-general-recommendations.md:103
msgid "// Guard functions to check roles\n"
msgstr ""

#: src/ch17-01-general-recommendations.md:118
msgid "\"Not owner\""
msgstr ""

#: src/ch17-01-general-recommendations.md:123
msgid "\"Not role A\""
msgstr ""

#: src/ch17-01-general-recommendations.md:126
msgid "// You can easily combine guards to perform complex checks\n"
msgstr ""

#: src/ch17-01-general-recommendations.md:128
msgid "\"Not allowed\""
msgstr ""

#: src/ch17-01-general-recommendations.md:131
msgid "// Functions to manage roles\n"
msgstr ""

#: src/ch17-01-general-recommendations.md:138
msgid ""
"// You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:3
msgid ""
"Testing smart contracts is a critical part of the development process. It is "
"important to ensure that smart contracts behave as expected and that they "
"are secure."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:5
msgid ""
"In a previous section of the Cairo Book, we learned how to write and "
"structure our tests for Cairo programs. We demonstrated how these tests "
"could be run using the `scarb` command-line tool. While this approach is "
"useful for testing standalone Cairo programs and functions, it lacks "
"functionality for testing smart contracts that require control over the "
"contract state and execution context. Therefore, in this section, we will "
"introduce how to use Starknet Foundry, a smart contract development "
"toolchain for Starknet, to test your Cairo contracts."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:8
msgid ""
"Throughout this chapter, we will be using as an example the `PizzaFactory` "
"contract in Listing 17-1 to demonstrate how to write tests with Starknet "
"Foundry."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:59
#: src/ch17-02-testing-smart-contracts.md:64
msgid "\"Amount cannot be 0\""
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:69
msgid "\"Not enough pepperoni\""
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:70
msgid "\"Not enough pineapple\""
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:75
#: src/ch17-02-testing-smart-contracts.md:210
#: src/ch17-02-testing-smart-contracts.md:326
#: src/ch17-02-testing-smart-contracts.md:438
#: src/ch17-02-testing-smart-contracts.md:550
#: src/ch17-02-testing-smart-contracts.md:664
msgid "\"Only the owner can make pizza\""
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:101
#: src/ch17-02-testing-smart-contracts.md:200
#: src/ch17-02-testing-smart-contracts.md:316
#: src/ch17-02-testing-smart-contracts.md:428
#: src/ch17-02-testing-smart-contracts.md:540
#: src/ch17-02-testing-smart-contracts.md:654
msgid "\"Only the owner can set ownership\""
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:109
msgid ""
"<span class=\"caption\">Listing 17-1: A pizza factory that needs to be "
"tested</span>"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:111
msgid "Configuring your Scarb project with Starknet Foundry"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:113
msgid ""
"The settings of your Scarb project can be configured in the `Scarb.toml` "
"file. To use Starknet Foundry as your testing tool, you will need to add it "
"as a dev dependency in your `Scarb.toml` file. At the time of writing, the "
"latest version of Starknet Foundry is `v0.22.0` - but you should use the "
"latest version."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:115
msgid ""
"```toml,noplayground\n"
"[dev-dependencies]\n"
"snforge_std = { git = "
"\"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"v0.22.0\" }\n"
"\n"
"[scripts]\n"
"test = \"snforge test\"\n"
"```"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:123
msgid ""
"The `scarb test` command is configured to execute `scarb cairo-test` by "
"default. In our settings, we have configured it to execute `snforge test` "
"instead. This will allow us to run our tests using Starknet Foundry when we "
"run the `scarb test` command."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:125
msgid ""
"Once your project is configured, you will need to install Starknet Foundry "
"by following the installation guide from the [Starknet Foundry "
"Documentation](https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html). "
"As usual, we recommend to use `asdf` to manage versions of your development "
"tools."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:127
msgid "Testing Smart Contracts with Starknet Foundry"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:129
msgid ""
"The usual command to run your tests using Starknet Foundry is `snforge "
"test`. However, when we configured our projects, we defined that the `scarb "
"test` command will run the `snforge test` command. Therefore, during the "
"rest of this chapter, consider that the `scarb test` command will be using "
"`snforge test` under the hood."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:131
msgid "The usual testing flow of a contract is as follows:"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:133
msgid "Declare the class of the contract to test, identified by its name"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:134
msgid "Serialize the constructor calldata into an array"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:135
msgid "Deploy the contract and retrieve its address"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:136
msgid "Interact with the contract's entrypoint to test various scenarios"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:138
msgid "Deploying the Contract to Test"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:140
msgid ""
"In Listing 17-2, we wrote a function that deploys the `PizzaFactory` "
"contract and sets up the dispatcher for interactions."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:162
#: src/ch17-02-testing-smart-contracts.md:278
#: src/ch17-02-testing-smart-contracts.md:390
#: src/ch17-02-testing-smart-contracts.md:502
#: src/ch17-02-testing-smart-contracts.md:616
msgid "\"PizzaFactory\""
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:178
#: src/ch17-02-testing-smart-contracts.md:294
#: src/ch17-02-testing-smart-contracts.md:406
#: src/ch17-02-testing-smart-contracts.md:518
#: src/ch17-02-testing-smart-contracts.md:632
msgid "\"pepperoni\""
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:179
#: src/ch17-02-testing-smart-contracts.md:295
#: src/ch17-02-testing-smart-contracts.md:407
#: src/ch17-02-testing-smart-contracts.md:519
#: src/ch17-02-testing-smart-contracts.md:633
msgid "\"pineapple\""
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:221
#: src/ch17-02-testing-smart-contracts.md:337
#: src/ch17-02-testing-smart-contracts.md:449
#: src/ch17-02-testing-smart-contracts.md:561
#: src/ch17-02-testing-smart-contracts.md:675
msgid "// Setup\n"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:226
#: src/ch17-02-testing-smart-contracts.md:342
#: src/ch17-02-testing-smart-contracts.md:454
#: src/ch17-02-testing-smart-contracts.md:566
#: src/ch17-02-testing-smart-contracts.md:680
msgid "// When\n"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:229
#: src/ch17-02-testing-smart-contracts.md:345
#: src/ch17-02-testing-smart-contracts.md:457
#: src/ch17-02-testing-smart-contracts.md:569
#: src/ch17-02-testing-smart-contracts.md:683
msgid "// Then\n"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:246
msgid ""
"<span class=\"caption\">Listing 17-2 Deploying the contract to test</span>"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:248
msgid "Testing our Contract"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:250
msgid ""
"Determining the behavior that your contract should respect is the first step "
"in writing tests. In the `PizzaFactory` contract, we determined that the "
"contract should have the following behavior:"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:252
msgid ""
"Upon deployment, the contract owner should be set to the address provided in "
"the constructor, and the factory should have 10 units of pepperoni and "
"pineapple, and no pizzas created."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:253
msgid ""
"If someone tries to make a pizza and they are not the owner, the operation "
"should fail. Otherwise, the pizza count should be incremented, and an event "
"should be emitted."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:254
msgid ""
"If someone tries to take ownership of the contract and they are not the "
"owner, the operation should fail. Otherwise, the owner should be updated."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:256
msgid "Accessing Storage Variables with `load`"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:362
msgid ""
"<span class=\"caption\">Listing 17-3: Testing the initial state by loading "
"storage variables </span>"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:364
msgid ""
"Once our contract is deployed, we want to assert that the initial values are "
"set as expected. If our contract has an entrypoint that returns the value of "
"a storage variable, we can call this entrypoint. Otherwise, we can use the "
"`load` function from `snforge` to load the value of a storage variable "
"inside our contract, even if not exposed by an entrypoint."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:366
msgid "Mocking the Caller Address with `start_cheat_caller_address`"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:368
msgid ""
"The security of our factory relies on the owner being the only one able to "
"make pizzas and transfer ownership. To test this, we can use the "
"`start_cheat_caller_address` function to mock the caller address and assert "
"that the contract behaves as expected."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:474
msgid ""
"<span class=\"caption\">Listing 17-4: Testing ownership of the contract by "
"mocking the caller address </span>"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:476
msgid ""
"Using `start_cheat_caller_address`, we call the `change_owner` function "
"first as the owner, and then as a different address. We assert that the "
"operation fails when the caller is not the owner, and that the owner is "
"updated when the caller is the owner."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:478
msgid "Capturing Events with `spy_events`"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:480
msgid ""
"When a pizza is created, the contract emits an event. To test this, we can "
"use the `spy_events` function to capture the emitted events and assert that "
"the event was emitted with the expected parameters. Naturally, we can also "
"assert that the pizza count was incremented, and that only the owner can "
"make a pizza."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:586
msgid ""
"<span class=\"caption\">Listing 17-5: Testing the events emitted when a "
"pizza is created</span>"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:588
msgid "Accessing Internal Functions with `contract_state_for_testing`"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:590
msgid ""
"All the tests we have seen so far have been using a workflow that involves "
"deploying the contract and interacting with the contract's entrypoints. "
"However, sometimes we may want to test the internals of the contract "
"directly, without deploying the contract. How could this be done, if we were "
"reasoning in purely Cairo terms?"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:592
msgid ""
"Recall the struct `ContractState`, which is used as a parameter to all the "
"entrypoints of a contract. To make it short, this struct contains zero-sized "
"fields, corresponding to the storage variables of the contract. The only "
"purpose of these fields is to allow the Cairo compiler to generate the "
"correct code for accessing the storage variables. If we could create an "
"instance of this struct, we could access these storage variables directly, "
"without deploying the contract..."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:594
msgid ""
"...and this is exactly what the `contract_state_for_testing` function does! "
"It creates an instance of the `ContractState` struct, allowing us to call "
"any function that takes as parameter a `ContractState` struct, without "
"deploying the contract. To interact with the storage variables properly, we "
"need to manually import the traits that define access to the storage "
"variables."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:700
msgid ""
"<span class=\"caption\">Listing 17-6: Unit testing our contract without "
"deployment</span>"
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:702
msgid ""
"These imports give us access to our internal functions (notably, "
"`set_owner`), as well as the read/write access to the `owner` storage "
"variable. Once we have these, we can interact with the contract directly, "
"changing the address of the owner by calling the `set_owner` method, "
"accessible through `InternalTrait`, and reading the `owner` storage variable."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:707
msgid ""
"Note: Both approaches cannot be used at the same time. If you decide to "
"deploy the contract, you interact with it using the dispatcher. If you "
"decide to test the internal functions, you interact with the `ContractState` "
"object directly."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:728
msgid ""
"The output of the tests shows that all the tests passed successfully, along "
"with an estimation of the gas consumed by each test."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:732
msgid ""
"In this chapter, we learned how to test smart contracts using Starknet "
"Foundry. We demonstrated how to deploy a contract and interact with it using "
"the dispatcher. We also showed how to test the contract's behavior by "
"mocking the caller address and capturing events. Finally, we demonstrated "
"how to test the internal functions of the contract directly, without "
"deploying the contract."
msgstr ""

#: src/ch17-02-testing-smart-contracts.md:734
msgid ""
"To learn more about Starknet Foundry, refer to the [Starknet Foundry "
"documentation](https://foundry-rs.github.io/starknet-foundry/index.html)."
msgstr ""

#: src/ch17-03-static-analysis-tools.md:3
msgid ""
"Static analysis refers to the process of examining code without its "
"execution, focusing on its structure, syntax, and properties. It involves "
"analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr ""

#: src/ch17-03-static-analysis-tools.md:5
msgid ""
"By defining rules, such as coding conventions or security guidelines, "
"developers can utilize static analysis tools to automatically check the code "
"against these standards."
msgstr ""

#: src/ch17-03-static-analysis-tools.md:7
msgid "Reference:"
msgstr ""

#: src/ch17-03-static-analysis-tools.md:9
msgid ""
"[Semgrep Cairo 1.0 "
"support](https://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0)"
msgstr ""

#: src/ch17-03-static-analysis-tools.md:10
msgid "[Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"
msgstr ""

#: src/appendix-000.md
msgid ""
"The following sections contain reference material you may find useful in "
"your Starknet journey."
msgstr ""

#: src/appendix-08-system-calls.md:1
msgid "Appendix A - System Calls"
msgstr ""

#: src/appendix-08-system-calls.md:3
msgid ""
"This chapter is based on the StarkNet documentation available at [StarkNet "
"Docs](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/)."
msgstr ""

#: src/appendix-08-system-calls.md:5
msgid ""
"Writing smart contracts requires various associated operations, such as "
"calling another contract or accessing the contract’s storage, that "
"standalone programs do not require."
msgstr ""

#: src/appendix-08-system-calls.md:7
msgid ""
"The Starknet contract language supports these operations by using system "
"calls. System calls enable a contract to require services from the Starknet "
"OS. You can use system calls in a function to get information that depends "
"on the broader state of Starknet, which would otherwise be inaccessible, "
"rather than local variables that appear in the function’s scope."
msgstr ""

#: src/appendix-08-system-calls.md:9
msgid "Here is a list of the system calls available in Cairo 1.0:"
msgstr ""

#: src/appendix-08-system-calls.md:11
msgid "[get_block_hash](#get_block_hash)"
msgstr ""

#: src/appendix-08-system-calls.md:12
msgid "[get_execution_info](#get_execution_info)"
msgstr ""

#: src/appendix-08-system-calls.md:13
msgid "[call_contract](#call_contract)"
msgstr ""

#: src/appendix-08-system-calls.md:14
msgid "[deploy](#deploy)"
msgstr ""

#: src/appendix-08-system-calls.md:15
msgid "[emit_event](#emit_event)"
msgstr ""

#: src/appendix-08-system-calls.md:16
msgid "[library_call](#library_call)"
msgstr ""

#: src/appendix-08-system-calls.md:17
msgid "[send_message_to_L1](#send_message_to_l1)"
msgstr ""

#: src/appendix-08-system-calls.md:18
msgid "[replace_class](#replace_class)"
msgstr ""

#: src/appendix-08-system-calls.md:19
msgid "[storage_read](#storage_read)"
msgstr ""

#: src/appendix-08-system-calls.md:20
msgid "[storage_write](#storage_write)"
msgstr ""

#: src/appendix-08-system-calls.md:22
msgid "`get_block_hash`"
msgstr ""

#: src/appendix-08-system-calls.md:24 src/appendix-08-system-calls.md:51
#: src/appendix-08-system-calls.md:79 src/appendix-08-system-calls.md:117
#: src/appendix-08-system-calls.md:153 src/appendix-08-system-calls.md:198
#: src/appendix-08-system-calls.md:230 src/appendix-08-system-calls.md:273
#: src/appendix-08-system-calls.md:305 src/appendix-08-system-calls.md:348
msgid "Syntax"
msgstr ""

#: src/appendix-08-system-calls.md:32 src/appendix-08-system-calls.md:59
#: src/appendix-08-system-calls.md:87 src/appendix-08-system-calls.md:128
#: src/appendix-08-system-calls.md:161 src/appendix-08-system-calls.md:206
#: src/appendix-08-system-calls.md:238 src/appendix-08-system-calls.md:281
#: src/appendix-08-system-calls.md:313 src/appendix-08-system-calls.md:356
msgid "Description"
msgstr ""

#: src/appendix-08-system-calls.md:34
msgid ""
"Gets the hash of a specific StarkNet block within the range of "
"`[first_v0_12_0_block, current_block - 10]`."
msgstr ""

#: src/appendix-08-system-calls.md:36 src/appendix-08-system-calls.md:69
#: src/appendix-08-system-calls.md:103 src/appendix-08-system-calls.md:139
#: src/appendix-08-system-calls.md:173 src/appendix-08-system-calls.md:220
#: src/appendix-08-system-calls.md:252 src/appendix-08-system-calls.md:295
#: src/appendix-08-system-calls.md:327 src/appendix-08-system-calls.md:372
msgid "Return Values"
msgstr ""

#: src/appendix-08-system-calls.md:38
msgid "Returns the hash of the given block."
msgstr ""

#: src/appendix-08-system-calls.md:40
msgid "Error Messages"
msgstr ""

#: src/appendix-08-system-calls.md:42
msgid ""
"`Block number out of range`: `block_number` is greater than "
"_`current_block`_`- 10`."
msgstr ""

#: src/appendix-08-system-calls.md:43
msgid "`0`: `block_number` is less than the first block number of v0.12.0."
msgstr ""

#: src/appendix-08-system-calls.md:45 src/appendix-08-system-calls.md:73
#: src/appendix-08-system-calls.md:107 src/appendix-08-system-calls.md:147
#: src/appendix-08-system-calls.md:192 src/appendix-08-system-calls.md:224
#: src/appendix-08-system-calls.md:267 src/appendix-08-system-calls.md:299
#: src/appendix-08-system-calls.md:342 src/appendix-08-system-calls.md:376
msgid "Common Library"
msgstr ""

#: src/appendix-08-system-calls.md:47
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls.cairo#L37)"
msgstr ""

#: src/appendix-08-system-calls.md:49
msgid "`get_execution_info`"
msgstr ""

#: src/appendix-08-system-calls.md:61
msgid "Gets information about the original transaction."
msgstr ""

#: src/appendix-08-system-calls.md:63
msgid ""
"In Cairo 1.0, all block/transaction/execution context getters are batched "
"into this single system call."
msgstr ""

#: src/appendix-08-system-calls.md:65 src/appendix-08-system-calls.md:97
#: src/appendix-08-system-calls.md:132 src/appendix-08-system-calls.md:167
#: src/appendix-08-system-calls.md:212 src/appendix-08-system-calls.md:246
#: src/appendix-08-system-calls.md:291 src/appendix-08-system-calls.md:321
#: src/appendix-08-system-calls.md:364
msgid "Arguments"
msgstr ""

#: src/appendix-08-system-calls.md:67 src/appendix-08-system-calls.md:175
#: src/appendix-08-system-calls.md:254 src/appendix-08-system-calls.md:297
#: src/appendix-08-system-calls.md:374
msgid "None."
msgstr ""

#: src/appendix-08-system-calls.md:71
msgid ""
"Returns a "
"[struct](https://github.com/starkware-libs/cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8) "
"containing the execution info."
msgstr ""

#: src/appendix-08-system-calls.md:75
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L35)"
msgstr ""

#: src/appendix-08-system-calls.md:77
msgid "`call_contract`"
msgstr ""

#: src/appendix-08-system-calls.md:89
msgid ""
"Calls a given contract. This system call expects the address of the called "
"contract, a selector for a function within that contract, and call arguments."
msgstr ""

#: src/appendix-08-system-calls.md:91 src/appendix-08-system-calls.md:285
msgid "**Note:**"
msgstr ""

#: src/appendix-08-system-calls.md:93
msgid ""
"An internal call can’t return Err(\\_) as this is not handled by the "
"sequencer and the Starknet OS."
msgstr ""

#: src/appendix-08-system-calls.md:95
msgid ""
"If call_contract_syscall fails, this can’t be caught and will therefore "
"result in the entire transaction being reverted."
msgstr ""

#: src/appendix-08-system-calls.md:99
msgid "_`address`_: The address of the contract you want to call."
msgstr ""

#: src/appendix-08-system-calls.md:100
msgid ""
"_`entry_point_selector`_: A selector for a function within that contract, "
"can be computed with the `selector!` macro."
msgstr ""

#: src/appendix-08-system-calls.md:101
msgid "_`calldata`_: The calldata array."
msgstr ""

#: src/appendix-08-system-calls.md:105 src/appendix-08-system-calls.md:222
msgid "The call response, of type `SyscallResult<Span<felt252>>`."
msgstr ""

#: src/appendix-08-system-calls.md:109
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10)"
msgstr ""

#: src/appendix-08-system-calls.md:111
msgid ""
"**Note:** This is considered a lower-level syntax for calling contracts. If "
"the interface of the called contract is available, then you can use a more "
"straightforward syntax."
msgstr ""

#: src/appendix-08-system-calls.md:115
msgid "`deploy`"
msgstr ""

#: src/appendix-08-system-calls.md:130
msgid "Deploys a new instance of a previously declared class."
msgstr ""

#: src/appendix-08-system-calls.md:134
msgid "_`class_hash`_: The class hash of the contract to be deployed."
msgstr ""

#: src/appendix-08-system-calls.md:135
msgid ""
"_`contract_address_salt`_: The salt, an arbitrary value provided by the "
"sender. It is used in the computation of the contract’s address."
msgstr ""

#: src/appendix-08-system-calls.md:136
msgid "_`calldata`_: The constructor’s calldata. An array of felts."
msgstr ""

#: src/appendix-08-system-calls.md:137
msgid ""
"_`deploy_from_zero`_: A flag used for the contract address computation. If "
"not set, the caller address will be used as the new contract’s deployer "
"address, otherwise 0 is used."
msgstr ""

#: src/appendix-08-system-calls.md:141
msgid "A tuple wrapped with SyscallResult where:"
msgstr ""

#: src/appendix-08-system-calls.md:143
msgid ""
"The first element is the address of the deployed contract, of type "
"`ContractAddress`."
msgstr ""

#: src/appendix-08-system-calls.md:145
msgid ""
"The second element is the response array from the contract’s constructor, of "
"type `Span::<felt252>`."
msgstr ""

#: src/appendix-08-system-calls.md:149
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls.cairo#L22)"
msgstr ""

#: src/appendix-08-system-calls.md:151
msgid "`emit_event`"
msgstr ""

#: src/appendix-08-system-calls.md:163
msgid "Emits an event with a given set of keys and data."
msgstr ""

#: src/appendix-08-system-calls.md:165
msgid ""
"For more information and a higher-level syntax for emitting events, see "
"[Starknet "
"events](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/starknet-events/)."
msgstr ""

#: src/appendix-08-system-calls.md:169
msgid ""
"_`keys`_: The event’s keys. These are analogous to Ethereum’s event topics, "
"you can use the starknet_getEvents method to filter by these keys."
msgstr ""

#: src/appendix-08-system-calls.md:171
msgid "_`data`_: The event’s data."
msgstr ""

#: src/appendix-08-system-calls.md:179
msgid ""
"The following example emits an event with two keys, the strings `status` and "
"`deposit` and three data elements: `1`, `2`, and `3`."
msgstr ""

#: src/appendix-08-system-calls.md:194
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L30)"
msgstr ""

#: src/appendix-08-system-calls.md:196
msgid "`library_call`"
msgstr ""

#: src/appendix-08-system-calls.md:208
msgid ""
"Calls the requested function in any previously declared class. The class is "
"only used for its logic."
msgstr ""

#: src/appendix-08-system-calls.md:210
msgid ""
"This system call replaces the known delegate call functionality from "
"Ethereum, with the important difference that there is only one contract "
"involved."
msgstr ""

#: src/appendix-08-system-calls.md:214
msgid "_`class_hash`_: The hash of the class you want to use."
msgstr ""

#: src/appendix-08-system-calls.md:216
msgid ""
"_`function_selector`_: A selector for a function within that class, can be "
"computed with the `selector!` macro."
msgstr ""

#: src/appendix-08-system-calls.md:218
msgid "_`calldata`_: The calldata."
msgstr ""

#: src/appendix-08-system-calls.md:226
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L43)"
msgstr ""

#: src/appendix-08-system-calls.md:228
msgid "`send_message_to_L1`"
msgstr ""

#: src/appendix-08-system-calls.md:240
msgid "Sends a message to L1."
msgstr ""

#: src/appendix-08-system-calls.md:242
msgid ""
"This system call includes the message parameters as part of the proof’s "
"output and exposes these parameters to the `StarknetCore` contract on L1 "
"once the state update, including the transaction, is received."
msgstr ""

#: src/appendix-08-system-calls.md:244
msgid ""
"For more information, see Starknet’s [messaging "
"mechanism](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/)."
msgstr ""

#: src/appendix-08-system-calls.md:248
msgid "_`to_address`_: The recipient’s L1 address."
msgstr ""

#: src/appendix-08-system-calls.md:250
msgid "_`payload`_: The array containing the message payload."
msgstr ""

#: src/appendix-08-system-calls.md:258
msgid ""
"The following example sends a message whose content is `(1,2)` to the L1 "
"contract whose address is `3423542542364363`."
msgstr ""

#: src/appendix-08-system-calls.md:269
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51)"
msgstr ""

#: src/appendix-08-system-calls.md:271
msgid "`replace_class`"
msgstr ""

#: src/appendix-08-system-calls.md:283
msgid ""
"Once `replace_class` is called, the class of the calling contract (i.e. the "
"contract whose address is returned by `get_contract_address` at the time the "
"syscall is called) will be replaced by the class whose hash is given by the "
"class_hash argument."
msgstr ""

#: src/appendix-08-system-calls.md:287
msgid ""
"After calling `replace_class`, the code currently executing from the old "
"class will finish running."
msgstr ""

#: src/appendix-08-system-calls.md:289
msgid ""
"The new class will be used from the next transaction onwards or if the "
"contract is called via the `call_contract` syscall in the same transaction "
"(after the replacement)."
msgstr ""

#: src/appendix-08-system-calls.md:293
msgid "_`class_hash`_: The hash of the class you want to use as a replacement."
msgstr ""

#: src/appendix-08-system-calls.md:301
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L77)"
msgstr ""

#: src/appendix-08-system-calls.md:303
msgid "`storage_read`"
msgstr ""

#: src/appendix-08-system-calls.md:315
msgid "Gets the value of a key in the storage of the calling contract."
msgstr ""

#: src/appendix-08-system-calls.md:317
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.read()`, which enables you to read storage variables that "
"are defined explicitly in the contract."
msgstr ""

#: src/appendix-08-system-calls.md:319 src/appendix-08-system-calls.md:362
msgid ""
"For information on accessing storage by using the storage variables, see "
"[storage "
"variables](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables)."
msgstr ""

#: src/appendix-08-system-calls.md:323 src/appendix-08-system-calls.md:366
msgid ""
"_`address_domain`_: The domain of the key, used to separate between "
"different data availability modes. This separation is used in Starknet to "
"offer different data availability modes. Currently, only the onchain mode "
"(where all updates go to L1), indicated by domain `0`, is supported. Other "
"address domains which will be introduced in the future will behave "
"differently in terms of publication (in particular, they will not be posted "
"on L1, creating a tradeoff between cost and security)."
msgstr ""

#: src/appendix-08-system-calls.md:325 src/appendix-08-system-calls.md:368
msgid "_`address`_: The requested storage address."
msgstr ""

#: src/appendix-08-system-calls.md:329
msgid "The value of the key, of type `SyscallResult<felt252>`."
msgstr ""

#: src/appendix-08-system-calls.md:344
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60)"
msgstr ""

#: src/appendix-08-system-calls.md:346
msgid "`storage_write`"
msgstr ""

#: src/appendix-08-system-calls.md:358
msgid "Sets the value of a key in the storage of the calling contract."
msgstr ""

#: src/appendix-08-system-calls.md:360
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.write()`, which enables you to write to storage variables "
"that are defined explicitly in the contract."
msgstr ""

#: src/appendix-08-system-calls.md:370
msgid "_`value`_: The value to write to the key."
msgstr ""

#: src/appendix-08-system-calls.md:378
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L70)"
msgstr ""

