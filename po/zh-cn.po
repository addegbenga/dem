#
msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: 2024-06-30T10:43:30+01:00\n"
"PO-Revision-Date: 2023-12-11 02:32+0900\n"
"Last-Translator: cryptonerdcn <cryptonerdcn@gmail.com>\n"
"Language-Team: zh <zh@example.com>\n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.1\n"

#: src/SUMMARY.md src/title-page.md
msgid "The Cairo Book"
msgstr ""

#: src/SUMMARY.md
msgid "The Cairo Book Foreword Introduction"
msgstr "前言导言"

#: src/SUMMARY.md
msgid "The Cairo Programming Language"
msgstr "Cairo编程语言"

#: src/SUMMARY.md src/ch01-00-getting-started.md
msgid "Getting Started"
msgstr "开始"

#: src/SUMMARY.md src/ch01-01-installation.md:1 src/ch01-01-installation.md:22
msgid "Installation"
msgstr "安装安装"

#: src/SUMMARY.md
msgid "Hello, World!"
msgstr "你好,世界!"

#: src/SUMMARY.md src/ch02-00-common-programming-concepts.md
msgid "Common Programming Concepts"
msgstr "共同方案拟订概念"

#: src/SUMMARY.md src/ch02-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr "变量和可变性"

#: src/SUMMARY.md src/ch02-02-data-types.md:1
msgid "Data Types"
msgstr "数据类型"

#: src/SUMMARY.md src/ch02-03-functions.md:1
msgid "Functions"
msgstr "职能职能职能职能职能职能职能职能职能职能职能职能职能职能职能"

#: src/SUMMARY.md src/ch02-04-comments.md:1
msgid "Comments"
msgstr "评论评论评论评论评论评论评论评论评论评论评论评论评论评论评论评论评论评论评论评论"

#: src/SUMMARY.md src/ch02-05-control-flow.md:1
msgid "Control Flow"
msgstr "控制流动"

#: src/SUMMARY.md src/ch03-00-common-collections.md
msgid "Common Collections"
msgstr "共同收藏"

#: src/SUMMARY.md src/ch03-01-arrays.md:1
msgid "Arrays"
msgstr "阵列数组"

#: src/SUMMARY.md src/ch03-02-dictionaries.md:1
msgid "Dictionaries"
msgstr "字典"

#: src/SUMMARY.md
msgid "Understanding Ownership"
msgstr "理解所有权"

#: src/SUMMARY.md
msgid "What is Ownership?"
msgstr "什么是所有权?"

#: src/SUMMARY.md src/ch04-02-references-and-snapshots.md:1
msgid "References and Snapshots"
msgstr "参考和抓图"

#: src/SUMMARY.md src/ch05-00-using-structs-to-structure-related-data.md
msgid "Using Structs to Structure Related Data"
msgstr "使用 Structs 来结构相关数据"

#: src/SUMMARY.md src/ch05-01-defining-and-instantiating-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr "界定和证明 \" 条规 \""

#: src/SUMMARY.md src/ch05-02-an-example-program-using-structs.md:1
msgid "An Example Program Using Structs"
msgstr "使用 structs 的示例程序"

#: src/SUMMARY.md src/ch05-03-method-syntax.md:1
msgid "Method Syntax"
msgstr "方法法 语法"

#: src/SUMMARY.md src/ch06-00-enums-and-pattern-matching.md
msgid "Enums and Pattern Matching"
msgstr "元和模式匹配"

#: src/SUMMARY.md src/ch06-01-enums.md:1 src/ch08-01-generic-data-types.md:181
msgid "Enums"
msgstr "环数"

#: src/SUMMARY.md src/ch06-02-the-match-control-flow-construct.md:1
msgid "The Match Control Flow Construct"
msgstr "匹配控制流程构造"

#: src/SUMMARY.md
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:1
msgid "Concise Control Flow with `if let` and `while let`"
msgstr "\" 如果 \" 和 \" 同时 \" 的简明控制流动"

#: src/SUMMARY.md
#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr "管理开罗项目,包括一揽子、高额和模块"

#: src/SUMMARY.md src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr "包包和高价"

#: src/SUMMARY.md src/ch07-02-defining-modules-to-control-scope.md:1
msgid "Defining Modules to Control Scope"
msgstr "定义控制范围模块"

#: src/SUMMARY.md
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr "模块树树中项目引用路径"

#: src/SUMMARY.md
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr "将路径带入“使用”关键词的范围"

#: src/SUMMARY.md src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr "将模块分隔成不同的文件"

#: src/SUMMARY.md src/ch08-01-generic-data-types.md:1
msgid "Generic Data Types"
msgstr "通用数据类型"

#: src/SUMMARY.md src/ch08-00-generic-types-and-traits.md
msgid "Generic Types and Traits"
msgstr "通用类型和托盘"

#: src/SUMMARY.md src/ch08-02-traits-in-cairo.md:1
msgid "Traits in Cairo"
msgstr "开罗的悲剧"

#: src/SUMMARY.md
msgid "Error Handling"
msgstr "错误处理错误处理"

#: src/SUMMARY.md
msgid "Unrecoverable Errors with panic"
msgstr "恐慌中无法恢复的错误"

#: src/SUMMARY.md
msgid "Recoverable Errors with Result"
msgstr "结果的可恢复错误"

#: src/SUMMARY.md src/ch10-00-testing-cairo-programs.md
#, fuzzy
msgid "Testing Cairo Programs"
msgstr "测试开罗方案"

#: src/SUMMARY.md src/ch10-01-how-to-write-tests.md:1
msgid "How To Write Tests"
msgstr "如何写作测试"

#: src/SUMMARY.md src/ch10-02-test-organization.md:1
msgid "Testing Organization"
msgstr "测试组织"

#: src/SUMMARY.md
msgid "Advanced Cairo Features"
msgstr "开罗高级地物"

#: src/SUMMARY.md src/ch11-01-custom-data-structures.md:1
msgid "Custom Data Structures"
msgstr "自定义数据结构"

#: src/SUMMARY.md src/ch11-02-smart-pointers.md:1
msgid "Smart Pointers"
msgstr "智能点"

#: src/SUMMARY.md src/ch11-03-operator-overloading.md:1
msgid "Operator Overloading"
msgstr "超载操作器"

#: src/SUMMARY.md src/ch11-04-hash.md:24
msgid "Working with Hashes"
msgstr "与Hashes合作"

#: src/SUMMARY.md src/ch11-05-macros.md:1
msgid "Macros"
msgstr "宏"

#: src/SUMMARY.md src/ch11-06-inlining-in-cairo.md:1
msgid "Inlining in Cairo"
msgstr "开罗"

#: src/SUMMARY.md src/ch11-08-printing.md:1
msgid "Printing"
msgstr "印刷印刷印刷"

#: src/SUMMARY.md
msgid "Appendix (Cairo)"
msgstr "附录(开罗)"

#: src/SUMMARY.md
msgid "A - Keywords"
msgstr "A - 关键词"

#: src/SUMMARY.md
msgid "B - Operators and Symbols"
msgstr "- 操作员和符号"

#: src/SUMMARY.md
msgid "C - Derivable Traits"
msgstr "- C - 可衍生的陷阱"

#: src/SUMMARY.md
msgid "D - The Cairo Prelude"
msgstr "- 开罗预兆"

#: src/SUMMARY.md
msgid "E - Common Error Messages"
msgstr "E - 常见错误消息"

#: src/SUMMARY.md
msgid "F - Useful Development Tools"
msgstr "F - 有用的发展工具"

#: src/SUMMARY.md
msgid "G - Installing Cairo binaries"
msgstr "G - 安装开罗二进制"

#: src/SUMMARY.md
msgid "Smart Contracts in Cairo"
msgstr "开罗的智能合同"

#: src/SUMMARY.md src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Introduction to Starknet Smart Contracts"
msgstr "Starknet智能合同介绍"

#: src/SUMMARY.md src/ch13-01-general-introduction-to-smart-contracts.md:1
msgid "General Introduction to Smart Contracts"
msgstr "智能合同一般介绍"

#: src/SUMMARY.md src/ch13-02-anatomy-of-a-simple-contract.md:1
msgid "Anatomy of a Simple Contract"
msgstr "简单合同解剖"

#: src/SUMMARY.md src/ch14-00-building-starknet-smart-contracts.md
msgid "Building Starknet Smart Contracts"
msgstr "建筑史塔克网智能合同"

#: src/SUMMARY.md src/ch14-01-contract-storage.md:1
msgid "Contract Storage"
msgstr "合同储存"

#: src/SUMMARY.md src/ch14-02-contract-functions.md:1
msgid "Contract Functions"
msgstr "合同职能"

#: src/SUMMARY.md src/ch14-03-contract-events.md:1
msgid "Contract Events"
msgstr "合同活动"

#: src/SUMMARY.md src/ch15-00-starknet-cross-contract-interactions.md
msgid "Starknet Cross-Contract Interactions"
msgstr "Starknet 跨合同互动"

#: src/SUMMARY.md src/ch15-01-abis-and-contract-interfaces.md:1
msgid "ABIs and Contract Interfaces"
msgstr "ABI和合同接口"

#: src/SUMMARY.md
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:1
msgid "Contract Dispatchers, Library Dispatchers and System Calls"
msgstr "合同调度员、图书馆调度员和系统呼叫"

#: src/SUMMARY.md src/ch16-00-building-advanced-starknet-smart-contracts.md
msgid "Building Advanced Starknet Smart Contracts"
msgstr "建筑高级史塔克网智能合同"

#: src/SUMMARY.md src/ch16-01-optimizing-storage-costs.md:1
msgid "Optimizing Storage Costs"
msgstr "优化储存成本"

#: src/SUMMARY.md
msgid "Composability and Components"
msgstr "组成和构件"

#: src/SUMMARY.md
msgid "Under the Hood"
msgstr "在兜帽下"

#: src/SUMMARY.md src/ch16-02-02-component-dependencies.md:1
msgid "Component Dependencies"
msgstr "构成部分 构成部分"

#: src/SUMMARY.md src/ch16-02-03-testing-components.md:1
msgid "Testing Components"
msgstr "测试部件"

#: src/SUMMARY.md
msgid "Upgradeability"
msgstr "升级可升级"

#: src/SUMMARY.md
msgid "L1 \\<\\> L2 Messaging"
msgstr "L1  L2 通信"

#: src/SUMMARY.md src/ch16-05-oracle-interactions.md:1
msgid "Oracle Interactions"
msgstr "Oracle 互动"

#: src/SUMMARY.md src/ch16-05-01-price-feeds.md:1
msgid "Price Feeds"
msgstr "价格饲料"

#: src/SUMMARY.md src/ch16-05-02-randomness.md:1
msgid "Randomness"
msgstr "随机随机"

#: src/SUMMARY.md src/ch16-06-00-other-examples.md:1
msgid "Other Examples"
msgstr "其他实例"

#: src/SUMMARY.md
msgid "Deploying and Interacting with a Voting Contract"
msgstr "与投票合同的部署和互动"

#: src/SUMMARY.md src/ch17-00-starknet-smart-contracts-security.md
msgid "Starknet Smart Contracts Security"
msgstr "Starknet智能智能合同安保"

#: src/SUMMARY.md src/ch17-01-general-recommendations.md:1
msgid "General Recommendations"
msgstr "一般性建议"

#: src/SUMMARY.md src/ch17-02-testing-smart-contracts.md:1
msgid "Testing Smart Contracts"
msgstr "测试智能合同"

#: src/SUMMARY.md src/ch17-03-static-analysis-tools.md:1
msgid "Static Analysis Tools"
msgstr "静态分析工具"

#: src/SUMMARY.md
msgid "Formal Verification"
msgstr "正式核查"

#: src/SUMMARY.md src/appendix-00.md src/appendix-000.md
msgid "Appendix"
msgstr "附录附录附录附录附录附录"

#: src/SUMMARY.md
msgid "Appendix (Starknet)"
msgstr "附录(星网)"

#: src/SUMMARY.md
msgid "A - System Calls"
msgstr "- 系统呼叫"

#: src/SUMMARY.md
msgid "Cairo VM"
msgstr "开罗VM"

#: src/SUMMARY.md src/ch00-00-introduction.md src/ch200-introduction.md
msgid "Introduction"
msgstr "导言 导言 导言 导言 导言 导言 导言 导言"

#: src/SUMMARY.md
msgid "Architecture"
msgstr "建筑结构结构"

#: src/SUMMARY.md
msgid "Memory"
msgstr "内存"

#: src/SUMMARY.md
msgid "Non-Deterministic Read-only Memory"
msgstr "非确定性可读只读存储器"

#: src/SUMMARY.md
msgid "Segments"
msgstr "线段"

#: src/SUMMARY.md
msgid "Segment Value"
msgstr "值"

#: src/SUMMARY.md
msgid "Relocation"
msgstr "搬迁搬迁"

#: src/SUMMARY.md
msgid "Layout"
msgstr ""
"布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布布"

#: src/SUMMARY.md
msgid "Execution Model"
msgstr "执行模式执行模式"

#: src/SUMMARY.md
msgid "Registers"
msgstr "登记册"

#: src/SUMMARY.md
msgid "Instructions"
msgstr "指示指示指示"

#: src/SUMMARY.md
msgid "Cairo Assembly (CASM)"
msgstr "开罗大会(开罗大会)"

#: src/SUMMARY.md
msgid "State transition"
msgstr "国家过渡期"

#: src/SUMMARY.md
msgid "Builtins"
msgstr "内建"

#: src/SUMMARY.md
msgid "Memory Communication"
msgstr "记忆通信"

#: src/SUMMARY.md
msgid "List of builtins"
msgstr "内嵌列表"

#: src/SUMMARY.md
msgid "Hints"
msgstr "提示"

#: src/SUMMARY.md
msgid "Structure"
msgstr "结构结构结构结构结构"

#: src/SUMMARY.md
msgid "Hint runner"
msgstr "提示运行中"

#: src/SUMMARY.md
msgid "List of hints"
msgstr "提示列表列表"

#: src/SUMMARY.md
msgid "Runner"
msgstr "运行运行器"

#: src/SUMMARY.md
msgid "Program"
msgstr "方案方案"

#: src/SUMMARY.md
msgid "Program Artifacts"
msgstr "方案非异形"

#: src/SUMMARY.md
msgid "Program Parsing"
msgstr "程序分析"

#: src/SUMMARY.md
msgid "Runner Mode"
msgstr "运行运行模式"

#: src/SUMMARY.md
msgid "Execution Mode"
msgstr "执行模式"

#: src/SUMMARY.md
msgid "Proof Mode"
msgstr "证明模式"

#: src/SUMMARY.md
msgid "Output"
msgstr ""
"产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出产出"

#: src/SUMMARY.md
msgid "Cairo PIE"
msgstr "开罗派"

#: src/SUMMARY.md
msgid "Memory File"
msgstr "内存文件"

#: src/SUMMARY.md
msgid "Trace file"
msgstr "追踪文件"

#: src/SUMMARY.md
msgid "AIR public input"
msgstr "AIR 公共投入"

#: src/SUMMARY.md
msgid "AIR private input"
msgstr "AIR 私人投入"

#: src/SUMMARY.md
msgid "Tracer"
msgstr "追踪器"

#: src/SUMMARY.md
msgid "Implementations"
msgstr "执行"

#: src/SUMMARY.md
msgid "Resources"
msgstr "资源资源资源 资源资源资源 资源资源 资源资源"

#: src/title-page.md
msgid ""
"By the Cairo Community and its [contributors](https://github.com/cairo-"
"book/cairo-book.github.io). Special thanks to "
"[StarkWare](https://starkware.co/) through "
"[OnlyDust](https://www.onlydust.xyz/), and "
"[Voyager](https://voyager.online/) for supporting the creation of this book."
msgstr ""
"由开罗社区及其[捐助者](https://github.com/cairo-book/cairo-"
"book.github.io)主持,特别感谢[StarkWare](https://starkware.co/)通过[独达 "
"(https://www.lydustrad.xyz/)和[Voyager](https://voyager.online/)支持创建这本书。"

#: src/title-page.md
msgid ""
"This version of the text assumes you’re using the [Cairo "
"Compiler](https://github.com/starkware-libs/cairo) [version "
"2.6.3](https://github.com/starkware-libs/cairo/releases). See the "
"[Installation](ch01-01-installation.md) section of Chapter 1 to install or "
"update Cairo."
msgstr ""
"本文本假定你使用第1章[Cairo 汇编机] (https://github.com/starkware-libs/cairo) [2.6.3] "
"[https://github.com/starkware-libs/cairo/releases] 部分安装或更新开罗。 "
"见[installation] (ch01-01-安放.md) 章节。"

#: src/title-page.md
msgid ""
"If you want to play around with Cairo code and see how it compiles into "
"Sierra (Intermediate Representation) and CASM (Cairo Assembly), you can use "
"[cairovm.codes](https://cairovm.codes/) playground."
msgstr ""
"如果您想玩弄开罗代码,看它如何编译成Sierra(中间代表)和CASM(开罗大会),您可以使用[cairovm.codes] "
"(https://cairovm.codes/)操场。"

#: src/ch00-01-foreword.md
msgid "Foreword"
msgstr "前言"

#: src/ch00-01-foreword.md
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and"
" gradually became more expressive. The learning curve was initially steep, "
"as Cairo 0.x was a low-level language that did not entirely abstract the "
"underlying cryptographic primitives required to build a proof for the "
"execution of a program."
msgstr ""
"2020年,史塔克瓦雷发布了支持可核查计算的一个图灵完整编程语言“开罗0 ” ( Cairo0 ) 。 开罗以组装语言开始,并逐渐变得更能表达。 "
"学习曲线最初是陡峭的,因为开罗 0.x 是低层次的语言,并不完全抽象建立执行程序证据所需的基本加密原始语言。"

#: src/ch00-01-foreword.md
msgid ""
"With the release of Cairo 1, the developer experience has considerably "
"improved, abstracting away the underlying immutable memory model of the "
"Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has "
"been built to help you create provable programs without specific knowledge "
"of its underlying architecture so that you can focus on the program itself, "
"increasing the overall security of Cairo programs. Powered by a Rust VM, the"
" execution of Cairo programs is now _blazingly_ fast, allowing you to build "
"an extensive test suite without compromising on performance."
msgstr ""
"随着开罗会议1号的发布,开发者的经验有了相当大的改善,尽可能地将开罗会议建筑的基本不可改变的记忆模型抽取出来。 "
"由鲁斯特(Rust)的强烈启发,开罗会议1号的建立是为了帮助您在对其基本结构没有具体了解的情况下创建可验证的方案,以便您能够专注于方案本身,提高开罗方案的总体安全性。"
" 由拉斯特VM(Rust VM)的推动,开罗方案的执行现在已经是快速的,使得您可以在不损及性能的情况下建立一个广泛的测试套件。"

#: src/ch00-01-foreword.md
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the"
" Cairo programming language to code their smart contracts. This allows the "
"Starknet OS to generate execution traces for transactions to be proved by a "
"prover, which is then verified on Ethereum L1 prior to updating the state "
"root of Starknet."
msgstr ""
"想要在 Starknet 上部署合同的街区链开发商将使用开罗编程语言来编码他们的智能合同。 这使得 Starknet OS 能够产生执行追踪, "
"以便由验证人来验证交易, 然后在更新 Starknet 的状态根之前在 Etheum L1 上验证。"

#: src/ch00-01-foreword.md
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit "
"from being proved on one computer and verified on other machines with lower "
"hardware requirements."
msgstr ""
"然而,开罗不仅适用于铁链开发商,而且作为一种通用编程语言,它可以用于任何计算,只要在一台计算机上得到验证,并在硬件需求较低的其他机器上得到验证,就可以从中受益。"

#: src/ch00-01-foreword.md
msgid ""
"This book is designed for developers with a basic understanding of "
"programming concepts. It is a friendly and approachable text intended to "
"help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there "
"is to know about Cairo!"
msgstr ""
"这本书是为对编程概念有基本了解的开发者设计的。 它是一个友好和可接近的文本,旨在帮助您提升对开罗的知识水平,同时也帮助您全面发展您的编程技能。 因此, "
"跳进并准备学习关于开罗的一切知识!"

#: src/ch00-01-foreword.md
msgid "Acknowledgements"
msgstr "鸣谢"

#: src/ch00-01-foreword.md
msgid ""
"This book would not have been possible without the help of the Cairo "
"community. We would like to thank every contributor for their contributions "
"to this book!"
msgstr "没有开罗社区的帮助,这本书是不可能出版的,我们要感谢每一个捐款者对这本书的贡献!"

#: src/ch00-01-foreword.md
msgid ""
"We would like to thank the Rust community for the [Rust "
"Book](https://doc.rust-lang.org/book/), which has been a great source of "
"inspiration for this book. Many examples and explanations have been adapted "
"from the Rust Book to fit the Cairo programming language, as the two "
"languages share many similarities."
msgstr ""
"我们要感谢鲁斯特社区编写了[鲁斯特书](https://doc.rust-"
"lang.org/book/),这是这本书灵感的源泉,《鲁斯特书》中的许多例子和解释已经改编,以适应开罗编程语言,因为两种语言有许多相似之处。"

#: src/ch00-00-introduction.md
msgid "What is Cairo?"
msgstr "什么是开罗?"

#: src/ch00-00-introduction.md
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name."
" The unique aspect of this processor is that it was not created for the "
"physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. "
"This means that you can perform time consuming operations on a machine you "
"don't trust, and check the result very quickly on a cheaper machine. While "
"Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo "
"1 is a higher level language. It first compiles to Sierra, an intermediate "
"representation of Cairo which will compile later down to a safe subset of "
"CASM. The point of Sierra is to ensure your CASM will always be provable, "
"even when the computation fails."
msgstr ""
"开罗是一个为同名的虚拟CPU设计的编程语言。 "
"这个处理器的独特之处在于它不是为世界上的物理限制而创建的,而是为加密的限制而创建的,使得它能够有效地证明任何程序正在运行。 "
"这意味着你可以在一个你不信任的机器上进行耗时操作,并且非常迅速地在更便宜的机器上检查结果。 虽然开罗0曾经直接编译给CASM, 开罗CPU大会, "
"开罗1是更高层次的语言。 它首先编译给Sierra, 后者是开罗的中间代表, 以后将编成CASM的一个安全子。 "
"塞拉利昂的要点是确保您的CASM永远是可行的, 即使计算失败了 。"

#: src/ch00-00-introduction.md
msgid "What Can you Do with It?"
msgstr "你能用它做什么?"

#: src/ch00-00-introduction.md
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One "
"major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a "
"decentralized blockchain platform that enables the creation of decentralized"
" applications where every single interaction between a user and a d-app is "
"verified by all the participants. Starknet is a Layer 2 built on top of "
"Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the "
"programs and generates proofs that the computations were done correctly. "
"These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and "
"reduced transaction costs while preserving Ethereum security."
msgstr ""
"开罗允许您在不受信任的机器上计算可信赖的值。 一个主要使用方是 Starknet, 这是 Ethereum 缩放的解决方案 。 Eceenum "
"是一个分散式的连锁平台, 能够创建分散式应用程序, 让所有参与者都对用户和 d- ap 进行校验。 Starknet 是位于 Etheum "
"上方的第二层。 Starknet 不是让网络的所有参与者来核查所有用户的相互作用, 而是让网络的所有参与者来核查一个节点, 叫做验证者, 执行程序, "
"并生成计算正确无误的证明。 这些证明随后由 Eceenum 智能合同进行验证, 与执行互动本身相比, 要求的计算能力要少得多 。 这种方法允许在保护 "
"Etheen 安全的同时增加吞吐量和降低交易成本 。"

#: src/ch00-00-introduction.md
msgid "What Are the Differences with Other Programming Languages?"
msgstr "与其他节目语言有什么不同?"

#: src/ch00-00-introduction.md
msgid ""
"Cairo is quite different from traditional programming languages, especially "
"when it comes to overhead costs and its primary advantages. Your program can"
" be executed in two different ways:"
msgstr "开罗与传统的编程语言有很大不同,特别是在间接费用及其主要优势方面。"

#: src/ch00-00-introduction.md
msgid ""
"When executed by the prover, it is similar to any other language. Because "
"Cairo is virtualized, and because the operations were not specifically "
"designed for maximum efficiency, this can lead to some performance overhead "
"but it is not the most relevant part to optimize."
msgstr ""
"由证明人执行时,它与其他语言类似。 因为开罗已经虚拟化,而且由于业务不是专门设计来达到最高效率的,这可能导致某些业绩管理费,但这不是最相关的部分。"

#: src/ch00-00-introduction.md
msgid ""
"When the generated proof is verified by a verifier, it is a bit different. "
"This has to be as cheap as possible since it could potentially be verified "
"on many very small machines. Fortunately verifying is faster than computing "
"and Cairo has some unique advantages to improve it even more. A notable one "
"is non-determinism. This is a topic you will cover in more detail later in "
"this book, but the idea is that you can theoretically use a different "
"algorithm for verifying than for computing. Currently, writing custom non-"
"deterministic code is not supported for the developers, but the standard "
"library leverages non-determinism for improved performance. For example "
"sorting an array in Cairo costs the same price as copying it. Because the "
"verifier doesn't sort the array, it just checks that it is sorted, which is "
"cheaper."
msgstr ""
"当生成的证明由核查者核查时,它就有点不同了。 它必须尽可能便宜, 因为它有可能在很多非常小的机器上被核查。 幸运的是, 核查比计算要快, "
"开罗有一些独特的优势来进一步改进它。 一个显著的优势是非决定性的。 这是一个您在本书后面会更详细地讨论的专题, 但这个想法是, "
"您可以在理论上使用一种不同的算法来核查。 目前, 开发者不支持写自定义的非确定性代码, 但标准图书馆可以利用非确定性来改进性能。 例如, "
"在开罗对一个阵列进行分类, 成本与复制该阵列相同。 因为验证者不排序阵列, 它只是检查它被排序的算法, 成本更低。"

#: src/ch00-00-introduction.md
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, "
"memory access is immutable, meaning that once a value is written to memory, "
"it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. "
"Therefore, developers must think carefully about how they manage memory and "
"data structures in their programs to optimize performance."
msgstr ""
"将语言分开的另一个方面是其记忆模型。 在开罗,记忆存取是不可改变的,这意味着一旦一个数值写入记忆,它就无法改变。 "
"开罗一号提供了抽象概念,帮助开发者克服这些制约,但并不完全模拟变异性。 因此,开发者必须仔细思考如何在程序内管理内存和数据结构,以优化性能。"

#: src/ch00-00-introduction.md
msgid "References"
msgstr "参考参考资料"

#: src/ch00-00-introduction.md
msgid "Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>"
msgstr "开罗CPU建筑:<https://eprint.iacr.org/2021/1063>"

#: src/ch00-00-introduction.md
msgid ""
"Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-"
"of-cairo-1-0-exploring-sierra-7f32808421f5>"
msgstr ""
"开罗、塞拉和卡斯姆:<https://medic.com/nethermind-eth/under-found-hood-for-"
"cairo-1-0-exploring-sierra-7f32808421f5>"

#: src/ch00-00-introduction.md
msgid ""
"State of non determinism: "
"<https://twitter.com/PapiniShahar/status/1638203716535713798>"
msgstr "非决定性现状:<https://twitter.com/PapiniShahar/status/1638203735353713798>"

#: src/ch01-00-getting-started.md
msgid ""
"Let’s start your Cairo journey! There’s a lot to learn, but every journey "
"starts somewhere. In this chapter, we’ll discuss:"
msgstr "让我们开始你的开罗之旅吧!有很多东西需要学习,但每次旅程都从某处开始。在本章中,我们将讨论:"

#: src/ch01-00-getting-started.md
msgid ""
"Installing Scarb, which is Cairo's build toolchain and package manager, on "
"Linux, macOS, and Windows."
msgstr "在Linux、MacOS和Windows上安装疤痕,这是开罗的建筑工具链和软件包管理器。"

#: src/ch01-00-getting-started.md
msgid "Writing a program that prints `Hello, world!`."
msgstr "写一个程序,印有 \" 你好,世界! \" 。"

#: src/ch01-00-getting-started.md
msgid "Using basic Scarb commands to create a project and execute a program."
msgstr "使用基本的疤痕命令创建工程并执行程序 。"

#: src/ch01-00-getting-started.md
msgid "Getting Help"
msgstr "寻求帮助"

#: src/ch01-00-getting-started.md
msgid ""
"If you have any questions about Starknet or Cairo, you can ask them in the "
"[Starknet Discord server](https://discord.gg/starknet-community). The "
"community is friendly and always willing to help."
msgstr ""
"如果您有任何关于斯塔克内特或开罗的疑问, 您可以在 Starknet Discord 服务器( https:// discord.gg/ "
"starknet- community) ( https:// discord. gg/ starknet- community) 中询问。 "
"社区是友好的, 并且总是愿意提供帮助 。"

#: src/ch01-00-getting-started.md
msgid "Interacting with the Cairo Chatbot"
msgstr "与开罗查波特互动"

#: src/ch01-00-getting-started.md
msgid ""
"Cairo has its own chatbot, which can help you with Cairo-related questions. "
"The chatbot is trained on the Cairo book, and uses RAG to efficiently "
"retrieve information to provide help. You can find the chatbot on the "
"[Cairo-Chatbot](https://cairo-chatbot.vercel.app/) website."
msgstr ""
"开罗有它自己的聊天室,可以帮助您解决与开罗有关的问题。 聊天室接受开罗书的培训,并利用RAG有效检索信息来提供帮助。 您可以在 [Cairo-"
"Chatbot] (https://cairo-chatbot.vercel.app/) 网站上找到聊天室。"

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading "
"[Scarb](https://docs.swmansion.com/scarb/docs). Scarb bundles the Cairo "
"compiler and the Cairo language server together in an easy-to-install "
"package so that you can start writing Cairo code right away."
msgstr ""
"开罗可以通过简单的下载 [Scarb] (https://docs.swmansion.com/scarb/docs) 来安装。 "
"斯卡布将开罗汇编器和开罗语言服务器捆绑在一起,在一个容易安装的软件包中,以便您能够马上开始写入开罗代码。"

#: src/ch01-01-installation.md:5
msgid ""
"Scarb is also Cairo's package manager and is heavily inspired by "
"[Cargo](https://doc.rust-lang.org/cargo/), Rust’s build system and package "
"manager."
msgstr ""
"Scarb也是开罗的一揽子计划经理,深受[Cargo](https://doc.rust-"
"lang.org/cargo/)、Rust的建筑系统和一揽子计划经理的启发。"

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either "
"pure Cairo or Starknet contracts), downloading the libraries your code "
"depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""
"刀疤为您处理许多任务, 例如建立您的代码(纯开罗或史塔克内特合同), 下载您的代码所依赖的图书馆, 建立这些图书馆, 并为 VSCode Cairo 1"
" 扩展提供LSP 支持 。"

#: src/ch01-01-installation.md:9
msgid ""
"As you write more complex Cairo programs, you might add dependencies, and if"
" you start a project using Scarb, managing external code and dependencies "
"will be a lot easier to do."
msgstr "当你写更复杂的开罗程序时,你可能会增加依赖性, 如果你开始一个使用刀疤的项目, 管理外部代码和依赖性会更容易得多。"

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr "我们先安装刀疤吧"

#: src/ch01-01-installation.md:16
msgid "Installing Scarb"
msgstr "正在安装 scrab"

#: src/ch01-01-installation.md:18
msgid "Requirements"
msgstr "所需资源所需资源所需资源所需资源所需资源所需资源所需资源所需资源所需资源所需资源所需资源"

#: src/ch01-01-installation.md:20
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment "
"variable."
msgstr "疤痕要求在“ PATH” 环境变量中提供 Git 执行文件。"

#: src/ch01-01-installation.md:24
msgid ""
"To install Scarb, please refer to the [installation "
"instructions](https://docs.swmansion.com/scarb/download). We strongly "
"recommend that you install Scarb [via "
"asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf), a "
"CLI tool that can manage multiple language runtime versions on a per-project"
" basis. This will ensure that the version of Scarb you use to work on a "
"project always matches the one defined in the project settings, avoiding "
"problems related to version mismatches."
msgstr ""
"要安装疤痕,请参见[安装指示] (https://docs.swmansion.com/scarb/download)。我们强烈建议您安装疤痕[通过 "
"asdf] (https://docs.swmansion.com/scarb/download.html#attall-via-"
"asdf),这是一个CLI工具,可以按项目管理多种语文运行时间版本。这将确保您用于执行项目的刀疤版本始终与项目设置中定义的相同,避免版本错配问题。"

#: src/ch01-01-installation.md:28
msgid ""
"Please refer to the [asdf documentation](https://asdf-vm.com/guide/getting-"
"started.html) to install all prerequisites."
msgstr ""
"请参看[asdf documents] (https://asdf-vm.com/guide/getting-"
"started.html),以安装所有先决条件。"

#: src/ch01-01-installation.md:30
msgid ""
"Once you have asdf installed locally, you can download Scarb plugin with the"
" following command:"
msgstr "您一旦在本地安装了 asdf, 就可以下载 Scarb 插件, 其命令如下 :"

#: src/ch01-01-installation.md:36
msgid "This will allow you to download specific versions:"
msgstr "这将允许您下载特定版本 :"

#: src/ch01-01-installation.md:42
msgid "and set a global version:"
msgstr "并设定一个全局版本 :"

#: src/ch01-01-installation.md:48
msgid ""
"Otherwise, you can simply run the following command in your terminal, and "
"follow the onscreen instructions. This will install the latest stable "
"release of Scarb."
msgstr "否则, 您可以在终端运行以下命令, 并遵循屏幕上的指令 。 这将安装最新的 Scarb 稳定释放 。"

#: src/ch01-01-installation.md:51
msgid "'=https'"
msgstr "\"<https\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch01-01-installation.md:68
msgid "Installing the VSCode Extension"
msgstr "安装 VSCode 扩展安装"

#: src/ch01-01-installation.md:70
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code "
"completion, and other useful features. You can install it from the [VSCode "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)."
" Once installed, go into the extension settings, and make sure to tick the "
"`Enable Language Server` and `Enable Scarb` options."
msgstr ""
"开罗有一个 VSCode 扩展名, 提供语法突顯、 代码完成和其他有用的功能。 您可以从 [ VSCode 市场] (https:// "
"smarkedplace. visualstudio.com/ items?itemName=starkware. cairo1) 安装它, "
"一旦安装后, 进入扩展设置, 并确保选中“ 可使用语言服务器” 和“ 可使用疤痕” 选项 。"

#: src/ch01-01-installation.md:75
msgid "{{#quiz ../quizzes/ch01-01-installation.toml}}"
msgstr "Quiz./quizzes/ch01-01-安放.toml"

#: src/ch01-02-hello-world.md:1
msgid "Hello, World"
msgstr "你好,世界,你好"

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first"
" Cairo program. It’s traditional when learning a new language to write a "
"little program that prints the text `Hello, world!` to the screen, so we’ll "
"do the same here!"
msgstr ""
"现在您已经通过刀疤安装了开罗,现在是时候写下您的第一个开罗程序了。 学习新语言写一个小程序,将文字印在屏幕上, “ 你好,世界!! ” "
"所以我们在这里也这样做!"

#: src/ch01-02-hello-world.md:7
msgid ""
"Note: This book assumes basic familiarity with the command line. Cairo makes"
" no specific demands about your editing or tooling or where your code lives,"
" so if you prefer to use an integrated development environment (IDE) instead"
" of the command line, feel free to use your favorite IDE. The Cairo team has"
" developed a VSCode extension for the Cairo language that you can use to get"
" the features from the language server and code highlighting. See [Appendix "
"F](./appendix-06-useful-development-tools.md) for more details."
msgstr ""
"注意 : 本书假定您基本熟悉命令行 。 开罗没有对您的编辑或工具或代码使用地点提出具体要求, 所以如果您喜欢使用综合开发环境( IDE) 而不是命令行,"
" 请随意使用您最喜欢的 IDE 。 开罗团队开发了开罗语言的 VSCode 扩展名, 您可以从语言服务器和代码突出显示中获取功能 。 详情请参见 [ "
"附录F] (./ ppendix- 06- useful Development- tools. md) 。"

#: src/ch01-02-hello-world.md:17
msgid "Creating a Project Directory"
msgstr "创建工程目录"

#: src/ch01-02-hello-world.md:19
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t "
"matter to Cairo where your code lives, but for the exercises and projects in"
" this book, we suggest making a _cairo_projects_ directory in your home "
"directory and keeping all your projects there."
msgstr ""
"首先,您将制作一个存储您的开罗代码的目录。 开罗与您的代码生活在哪里无关,但对于这本书中的练习和项目,我们建议在您的主目录中制作一个 "
"_cairo_projects_目录,并将您的所有项目保存在那里。"

#: src/ch01-02-hello-world.md:24
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory."
msgstr "打开一个终端并输入以下命令以创建 _cairo_project_ 目录 。"

#: src/ch01-02-hello-world.md:26
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr "Linux, macOS, 和Windows上的PowerShell, 请输入此信息 :"

#: src/ch01-02-hello-world.md:33
msgid "For Windows CMD, enter this:"
msgstr "Windows CCMD 输入此选项:"

#: src/ch01-02-hello-world.md:36 src/ch01-02-hello-world.md:37
msgid "\"%USERPROFILE%\\cairo_projects\""
msgstr ""
"“% USERPROFILE cairo_ Projects” ( % USERPROFILE cairo_ Projects) ( % "
"USERPROFILE cairo_ Projects) ( % USERPROFILE cairo_ projects) ( % "
"USERPROFILE cairo_ projects) ” (% USERPERPROFILE cairo_ projects) ( %) (% "
"USERPROFILE cairo_ projects) ( %) (% USERPROPILILE) (项目) (项目)"

#: src/ch01-02-hello-world.md:40
msgid ""
"Note: From now on, for each example shown in the book, we assume that you "
"will be working from a Scarb project directory. If you are not using Scarb, "
"and try to run the examples from a different directory, you might need to "
"adjust the commands accordingly or create a Scarb project."
msgstr ""
"注意 : 从现在开始, 对于书中显示的每个示例, 我们假设您将使用“ 疤痕” 项目目录。 如果您没有使用“ 疤痕” 项目目录, "
"并尝试从不同的目录运行示例, 您可能需要相应调整命令或创建“ 疤痕” 项目 。"

#: src/ch01-02-hello-world.md:43
msgid "Creating a Project with Scarb"
msgstr "创建带有刀疤的工程"

#: src/ch01-02-hello-world.md:45
msgid "Let’s create a new project using Scarb."
msgstr "让我们用刀疤创建一个新项目。"

#: src/ch01-02-hello-world.md:47
msgid ""
"Navigate to your _cairo_projects_ directory (or wherever you decided to "
"store your code). Then run the following:"
msgstr "导航到您的 _cairo_ projects_ 目录 (或决定存储代码的地址) 。 然后运行以下操作 :"

#: src/ch01-02-hello-world.md:53
msgid ""
"It creates a new directory and project called _hello_world_. We’ve named our"
" project _hello_world_, and Scarb creates its files in a directory of the "
"same name."
msgstr ""
"它创建了一个新的目录和工程,名为_Hello_world_。我们命名了我们的工程_Hello_world_,Scarb在同一个名称的目录中创建了自己的文件。"

#: src/ch01-02-hello-world.md:55
msgid ""
"Go into the _hello_world_ directory with the command `cd hello_world`. "
"You’ll see that Scarb has generated two files and one directory for us: a "
"_Scarb.toml_ file and a _src_ directory with a _lib.cairo_ file inside."
msgstr ""
"进入“ cd hello_world” 命令的 _hello_world_目录。你会看到,疤痕为我们生成了两个文件和一个目录:一个 "
"_Scarb.toml_文件,以及一个包含 _lib.cairo_文件的 _src_目录。"

#: src/ch01-02-hello-world.md:57
msgid ""
"It has also initialized a new Git repository along with a `.gitignore` file"
msgstr "它还启动了一个新的 Git 仓库,以及一个`.gitignore'文件。"

#: src/ch01-02-hello-world.md:59
msgid ""
"Note: Git is a common version control system. You can stop using version "
"control system by using the `--no-vcs` flag. Run `scarb new --help` to see "
"the available options."
msgstr ""
"注: Git 是一个通用的版本控制系统。 您可以使用 ` - no- vcs' 旗帜停止使用版本控制系统。 运行'scarb new - "
"help'以查看可用的选项 。"

#: src/ch01-02-hello-world.md:62
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-1."
msgstr "在您选择的文本编辑器中打开 _Scarb.toml_。 它应该与列表 1-1 中的代码相似 。"

#: src/ch01-02-hello-world.md:64
msgid "<span class=\"filename\">Filename: Scarb.toml</span>"
msgstr "<span类=\"filename\" >Filename: Scarb.toml </span>"

#: src/ch01-02-hello-world.md:66
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"edition = \"2023_11\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"*Toml [包 名称 = \"Hello_world\" 版本 = \"0.1.0\" 版本 = \"2023_11\" # 更多钥匙及其定义见 "
"https://docs.swmansion.com/scarb/docs/ reference/manifest [dependies] # foo "
"= {路径 = \"vendor/foo\" } *"

#: src/ch01-02-hello-world.md:78
msgid ""
"<span class=\"caption\">Listing 1-1: Contents of _Scarb.toml_ generated by "
"`scarb new`</span>"
msgstr "<span类=“ caption” > listing 1-1:`scarb new_/span>生成的_Scarb.toml_的内容"

#: src/ch01-02-hello-world.md:80
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal "
"Language) format, which is Scarb’s configuration format."
msgstr "此文件采用[ TOML] (https://toml.io/) (Tom的显性、 最小语言) 格式, 即刀疤的配置格式 。"

#: src/ch01-02-hello-world.md:82
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr "第一行,`[包 `,是一节标题,显示以下语句正在配置一个软件包,随着我们增加更多信息,我们将增加其他部分。"

#: src/ch01-02-hello-world.md:84
msgid ""
"The next three lines set the configuration information Scarb needs to "
"compile your program: the name of the package and the version of Scarb to "
"use, and the edition of the prelude to use. The prelude is the collection of"
" the most commonly used items that are automatically imported into every "
"Cairo program. You can learn more about the prelude in [Appendix "
"D](./appendix-04-cairo-prelude.md)."
msgstr ""
"接下来的三行设置了配置信息 Scarb 需要来编译您的程序: 软件包的名称和要使用的 Scarb 版本, 以及要使用的序曲版本。 "
"前导是收集每个开罗程序自动导入的最常用的物品。 您可以在 [ 附录D] (./ appendix- 04- cairo- prelude. md) "
"中了解更多前奏 。"

#: src/ch01-02-hello-world.md:86
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Cairo, packages of code are referred "
"to as crates. We won’t need any other crates for this project."
msgstr "最后一行“[依附 ”是您列出您项目任何属地的一节的起始部分。 在开罗, 代码包被称为箱子。 我们不需要其它任何用于这个项目的箱子 。"

#: src/ch01-02-hello-world.md:88
msgid ""
"Note: If you're building contracts for Starknet, you will need to add the "
"`starknet` dependency as mentioned in the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-"
"package.html)."
msgstr ""
"注:如果您正在为Starknet订立合同,您需要添加[Scarb文件](https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-"
"package.html)中提及的`starknet'依赖性。"

#: src/ch01-02-hello-world.md:90
msgid ""
"The other file created by Scarb is _src/lib.cairo_, let's delete all the "
"content and put in the following content, we will explain the reason later."
msgstr "Scarb 创建的另一个文件是 _src/lib.cairo_,让我们删除所有内容并加入以下内容,我们稍后解释原因。"

#: src/ch01-02-hello-world.md:96
msgid ""
"Then create a new file called _src/hello_world.cairo_ and put the following "
"code in it:"
msgstr "然后创建一个名为 _src/hello_world.cairo_的新文件,并在其中输入以下代码:"

#: src/ch01-02-hello-world.md:98
msgid "<span class=\"filename\">Filename: src/hello_world.cairo</span>"
msgstr "<span类=\"filename\" >Filename: src/hello_world.cairo </span>"

#: src/ch01-02-hello-world.md:102 src/ch01-02-hello-world.md:185
msgid "\"Hello, World!\""
msgstr "\"你好,世界!\""

#: src/ch01-02-hello-world.md:106
msgid ""
"We have just created a file called _lib.cairo_, which contains a module "
"declaration referencing another module named `hello_world`, as well as the "
"file _hello_world.cairo_, containing the implementation details of the "
"`hello_world` module."
msgstr ""
"我们刚刚创建了一个名为_lib.cairo_的文件,其中载有一个模块声明,其中引用了另一个名为`Hello_world'的模块,以及载有`Hello_world'模块实施细节的文件_Hello_world.cairo_。"

#: src/ch01-02-hello-world.md:108
msgid ""
"Scarb requires your source files to be located within the _src_ directory."
msgstr "Scarb 要求您的源文件位于 _src_目录内。"

#: src/ch01-02-hello-world.md:110
msgid ""
"The top-level project directory is reserved for README files, license "
"information, configuration files, and any other non-code-related content. "
"Scarb ensures a designated location for all project components, maintaining "
"a structured organization."
msgstr ""
"顶级项目目录保留给 README 文件、 许可证信息、 配置文件和任何其他非代码相关内容。 刀疤确保为所有项目组成部分指定一个位置, "
"并维持一个结构化的组织 。"

#: src/ch01-02-hello-world.md:113
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a "
"project that does use Scarb. Move the project code into the _src_ directory "
"and create an appropriate _Scarb.toml_ file. You can also use `scarb init` "
"command to generate the _src_ folder and the _Scarb.toml_ it contains."
msgstr ""
"如果您启动一个不使用 scrab 的工程, 您可以将其转换为使用 scrab 的工程。 将工程代码移动到 _ src_ 目录中, 并创建合适的 _ "
"Scarb.toml_ 文件。 您也可以使用 sccarb init 命令生成 _ src_ 文件夹及其包含的 _ Scarb.toml_ 。"

#: src/ch01-02-hello-world.md:122
msgid "<span class=\"caption\"> A sample Scarb project structure</span>"
msgstr "<span类=“caption” > > 一个刀疤项目结构样本 </span>"

#: src/ch01-02-hello-world.md:128
msgid "Building a Scarb Project"
msgstr "建造刀疤项目"

#: src/ch01-02-hello-world.md:130
msgid ""
"From your _hello_world_ directory, build your project by entering the "
"following command:"
msgstr "从您的 _Hello_world_目录中输入以下命令来构建您的工程 :"

#: src/ch01-02-hello-world.md:138
msgid ""
"This command creates a `sierra` file in _target/dev_, let's ignore the "
"`sierra` file for now."
msgstr "此命令在 _ target/ dev_ 创建一个“ sierra” 文件, 让我们暂时忽略“ sierra” 文件 。"

#: src/ch01-02-hello-world.md:140
msgid ""
"If you have installed Cairo correctly, you should be able to run the `main` "
"function of your program with the `scarb cairo-run` command and see the "
"following output:"
msgstr "如果您正确安装了开罗, 您应该能够使用“ scarb cairo- run” 命令运行您的程序的“ main” 函数, 并查看以下输出 :"

#: src/ch01-02-hello-world.md:149
msgid ""
"Regardless of your operating system, the string `Hello, world!` should be "
"printed to the terminal."
msgstr "不论操作系统如何,字符串`你好,世界!'应印在终端上。"

#: src/ch01-02-hello-world.md:152
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Cairo program. That makes you a Cairo programmer — welcome!"
msgstr "如果“你好,世界!”你印了字,恭喜你!你已经正式写了开罗方案,使你成为开罗程序员——欢迎!"

#: src/ch01-02-hello-world.md:155
msgid "Anatomy of a Cairo Program"
msgstr "开罗方案解剖"

#: src/ch01-02-hello-world.md:157
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of the puzzle:"
msgstr "让我们详细审查这个“哈罗,世界! ” 的程序。 这是拼图的第一块:"

#: src/ch01-02-hello-world.md:166
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it is always the first code that runs in every executable Cairo program. "
"Here, the first line declares a function named `main` that has no parameters"
" and returns nothing. If there were parameters, they would go inside the "
"parentheses `()`."
msgstr ""
"这些线条定义了名为`main' 的函数。 `main' 函数是特殊的: 每个可执行的开罗程序总是第一个运行的代码。 这里, "
"第一行宣布一个名为`main'的函数, 它没有参数, 没有返回任何函数。 如果有参数, 它们会进入括号` ()' 。"

#: src/ch01-02-hello-world.md:171
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around "
"all function bodies. It’s good style to place the opening curly bracket on "
"the same line as the function declaration, adding one space in between."
msgstr ""
"函数正文在 {} 中包装 。 开罗需要将所有函数机构括号括号括在括号上。 将打开的圆括号放在与函数声明相同的行上, 并在中间添加一个空格, 很有风格 。"

#: src/ch01-02-hello-world.md:175
msgid ""
"Note: If you want to stick to a standard style across Cairo projects, you "
"can use the automatic formatter tool available with `scarb fmt` to format "
"your code in a particular style (more on `scarb fmt` in [Appendix "
"F](./appendix-06-useful-development-tools.md)). The Cairo team has included "
"this tool with the standard Cairo distribution, as `cairo-run` is, so it "
"should already be installed on your computer!"
msgstr ""
"注意 : 如果您想要在整个开罗工程中坚持标准样式, 您可以使用可用“ sccarb fmt” 的自动物质工具, 以特定样式( 更多在 [ 附录F 中的“"
" scarb fmt” (./ appendix-06- useful Development- tools. md) ) 格式化您的代码。 "
"开罗团队已经将这个工具与标准开罗分布( “ cairo- run” ) 格式化为“ cairo- run”, 因此它应该已经安装在您的计算机上!"

#: src/ch01-02-hello-world.md:182
msgid "The body of the `main` function holds the following code:"
msgstr "`主要'职能的主体有以下代码:"

#: src/ch01-02-hello-world.md:188
msgid ""
"This line does all the work in this little program: it prints text to the "
"screen. There are four important details to notice here."
msgstr "这条线可以完成这个小程序的所有工作: 它打印到屏幕上的文字。 这里需要注意四个重要细节 。"

#: src/ch01-02-hello-world.md:191
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr "首先,开罗风格是用四个空格缩进,而不是一个标签。"

#: src/ch01-02-hello-world.md:193
msgid ""
"Second, `println!` calls a Cairo macro. If it had called a function instead,"
" it would be entered as `println` (without the `!`). We’ll discuss Cairo "
"macros in more detail in the [\"Macros\"](./ch11-05-macros.md) chapter. For "
"now, you just need to know that using a `!` means that you’re calling a "
"macro instead of a normal function and that macros don’t always follow the "
"same rules as functions."
msgstr ""
"第二,`println!' 称为开罗宏,如果它称为函数,则输入为`println'(没有`!'!”),我们将在[“Macross'] "
"(./ch11-05-macros.md)章中更详细地讨论开罗宏。现在,你只需要知道,使用`!'就意味着你正在调用一个宏而不是正常的函数,而且宏并不总是遵循与函数相同的规则。"

#: src/ch01-02-hello-world.md:196
msgid ""
"Third, you see the `\"Hello, world!\"` string. We pass this string as an "
"argument to `println!`, and the string is printed to the screen."
msgstr "第三,你可以看到“你好,世界!” 字符串,我们通过这一字符串作为`println!'的论据,字符串印在屏幕上。"

#: src/ch01-02-hello-world.md:198
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this "
"expression is over and the next one is ready to begin. Most lines of Cairo "
"code end with a semicolon."
msgstr "第四,我们用分号(`;`)结束这条线,表示这一表达方式已经结束,下一个表达方式准备开始,开罗代码的大多数行以分号结束。"

#: src/ch01-02-hello-world.md:205
msgid "{{#quiz ../quizzes/ch01-02-hello-world.toml}}"
msgstr "/ quizzes/ch01-02-Hello-world.toml"

#: src/ch01-02-hello-world.md:207 src/ch02-05-control-flow.md:311
#: src/ch07-05-separating-modules-into-different-files.md:97
#: src/ch09-02-recoverable-errors.md:188
#: src/ch11-01-custom-data-structures.md:345
#: src/ch11-06-inlining-in-cairo.md:269
#: src/ch17-02-testing-smart-contracts.md:730
msgid "Summary"
msgstr "摘要摘要摘要"

#: src/ch01-02-hello-world.md:209
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr "让我们回顾一下我们至今为止所学到的关于刀疤的教训:"

#: src/ch01-02-hello-world.md:211
msgid ""
"We can install one or multiple Scarb versions, either the latest stable or a"
" specific one, using asdf."
msgstr "我们可以安装一个或多个疤痕版本, 无论是最新的稳定版本还是特定的版本, 使用 asdf 。"

#: src/ch01-02-hello-world.md:212
msgid "We can create a project using `scarb new`."
msgstr "我们可以用`新的碳碳'创建一个项目。"

#: src/ch01-02-hello-world.md:213
msgid ""
"We can build a project using `scarb build` to generate the compiled Sierra "
"code."
msgstr "我们可以利用`碳碳建设'建立一个项目,以产生汇编的塞拉利昂法典。"

#: src/ch01-02-hello-world.md:214
msgid "We can execute a Cairo program using the `scarb cairo-run` command."
msgstr "我们可以使用`scarb cairo-run'命令执行开罗方案。"

#: src/ch01-02-hello-world.md:216
msgid ""
"An additional advantage of using Scarb is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no"
" longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""
"使用刀疤的另一个好处是,无论你正在操作哪个操作系统,命令都是一样的。 因此,此时此刻,我们将不再为Linux和MacOS与Windows提供具体的指示。"

#: src/ch01-02-hello-world.md:218
msgid ""
"You’re already off to a great start on your Cairo journey! This is a great "
"time to build a more substantial program to get used to reading and writing "
"Cairo code."
msgstr "您已经踏上开罗之旅的伟大开端了 。 这是一个构建一个更实质性的程式, 以适应阅读和写开罗代码的好时机 。"

#: src/ch02-00-common-programming-concepts.md
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Cairo. Many programming languages have much in"
" common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain "
"the conventions around using these concepts."
msgstr ""
"本章涵盖了几乎每种编程语言中出现的概念及其在开罗的工作方式。 许多编程语言的核心有许多共同之处。 "
"本章提出的任何概念都不是开罗所独有的,但我们将在开罗讨论这些概念,并解释使用这些概念的公约。"

#: src/ch02-00-common-programming-concepts.md
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Cairo "
"program, and learning them early will give you a strong core to start from."
msgstr "具体地说,你会了解变量、基本类型、功能、评论和控制流程。 这些基础将被纳入每个开罗方案,而早期的学习将为您提供从头开始的强大核心。"

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is "
"written to, it can't be overwritten but only read from. To reflect this "
"immutable memory model, variables in Cairo are immutable by default. "
"However, the language abstracts this model and gives you the option to make "
"your variables mutable. Let’s explore how and why Cairo enforces "
"immutability, and how you can make your variables mutable."
msgstr ""
"开罗使用不可更改的内存模型,这意味着一旦内存单元格被写入,它就不能被覆盖,而只能从中读取。为了反映这种不可更改的内存模型,开罗的变量默认是不可变的。然而,语言摘要本模型给了您使变量变异的选项。让我们来探索开罗是如何和为什么强制执行不可变化的,以及如何使变量变异。"

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t "
"change that value. To illustrate this, generate a new project called "
"_variables_ in your _cairo_projects_ directory by using `scarb new "
"variables`."
msgstr ""
"当变量不可变时, 一旦一个值与名称捆绑在一起, 您就不能更改该值 。 要说明这一点, 请在您的 _ cairo_ Projects_ 目录中, 使用“ "
"scrab new 变量” 创建一个名为 _ variables_ 的新工程 。"

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace "
"its code with the following code, which won’t compile just yet:"
msgstr "然后,在您新的可变目录中,打开 _src/lib.cairo_,用以下代码取代代码,这些代码目前还无法编译:"

#: src/ch02-01-variables-and-mutability.md:17
#: src/ch04-01-what-is-ownership.md:265 src/ch04-01-what-is-ownership.md:310
#: src/ch04-02-references-and-snapshots.md:26
#: src/ch04-02-references-and-snapshots.md:118
#: src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:27
#: src/ch05-01-defining-and-instantiating-structs.md:53
#: src/ch05-01-defining-and-instantiating-structs.md:89
#: src/ch05-01-defining-and-instantiating-structs.md:125
#: src/ch05-01-defining-and-instantiating-structs.md:167
#: src/ch05-01-defining-and-instantiating-structs.md:203
#: src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:50
#: src/ch05-02-an-example-program-using-structs.md:75
#: src/ch07-02-defining-modules-to-control-scope.md:80
#: src/ch07-02-defining-modules-to-control-scope.md:137
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:14
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:90
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:116
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:150
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:36
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:81
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:133
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:206
#: src/ch07-05-separating-modules-into-different-files.md:18
#: src/ch09-01-unrecoverable-errors-with-panic.md:9
#: src/ch10-01-how-to-write-tests.md:32 src/ch10-01-how-to-write-tests.md:89
#: src/ch10-01-how-to-write-tests.md:140 src/ch10-01-how-to-write-tests.md:222
#: src/ch10-01-how-to-write-tests.md:334 src/ch10-01-how-to-write-tests.md:558
#: src/ch10-01-how-to-write-tests.md:652 src/ch10-01-how-to-write-tests.md:741
msgid "<span class=\"filename\">Filename: src/lib.cairo</span>"
msgstr "<span类=\"filename\" >Filename: src/lib.cairo </span>"

#: src/ch02-01-variables-and-mutability.md:22
#: src/ch02-01-variables-and-mutability.md:24
#: src/ch02-01-variables-and-mutability.md:89
#: src/ch02-01-variables-and-mutability.md:91
#: src/ch02-01-variables-and-mutability.md:248
#: src/ch02-01-variables-and-mutability.md:250 src/ch02-03-functions.md:71
#: src/ch02-03-functions.md:287 src/ch02-03-functions.md:325
#: src/ch02-03-functions.md:341
msgid "\"The value of x is: {}\""
msgstr "\"x的值是:\""

#: src/ch02-01-variables-and-mutability.md:29
msgid ""
"Save and run the program using `scarb cairo-run`. You should receive an "
"error message regarding an immutability error, as shown in this output:"
msgstr "使用“ scarb cairo- run” 保存并运行程序。 您应该收到关于不可改变错误的错误信息, 如此输出所示 :"

#: src/ch02-01-variables-and-mutability.md:45
msgid ""
"This example shows how the compiler helps you find errors in your programs. "
"Compiler errors can be frustrating, but they only mean your program isn’t "
"safely doing what you want it to do yet; they do _not_ mean that you’re not "
"a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""
"这个示例显示了编译器如何帮助您在您的编程中发现错误。 编译器的错误可能令人沮丧, 但这些错误只意味着您的编译器无法安全地完成您想要它做的事情; "
"它们确实不是意味着您不是一个好的编译器! 经验丰富的开罗会议仍然有编译器错误 。"

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"You received the error message `Cannot assign to an immutable variable.` "
"because you tried to assign a second value to the immutable `x` variable."
msgstr "您收到了错误消息 `无法指定为不可更改的变量 。'因为你试图为不可更改的“ x” 变量指定第二个值 。"

#: src/ch02-01-variables-and-mutability.md:53
msgid ""
"It’s important that we get compile-time errors when we attempt to change a "
"value that’s designated as immutable because this specific situation can "
"lead to bugs. If one part of our code operates on the assumption that a "
"value will never change and another part of our code changes that value, "
"it’s possible that the first part of the code won’t do what it was designed "
"to do. The cause of this kind of bug can be difficult to track down after "
"the fact, especially when the second piece of code changes the value only "
"_sometimes_."
msgstr ""
"重要的是,当我们试图改变一个被指定为不可改变的值时,当我们试图改变一个被指定为不可改变的值时,我们就会发现编译时间错误,因为这一具体情况可能导致错误。 "
"如果我们的代码的一部分是基于一个值永远不会改变的假设操作的,而我们的代码的另一部分则会改变这个值,那么代码的第一部分可能不会做它设计要做的事情。 "
"这种错误的原因在事后很难找到,特别是当第二部分代码只改变值时。"

#: src/ch02-01-variables-and-mutability.md:61
msgid ""
"Cairo, unlike most other languages, has immutable memory. This makes a whole"
" class of bugs impossible, because values will never change unexpectedly. "
"This makes code easier to reason about."
msgstr "开罗与其他大多数语言不同,它有着不可改变的记忆。 这使得一整类的错误不可能存在,因为价值永远不会意外地改变。 这让代码更容易解释。"

#: src/ch02-01-variables-and-mutability.md:65
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write. Although variables are immutable by default, you can make them "
"mutable by adding `mut` in front of the variable name. Adding `mut` also "
"conveys intent to future readers of the code by indicating that other parts "
"of the code will be changing the value associated to this variable."
msgstr ""
"但易变性可以非常有用, 并且可以让代码更方便地写入。 虽然变量默认是不可变的, 但是您可以通过在变量名称前面添加“ mot” 来使其变异性。 添加“ "
"mut” 也可以通过显示代码的其他部分将改变与该变量相关的值, 向代码的未来阅读者表达其意图 。"

#: src/ch02-01-variables-and-mutability.md:73
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable is declared as `mut`, as we previously mentioned that Cairo's "
"memory is immutable. The answer is that the _value_ is immutable, but the "
"_variable_ isn't. The value associated to the variable can be changed. "
"Assigning to a mutable variable in Cairo is essentially equivalent to "
"redeclaring it to refer to another value in another memory cell, but the "
"compiler handles that for you, and the keyword `mut` makes it explicit. Upon"
" examining the low-level Cairo Assembly code, it becomes clear that variable"
" mutation is implemented as syntactic sugar, which translates mutation "
"operations into a series of steps equivalent to variable shadowing. The only"
" difference is that at the Cairo level, the variable is not redeclared so "
"its type cannot change."
msgstr ""
"然而,您可能会在这一点上想知道当变量被宣布为“ mut ” 时,当变量被宣布为“ mut ”, 正如我们先前提到的开罗的内存是不可变的。 答案是 _ "
"value_ 是不可变的, 但却不是。 变量的相关值可以被更改。 在开罗指定为可变变量实质上相当于重新声明它指另一个内存单元格中的另一个值, "
"但编译者会处理该变量, 而关键词“ mut ” 则让它变得清晰。 在审查开罗大会的低级别代码时, 很明显变异是作为合成糖执行的, "
"它将变异操作转化为一系列与变影相等的步骤。 唯一不同的是, 在开罗一级, 该变量没有被重新声明, 其类型无法改变 。"

#: src/ch02-01-variables-and-mutability.md:84
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr "例如,让我们将 _src/lib.cairo_改为:"

#: src/ch02-01-variables-and-mutability.md:95
msgid "When we run the program now, we get this:"
msgstr "当我们现在运行这个程序时, 我们得到这个:"

#: src/ch02-01-variables-and-mutability.md:108
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is"
" used. Ultimately, deciding whether to use mutability or not is up to you "
"and depends on what you think is clearest in that particular situation."
msgstr "我们被允许将`x'的定值从`5'改为`6'时使用` mut',最终决定是否使用变异性取决于你,取决于你认为在这一特定情况下最清楚什么。"

#: src/ch02-01-variables-and-mutability.md:112
msgid "Constants"
msgstr "常数常数"

#: src/ch02-01-variables-and-mutability.md:114
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and are not allowed to change, but there are a few differences between "
"constants and variables."
msgstr "和不可变变量一样, _contaants_ 是受名称约束且不允许更改的数值,但常数和变量之间有一些差异。"

#: src/ch02-01-variables-and-mutability.md:118
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just"
" immutable by default—they’re always immutable. You declare constants using "
"the `const` keyword instead of the `let` keyword, and the type of the value "
"_must_ be annotated. We’ll cover types and type annotations in the next "
"section, [“Data Types”](./ch02-02-data-types.md), so don’t worry about the "
"details right now. Just know that you must always annotate the type."
msgstr ""
"首先,您不允许使用“ mut' with stants ” 。 常数不仅仅是默认的不可变的 — — 常数总是不可变的。 您声明常数使用“ "
"const'keys ” 而不是“ let'key, 值类型 _ must_ be a 附加说明 。 我们将在下一节中包含类型和类型说明, [“数据类型"
" ” (./ch02-02- data-types. md), 所以不要担心现在的细节 。 只要知道您必须总是注意该类型 。"

#: src/ch02-01-variables-and-mutability.md:125
msgid ""
"Constant variables can be declared with any usual data type, including "
"structs, enums and fixed-size arrays."
msgstr "常数变量可以用任何通常的数据类型来声明,包括支架、柱形和固定尺寸阵列。"

#: src/ch02-01-variables-and-mutability.md:127
msgid ""
"Constants can only be declared in the global scope, which makes them useful "
"for values that many parts of code need to know about."
msgstr "常数只能在全球范围内申报,因此对守则许多部分需要了解的价值有用。"

#: src/ch02-01-variables-and-mutability.md:130
msgid ""
"The last difference is that constants may natively be set only to a constant"
" expression, not the result of a value that could only be computed at "
"runtime."
msgstr "最后一个区别是,常数只能由本地设定为常数表达式,而不是只能在运行时计算的数值结果。"

#: src/ch02-01-variables-and-mutability.md:133
msgid "Here’s an example of constants declaration:"
msgstr "以下是常数声明的例子:"

#: src/ch02-01-variables-and-mutability.md:152
msgid ""
"Nonetheless, it is possible to use the `consteval_int!` macro to create a "
"`const` variable that is the result of some computation:"
msgstr "尽管如此,仍有可能使用`conteval_int!' 宏来创建某种计算结果得出的` contal_int!' 变量:"

#: src/ch02-01-variables-and-mutability.md:158
msgid ""
"We will dive into more detail about macros in the [dedicated "
"section](./ch11-05-macros.md)."
msgstr "我们将更详细地阐述[专门章节](./ch11-05-macros.md)中的宏。"

#: src/ch02-01-variables-and-mutability.md:160
msgid ""
"Cairo's naming convention for constants is to use all uppercase with "
"underscores between words."
msgstr "开罗对常数的命名惯例是使用所有大写字母,在两字之间加下划线。"

#: src/ch02-01-variables-and-mutability.md:162
msgid ""
"Constants are valid for the entire time a program runs, within the scope in "
"which they were declared. This property makes constants useful for values in"
" your application domain that multiple parts of the program might need to "
"know about, such as the maximum number of points any player of a game is "
"allowed to earn, or the speed of light."
msgstr ""
"常数在程序运行的整个期间有效, 在程序声明的范围内。 此属性使常数对程序多个部分可能需要知道的应用程序域中的值有用, 如允许任何玩家赚取的最大点数, "
"或光速 。"

#: src/ch02-01-variables-and-mutability.md:168
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in conveying the meaning of that value to future maintainers of the code. It"
" also helps to have only one place in your code you would need to change if "
"the hardcoded value needed to be updated in the future."
msgstr ""
"将整个程序中使用的硬编码值命名为常数对向未来的代码维护者传达该值的意义很有用。 如果硬编码值今后需要更新, 在您的代码中只保留一个位置, 您也需要更改 "
"。"

#: src/ch02-01-variables-and-mutability.md:175
msgid "Shadowing"
msgstr "阴影"

#: src/ch02-01-variables-and-mutability.md:177
msgid ""
"Variable shadowing refers to the declaration of a new variable with the same"
" name as a previous variable. Caironautes say that the first variable is "
"_shadowed_ by the second, which means that the second variable is what the "
"compiler will see when you use the name of the variable. In effect, the "
"second variable overshadows the first, taking any uses of the variable name "
"to itself until either it itself is shadowed or the scope ends. We can "
"shadow a variable by using the same variable’s name and repeating the use of"
" the `let` keyword as follows:"
msgstr ""
"变量阴影是指与前一个变量名称相同的新变量的宣布。开罗瑙特斯说第一个变量在第二个变量下是 "
"_shadowed_,这意味着第二个变量是汇编者在使用变量名称时会看到的东西。实际上,第二个变量将第一个变量遮盖起来,在变量名称本身被阴影化或范围结束之前,将变量名称的任何用途都用在自己身上。我们可以使用同一个变量的名称来阴影变量,并重复使用“let'let”关键字如下:"

#: src/ch02-01-variables-and-mutability.md:192
msgid "\"Inner scope x value is: {}\""
msgstr "“内部范围 x 值是 :   ”"

#: src/ch02-01-variables-and-mutability.md:194
msgid "\"Outer scope x value is: {}\""
msgstr ""
"“外部范围x值是:___________________________________________________________________________________________________________________________________________________________________________________"

#: src/ch02-01-variables-and-mutability.md:198
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable `x` by repeating `let x =`, taking the original value and adding "
"`1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and "
"creates a new variable, multiplying the previous value by `2` to give `x` a "
"value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the "
"following:"
msgstr ""
"本程序首先将`x'与`5'值捆绑在一起,然后通过重复`let x'创造一个新的变量`x ',重复`let x ',以原值并增加`1 "
"',因此`x'值即为`6'。然后,在以圆括号创建的内部范围内,第三个`let'语句也将阴影'x'并创建一个新的变量,将以前的值乘以`2 "
"',以给`x'12'值。当范围结束时,内阴影端和`x'返回为`6'。当我们运行此程序时,它将输出以下内容:"

#: src/ch02-01-variables-and-mutability.md:217
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a "
"compile-time error if we accidentally try to reassign to this variable "
"without using the `let` keyword. By using `let`, we can perform a few "
"transformations on a value but have the variable be immutable after those "
"transformations have been completed."
msgstr ""
"阴影不同于将变量标记为“ mut ”, 因为如果我们不小心试图在不使用“ let let” 关键字的情况下改派到该变量, 我们就会有编译时间错误。 "
"通过使用 `let', 我们可以对一个值执行一些变换, 但变量在这些变换完成后不可更改 。"

#: src/ch02-01-variables-and-mutability.md:223
msgid ""
"Another distinction between `mut` and shadowing is that when we use the "
"`let` keyword again, we are effectively creating a new variable, which "
"allows us to change the type of the value while reusing the same name. As "
"mentioned before, variable shadowing and mutable variables are equivalent at"
" the lower level. The only difference is that by shadowing a variable, the "
"compiler will not complain if you change its type. For example, say our "
"program performs a type conversion between the `u64` and `felt252` types."
msgstr ""
"`mut'和阴影之间的另一个区别是,当我们再次使用`let'关键字时,我们实际上正在创建一个新的变量,允许我们在重复使用同一名称的同时改变数值的类型。如前所述,在较低层次,可变阴影变量和可变变量等值。唯一的区别是,通过阴影变量,如果您更改变量的类型,编纂者不会抱怨。例如,我们的程序在`u64'和`felt252'类型之间进行类型转换。"

#: src/ch02-01-variables-and-mutability.md:234
msgid "\"The value of x is {} of type u64\""
msgstr ""
"\"x的值是_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________"

#: src/ch02-01-variables-and-mutability.md:235
msgid "// converts x to a felt, type annotation is required.\n"
msgstr "/将x转换为感觉,需要类型注解。\n"

#: src/ch02-01-variables-and-mutability.md:236
msgid "\"The value of x is {} of type felt252\""
msgstr "\"x的值是... 感觉252型的\""

#: src/ch02-01-variables-and-mutability.md:240
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type. Shadowing thus spares us from having to come up with "
"different names, such as `x_u64` and `x_felt252`; instead, we can reuse the "
"simpler `x` name. However, if we try to use `mut` for this, as shown here, "
"we’ll get a compile-time error:"
msgstr ""
"第一个`x'变量有`u64'类型,而第二个`x'变量有`felt252'类型,因此阴影使我们不必提出不同的名称,例如`x_u64'和`x_felt252';相反,我们可以重新使用更简单的`x'名称。然而,如果我们试图为此使用`m`,如此处所示,我们会发现一个编译时间错误:"

#: src/ch02-01-variables-and-mutability.md:254
msgid ""
"The error says we were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr "错误表示我们预期会有一个`u64'(原型),"

#: src/ch02-01-variables-and-mutability.md:269
msgid "{{#quiz ../quizzes/ch02-01-variables-and-mutability.toml}}"
msgstr "Quiz./quizzes/ch02-01-可变性和可变性.toml"

#: src/ch02-01-variables-and-mutability.md:271
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they can have."
msgstr "既然我们已经探索了变数是如何运作的, 让我们来看看它们能拥有的更多数据类型。"

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what "
"kind of data is being specified so it knows how to work with that data. This"
" section covers two subsets of data types: scalars and compounds."
msgstr ""
"开罗的每个值都具有一定的 _data类型_,它告诉开罗具体指定了何种数据,以便它知道如何使用这些数据。本节涵盖两类数据类型:卡路里和化合物。"

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that "
"it must know the types of all variables at compile time. The compiler can "
"usually infer the desired type based on the value and its usage. In cases "
"when many types are possible, we can use a cast method where we specify the "
"desired output type."
msgstr ""
"记住开罗是一种以统计形式打字的语言, 这意味着它必须在编译时知道所有变量的类型。 编译者通常可以根据数值及其使用量推断理想类型。 "
"在可以使用多种类型的情况下, 我们可以使用一种手动方法, 来指定想要的输出类型 。"

#: src/ch02-02-data-types.md:16
msgid "You’ll see different type annotations for other data types."
msgstr "您将会看到其他数据类型的不同类型注释 。"

#: src/ch02-02-data-types.md:18
msgid "Scalar Types"
msgstr "Scalar 类型"

#: src/ch02-02-data-types.md:20
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar "
"types: felts, integers, and booleans. You may recognize these from other "
"programming languages. Let’s jump into how they work in Cairo."
msgstr ""
"一种 _scalar_ 类型代表一个单一值。 开罗有三种主要的标度类型:感觉、整数和布尔语。 你可以从其他编程语言中认出这些。 让我们跳入开罗的操作方式"
" 。"

#: src/ch02-02-data-types.md:24
msgid "Felt Type"
msgstr "felt 类型"

#: src/ch02-02-data-types.md:26
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the "
"context of Cairo, when we say “a field element” we mean an integer in the "
"range \\\\( 0 \\leq x \\< P \\\\), where \\\\( P \\\\) is a very large prime"
" number currently equal to \\\\( {2^{251}} + 17 \\cdot {2^{192}} + 1 \\\\). "
"When adding, subtracting, or multiplying, if the result falls outside the "
"specified range of the prime number, an overflow (or underflow) occurs, and "
"an appropriate multiple of \\\\( P \\\\) is added or subtracted to bring the"
" result back within the range (i.e., the result is computed \\\\( \\mod P "
"\\\\) )."
msgstr ""
"在开罗, 如果您没有指定变量或参数的类型, 则其类型默认为以关键字 `felt252' 表示的字段元素。 在开罗, 当我们说“ 字段元素” 时, "
"我们指范围\\\\\\ ( 0\\leq x \\ \\ \\ P\\\\ ) 的整数, 其中\\\\ (P\\\\\\ ) 的质数非常大, "
"目前等于\\\\ ( {2\\\\ 251\\ + 17\\ cdot {2\\\\\\ 192\\ + 1\\\\ \\ ) 。 当添加、 "
"减去或乘数时, 如果结果超出质数的指定范围, 就会发生溢出( 或下流), 和 \\\\\\ (P\\\\ \\ \\ ) 的适当倍数被加或减, "
"使结果回到范围( 即, 结果是计算\\\\\\ (\\ mod P\\\\ ) 。"

#: src/ch02-02-data-types.md:29
msgid ""
"The most important difference between integers and field elements is "
"division: Division of field elements (and therefore division in Cairo) is "
"unlike regular CPUs division, where integer division \\\\( \\frac{x}{y} "
"\\\\) is defined as \\\\( \\left\\lfloor \\frac{x}{y} \\right\\rfloor \\\\) "
"where the integer part of the quotient is returned (so you get \\\\( "
"\\frac{7}{3} = 2 \\\\)) and it may or may not satisfy the equation \\\\( "
"\\frac{x}{y} \\cdot y == x \\\\), depending on the divisibility of `x` by "
"`y`."
msgstr "整数和字段元素之间的最重要的区别是分割: 字段元素的分割( 因此在开罗的分割) 不同于常规 CPU 分割, 其整数分割\\\\ (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch02-02-data-types.md:34
msgid ""
"In Cairo, the result of \\\\( \\frac{x}{y} \\\\) is defined to always "
"satisfy the equation \\\\( \\frac{x}{y} \\cdot y == x \\\\). If y divides x "
"as integers, you will get the expected result in Cairo (for example \\\\( "
"\\frac{6}{2} \\\\) will indeed result in `3`). But when y does not divide x,"
" you may get a surprising result: for example, since \\\\( 2 \\cdot \\frac{P"
" + 1}{2} = P + 1 \\equiv 1 \\mod P \\\\), the value of \\\\( \\frac{1}{2} "
"\\\\) in Cairo is \\\\( \\frac{P + 1}{2} \\\\) (and not 0 or 0.5), as it "
"satisfies the above equation."
msgstr "在开罗,\\\\ (\\\\\\ frac{ x\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch02-02-data-types.md:37
msgid "Integer Types"
msgstr "整数类型"

#: src/ch02-02-data-types.md:39
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating"
" all types in the core library. However, it is highly recommended for "
"programmers to use the integer types instead of the `felt252` type whenever "
"possible, as the `integer` types come with added security features that "
"provide extra protection against potential vulnerabilities in the code, such"
" as overflow and underflow checks. By using these integer types, programmers"
" can ensure that their programs are more secure and less susceptible to "
"attacks or other security threats. An `integer` is a number without a "
"fractional component. This type declaration indicates the number of bits the"
" programmer can use to store the integer. Table 3-1 shows the built-in "
"integer types in Cairo. We can use any of these variants to declare the type"
" of an integer value."
msgstr ""
"感觉252类型是一种基本类型,可作为在核心图书馆创建所有类型的基础,然而,高度建议程序员尽可能使用整数类型,而不是“felt252”类型,因为“整数”类型中增加了安全特征,为防范代码中的潜在脆弱性提供了额外的保护,如溢出和下流检查。通过使用这些整数类型,程序员可以确保其程序更加安全,更容易受到攻击或其他安全威胁。“整数”是一个没有分数部分成分的数字。这种类型声明表明程序员可以用来存储整数的位数。表3-1显示开罗的内建整数类型。我们可以使用任何这些变式来申报整数值的类型。"

#: src/ch02-02-data-types.md:44
msgid "Length"
msgstr "长长"

#: src/ch02-02-data-types.md:44
msgid "Unsigned"
msgstr "无签名"

#: src/ch02-02-data-types.md:46
msgid "8-bit"
msgstr "8 位数"

#: src/ch02-02-data-types.md:46
msgid "`u8`"
msgstr "`8`"

#: src/ch02-02-data-types.md:47
msgid "16-bit"
msgstr "16 位数"

#: src/ch02-02-data-types.md:47
msgid "`u16`"
msgstr "`16`"

#: src/ch02-02-data-types.md:48 src/ch02-02-data-types.md:52
msgid "32-bit"
msgstr "32 位数"

#: src/ch02-02-data-types.md:48
msgid "`u32`"
msgstr "`u32'"

#: src/ch02-02-data-types.md:49
msgid "64-bit"
msgstr "64 位数"

#: src/ch02-02-data-types.md:49
msgid "`u64`"
msgstr "`64`"

#: src/ch02-02-data-types.md:50
msgid "128-bit"
msgstr "128 位数"

#: src/ch02-02-data-types.md:50
msgid "`u128`"
msgstr "`u128`"

#: src/ch02-02-data-types.md:51
msgid "256-bit"
msgstr "256比特"

#: src/ch02-02-data-types.md:51
msgid "`u256`"
msgstr "`256 '"

#: src/ch02-02-data-types.md:52
msgid "`usize`"
msgstr "`使用 '"

#: src/ch02-02-data-types.md:57
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is "
"just an alias for `u32`; however, it might be useful when in the future "
"Cairo can be compiled to MLIR. As variables are unsigned, they can't contain"
" a negative number. This code will cause the program to panic:"
msgstr ""
"每个变量都有明确的大小。 请注意, 目前, “ 启用” 类型只是“ u32” 的别名; 但是, 在未来开罗可以编译为 MLIR 时, 可能有用 。 "
"由于变量没有符号, 它们不能包含负数 。 此代码会使程序产生恐慌 :"

#: src/ch02-02-data-types.md:70
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for "
"`u256` which needs 4 more bits to be stored. Under the hood, `u256` is "
"basically a struct with 2 fields: `u256 {low: u128, high: u128}`."
msgstr ""
"前面提到的所有整数类型都适合“felt252”,但“u256”除外,“u256”需要再储存4位元。在头罩下,“u256”基本上是一个有2个字段的支架:`u256"
" {以下:u128,高:u128}。"

#: src/ch02-02-data-types.md:72
msgid ""
"Cairo also provides support for signed integers, starting with the prefix "
"`i`. These integers can represent both positive and negative values, with "
"sizes ranging from `i8` to `i128`. Each signed variant can store numbers "
"from \\\\( -({2^{n - 1}}) \\\\) to \\\\( {2^{n - 1}} - 1 \\\\) inclusive, "
"where `n` is the number of bits that variant uses. So an i8 can store "
"numbers from \\\\( -({2^7}) \\\\) to \\\\( {2^7} - 1 \\\\), which equals "
"`-128` to `127`."
msgstr ""
"开罗还支持签名的整数, 从前缀`i' 开始。 这些整数可以代表正值和负值, 大小从`i8' 至`i128'不等。 "
"每个签名的变异体都可以存储以下数字:\\\\ (- ({2n - 1) 至\\\\\\ ({2n - 1 - 1\\\\), 其中`n' "
"是变量使用的位数。 因此, i8 可以存储\\\\ (- ({{27})\\\\\\) 至\\\\\\ ({27} - 1\\\\), "
"等号为`-128'至`127'。"

#: src/ch02-02-data-types.md:75
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note "
"that number literals that can be multiple numeric types allow a type suffix,"
" such as `57_u8`, to designate the type. It is also possible to use a visual"
" separator `_` for number literals, in order to improve code readability."
msgstr ""
"您可以在表 3-2 中显示的任何表格中写入整数字。 请注意, 数字字数可以是多个数字类型, 允许类型后缀, 如 `57_ u8', 来指定该类型。 "
"也可以对数字字数使用视觉分隔符 {}, 以便改进代码可读性 。"

#: src/ch02-02-data-types.md:80
msgid "Numeric literals"
msgstr "数值字数"

#: src/ch02-02-data-types.md:80 src/appendix-02-operators-and-symbols.md:9
#: src/appendix-08-system-calls.md:177 src/appendix-08-system-calls.md:256
#: src/appendix-08-system-calls.md:331
msgid "Example"
msgstr "示例示例示例示例"

#: src/ch02-02-data-types.md:82
msgid "Decimal"
msgstr "十进制"

#: src/ch02-02-data-types.md:82
msgid "`98222`"
msgstr "`98222`"

#: src/ch02-02-data-types.md:83
msgid "Hex"
msgstr "十六进"

#: src/ch02-02-data-types.md:83
msgid "`0xff`"
msgstr "`0xff'"

#: src/ch02-02-data-types.md:84
msgid "Octal"
msgstr "八进"

#: src/ch02-02-data-types.md:84
msgid "`0o04321`"
msgstr "`0O04321'"

#: src/ch02-02-data-types.md:85
msgid "Binary"
msgstr "二进二进"

#: src/ch02-02-data-types.md:85
msgid "`0b01`"
msgstr "`0b01'"

#: src/ch02-02-data-types.md:90
msgid ""
"So how do you know which type of integer to use? Try to estimate the max "
"value your int can have and choose the good size. The primary situation in "
"which you’d use `usize` is when indexing some sort of collection."
msgstr "你怎么知道要使用哪类整数? 尝试估计您能拥有的最大值, 并选择好的大小。 您使用“ usize” 的主要情形是将某种收藏索引化 。"

#: src/ch02-02-data-types.md:93
msgid "Numeric Operations"
msgstr "数值操作"

#: src/ch02-02-data-types.md:95
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the "
"integer types: addition, subtraction, multiplication, division, and "
"remainder. Integer division truncates toward zero to the nearest integer. "
"The following code shows how you’d use each numeric operation in a `let` "
"statement:"
msgstr ""
"开罗支持所有整数类型的基本数学操作:添加、减法、乘法、除法和剩余。整数分裂向零向最接近的整数划线。以下代码显示您如何在“let”语句中使用每个数字操作:"

#: src/ch02-02-data-types.md:102
msgid "// addition\n"
msgstr "/ 增加/增加\n"

#: src/ch02-02-data-types.md:105
msgid "// subtraction\n"
msgstr "减/减\n"

#: src/ch02-02-data-types.md:108
msgid "// multiplication\n"
msgstr "/ 乘法\n"

#: src/ch02-02-data-types.md:111
msgid "// division\n"
msgstr "/ 司/司\n"

#: src/ch02-02-data-types.md:112
msgid "//result is 1\n"
msgstr "/结果为1\n"

#: src/ch02-02-data-types.md:113
msgid "//result is 2\n"
msgstr "/结果为2\n"

#: src/ch02-02-data-types.md:115
msgid "// remainder\n"
msgstr "/ 剩余 /\n"

#: src/ch02-02-data-types.md:116
msgid "// result is 3\n"
msgstr "/结果为3\n"

#: src/ch02-02-data-types.md:120
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates to a single value, which is then bound to a variable."
msgstr "这些语句中的每个表达式都使用一个数学运算符,并评价一个单一值,然后与一个变量捆绑在一起。"

#: src/ch02-02-data-types.md:123
msgid ""
"[Appendix B](./appendix-02-operators-and-symbols.md#operators) contains a "
"list of all operators that Cairo provides."
msgstr "[附录B](./附录02-Operators-and-symbols.md#operators)载有开罗提供的所有运营商的名单。"

#: src/ch02-02-data-types.md:127
msgid "The Boolean Type"
msgstr "布尔类型"

#: src/ch02-02-data-types.md:129
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two "
"possible values: `true` and `false`. Booleans are one `felt252` in size. The"
" Boolean type in Cairo is specified using `bool`. For example:"
msgstr "与大多数其他节目语言一样,开罗的布尔型有两种可能的价值:`真'和`假';布尔型是尺寸为`felt252'的。"

#: src/ch02-02-data-types.md:137
msgid "// with explicit type annotation\n"
msgstr "/ 带有明确类型的注解\n"

#: src/ch02-02-data-types.md:141
msgid ""
"When declaring a `bool` variable, it is mandatory to use either `true` or "
"`false` literals as value. Hence, it is not allowed to use integer literals "
"(i.e. `0` instead of false) for `bool` declarations."
msgstr ""
"在宣布`bool' 变量时,必须使用` true' 或`false' 字作为值,因此,不允许在`bool' 声明中使用整数字(即`0'而不是假字)。"

#: src/ch02-02-data-types.md:143
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` "
"expression. We’ll cover how `if` expressions work in Cairo in the [\"Control"
" Flow\"](./ch02-05-control-flow.md) section."
msgstr ""
"使用布尔值的主要方法是有条件的,如`如果'表达式。我们将在[“控制流程” (./ch02-05- control-flow.md) "
"部分说明`如果'表达式在开罗如何起作用。"

#: src/ch02-02-data-types.md:148
msgid "String Types"
msgstr "字符串类型"

#: src/ch02-02-data-types.md:150
msgid ""
"Cairo doesn't have a native type for strings but provides two ways to handle"
" them: short strings using simple quotes and ByteArray using double quotes."
msgstr "开罗没有本地的字符串类型,但提供了两种处理方式:短字符串使用简单的引号,ByteAray使用双重引号。"

#: src/ch02-02-data-types.md:152
msgid "Short strings"
msgstr "短短字符串"

#: src/ch02-02-data-types.md:154
msgid ""
"A short string is an ASCII string where each character is encoded on one "
"byte (see the [ASCII table](https://www.asciitable.com/)). For example:"
msgstr ""
"短字符串是一个 ASCII 字符串,其中每个字符编码在一个字节上(见[ASCII表](https://www.asciitable.com/)。 例如:"

#: src/ch02-02-data-types.md:156
msgid "`'a'` is equivalent to `0x61`"
msgstr "`a'等于`0x61'"

#: src/ch02-02-data-types.md:157
msgid "`'b'` is equivalent to `0x62`"
msgstr "``b'等于`0x62'"

#: src/ch02-02-data-types.md:158
msgid "`'c'` is equivalent to `0x63`"
msgstr "`c'等于`0x63'"

#: src/ch02-02-data-types.md:159
msgid "`0x616263` is equivalent to `'abc'`."
msgstr "`0x6162663'等于`abc'。"

#: src/ch02-02-data-types.md:161
msgid ""
"Cairo uses the `felt252` for short strings. As the `felt252` is on 251 bits,"
" a short string is limited to 31 characters (31 \\* 8 = 248 bits, which is "
"the maximum multiple of 8 that fits in 251 bits)."
msgstr "由于“felt252”在251位数上,短字符限为31个字符(31  8 = 248位数,这是251位数中最大8倍的乘数)。"

#: src/ch02-02-data-types.md:163
msgid ""
"You can choose to represent your short string with an hexadecimal value like"
" `0x616263` or by directly writing the string using simple quotes like "
"`'abc'`, which is more convenient."
msgstr "您可以选择以“ 0x61626263” 等十六进制值代表您的短字符串,或者使用“ abc” 等简单引号直接写入字符串,这更方便。"

#: src/ch02-02-data-types.md:165
msgid "Here are some examples of declaring short strings in Cairo:"
msgstr "以下是在开罗宣布短线的一些例子:"

#: src/ch02-02-data-types.md:169 src/ch02-02-data-types.md:187
msgid "'C'"
msgstr "\"C\" \"C\" (C)"

#: src/ch02-02-data-types.md:175 src/ch02-02-data-types.md:193
msgid "\"this is a string which has more than 31 characters\""
msgstr "\"这是一个有超过31个字符的字符串\""

#: src/ch02-02-data-types.md:181
msgid "Byte Array Strings"
msgstr "字节数组字符串"

#: src/ch02-02-data-types.md:183
msgid ""
"With the `ByteArray` struct added in Cairo 2.4.0, you are not limited to 31 "
"characters anymore. These `ByteArray` strings are written in double quotes "
"like in the following example:"
msgstr "开罗2.4.0添加了`ByteAray'结构,不再局限于31个字符。这些`ByteAray'字符串以双重引号写成,例如如下例子:"

#: src/ch02-02-data-types.md:197
msgid "Type Casting"
msgstr "种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种 种"

#: src/ch02-02-data-types.md:199
msgid ""
"In Cairo, you can convert scalar types from one type to another by using the"
" `try_into` and `into` methods provided by the `TryInto` and `Into` traits "
"from the core library."
msgstr ""
"在开罗,您可以通过使用核心图书馆的`TryInto'和`Into'提供的`tryinto'和`Into'特性的`tryinto'和`into'方法,将卡路里的类型从一种类型转换为另一种类型。"

#: src/ch02-02-data-types.md:201
msgid ""
"The `try_into` method allows for safe type casting when the target type "
"might not fit the source value. Keep in mind that `try_into` returns an "
"`Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""
"`try_ in' 方法允许在目标类型可能与源值不符时进行安全型式铸造。 请记住` trin_ in' 返回“ option < T} 类型, "
"您需要解开该类型才能访问新值 。"

#: src/ch02-02-data-types.md:203
msgid ""
"On the other hand, the `into` method can be used for type casting when "
"success is guaranteed, such as when the source type is smaller than the "
"destination type."
msgstr "另一方面, \" 内插 \" 方法在成功得到保证时,如来源类型小于目的地类型时,可用于打字。"

#: src/ch02-02-data-types.md:205
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the "
"source value to cast it to another type. The new variable's type must be "
"explicitly defined, as demonstrated in the example below."
msgstr ""
"要执行转换,请在源值上调用“var.into()”或“var.try_into()”将其投放到另一类型。必须明确界定新变量的类型,如下文示例所示。"

#: src/ch02-02-data-types.md:210
msgid ""
"// Since a felt252 might not fit in a u8, we need to unwrap the Option<T> "
"type\n"
msgstr "/ 因为感觉252可能不适合u8, 我们需要解开选项 < T> 类型\n"

#: src/ch02-02-data-types.md:216
msgid "// As a felt252 is smaller than a u256, we can use the into() method\n"
msgstr "由于感觉252小于u256, 我们可以使用()方法\n"

#: src/ch02-02-data-types.md:224
msgid "The Tuple Type"
msgstr "图例类型"

#: src/ch02-02-data-types.md:226
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a "
"variety of types into one compound type. Tuples have a fixed length: once "
"declared, they cannot grow or shrink in size."
msgstr "Atuple_ 是一种将若干种类型不同的数值组合成一种化合物类型的一般方法。图例有一个固定长度:一旦申报,它们就不能生长或缩小大小。"

#: src/ch02-02-data-types.md:230
msgid ""
"We create a tuple by writing a comma-separated list of values inside "
"parentheses. Each position in the tuple has a type, and the types of the "
"different values in the tuple don’t have to be the same. We’ve added "
"optional type annotations in this example:"
msgstr ""
"我们通过在括号中写一个逗号分隔的数值列表来创建一个 tuple 。 括号中的每个位置都有一个类型, 而图Ple中不同值的类型不一定是相同的。 "
"我们在此例中添加了可选类型的注释 :"

#: src/ch02-02-data-types.md:241
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a"
" single compound element. To get the individual values out of a tuple, we "
"can use pattern matching to destructure a tuple value, like this:"
msgstr "变量“ tup” 与整个图普相连, 因为图普被视为单一的复合元素。 要从图普中获取单个值, 我们可以使用匹配模式来改变图普值, 比如 :"

#: src/ch02-02-data-types.md:252
msgid "\"y is 6!\""
msgstr "\"y is 6!\" \"y is 6!\""

#: src/ch02-02-data-types.md:257
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then uses a pattern with `let` to take `tup` and turn it into three separate"
" variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints `y is "
"6!` as the value of `y` is `6`."
msgstr ""
"这个程序首先创建一个图普,并将其与变量`tup'捆绑在一起,然后使用“let`let' to take "
"`tup'”的图案,将其变成三个独立的变量`x'、`y'和`z',这称为`instrument',因为它将单图普分成三个部分。最后,程序指纹`y is "
"6!',因为`y'值是`6'。"

#: src/ch02-02-data-types.md:263
msgid ""
"We can also declare the tuple with value and types, and destructure it at "
"the same time. For example:"
msgstr "我们还可以以价值和类型来宣布图普,并同时进行结构调整。例如:"

#: src/ch02-02-data-types.md:272
msgid "The Unit Type ()"
msgstr "单位类型(单位类型)"

#: src/ch02-02-data-types.md:274
msgid ""
"A _unit type_ is a type which has only one value `()`. It is represented by "
"a tuple with no elements. Its size is always zero, and it is guaranteed to "
"not exist in the compiled code."
msgstr "A_unittype_是一种只有一个值的“()”类型。它用一个没有元素的图普表示,其大小始终为零,并且保证在汇编的代码中不存在。"

#: src/ch02-02-data-types.md:278
msgid ""
"You might be wondering why you would even need a unit type? In Cairo, "
"everything is an expression, and an expression that returns nothing actually"
" returns `()` implicitly."
msgstr "你也许想知道为什么你甚至需要一个单位类型?在开罗,一切都是一个表达方式,一个没有任何实际返回`()'的表达方式。"

#: src/ch02-02-data-types.md:280
msgid "{{#quiz ../quizzes/ch02-02-data-types.toml}}"
msgstr "./quizzes/ch02-02-data-types.toml"

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry"
" point of many programs. You’ve also seen the `fn` keyword, which allows you"
" to declare new functions."
msgstr ""
"函数在开罗代码中很普遍。 您已经看到语言中最重要的函数之一 : “ 主要” 函数, 这是许多程序的切入点 。 您也看到允许您声明新功能的“ fn” "
"关键字 。"

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr ""
"开罗代码使用 _snake case_作为函数和变量名称的常规样式,其中所有字母都是小写,并突出单独的单词。这里有一个包含示例函数定义的程序 :"

#: src/ch02-03-functions.md:14
msgid "\"Another function.\""
msgstr "\"另一个功能\""

#: src/ch02-03-functions.md:18
msgid "\"Hello, world!\""
msgstr "\"你好,世界!\""

#: src/ch02-03-functions.md:23
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr "我们在开罗定义了函数,输入了“fn”,然后输入了一个函数名称和一组括号。圆括号告诉汇编者函数体的起点和终点。"

#: src/ch02-03-functions.md:27
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it"
" can be called from inside the `main` function. Note that we defined "
"`another_function` _before_ the `main` function in the source code; we could"
" have defined it after as well. Cairo doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr ""
"我们可以调用我们通过输入其名称而定义的任何函数, 并加上一组括号。 因为程序定义了 \" 另一种功能 \", 它可以从`主要'函数中调用。 请注意, "
"我们在源代码中定义了`另一种功能'_ 之前的`主要'函数; 我们也可以在源代码中也定义它。 开罗并不关心您在哪里定义您的职能, "
"只是它们被定义在某个范围内, 来电者可以看到。"

#: src/ch02-03-functions.md:34
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions "
"further. Place the `another_function` example in _src/lib.cairo_ and run it."
" You should see the following output:"
msgstr ""
"让我们用名为 _forms_ 的刀疤启动一个新工程,进一步探索函数。 将“ 另一功能” 示例放置到 _src/lib. cairo_ 并运行。 "
"您应该看到以下输出 :"

#: src/ch02-03-functions.md:49
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the `Hello, world!` message prints, and then `another_function` is "
"called and its message is printed."
msgstr "“主”函数中行执行顺序的行,首先是“哈罗、世界!” ; 信息指纹,然后是“另一种功能”,并打印其信息。"

#: src/ch02-03-functions.md:53
msgid "Parameters"
msgstr "参数参数"

#: src/ch02-03-functions.md:55
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you"
" can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr ""
"我们可以定义具有 _参数_ 的函数, 它们是作为函数签名一部分的特殊变量。 当函数有参数时, 您可以为参数提供这些参数的具体值。 从技术上讲, "
"具体值被称为 _ 参数_, 但是在随意交谈中, 人们往往对函数定义中的变量或调用函数时传递的具体值使用 _ 参数_ 和 _ 参数_ 可互换的词, "
"无论是函数定义中的变量, 还是在调用函数时传递的具体值 。"

#: src/ch02-03-functions.md:63
msgid "In this version of `another_function` we add a parameter:"
msgstr "在本版本的 \" 另一种功能 \" 中,我们添加一个参数:"

#: src/ch02-03-functions.md:75
msgid "Try running this program; you should get the following output:"
msgstr "尝试运行此程序; 您应该获得以下输出 :"

#: src/ch02-03-functions.md:87
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `felt252`. When we pass `5` in to `another_function`,"
" the `println!` macro puts `5` where the pair of curly brackets containing "
"`x` was in the format string."
msgstr ""
"`另一功用'的申报有一个称为`x'的参数。`x'类型被定为`felt252'。当我们通过`5'到`另一功用'时,`println!' "
"宏将`5'放在格式字符串中包含`x'的卷括号对应处。"

#: src/ch02-03-functions.md:91
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Cairo’s design: requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also"
" able to give more helpful error messages if it knows what types the "
"function expects."
msgstr ""
"在函数签名中,您必须声明每个参数的类型。这是开罗设计过程中有意决定的:要求函数定义中的字型说明意味着汇编者几乎从来不需要你在代码的其他地方使用它们来确定您指的是哪种类型。如果汇编者知道函数所期望的类型,也可以提供更有用的错误信息。"

#: src/ch02-03-functions.md:97
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr "在定义多个参数时,将参数声明与逗号分开,例如:"

#: src/ch02-03-functions.md:102
msgid "\"h\""
msgstr "\"h\" \"h\" \"h\""

#: src/ch02-03-functions.md:106
msgid "\"The measurement is: {value}{unit_label}\""
msgstr "\"衡量标准是:{价值{单位_标签}\""

#: src/ch02-03-functions.md:110
msgid ""
"This example creates a function named `print_labeled_measurement` with two "
"parameters. The first parameter is named `value` and is a `u128`. The second"
" is named `unit_label` and is of type `ByteArray` - Cairo's internal type to"
" represent string literals. The function then prints text containing both "
"the `value` and the `unit_label`."
msgstr ""
"此示例创建了名为“ print_ labeled_ 度量” 的函数, 有两个参数。 第一个参数名为“ value ”, 是一个“ u128 ”, "
"第二个称为“ unit_ label ”, 属于 type `ByteArray' - Cairo 的内部类型, 代表字符串字典。 "
"该函数然后打印含有“value” 和“ unit_ label” 的文本。"

#: src/ch02-03-functions.md:114
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/lib.cairo_ file with the preceding example and "
"run it using `scarb cairo-run`:"
msgstr ""
"让我们尝试运行此代码。 替换您在 _src/ lib. cairo_ 文件中的当前 _ 函数_ Project's _ src/lib. cairo_ "
"文件, 使用“ scarb cairo- run” 运行 :"

#: src/ch02-03-functions.md:127
msgid ""
"Because we called the function with `5` as the value for value and `\"h\"` "
"as the value for `unit_label`, the program output contains those values."
msgstr "由于我们将函数“5”称为值值的值,将“h”称为`unit_ label'的值,因此程序输出包含这些值。"

#: src/ch02-03-functions.md:129
msgid "Named Parameters"
msgstr "命名参数"

#: src/ch02-03-functions.md:131
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when "
"you call a function. This makes the function calls more readable and self-"
"descriptive. If you want to use named parameters, you need to specify the "
"name of the parameter and the value you want to pass to it. The syntax is "
"`parameter_name: value`. If you pass a variable that has the same name as "
"the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""
"在开罗, 命名参数允许您在调用函数时指定参数名称。 这会使函数调用更加可读和自我描述性。 如果您想要使用指定参数, "
"您需要指定参数的名称和要传递给参数的值。 语法是 ` 参数_ name: value'。 如果您通过一个与参数名称相同的变量, 您可以简单地写入 `: "
"参数_ name ', 而不是`参数_ name: 变量_ name' 。"

#: src/ch02-03-functions.md:134
#: src/ch09-01-unrecoverable-errors-with-panic.md:72
#: src/ch09-02-recoverable-errors.md:141
#: src/appendix-03-derivable-traits.md:151
#: src/appendix-03-derivable-traits.md:200
msgid "Here is an example:"
msgstr "以下是一个例子:"

#: src/ch02-03-functions.md:149
msgid "Statements and Expressions"
msgstr "语句和表达式"

#: src/ch02-03-functions.md:151
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Cairo is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions,"
" so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr ""
"功能机构由一系列可选以表达方式结尾的声明组成。 到目前为止,我们所覆盖的功能没有包含结束表达方式,但你把表达方式看作是声明的一部分。 "
"由于开罗是一种以表达方式为基础的语言,这是理解的重要区别。 其他语言没有相同的区别,所以让我们看看什么是声明和表达方式,以及它们的差异如何影响职能体系。"

#: src/ch02-03-functions.md:159
msgid ""
"**Statements** are instructions that perform some action and do not return a"
" value."
msgstr "** 说明** 是指示,可采取某些行动,但不返回值。"

#: src/ch02-03-functions.md:161
msgid ""
"**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr "** 表达** 评估结果价值。让我们看看一些例子。"

#: src/ch02-03-functions.md:163
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 2-1, `let y = 6;` is a statement."
msgstr ""
"我们实际上已经使用了语句和表达式。 创建一个变量, 用“ let' key is a statement. in listing 2- 1, `let "
"y = 6;'是一个语句, 并给它指定一个值 。"

#: src/ch02-03-functions.md:173
msgid ""
"<span class=\"caption\">Listing 2-1: A `main` function declaration "
"containing one statement</span>"
msgstr "<span类=“caption” > listing 2-1: 包含一个声明 </span>的“主要”功能声明"

#: src/ch02-03-functions.md:175
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself."
msgstr "功能定义也是一种说明;前一例子的全部是说明本身。"

#: src/ch02-03-functions.md:177
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get"
" an error:"
msgstr "语句不返回值。 因此, 您不能像以下代码试图做到的那样, 将“ let” 语句指定给另一个变量; 您会遇到错误 :"

#: src/ch02-03-functions.md:186
msgid "When you run this program, the error you’ll get looks like this:"
msgstr "当您运行此程序时, 错误会变成这个样子 :"

#: src/ch02-03-functions.md:226
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Cairo."
msgstr ""
"`let y = 6' 语句不返回一个值,所以`x' "
"没有任何东西可以约束。这与其他语言,如C和Ruby不同,在这两个语言中,任务返回了任务的价值。在这些语言中,您可以写“x = y = "
"6”,并且有`x'和`y'都有价值`6';开罗的情况并非如此。"

#: src/ch02-03-functions.md:232
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Cairo. Consider a math operation, such as `5 + 6`, "
"which is an expression that evaluates to the value `11`. Expressions can be "
"part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is"
" an expression that evaluates to the value `6`."
msgstr ""
"表达式可以作为声明的一部分:在“列出2-1”、“列出”和“列出”中的“6”中,表示式可以是声明的一部分;在“列出”和“列出”中,表示式可以是“6”中的“6”表示式,也可以是“6”的表示式。"

#: src/ch02-03-functions.md:238
msgid ""
"Calling a function is an expression since it always evaluates to a value: "
"the function's explicit return value, if specified, or the 'unit' type `()` "
"otherwise."
msgstr "调用函数是一个表达式,因为它总是对一个值进行评价:函数的明显返回值(如果有指定的话)或“单位”类型`()'。"

#: src/ch02-03-functions.md:240
msgid ""
"A new scope block created with curly brackets is an expression, for example:"
msgstr "以卷轴括号创建的新范围块是一个表达式,例如:"

#: src/ch02-03-functions.md:249
msgid "\"The value of y is: {}\""
msgstr "\"y的价值是:\""

#: src/ch02-03-functions.md:253
msgid "This expression:"
msgstr "此表达式:"

#: src/ch02-03-functions.md:262
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note that the `x + 1` line doesn’t have "
"a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to"
" the end of an expression, you turn it into a statement, and it will then "
"not return a value. Keep this in mind as you explore function return values "
"and expressions next."
msgstr ""
"是一个块块,在此情况下,该值作为“ let” 语句的一部分被“ y” 绑在“ let” 语句中。 请注意, “ x+ 1” 线在结尾处没有分号, "
"这与您目前所看到的多数行不同。 表达式不包括结束分号。 如果您在表达式结尾处添加分号, 您将把它转换成一个语句, 这样它就不会返回一个值。 "
"当您在探索下一个函数返回值和表达式时, 请记住这一点 。"

#: src/ch02-03-functions.md:270
msgid "Functions with Return Values"
msgstr "具有返回值的函数"

#: src/ch02-03-functions.md:272
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Cairo, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr "函数可以返回到调用它们的代码中值。 我们不命名返回值, 但是我们必须在箭头后声明其类型 (`- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch02-03-functions.md:291
msgid ""
"There are no function calls, or even `let` statements in the `five` "
"function—just the number `5` by itself. That’s a perfectly valid function in"
" Cairo. Note that the function’s return type is specified too, as `-> u32`. "
"Try running this code; the output should look like this:"
msgstr ""
"` 5' 函数中没有函数调用,甚至没有`let'mentions "
"',仅用数字'5'本身即可。在开罗,这是一个完全有效的函数。请注意,函数的返回类型也被指定为'- > u32'。尝试运行此代码;输出应该像这样显示 :"

#: src/ch02-03-functions.md:306
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `u32`. Let’s examine this in more detail. There are two important "
"bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr ""
"`5'中的`5'是函数的返回值,正因为如此,返回类型是`u32'。让我们更详细地研究这一点。有两个重要部分:第一,`let x = 5 "
"();`显示我们正在使用函数的返回值来初始化变量。由于函数`5'返回`5 ',该行与以下各行相同:"

#: src/ch02-03-functions.md:316
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon"
" because it’s an expression whose value we want to return. Let’s look at "
"another example:"
msgstr "第二,`五'函数没有参数,也没有定义返回值的类型,但函数的体是一个孤单的`五 ',没有分号,因为它是我们希望返回的价值的表达式。"

#: src/ch02-03-functions.md:333
msgid ""
"Running this code will print `x = 6`. But if we place a semicolon at the end"
" of the line containing `x + 1`, changing it from an expression to a "
"statement, we’ll get an error:"
msgstr ""
"运行此代码时将打印“ x = 6 ” 。 但是,如果我们在含有“ x + 1” 的线条结尾处放置分号,将其从表达式改为语句,我们会发现错误 :"

#: src/ch02-03-functions.md:349
msgid ""
"```shell\n"
"$ scarb cairo-run \n"
"   Compiling no_listing_22_function_return_invalid v0.1.0 (listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml)\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".\n"
" --> listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:9:28\n"
"fn plus_one(x: u32) -> u32 {\n"
"                           ^\n"
"\n"
"error: could not compile `no_listing_22_function_return_invalid` due to previous error\n"
"error: `scarb metadata` exited with error\n"
"\n"
"```"
msgstr ""
"@shell $ scarb cairo-run 拼写 no_ list_22_form_ return_invalid v0.1.0 ( "
"lists/ch02-common- programming- "
"confits/no_late_24_form_form_regin_invalid/Scarb.tol) 错误: 意外返回类型。 期待 : “ 核心 "
": integer: u32 ” 找到 : \" () - > lists/ch02- common- programing- "
"conclutions/no_ list_24_ conflate_ src/src/sc. cairo: 9: 28 fn+_ one(x: u32)"
" - 错误 {{{% 错误: 无法编译`no lot_ 22_forpresent_ return_invalid ', 原因是错误: “ `scrab"
" 元数据因以前的错误退出 退出 退出 =_____"

#: src/ch02-03-functions.md:362
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue "
"with this code. The definition of the function `plus_one` says that it will "
"return an `u32`, but statements don’t evaluate to a value, which is "
"expressed by `()`, the unit type. Therefore, nothing is returned, which "
"contradicts the function definition and results in an error."
msgstr ""
"主错误信息“意外返回类型”显示此代码的核心问题。函数“+_one”的定义表示返回“u32”,但声明不评价单位类型`()'表示的价值。因此,不返回任何内容,这与函数定义相矛盾,导致错误。"

#: src/ch02-03-functions.md:368
msgid "{{#quiz ../quizzes/ch02-03-functions.toml}}"
msgstr ""
"Quiz./quizzes/ch02-03-功用.toml_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________"

#: src/ch02-04-comments.md:3
msgid ""
"All programmers strive to make their code easy to understand, but sometimes "
"extra explanation is warranted. In these cases, programmers leave comments "
"in their source code that the compiler will ignore but people reading the "
"source code may find useful."
msgstr ""
"所有程序设计员都努力使其代码易于理解,但有时需要额外解释。 在这些情况下,程序设计员在源代码中留下编辑者会忽略的评论,但阅读源代码的人可能会发现有用。"

#: src/ch02-04-comments.md:5
msgid "Here’s a simple comment:"
msgstr "简而言之,"

#: src/ch02-04-comments.md:8
msgid "// hello, world\n"
msgstr "(你好,世界)\n"

#: src/ch02-04-comments.md:11
msgid ""
"In Cairo, the idiomatic comment style starts a comment with two slashes, and"
" the comment continues until the end of the line. For comments that extend "
"beyond a single line, you’ll need to include `//` on each line, like this:"
msgstr "在开罗,单词评论风格以两条斜线开始评论,该评论持续到行尾。 对于超过单行的评论,您需要在每个行都包括`// ',例如:"

#: src/ch02-04-comments.md:14
msgid ""
"// So we’re doing something complicated here, long enough that we need\n"
"// multiple lines of comments to do it! Whew! Hopefully, this comment will\n"
"// explain what’s going on.\n"
msgstr "/ 所以,我们正在做一些复杂的事情, 足够长的时间,我们需要//多行的评论来做!!Whew! 希望这个评论能解释到底发生了什么。 //\n"

#: src/ch02-04-comments.md:19
msgid "Comments can also be placed at the end of lines containing code:"
msgstr "也可在含有代码的行尾列出评论意见:"

#: src/ch02-04-comments.md:23
msgid "// return the sum of 1 and 4\n"
msgstr "/ 返回 1 和 4 之和\n"

#: src/ch02-04-comments.md:27
msgid ""
"But you’ll more often see them used in this format, with the comment on a "
"separate line above the code it’s annotating:"
msgstr "但您会更经常地看到它们用在这种格式上,"

#: src/ch02-04-comments.md:31
msgid "// this function performs a simple addition\n"
msgstr "/ 此函数执行一个简单的添加\n"

#: src/ch02-04-comments.md:36
msgid "Item-level Documentation"
msgstr "项目级别文件"

#: src/ch02-04-comments.md:38
msgid ""
"Item-level documentation comments refer to specific items such as functions,"
" implementations, traits, etc. They are prefixed with three slashes (`///`)."
" These comments provide a detailed description of the item, examples of "
"usage, and any conditions that might cause a panic. In case of functions, "
"the comments may also include separate sections for parameter and return "
"value descriptions."
msgstr ""
"项目级文件评论是指具体项目,如功能、执行、特性等。它们以三条斜线(`///')为前缀,详细描述项目、使用实例和可能引起恐慌的任何条件。如果是功能,评论还可包括参数和返回值说明的单独部分。"

#: src/ch02-04-comments.md:41
msgid ""
"/// Returns the sum of `arg1` and `arg2`.\n"
"/// `arg1` cannot be zero.\n"
"///\n"
"/// # Panics\n"
"///\n"
"/// This function will panic if `arg1` is `0`.\n"
"///\n"
"/// # Examples\n"
"///\n"
"/// ```\n"
"/// let a: felt252 = 2;\n"
"/// let b: felt252 = 3;\n"
"/// let c: felt252 = add(a, b);\n"
"/// assert(c == a + b, \"Should equal a + b\");\n"
"/// ```\n"
msgstr ""
"// 返回`arg1'和`arg2'的和。 // //`arg1'不能为零。 // ///##恐慌 /// /////// "
"/此函数将恐慌,如果`arg1'是`0'。 ////////#示例 /// /// / ////让 a: fel252=3;///让c: "
"feel252=3;// 允许c: fel252=加(a,b);/ 主张(c) a+b,“应该等于a+b”);/ / / / / /\n"

#: src/ch02-04-comments.md:62
msgid "Module Documentation"
msgstr "模块文件文件"

#: src/ch02-04-comments.md:64
msgid ""
"Module documentation comments provide an overview of the entire module, "
"including its purpose and examples of use. These comments are meant to be "
"placed above the module they're describing and are prefixed with `//!`. This"
" type of documentation gives a broad understanding of what the module does "
"and how it can be used."
msgstr "模块文档评论概括了整个模块,包括其目的和使用实例。这些评论应置于模块之上,以`/!'作为前缀。这类文件广泛了解模块的工作和如何使用。"

#: src/ch02-04-comments.md:67
msgid ""
"//! # my_module and implementation\n"
"//!\n"
"//! This is an example description of my_module and some of its features.\n"
"//!\n"
"//! # Examples\n"
"//!\n"
"//! ```\n"
"//! mod my_other_module {\n"
"//!   use path::to::my_module;\n"
"//!\n"
"//!   fn foo() {\n"
"//!     my_module.bar();\n"
"//!   }\n"
"//! }\n"
"//! ```\n"
msgstr ""
"/ /!! # 我的模块和执行 / / /! 这是对我模块及其某些特征的示例描述 。 / / / / / # 示例 / / / / / / / / "
"/!!! 使用路径 : to: : my_ 模块 ; / / / /! fn foo () {/! my_ 模块.bar (); / / / } / /"
" / / / / / /! / / / / / /!\n"

#: src/ch02-04-comments.md:82
msgid "// rest of implementation...\n"
msgstr "/ 执行的其余部分.\n"

#: src/ch02-04-comments.md:86
msgid "{{#quiz ../quizzes/ch02-04-comments.toml}}"
msgstr "./quizzes/ch02-04-comments.toml"

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to"
" run some code repeatedly while a condition is true are basic building "
"blocks in most programming languages. The most common constructs that let "
"you control the flow of execution of Cairo code are if expressions and "
"loops."
msgstr ""
"运行某些代码的能力取决于一个条件是否真实,在条件为真实时反复运行某些代码的能力是大多数编程语言的基本构件。 "
"最普通的构件是表达和循环(如果表达和循环),它能控制开罗代码执行过程的流程。"

#: src/ch02-05-control-flow.md:5
msgid "`if` Expressions"
msgstr "`如果'表示式"

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You"
" provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr ""
"如果表达式允许您根据条件分割您的代码。 您提供一个条件, 然后声明, “ 如果满足此条件, 请运行此条代码块 。 如果不符合此条件, 请不要运行此代码块"
" 。 ”"

#: src/ch02-05-control-flow.md:9
msgid ""
"Create a new project called _branches_ in your _cairo_projects_ directory to"
" explore the `if` expression. In the _src/lib.cairo_ file, input the "
"following:"
msgstr ""
"在您的 _cairo_ project_ 目录中创建一个名为 _branches_的新工程,以探索“if” 表达式。在 "
"_src/lib.cairo_文件中,输入以下内容:"

#: src/ch02-05-control-flow.md:16
msgid "\"condition was true and number = {}\""
msgstr "\"条件是真实的,数字=\""

#: src/ch02-05-control-flow.md:18
msgid "\"condition was false and number = {}\""
msgstr "\"条件是虚假的 号码是= \""

#: src/ch02-05-control-flow.md:23
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value equal to 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets."
msgstr ""
"所有`如果'表达式都以关键词`如果'开头,然后有一个条件,在这种情况下,条件检查变量`数字'是否有等于5的值。如果条件是`真正的',则在条件在圆括号内后立即将执行的代码块放入。"

#: src/ch02-05-control-flow.md:25
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the"
" condition evaluate to `false`. If you don’t provide an `else` expression "
"and the condition is `false`, the program will just skip the `if` block and "
"move on to the next bit of code."
msgstr ""
"我们也可以选用“else”表达式,我们选择在这里这样做,以便在条件评估为“false”时,给程序一个可执行的替代代号块。如果你不提供“else”表达式,条件为“false”,则程序将跳过`if'块,跳过下一个代号。"

#: src/ch02-05-control-flow.md:27
msgid "Try running this code; you should see the following output:"
msgstr "尝试运行此代码; 您应该看到以下输出 :"

#: src/ch02-05-control-flow.md:39
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition"
" `true` to see what happens:"
msgstr "让我们尝试将`数字'的值改变为使条件`真实'的值,以观察会发生什么:"

#: src/ch02-05-control-flow.md:51
msgid ""
"It’s also worth noting that the condition in this code must be a `bool`. If "
"the condition isn’t a `bool`, we’ll get an error. For example, try running "
"the following code:"
msgstr "值得指出的是,该代码中的条件必须是`bool'。如果条件不是`bool ',我们会有错误。例如,尝试运行以下代码:"

#: src/ch02-05-control-flow.md:58
msgid "\"number was three\""
msgstr "\"数字是三个\""

#: src/ch02-05-control-flow.md:63
msgid ""
"The `if` condition evaluates to a value of 3 this time, and Cairo throws an "
"error:"
msgstr "`如果'条件这次评价值为3, 开罗出错 :"

#: src/ch02-05-control-flow.md:77
msgid ""
"The error indicates that Cairo inferred the type of `number` to be a `bool` "
"based on its later use as a condition of the `if` statement. It tries to "
"create a `bool` from the value `3`, but Cairo doesn't support instantiating "
"a `bool` from a numeric literal anyway - you can only use `true` or `false` "
"to create a `bool`. Unlike languages such as Ruby and JavaScript, Cairo will"
" not automatically try to convert non-Boolean types to a Boolean. If we want"
" the `if` code block to run only when a number is not equal to 0, for "
"example, we can change the if expression to the following:"
msgstr ""
"错误表明,开罗根据后来作为`如果'语句的一个条件使用`数字'来推断`数字'是`bool'的类型,它试图从`3'值中创建`bool',但开罗不支持从数字字句中即时使用`bool'——你只能使用`treal'或`false'来创建`bool'。与Ruby和JavaScript等语言不同,开罗不会自动尝试将非Boolean类型转换为Boolean。如果我们想要“if'代码块仅在数字不等于0时运行,例如,我们可以将表达方式改为:"

#: src/ch02-05-control-flow.md:91
msgid "\"number was something other than zero\""
msgstr "\"数字不是零\""

#: src/ch02-05-control-flow.md:97
msgid "Running this code will print `number was something other than zero`."
msgstr "运行此代码时将打印“ 数字不是零” 。"

#: src/ch02-05-control-flow.md:99
msgid "Handling Multiple Conditions with `else if`"
msgstr "使用“else if ” 处理多个条件"

#: src/ch02-05-control-flow.md:101
msgid ""
"You can use multiple conditions by combining `if` and `else` in an `else if`"
" expression. For example:"
msgstr "您可以使用多个条件,将“如果”和“else”结合到“else if”表达式中。例如:"

#: src/ch02-05-control-flow.md:108
msgid "\"number is 12\""
msgstr "\"数字是12\""

#: src/ch02-05-control-flow.md:110
msgid "\"number is 3\""
msgstr "\"数字是3\""

#: src/ch02-05-control-flow.md:112
msgid "\"number minus 2 is 1\""
msgstr "\"数字减2是1\""

#: src/ch02-05-control-flow.md:114
msgid "\"number not found\""
msgstr "\"数量未找到\""

#: src/ch02-05-control-flow.md:119
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr "此程序有四种可能的路径。 运行后, 您应该看到以下输出 :"

#: src/ch02-05-control-flow.md:131
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1` nor do we see the `number not found` text from the "
"`else` block. That’s because Cairo only executes the block for the first "
"true condition, and once it finds one, it doesn’t even check the rest. Using"
" too many `else if` expressions can clutter your code, so if you have more "
"than one, you might want to refactor your code. [Chapter 6](./ch06-02-the-"
"match-control-flow-construct.md) describes a powerful Cairo branching "
"construct called `match` for these cases."
msgstr ""
"当此程序执行时, 它会检查每个` 如果'的表达式, 并执行条件评估为` true'的第一个体。 请注意, 即使` 数字 - 2 = 1'是` true "
"', 我们看不到输出'数 - 2 = 1 ', 我们看不到` 数字 - 2 = 1 ', 也没有看到`else'区块的` 未找到'文字。 "
"这是因为开罗仅在第一个真实状态下执行区块, 一旦找到区块, 它甚至不会检查其余部分。 使用太多的` ele 表示式, 如果` 表达式可以将您的代码打乱,"
" 所以如果您有不止一个, 您可能想要重写您的代码 。 [ 第 6章] (./ ch06-02- the- match- control- "
"construct. md) 描述这些情况下一个强大的开罗分支结构, 称为` match'。"

#: src/ch02-05-control-flow.md:135
msgid "Using `if` in a `let` Statement"
msgstr "在`let'语句中使用`if'"

#: src/ch02-05-control-flow.md:137
msgid ""
"Because `if` is an expression, we can use it on the right side of a `let` "
"statement to assign the outcome to a variable."
msgstr "因为`如果'是一种表达方式,我们可以在`let'语句右侧使用它来将结果分配给变量。"

#: src/ch02-05-control-flow.md:149
msgid "\"condition was true and number is {}\""
msgstr "\"条件是真实的,数字是...\""

#: src/ch02-05-control-flow.md:164
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression, which will be 5 here."
msgstr "`数字'变量将受基于`如果'表达式结果的数值的约束,此处为5。"

#: src/ch02-05-control-flow.md:166
msgid "Repetition with Loops"
msgstr "与循环重复"

#: src/ch02-05-control-flow.md:168
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Cairo provides a simple loop syntax, which will run through the code inside "
"the loop body to the end and then start immediately back at the beginning. "
"To experiment with loops, let’s create a new project called _loops_."
msgstr ""
"多次执行一组代码往往有用。 对于这项任务,开罗提供了一个简单的循环语法, 它将在循环体内部运行到最后, 然后从头开始运行。 要尝试循环, "
"让我们创建一个名为 _loops_ 的新项目 。"

#: src/ch02-05-control-flow.md:170
msgid "Cairo has two kinds of loops: `loop` and `while`."
msgstr "开罗有两种循环:`循环'和`同时'。"

#: src/ch02-05-control-flow.md:172
msgid "Repeating Code with `loop`"
msgstr "使用 `loop' 重复代码"

#: src/ch02-05-control-flow.md:174
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over "
"again forever or until you explicitly tell it to stop."
msgstr "`循环'关键词指示开罗永远或永远执行一组代码,或直到你明确要求停止。"

#: src/ch02-05-control-flow.md:176
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to "
"look like this:"
msgstr "举例来说, 在您的目录中更改 _src/lib.cairo_ 文件, 使其看起来如此 :"

#: src/ch02-05-control-flow.md:181
msgid "\"again!\""
msgstr "\"又来了!\""

#: src/ch02-05-control-flow.md:189
msgid ""
"Note: This program would not compile without a break condition. For the "
"purpose of the example, we added a `break` statement that will never be "
"reached, but satisfies the compiler."
msgstr "注:本程序不会在没有中断条件的情况下进行编译。为例举的目的,我们添加了“中断”语句,该语句永远无法达到,但满足了编译者的要求。"

#: src/ch02-05-control-flow.md:191
msgid ""
"When we run this program, we’ll see `again!` printed over and over "
"continuously until either the program runs out of gas or we stop the program"
" manually. Most terminals support the keyboard shortcut ctrl-c to interrupt "
"a program that is stuck in a continual loop. Give it a try:"
msgstr ""
"当我们运行此程序时, 我们会看到“ 再次! ” 不断打印, 直到程序用完气体或手动停止程序。 大多数终端都支持键盘快捷键 ctrl- c "
"来中断被卡在连续循环中的程序。 尝试一下 :"

#: src/ch02-05-control-flow.md:193
msgid ""
"```shell\n"
"$ scarb cairo-run --available-gas=20000000\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished release target(s) in 0 seconds\n"
"     Running loops\n"
"again!\n"
"again!\n"
"again!\n"
"^Cagain!\n"
"```"
msgstr ""
"$shell $ scarb cairo-run - 可用 gas=2000000 Comping locations v.1.0 ( "
"file:///projects/loops) 0 秒内完成释放目标! 再次运行循环! 再次!\\ again! "
"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
" "
"=+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"

#: src/ch02-05-control-flow.md:204
msgid ""
"The symbol `^C` represents where you pressed ctrl-c. You may or may not see "
"the word `again!` printed after the ^C, depending on where the code was in "
"the loop when it received the interrupt signal."
msgstr ""
"符号 `C' 表示您按下 ctrl-c 的位置。 您可能看到或可能看不到在 °C 之后打印的单词 `又!', 取决于代码收到中断信号时在循环中的位置。"

#: src/ch02-05-control-flow.md:206
msgid ""
"Note: Cairo prevents us from running program with infinite loops by "
"including a gas meter. The gas meter is a mechanism that limits the amount "
"of computation that can be done in a program. By setting a value to the "
"`--available-gas` flag, we can set the maximum amount of gas available to "
"the program. Gas is a unit of measurement that expresses the computation "
"cost of an instruction. When the gas meter runs out, the program will stop. "
"In the previous case, we set the gas limit high enough for the program to "
"run for quite some time."
msgstr ""
"注:开罗防止我们以无穷环环运行程序,办法是加入一个气体计数仪。气体计数仪是一个限制程序内可以完成的计算数量的机制。通过设定“可用气体”旗帜的值,我们可以设定程序可使用的最大气体量。气体是表示一项指令计算成本的测量单位。当气体计数仪用完时,程序将停止。在前一种情况下,我们设定了足够高的气体限值,使程序运行相当长的时间。"

#: src/ch02-05-control-flow.md:208
msgid ""
"It is particularly important in the context of smart contracts deployed on "
"Starknet, as it prevents from running infinite loops on the network. If "
"you're writing a program that needs to run a loop, you will need to execute "
"it with the `--available-gas` flag set to a value that is large enough to "
"run the program."
msgstr ""
"这一点在部署在斯塔克内特的智能合同中特别重要,因为它无法在网络上运行无限循环。如果您正在撰写一个需要运行循环的程序,您需要用“有气”的标记来执行它,这个标记的值足以运行程序。"

#: src/ch02-05-control-flow.md:211
msgid ""
"Now, try running the same program again, but this time with the "
"`--available-gas` flag set to `200000` instead of `2000000000000`. You will "
"see the program only prints `again!` 3 times before it stops, as it ran out "
"of gas to keep executing the loop."
msgstr ""
"现在,尝试再次运行同一个程序,但这次使用`有气'的旗帜,设定为`200000'而不是`2000000000'。在停止之前,您将看到程序只打印“再次!”3次,因为没有气来持续执行环绕。"

#: src/ch02-05-control-flow.md:213
msgid ""
"Fortunately, Cairo also provides a way to break out of a loop using code. "
"You can place the `break` keyword within the loop to tell the program when "
"to stop executing the loop."
msgstr "幸运的是,开罗也提供了一个使用代码打破循环的方法。 您可以在循环中放置“ 中断” 关键字, 告诉程序何时停止执行循环 。"

#: src/ch02-05-control-flow.md:222 src/ch02-05-control-flow.md:242
msgid "\"i = {}\""
msgstr "\"一=\""

#: src/ch02-05-control-flow.md:228
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the "
"loop and to skip the rest of the code in this iteration. Let's add a "
"`continue` statement to our loop to skip the `println!` statement when `i` "
"is equal to `5`."
msgstr ""
"`连续'关键词指示程序转到循环的下一个迭代,并跳过此迭代中代码的其余部分。让我们在循环中添加一个`连续'语句,以跳过`打印!'语句,当`i'等于`5'时。"

#: src/ch02-05-control-flow.md:248
msgid ""
"Executing this program will not print the value of `i` when it is equal to "
"`5`."
msgstr "执行此程序时, 当值等于“ 5” 时, 将不会打印“ i” 值 。"

#: src/ch02-05-control-flow.md:250
msgid "Returning Values from Loops"
msgstr "从循环返回值"

#: src/ch02-05-control-flow.md:252
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such as checking whether an operation has succeeded. You might also need to "
"pass the result of that operation out of the loop to the rest of your code. "
"To do this, you can add the value you want returned after the `break` "
"expression you use to stop the loop; that value will be returned out of the "
"loop so you can use it, as shown here:"
msgstr ""
"`循环'的一个用途是重新尝试您知道可能失败的操作, 例如检查操作是否成功。 您可能需要将操作的结果从循环中传送到您的代码的其余部分。 要做到这一点, "
"您可以添加您想要在` 中断'表达式后返回的值, 您用它来阻止循环; 该值将被从循环中返回, 这样您就可以使用它, 如这里所示 :"

#: src/ch02-05-control-flow.md:270
msgid "\"The result is {}\""
msgstr "\"结果就是...\""

#: src/ch02-05-control-flow.md:274
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to "
"`0`. Then we declare a variable named `result` to hold the value returned "
"from the loop. On every iteration of the loop, we check whether the "
"`counter` is equal to `10`, and then add `1` to the `counter` variable. When"
" the condition is met, we use the `break` keyword with the value `counter * "
"2`. After the loop, we use a semicolon to end the statement that assigns the"
" value to `result`. Finally, we print the value in `result`, which in this "
"case is `20`."
msgstr ""
"在循环之前,我们宣布一个名为`反'的变量,并将其初始化为`0'。然后我们宣布一个名为`结果'的变量,以保持循环返回的值。在循环的每一次迭代中,我们检查`反'是否等于`10"
" "
"',然后在`反'变量中加上`1'。在条件得到满足时,我们使用`突破'关键词,其值为`反'2。在循环之后,我们用分号来结束将值划为`结果'的语句。最后,我们在`结果'中打印了数值,在这种情况下是`20'。"

#: src/ch02-05-control-flow.md:281
msgid "Conditional Loops with `while`"
msgstr "与`同时'的有条件循环"

#: src/ch02-05-control-flow.md:283
msgid ""
"A program will often need to evaluate a condition within a loop. While the "
"condition is `true`, the loop runs. When the condition ceases to be `true`, "
"the program calls `break`, stopping the loop. It’s possible to implement "
"behavior like this using a combination of `loop`, `if`, `else`, and `break`;"
" you could try that now in a program, if you’d like. However, this pattern "
"is so common that Cairo has a built-in language construct for it, called a "
"`while` loop."
msgstr ""
"程序通常需要在循环中评估一个条件。 虽然条件是“ 真实的 ”, 循环会运行。 当条件不再是“真实的 ” 时, 程序会叫“ 中断 ”, 停止循环 。 "
"使用“ 循环 ” 、 “ 如果 ” 、 “ else ” 和“ 打破 ” 的组合来实施类似的行为是可能的; 你可以在程序里尝试这一点, 如果你喜欢的话。"
" 但是, 这种模式非常常见, 以至于开罗有一个内部语言结构, 叫做“ 循环 ” 。"

#: src/ch02-05-control-flow.md:289
msgid ""
"In Listing 2-2, we use `while` to loop the program three times, counting "
"down each time after printing the value of `number`, and then, after the "
"loop, print a message and exit."
msgstr "在清单2-2中,我们使用`同时'将程序循环三次,每次在打印`数字'值后计算一次,然后在循环后打印消息和退出。"

#: src/ch02-05-control-flow.md:296
msgid "\"{number}!\""
msgstr "\"{数目}!\""

#: src/ch02-05-control-flow.md:300
msgid "\"LIFTOFF!!!\""
msgstr "举起手来! 举起手来! 举起手来! 举起手来! 举起手来!"

#: src/ch02-05-control-flow.md:304
msgid ""
"<span class=\"caption\">Listing 2-2: Using a `while` loop to run code while "
"a condition holds `true`.</span>"
msgstr ""
"<span class=\"caption\" > listing 2-2: 使用“ 循环” 运行代码, 而条件持有“ true” 。 </span>"

#: src/ch02-05-control-flow.md:306
msgid ""
"This construct eliminates a lot of nesting that would be necessary if you "
"used `loop`, `if`, `else`, and `break`, and it’s clearer. While a condition "
"evaluates to `true`, the code runs; otherwise, it exits the loop."
msgstr ""
"这种构思消除了使用`loop'、`if'、`else'和`break'等`loop'、`if'、`else'和`break'所必要的许多巢穴,而且更清楚。当一种条件对`"
" true'作出评估时,代码运行;否则,它就会退出循环。"

#: src/ch02-05-control-flow.md:309
msgid "{{#quiz ../quizzes/ch02-05-control-flow.toml}}"
msgstr ""
"./quizzes/ch02-05- control- flow.toml  /quizzes/ch02-05- control- flow.toml"

#: src/ch02-05-control-flow.md:313
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data "
"types, functions, comments, `if` expressions and loops! To practice with the"
" concepts discussed in this chapter, try building programs to do the "
"following:"
msgstr ""
"您做到了! 这是一个相当可观的章节: 您学习了变量、 数据类型、 函数、 注释、 “ 如果” 表达式和循环 。 要实践本章讨论的概念, "
"请尝试构建程序来完成以下任务 :"

#: src/ch02-05-control-flow.md:317
msgid "Generate the _n_\\-th Fibonacci number."
msgstr "生成 _n-th Fibonacci 编号。"

#: src/ch02-05-control-flow.md:318
msgid "Compute the factorial of a number _n_."
msgstr "计算一个数字的乘数 _n_。"

#: src/ch02-05-control-flow.md:320
msgid ""
"Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr "现在,我们将在下一章中审查开罗的常见收集类型。"

#: src/ch03-00-common-collections.md
msgid ""
"Cairo provides a set of common collection types that can be used to store "
"and manipulate data. These collections are designed to be efficient, "
"flexible, and easy to use. This section introduces the primary collection "
"types available in Cairo: Arrays and Dictionaries."
msgstr "开罗提供了一套共同的收集类型,可用于储存和操作数据,这些收集旨在高效、灵活和易于使用,本节介绍开罗的主要收集类型:阵列和字典。"

#: src/ch03-01-arrays.md:3
msgid ""
"An array is a collection of elements of the same type. You can create and "
"use array methods by using the `ArrayTrait` trait from the core library."
msgstr "数组是同一类型元素的集合。您可以使用核心库中的“ ArrayTrait” 特性创建和使用数组方法。"

#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modification options."
" Arrays are, in fact, queues whose values can't be modified. This has to do "
"with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of "
"an array and remove items from the front."
msgstr ""
"需要注意的一个问题是,阵列的修改选项有限。事实上,阵列是无法修改其值的队列。这与以下事实有关:一旦内存槽被写入,它就不能被覆盖,而只能从中读取。您只能将项目附加到阵列的末尾,并从前端删除项目。"

#: src/ch03-01-arrays.md:8
msgid "Creating an Array"
msgstr "创建队列"

#: src/ch03-01-arrays.md:10
msgid ""
"Creating an array is done with the `ArrayTrait::new()` call. Here's an "
"example of creating an array and appending 3 elements to it::"
msgstr "创建数组时使用 `ArrayTrait::new () ` call' 。 这里有一个创建数组并附加 3 元素的示例 :"

#: src/ch03-01-arrays.md:21
msgid ""
"When required, you can pass the expected type of items inside the array when"
" instantiating the array like this, or explicitly define the type of the "
"variable."
msgstr "需要时,您可以将数组内的预期项目类型通过数组中,当对数组进行这种同步时,或者明确定义变量的类型。"

#: src/ch03-01-arrays.md:31
msgid "Updating an Array"
msgstr "更新队列"

#: src/ch03-01-arrays.md:33
msgid "Adding Elements"
msgstr "添加元素"

#: src/ch03-01-arrays.md:35
msgid ""
"To add an element to the end of an array, you can use the `append()` method:"
msgstr "要在数组结尾添加元素,请使用“附录()”方法:"

#: src/ch03-01-arrays.md:46
msgid "Removing Elements"
msgstr "删除元素"

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the "
"`pop_front()` method. This method returns an `Option` that can be unwrapped,"
" containing the removed element, or `Option::None` if the array is empty."
msgstr ""
"您只能使用“pop_front()” 方法从数组前端删除元素。 如果数组为空, 此方法返回可解开的“ 选项”, 包含已删除元素, 或“ 选项: 无 ” "
"。"

#: src/ch03-01-arrays.md:59
msgid "\"The first value is {}\""
msgstr "\"第一个值是\""

#: src/ch03-01-arrays.md:63
msgid ""
"The above code will print `The first value is 10` as we remove the first "
"element that was added."
msgstr "上述代码将打印“第一个值为10”,因为我们删除了添加的第一个要素。"

#: src/ch03-01-arrays.md:65
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify"
" the elements of an array once they've been added. You can only add elements"
" to the end of an array and remove elements from the front of an array. "
"These operations do not require memory mutation, as they involve updating "
"pointers rather than directly modifying the memory cells."
msgstr ""
"在开罗, 内存是不可变的, 这意味着一旦加入一个数组的元素, 就不可能修改它们。 您只能将元素添加到数组的末尾, 从数组的前面删除元素。 "
"这些操作不需要内存突变, 因为它们涉及更新指针, 而不是直接修改内存单元格 。"

#: src/ch03-01-arrays.md:67
msgid "Reading Elements from an Array"
msgstr "从数组读取元素"

#: src/ch03-01-arrays.md:69
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that "
"return different types. Using `arr.at(index)` is equivalent to using the "
"subscripting operator `arr[index]`."
msgstr ""
"对于访问数组元素,您可以使用返回不同类型的`get()`或`at()`数组方法,使用`arr.at(index)'等于使用下标操作员`arr[index]'。"

#: src/ch03-01-arrays.md:71
msgid "`get()` Method"
msgstr "`get()`方法"

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an "
"option to a Box type (Cairo's smart-pointer type) containing a snapshot to "
"the element at the specified index if that element exists in the array. If "
"the element doesn't exist, `get` returns `None`. This method is useful when "
"you expect to access indices that may not be within the array's bounds and "
"want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [\"References and "
"Snapshots\"](./ch04-02-references-and-snapshots.md#snapshots) chapter."
msgstr ""
"`get' 函数返回“ option<Box_T ”, 这意味着它返回一个选项, 返回一个框类型( Cairo 的智能指针类型), "
"如果该元素存在于数组中, 则含有该元素在指定索引中的速记元素。 如果元素不存在, `get' 返回` non' 。 "
"当您期望访问可能不在数组范围内的指数, 并且想要在不引起恐慌的情况下优雅地处理这些案例时, 此方法非常有用 。 抓图将在 [ “ 引用和抓图” (./ "
"ch04-02- references- snapshots. md# snapshots. md# snappasss) 章中更详细地解释 。"

#: src/ch03-01-arrays.md:75
msgid "Here is an example with the `get()` method:"
msgstr "以下是`get()'方法的例子:"

#: src/ch03-01-arrays.md:82
msgid ""
"// Change this value to see different results, what would happen if the "
"index doesn't exist?\n"
msgstr "改变这个值以看到不同的结果, 如果指数不存在, 会发生什么?\n"

#: src/ch03-01-arrays.md:86
msgid ""
"// Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator\n"
"        // It basically means \"transform what get(idx) returned into a real value\"\n"
msgstr "/ 不要担心 * 目前, 如果你想知道看 第4.2章#desnap 操作员/ / 它基本上意指\"转换什么得到( idx) 返回到一个真实值\"。\n"

#: src/ch03-01-arrays.md:89
msgid "\"out of bounds\""
msgstr "\"不受约束\""

#: src/ch03-01-arrays.md:96
msgid "`at()` Method"
msgstr "`at()`方法 '"

#: src/ch03-01-arrays.md:98
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the "
"element at the specified index using the `unbox()` operator to extract the "
"value stored in a box. If the index is out of bounds, a panic error occurs. "
"You should only use `at` when you want the program to panic if the provided "
"index is out of the array's bounds, which can prevent unexpected behavior."
msgstr ""
"`at'函数,另一方面,直接返回指定索引中元素的速记,使用`unbox()`运算符'提取存储在框中的值。如果索引超出界限,就会发生恐慌错误。如果提供的索引超出数组的界限,则只有在程序需要恐慌时才使用`at'程序,这样可以防止出乎意料的行为。"

#: src/ch03-01-arrays.md:100
msgid "Here is an example with the `at()` method:"
msgstr "以下是`at()'方法的例子:"

#: src/ch03-01-arrays.md:113
msgid ""
"In this example, the variable named `first` will get the value `0` because "
"that is the value at index `0` in the array. The variable named `second` "
"will get the value `1` from index `1` in the array."
msgstr "在此示例中,名为“第一个”的变量将获得数组中“0”值,因为这就是在`0'指数值。“第二个”变量将从数组中的“1”指数值中获取“1”值。"

#: src/ch03-01-arrays.md:117
msgid ""
"If you want to use the subscripting operator `arr[index]`, you will need to "
"explicitly define the type of the elements of the array, otherwise it will "
"not compile. For example:"
msgstr "如果您想要使用下标运算符`arr[index] ', 您需要明确定义数组元素的类型, 否则它不会编译 。 例如 :"

#: src/ch03-01-arrays.md:130
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access "
"attempts, and use `get` when you prefer to handle such cases gracefully "
"without panicking."
msgstr "简言之,当你想对出入境的企图感到恐慌时,使用`at ',如果你想顺利处理此类案件而不必惊慌,则使用`get'。"

#: src/ch03-01-arrays.md:132
msgid "Size-related Methods"
msgstr "与规模有关的方法"

#: src/ch03-01-arrays.md:134
msgid ""
"To determine the number of elements in an array, use the `len()` method. The"
" return value is of type `usize`."
msgstr "为确定数组中元素的数量,请使用“ len()” 方法。返回值为“usize” 类型。"

#: src/ch03-01-arrays.md:136
msgid ""
"If you want to check if an array is empty or not, you can use the "
"`is_empty()` method, which returns `true` if the array is empty and `false` "
"otherwise."
msgstr "如果您想要检查一个数组是否为空, 您可以使用“ 是空( ) ” 方法, 如果数组为空或“ 假”, 该方法返回“ 真正的 ” 。"

#: src/ch03-01-arrays.md:138 src/ch11-05-macros.md:25
msgid "`array!` Macro"
msgstr "`阵列!'宏观"

#: src/ch03-01-arrays.md:140
msgid ""
"Sometimes, we need to create arrays with values that are already known at "
"compile time. The basic way of doing that is redundant. You would first "
"declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, "
"the compiler will expand the macro to generate the code that appends the "
"items sequentially."
msgstr ""
"有时,我们需要创建在编译时已经知道的值的阵列。 这样做的基本方式是多余的。 您首先声明数组, 然后逐个附加每个值 。 “ 数组! ” 是一个简单的方法,"
" 通过将两个步骤合并来完成这项任务 。 在编译时, 编译者将扩大宏, 以生成依次附加项目的代码 。"

#: src/ch03-01-arrays.md:143
msgid "Without `array!`:"
msgstr "没有`数组!':"

#: src/ch03-01-arrays.md:154
msgid "With `array!`:"
msgstr "使用`数组!':"

#: src/ch03-01-arrays.md:160
msgid "Storing Multiple Types with Enums"
msgstr "与 Enums 一起存储多种类型"

#: src/ch03-01-arrays.md:162
msgid ""
"If you want to store elements of different types in an array, you can use an"
" `Enum` to define a custom data type that can hold multiple types. Enums "
"will be explained in more detail in the [\"Enums and Pattern "
"Matching\"](./ch06-00-enums-and-pattern-matching.md) chapter."
msgstr ""
"如果您想要将不同类型元素存储在一个数组中, 您可以使用“ Enum” 来定义一个可以持有多种类型的自定义数据类型。 在 [“ Enums and "
"Stands 匹配” (./ch06- 00- enums- and- batern- 匹配. md) 章中, 将会更详细地解释 Enums 。"

#: src/ch03-01-arrays.md:182
msgid "Span"
msgstr "平平面"

#: src/ch03-01-arrays.md:184
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed "
"to provide safe and controlled access to the elements of an array without "
"modifying the original array. Span is particularly useful for ensuring data "
"integrity and avoiding borrowing issues when passing arrays between "
"functions or when performing read-only operations, as introduced in "
"[\"References and Snapshots\"](./ch04-02-references-and-snapshots.md)."
msgstr ""
"`Span'是代表`Array'的快照的支架,目的是在不修改原始阵列的情况下提供安全和有控制地访问阵列各元素,对于确保数据完整性和避免在函数之间传递阵列时或在进行[“参考和抓图”](./ch04-02-参考-"
"和Snapshots.md)中介绍的只读操作时借用问题特别有用。"

#: src/ch03-01-arrays.md:186
msgid ""
"All methods provided by `Array` can also be used with `Span`, except for the"
" `append()` method."
msgstr "`Array'提供的所有方法也可以用`span'使用,但`附录()'方法除外。"

#: src/ch03-01-arrays.md:190
msgid "Turning an Array into Span"
msgstr "正在将矩阵转换成 Span"

#: src/ch03-01-arrays.md:192
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr "创建`阵列'的`板 ',称为`板()'方法:"

#: src/ch03-01-arrays.md:201
msgid "{{#quiz ../quizzes/ch03-01-arrays.toml}}"
msgstr "/ quizzes/ch03-01-arrays.toml"

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The "
"`Felt252Dict<T>` data type represents a collection of key-value pairs where "
"each key is unique and associated with a corresponding value. This type of "
"data structure is known differently across different programming languages "
"such as maps, hash tables, associative arrays and many others."
msgstr ""
"开罗的核心图书馆提供了类似于字典的类型。 “ Felt252Dict<T}数据类型”代表了每个键的独特和与相应值相关的关键值对的集合。 "
"这种类型的数据结构在地图、散列表、关联阵列和许多其他不同的编程语言(如地图、散列表、连成阵列)中都不同。"

#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a"
" certain way for which using an `Array<T>` and indexing doesn't suffice. "
"Cairo dictionaries also allow the programmer to easily simulate the "
"existence of mutable memory when there is none."
msgstr ""
"`Felt252Dict<T}当您想要以某种方式组织您的数据时,使用“Array<T}”和“索引”是不够的。开罗词典还允许程序员在不存在时很容易地模拟移动内存的存在。"

#: src/ch03-02-dictionaries.md:7
msgid "Basic Use of Dictionaries"
msgstr "字典基本使用"

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the"
" data types of both key and value. In Cairo, the key type is restricted to "
"`felt252`, leaving only the possibility to specify the value data type, "
"represented by `T` in `Felt252Dict<T>`."
msgstr ""
"在创建新字典以定义键和值的数据类型时,在其他语言中这是正常的。 在开罗, 关键类型仅限于“ felt252 ”, 只留下指定价值数据类型的可能性, 在“"
" Felt252Dict<T> 中以“ T” 表示 。"

#: src/ch03-02-dictionaries.md:11
msgid ""
"The core functionality of a `Felt252Dict<T>` is implemented in the trait "
"`Felt252DictTrait` which includes all basic operations. Among them we can "
"find:"
msgstr "“Felt252Dict<T”的核心功能在“Felt252DictTrait”特性下实施,其中包括所有基本操作。"

#: src/ch03-02-dictionaries.md:13
msgid ""
"`insert(felt252, T) -> ()` to write values to a dictionary instance and"
msgstr "`插入(felt252, T) - > ()'将值写入字典实例和"

#: src/ch03-02-dictionaries.md:14
msgid "`get(felt252) -> T` to read values from it."
msgstr "`get(felt252) - > T` 读取它的值。"

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other "
"language. In the following example, we create a dictionary to represent a "
"mapping between individuals and their balance:"
msgstr "这些功能允许我们像用任何其他语言一样操纵字典。 在下面的例子中,我们创建了一本字典,以代表个人与平衡之间的映射:"

#: src/ch03-02-dictionaries.md:26
msgid "\"Balance is not 100\""
msgstr "\"平衡不是100\""

#: src/ch03-02-dictionaries.md:29
msgid "\"Balance is not 200\""
msgstr "\"平衡不是200\""

#: src/ch03-02-dictionaries.md:33
msgid ""
"We can create a new instance of `Felt252Dict<u64>` by using the `default` "
"method of the `Default` trait and add two individuals, each one with their "
"own balance, using the `insert` method. Finally, we check the balance of our"
" users with the `get` method. These methods are defined in the "
"`Felt252DictTrait` trait in the core library."
msgstr ""
"我们可以使用`默认'特性的`默认'方法创建一个`Felt252Dict<u64'的新实例,并使用`插入'方法增加两人,每个个人都有自己的平衡,最后,我们用`get'方法检查用户的平衡,这些方法在核心图书馆的`Felt252DictTrait'特性中定义。"

#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, "
"meaning you can only write to a memory cell once but the `Felt252Dict<T>` "
"type represents a way to overcome this obstacle. We will explain how this is"
" implemented later on in [\"Dictionaries "
"Underneath\"](./ch03-02-dictionaries.md#dictionaries-underneath)."
msgstr ""
"在整个书中,我们谈到开罗的记忆是不可改变的,这意味着你只能写给一个记忆细胞一次,而“Felt252Dict<T}类型是克服这一障碍的一种方法。我们会解释在[“地下字典”"
" (./ch03-02-词典.md#词典-unununneath) 中如何执行这一点。"

#: src/ch03-02-dictionaries.md:37
msgid ""
"Building upon our previous example, let us show a code example where the "
"balance of the same user changes:"
msgstr "以我们先前的例子为基础,让我们展示一个代码示例,其中同一用户的平衡会发生变化:"

#: src/ch03-02-dictionaries.md:43
msgid "// Insert Alex with 100 balance\n"
msgstr "/ 插入有100平衡的亚历克斯\n"

#: src/ch03-02-dictionaries.md:45
msgid "// Check that Alex has indeed 100 associated with him\n"
msgstr "检查亚历克斯 确实有100 与他有关联\n"

#: src/ch03-02-dictionaries.md:47
msgid "\"Alex balance is not 100\""
msgstr "\"时间平衡不是100\""

#: src/ch03-02-dictionaries.md:49
msgid "// Insert Alex again, this time with 200 balance\n"
msgstr "/再插入亚历克斯,这一次,以200的平衡\n"

#: src/ch03-02-dictionaries.md:51
msgid "// Check the new balance is correct\n"
msgstr "/ 检查新余额是否正确\n"

#: src/ch03-02-dictionaries.md:53
msgid "\"Alex balance is not 200\""
msgstr "\"时间平衡不是200\""

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the 'Alex' individual twice, each time "
"using a different balance and each time that we checked for its balance it "
"had the last value inserted! `Felt252Dict<T>` effectively allows us to "
"\"rewrite\" the stored value for any given key."
msgstr ""
"在此示例中, 我们如何添加“ Alex” 个人两次, 每次使用不同的平衡, 每次检查是否平衡, 都插入了最后的值! "
"`Felt252Dict<T\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is "
"worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the "
"scenes all keys have their associated values initialized as zero. This means"
" that if for example, you tried to get the balance of an inexistent user you"
" will get 0 instead of an error or an undefined value. This also means there"
" is no way to delete data from a dictionary. Something to take into account "
"when incorporating this structure into your code."
msgstr ""
"在标题和解释词典如何执行之前,值得一提的是,一旦您在幕后即时输入了 `Felt252Dict <T, 所有密钥都将其相关值初始化为零。 这意味着, "
"例如,如果您试图获取一个不存在的用户的余额, 您将得到 0, 而不是错误或未定义的值。 这也意味着无法从字典中删除数据。 在将此结构纳入您的代码时, "
"某些需要考虑的东西 。"

#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` "
"and how it mimics the same behavior as the corresponding data structures in "
"any other language, that is, externally of course. Cairo is at its core a "
"non-deterministic Turing-complete programming language, very different from "
"any other popular language in existence, which as a consequence means that "
"dictionaries are implemented very differently as well!"
msgstr ""
"在这一点之前,我们已经看到“Felt252Dict<T”的所有基本特征,以及它如何以任何其他语言,即外部语言,模仿相应的数据结构。 "
"开罗的核心是非决定性的图灵完整编程语言,与现有的任何其他流行语言非常不同,结果意味着字典的执行也非常不同! ”"

#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about "
"`Felt252Dict<T>` inner mechanisms and the compromises that were taken to "
"make them work. After that, we are going to take a look at how to use "
"dictionaries with other data structures as well as use the `entry` method as"
" another way to interact with them."
msgstr ""
"在以下各节中,我们将对`Felt252Dict<T}内部机制以及为使这些机制发挥作用而采取的妥协办法'提供一些见解,然后我们将研究如何使用与其他数据结构的字典,以及使用`进入'方法作为与它们互动的另一种方式。"

#: src/ch03-02-dictionaries.md:67
msgid "Dictionaries Underneath"
msgstr "词典"

#: src/ch03-02-dictionaries.md:69
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its "
"memory system is immutable, so in order to simulate mutability, the language"
" implements `Felt252Dict<T>` as a list of entries. Each of the entries "
"represents a time when a dictionary was accessed for "
"reading/updating/writing purposes. An entry has three fields:"
msgstr ""
"开罗非决定性设计的一个制约因素是其记忆系统是不可变的,因此,为了模拟变异性,语言将“Felt252Dict<T”作为条目清单。每个条目代表为阅读/更新/写作目的访问字典的时间。一个条目有三个字段:"

#: src/ch03-02-dictionaries.md:71
msgid ""
"A `key` field that identifies the key for this key-value pair of the "
"dictionary."
msgstr "“关键”字段,用于确定词典中这对关键值的钥匙。"

#: src/ch03-02-dictionaries.md:72
msgid ""
"A `previous_value` field that indicates which previous value was held at "
"`key`."
msgstr "\" 前价值 \" 字段,显示在 \" Key \" 上持有的先前价值。"

#: src/ch03-02-dictionaries.md:73
msgid ""
"A `new_value` field that indicates the new value that is held at `key`."
msgstr "`新价值'字段,显示`关键'所持有的新价值。"

#: src/ch03-02-dictionaries.md:75
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would"
" internally define it as `Array<Entry<T>>` where each `Entry<T>` has "
"information about what key-value pair it represents and the previous and new"
" values it holds. The definition of `Entry<T>` would be:"
msgstr ""
"如果我们尝试使用高级结构实施“Felt252Dict<T”,我们将在内部将其定义为“Array<Entry<T”,其中每个“Entry<T”都拥有关于它所代表的关键值配对以及它持有的先前和新的值的信息。"

#: src/ch03-02-dictionaries.md:85
msgid ""
"For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be "
"registered:"
msgstr "每次我们与“Felt252Dict<T”互动时,将登记一个新的“Entry<T”:"

#: src/ch03-02-dictionaries.md:87
msgid ""
"A `get` would register an entry where there is no change in state, and "
"previous and new values are stored with the same value."
msgstr "\" Get \" 将登记一个在状态没有变化、以前和新的价值以相同价值储存的条目。"

#: src/ch03-02-dictionaries.md:88
msgid ""
"An `insert` would register a new `Entry<T>` where the `new_value` would be "
"the element being inserted, and the `previous_value` the last element "
"inserted before this. In case it is the first entry for a certain key, then "
"the previous value will be zero."
msgstr ""
"`插入'将登记一个新的`输入<T "
"',其中`新价值'是插入的元素,`前置价值'是在此之前插入的最后一个元素。如果它是某个密钥的第一个条目,那么以前的数值将是零。"

#: src/ch03-02-dictionaries.md:90
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the "
"creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an"
" example of this using the `balances` dictionary from the previous section "
"and inserting the users 'Alex' and 'Maria':"
msgstr ""
"使用此条目列表可以显示为什么没有重写, 只需在“ Felt252Dict<T} 互动关系” 中创建新的内存单元格。 让我们用上一节的“ 平衡” "
"字典来显示一个实例, 然后插入用户“ Alex” 和“ Maria ” :"

#: src/ch03-02-dictionaries.md:108
msgid "These instructions would then produce the following list of entries:"
msgstr "这些指示随后将产生下列条目清单:"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "key"
msgstr "键键"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "previous"
msgstr "上一个"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "new"
msgstr "新建新"

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:114
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:138
#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:141
#: src/ch03-02-dictionaries.md:147
msgid "Alex"
msgstr "亚历克斯"

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:135
#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:147
#: src/ch03-02-dictionaries.md:148 src/ch03-02-dictionaries.md:149
msgid "0"
msgstr "0,0"

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:114
#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:137
msgid "100"
msgstr "100 100 中 100"

#: src/ch03-02-dictionaries.md:113 src/ch03-02-dictionaries.md:115
#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:137
#: src/ch03-02-dictionaries.md:140 src/ch03-02-dictionaries.md:148
msgid "Maria"
msgstr "玛丽亚"

#: src/ch03-02-dictionaries.md:113 src/ch03-02-dictionaries.md:115
msgid "50"
msgstr "50 50个"

#: src/ch03-02-dictionaries.md:114
msgid "200"
msgstr "200 200"

#: src/ch03-02-dictionaries.md:117
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the "
"`previous` and `current` values are set properly. Also reading from 'Maria' "
"registered an entry with no change from previous to current values."
msgstr ""
"请注意,自从插入了“Alex”两次之后,似乎有两次,而“先前的”和“当前”的数值设置得当,从“Maria”中读到的条目与以前的值和目前的值没有变化。"

#: src/ch03-02-dictionaries.md:119
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each "
"read/write operation, there is a scan for the whole entry list in search of "
"the last entry with the same `key`. Once the entry has been found, its "
"`new_value` is extracted and used on the new entry to be added as the "
"`previous_value`. This means that interacting with `Felt252Dict<T>` has a "
"worst-case time complexity of `O(n)` where `n` is the number of entries in "
"the list."
msgstr ""
"执行“Felt252Dict<T”的这一方法意味着,对于每个读/写操作,在搜索最后一个条目时,用同一个`键'搜索整个条目列表时都要进行扫描,一旦发现条目,将提取其`新值"
" ',并将其用于新条目中,作为`前一`值'添加的新条目中,这意味着与`Felt252Dict<T'进行互动时,最坏的情况是`O(n) "
"',其中`n'是列表中条目的数量。"

#: src/ch03-02-dictionaries.md:121
msgid ""
"If you pour some thought into alternate ways of implementing "
"`Felt252Dict<T>` you'd surely find them, probably even ditching completely "
"the need for a `previous_value` field, nonetheless, since Cairo is not your "
"normal language this won't work. One of the purposes of Cairo is, with the "
"STARK proof system, to generate proofs of computational integrity. This "
"means that you need to verify that program execution is correct and inside "
"the boundaries of Cairo restrictions. One of those boundary checks consists "
"of \"dictionary squashing\" and that requires information on both previous "
"and new values for every entry."
msgstr ""
"如果你把一些想法加到执行“Felt252Dict<T>”的替代方法中,你肯定能找到它们,也许甚至完全抛弃了对“前价值”领域的需求,然而,由于开罗并不是你通常的语言,这行不通。开罗的目的之一是利用STARK验证系统来提供计算完整性的证明。这意味着你需要核查程序执行是否正确,并符合开罗限制的界限。其中之一的边界检查包括“辖区压压”,它要求每个条目都提供关于以前和新价值的信息。"

#: src/ch03-02-dictionaries.md:124
msgid "Squashing Dictionaries"
msgstr "抖动字典"

#: src/ch03-02-dictionaries.md:126
msgid ""
"To verify that the proof generated by a Cairo program execution that used a "
"`Felt252Dict<T>` is correct, we need to check that there wasn't any illegal "
"tampering with the dictionary. This is done through a method called "
"`squash_dict` that reviews each entry of the entry list and checks that "
"access to the dictionary remains coherent throughout the execution."
msgstr ""
"为了核实使用“Felt252Dict<T” 的开罗程序执行所产生的证据是正确的,我们需要检查字典是否被非法篡改。 "
"这是通过一个名为“squash_dict”的方法进行的,该方法审查条目清单的每一条目,并检查在执行过程中对字典的查阅是否始终一致。"

#: src/ch03-02-dictionaries.md:128
msgid ""
"The process of squashing is as follows: given all entries with certain key "
"`k`, taken in the same order as they were inserted, verify that the ith "
"entry `new_value` is equal to the ith + 1 entry `previous_value`."
msgstr "挤压过程如下:如果所有带有某些密钥“k”的条目都与插入的顺序相同,则核查Ish条目“新价值”等于Ish+1条目“前置价值”。"

#: src/ch03-02-dictionaries.md:130
msgid "For example, given the following entry list:"
msgstr "例如,考虑到下列条目清单:"

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:138
msgid "150"
msgstr "150 150"

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:149
msgid "Charles"
msgstr "查尔斯·查尔斯"

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:149
msgid "70"
msgstr "70个"

#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:140
msgid "250"
msgstr "250 250"

#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:139
msgid "40"
msgstr "40个 40个"

#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:141
msgid "300"
msgstr "300 300个"

#: src/ch03-02-dictionaries.md:140 src/ch03-02-dictionaries.md:148
msgid "190"
msgstr "190 190"

#: src/ch03-02-dictionaries.md:141 src/ch03-02-dictionaries.md:147
msgid "90"
msgstr "90 90"

#: src/ch03-02-dictionaries.md:143
msgid "After squashing, the entry list would be reduced to:"
msgstr "在挤压后,条目清单将缩减为:"

#: src/ch03-02-dictionaries.md:151
msgid ""
"In case of a change on any of the values of the first table, squashing would"
" have failed during runtime."
msgstr "如果第一个表格的任何值发生变化,在运行期间,压碎会失败。"

#: src/ch03-02-dictionaries.md:153
msgid "Dictionary Destruction"
msgstr "词典销毁"

#: src/ch03-02-dictionaries.md:155
msgid ""
"If you run the examples from [\"Basic Use of "
"Dictionaries\"](./ch03-02-dictionaries.md#basic-use-of-dictionaries) "
"section, you'd notice that there was never a call to squash dictionary, but "
"the program compiled successfully nonetheless. What happened behind the "
"scene was that squash was called automatically via the `Felt252Dict<T>` "
"implementation of the `Destruct<T>` trait. This call occurred just before "
"the `balance` dictionary went out of scope."
msgstr ""
"如果您运行 [“字典的基本使用 ” (./ch03-02- 字典. md# 基本使用词典) 部分的示例, 您就会注意到, 从来没有人拨打过壁球字典, "
"但程序还是成功地编译了。 幕后发生的情况是, 壁球通过“ Felt252Dict<T ” 执行“ 破坏 < T 特性” 自动被调用。 此呼叫发生在“ "
"平衡” 字典超出范围之前 。"

#: src/ch03-02-dictionaries.md:157
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of "
"scope apart from `Drop<T>`. The main difference between these two is that "
"`Drop<T>` is treated as a no-op operation, meaning it does not generate new "
"CASM while `Destruct<T>` does not have this restriction. The only type which"
" actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other "
"type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these"
" traits in [Drop and Destruct](./appendix-03-derivable-traits.md#drop-and-"
"destruct) section of Appendix C."
msgstr ""
"`Dstruct<T>特性是除`Drop<T>之外的另一种排除范围外事件的方法。这两个特性之间的主要区别是,`Drop<T'被作为无操作处理,意思是它不会产生新的化学文摘社,而`Dstruct<T>没有这种限制。唯一积极使用`Destruct"
" <Tt <T>特性的类型是`Felt252Dict<T,“Drop<T”是同义词。你可以阅读更多关于附录C[drop and destruct] "
"(./apendix-03-derivits-traits.md#dlot-and-destruction)部分中的这些特性。"

#: src/ch03-02-dictionaries.md:159
msgid ""
"Later in [\"Dictionaries as Struct Members\"](./ch11-01-custom-data-"
"structures.html#dictionaries-as-struct-members) section, we will have a "
"hands-on example where we implement the `Destruct<T>` trait for a custom "
"type."
msgstr ""
"稍后,在““作为严格成员”的词汇” (./ch11-01-海关-数据结构.html#词典-"
"构成成员)一节中,我们将有一个实践实例,说明我们如何对一种习惯类型实施“销毁<T”特性。"

#: src/ch03-02-dictionaries.md:165
msgid "More Dictionaries"
msgstr "更多字典"

#: src/ch03-02-dictionaries.md:167
msgid ""
"Up to this point, we have given a comprehensive overview of the "
"functionality of `Felt252Dict<T>` as well as how and why it is implemented "
"in a certain way. If you haven't understood all of it, don't worry because "
"in this section we will have some more examples using dictionaries."
msgstr ""
"至此,我们全面概述了“Felt252Dict<T”的功能,以及如何和为什么以某种方式实施。如果你还没有完全理解,请不要担心,因为在本节中我们将有更多使用字典的例子。"

#: src/ch03-02-dictionaries.md:169
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary"
" basic functionality included in `Felt252DictTrait<T>` which we didn't "
"mention at the beginning. Soon after, we will see examples of how to use "
"`Felt252Dict<T>` with other [complex "
"types](./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-"
"natively) such as `Array<T>`."
msgstr ""
"首先,我们将解释“进入”方法,这是“Felt252DictTrait<T”中包含的字典基本功能的一部分,我们一开始没有提及该功能。不久之后,我们将看到如何使用“Felt252Dict<T”和其他[复合类型](./ch03-02-词典.md#词典-"
"类型-不支持-名义)如“Array<T”的例子。"

#: src/ch03-02-dictionaries.md:173
msgid "Entry and Finalize"
msgstr "并最后审定"

#: src/ch03-02-dictionaries.md:175
msgid ""
"In the [\"Dictionaries Underneath\"](./ch03-02-dictionaries.md#dictionaries-"
"underneath) section, we explained how `Felt252Dict<T>` internally worked. It"
" was a list of entries for each time the dictionary was accessed in any "
"manner. It would first find the last entry given a certain `key` and then "
"update it accordingly to whatever operation it was executing. The Cairo "
"language gives us the tools to replicate this ourselves through the `entry` "
"and `finalize` methods."
msgstr ""
"我们解释了“Felt252Dict<T”的内部工作方式,这是每次以任何方式访问字典时的条目清单,首先找到最后一个条目,给它一个特定的`关键',然后根据它执行的任何操作对它进行相应的更新。开罗语言为我们提供了通过`输入'和`最后化'方法复制它的工具。"

#: src/ch03-02-dictionaries.md:177
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose "
"of creating a new entry given a certain key. Once called, this method takes "
"ownership of the dictionary and returns the entry to update. The method "
"signature is as follows:"
msgstr ""
"`输入'方法作为`Felt252DictTrait "
"<T'的一部分而出现,目的是创建一个给定某个密钥的新条目。该方法一旦被调用,即取得对字典的所有权,并返回条目更新。方法签字如下:"

#: src/ch03-02-dictionaries.md:183
msgid ""
"The first input parameter takes ownership of the dictionary while the second"
" one is used to create the appropriate entry. It returns a tuple containing "
"a `Felt252DictEntry<T>`, which is the type used by Cairo to represent "
"dictionary entries, and a `T` representing the value held previously. The "
"`nopanic` notation simply indicates that the function is guaranteed to never"
" panic."
msgstr ""
"第一个输入参数对字典拥有所有权, 而第二个参数用于创建合适的条目。 它返回含有“ Felt252Dictintry < T” 的图普, "
"这是开罗用来代表字典条目的类型, 并返回代表先前持有的值的“ T” 。 “ 普遍” 符号只是表示函数保证永远不惊慌。"

#: src/ch03-02-dictionaries.md:186
msgid ""
"The next thing to do is to update the entry with the new value. For this, we"
" use the `finalize` method which inserts the entry and returns ownership of "
"the dictionary:"
msgstr "接下来要做的是用新值更新条目。 为此, 我们使用“ 最终化” 方法, 插入字典的条目和返回所有权 :"

#: src/ch03-02-dictionaries.md:192
msgid ""
"This method receives the entry and the new value as parameters, and returns "
"the updated dictionary."
msgstr "此方法接收条目和新值作为参数, 并返回更新的字典 。"

#: src/ch03-02-dictionaries.md:194
msgid ""
"Let us see an example using `entry` and `finalize`. Imagine we would like to"
" implement our own version of the `get` method from a dictionary. We should "
"then do the following:"
msgstr "让我们以`进入'和`最后定本'为例,想象一下我们想从字典中执行我们自己版本的`获取'方法。"

#: src/ch03-02-dictionaries.md:196
msgid "Create the new entry to add using the `entry` method."
msgstr "创建使用“输入”方法添加的新条目。"

#: src/ch03-02-dictionaries.md:197
msgid ""
"Insert back the entry where the `new_value` equals the `previous_value`."
msgstr "在“新价值”等于“前一价值”的条目后插入“新价值”的条目。"

#: src/ch03-02-dictionaries.md:198
msgid "Return the value."
msgstr "回报价值。"

#: src/ch03-02-dictionaries.md:200
msgid "Implementing our custom get would look like this:"
msgstr "执行我们的习俗 看起来像这样:"

#: src/ch03-02-dictionaries.md:208 src/ch03-02-dictionaries.md:252
msgid "// Get the new entry and the previous value held at `key`\n"
msgstr "// 获取新条目和先前的“ Key' ” 中保存的值\n"

#: src/ch03-02-dictionaries.md:211 src/ch03-02-dictionaries.md:255
msgid "// Store the value to return\n"
msgstr "/ 存储要返回的值\n"

#: src/ch03-02-dictionaries.md:214 src/ch03-02-dictionaries.md:258
msgid ""
"// Update the entry with `prev_value` and get back ownership of the "
"dictionary\n"
msgstr "/ 以“prev_value”更新条目,并恢复对字典的所有权\n"

#: src/ch03-02-dictionaries.md:217 src/ch03-02-dictionaries.md:261
msgid "// Return the read value\n"
msgstr "/ 返回读数\n"

#: src/ch03-02-dictionaries.md:222
msgid ""
"The `ref` keyword means that the ownership of the variable will be given "
"back at the end of the function. This concept will be explained in more "
"detail in the [\"References and Snapshots\"](./ch04-02-references-and-"
"snapshots.md) section."
msgstr ""
"`ref'关键字是指变量的所有权将回溯到函数的末尾,这一概念将在[“参考和抓图”(./ch04-02-references-and-"
"snapshots.md)部分更详细地解释。"

#: src/ch03-02-dictionaries.md:225
msgid ""
"Implementing the `insert` method would follow a similar workflow, except for"
" inserting a new value when finalizing. If we were to implement it, it would"
" look like the following:"
msgstr "实施`插入'方法将遵循类似的工作流程,除非在最后敲定时插入新的值。"

#: src/ch03-02-dictionaries.md:233
msgid ""
"// Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exist, `_prev_value` will\n"
"    // be the default value of T.\n"
msgstr "/ 获得与`关键'//通知相关的最后一个条目,即如果`关键'不存在,则`prev_value'将//是T的默认值。\n"

#: src/ch03-02-dictionaries.md:238
msgid ""
"// Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
msgstr "//在字典中加上`输入',加上更新值,///和接受对字典的所有权。\n"

#: src/ch03-02-dictionaries.md:244
msgid ""
"As a finalizing note, these two methods are implemented in a similar way to "
"how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows"
" some example usage:"
msgstr ""
"最后一点是,这两种方法的实施方式与Felt252Dict<T_BAR_Felt252Dit_T_BAR__BAR_如何实施“插入”和“获取”方法相类似。"

#: src/ch03-02-dictionaries.md:268
msgid "// Get the last entry associated with `key`\n"
msgstr "// 获取与`关键'相关的最后一个条目\n"

#: src/ch03-02-dictionaries.md:269
msgid "// Notice that if `key` does not exist, `_prev_value` will\n"
msgstr "/ 通知,如果`关键`不存在,`prev_value'将\n"

#: src/ch03-02-dictionaries.md:270
msgid "// be the default value of T.\n"
msgstr "/ 是 T 的默认值 。\n"

#: src/ch03-02-dictionaries.md:273
msgid "// Insert `entry` back in the dictionary with the updated value,\n"
msgstr "/ 在字典中加上`输入',加上更新值,\n"

#: src/ch03-02-dictionaries.md:274
msgid "// and receive ownership of the dictionary\n"
msgstr "/ 并获得对字典的所有权\n"

#: src/ch03-02-dictionaries.md:281 src/ch03-02-dictionaries.md:283
msgid "'0'"
msgstr "'0' (0)"

#: src/ch03-02-dictionaries.md:285
msgid "\"Expecting 100\""
msgstr "\"预期100\""

#: src/ch03-02-dictionaries.md:294
msgid "Dictionaries of Types not Supported Natively"
msgstr "不支持类型词典"

#: src/ch03-02-dictionaries.md:296
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the "
"trait `Felt252DictValue<T>`. This trait defines the `zero_default` method "
"which is the one that gets called when a value does not exist in the "
"dictionary. This is implemented by some common data types, such as most "
"unsigned integers, `bool` and `felt252` - but it is not implemented for more"
" complex types such as arrays, structs (including `u256`), and other types "
"from the core library. This means that making a dictionary of types not "
"natively supported is not a straightforward task, because you would need to "
"write a couple of trait implementations in order to make the data type a "
"valid dictionary value type. To compensate this, you can wrap your type "
"inside a `Nullable<T>`."
msgstr ""
"“Felt252Dict<T” 中我们没有谈到的一个限制是“Felt252DictValue<T”的特性。 此特性定义了“ 零- 默认” 方法, "
"即当字典中不存在值时被调用的方法。 这是用一些常见的数据类型执行的, 如大多数未符号的整数、 `bool' 和`felt252', 但对于阵列、 "
"strutcts( 包括` u256' ) 和核心库中的其他类型等更复杂的类型没有执行。 这意味着, 制作本地不支持的类型的字典并不是一项简单的任务, "
"因为您需要写几个特性执行功能, 才能使数据类型成为有效的字典值类型。 为了补偿这一点, 您可以在“ Nullable < T” 中包装您的类型。"

#: src/ch03-02-dictionaries.md:302
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be"
" `null` in the absence of value. It is usually used in Object Oriented "
"Programming Languages when a reference doesn't point anywhere. The "
"difference with `Option` is that the wrapped value is stored inside a "
"`Box<T>` data type. The `Box<T>` type is a smart pointer that allows us to "
"use a dedicated `boxed_segment` memory segment for our data, and access this"
" segment using a pointer that can only be manipulated in one place at a "
"time. See [Smart Pointers Chapter](./ch11-02-smart-pointers.md) for more "
"information."
msgstr ""
"`Nullallble<T}是一种智能指针类型,可以指向一个值,也可以指向一个值,或者在没有值的情况下是`Nullble<T'。当一个引用没有指向任何地方时,它通常用于对象定向编程语言。与`Option'的区别在于包包藏值存储在`Box<T}数据类型中。`Box<T}类型是一个智能指针,它使我们能够为我们的数据使用专用的`boxed_segment'内存部分,并使用只能一次在一个地方操作的指针访问此段。更多信息见[Smart指针章](./ch11-02-Smart-"
"point-pointers.md)。"

#: src/ch03-02-dictionaries.md:304
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a"
" dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are "
"storing a `Span<T>` and not an `Array<T>` because the latter does not "
"implement the `Copy<T>` trait which is required for reading from a "
"dictionary."
msgstr ""
"让我们举一个例子来显示。 我们将尝试在字典中存储“ span< fellt252 ” 。 为此, 我们将使用“ nullble < T ” 和“ box"
" < T ” 。 另外, 我们正在存储一个“ span < T ” 而不是“ Array < T ”, 因为后者没有执行从字典读取所需的“ compy "
"< T 特性 ” 。"

#: src/ch03-02-dictionaries.md:310 src/ch03-02-dictionaries.md:359
msgid "// Create the dictionary\n"
msgstr "/ 创建字典\n"

#: src/ch03-02-dictionaries.md:313 src/ch03-02-dictionaries.md:362
msgid "// Create the array to insert\n"
msgstr "/ 创建要插入的数组\n"

#: src/ch03-02-dictionaries.md:316 src/ch03-02-dictionaries.md:365
msgid "// Insert it as a `Span`\n"
msgstr "/ 插入为“span”\n"

#: src/ch03-02-dictionaries.md:318 src/ch03-02-dictionaries.md:329
msgid "//...\n"
msgstr "//... /\n"

#: src/ch03-02-dictionaries.md:322
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary "
"`d`. We want it to hold a `Nullable<Span>`. After that, we created an array "
"and filled it with values."
msgstr ""
"在这个代码片断中,我们做的第一件事就是创建一个新的字典 `d'。我们希望它能保持一个`Nullable<span>。 之后, 我们创建了一个阵列, "
"并填满了数值 。"

#: src/ch03-02-dictionaries.md:324
msgid ""
"The last step is inserting the array as a span inside the dictionary. Notice"
" that we do this using the `new` function of the `NullableTrait`."
msgstr "最后一步是将阵列作为横幅插入字典中。请注意,我们使用`NullbleTrait'的`新'功能来这样做。"

#: src/ch03-02-dictionaries.md:326
msgid ""
"Once the element is inside the dictionary, and we want to get it, we follow "
"the same steps but in reverse order. The following code shows how to achieve"
" that:"
msgstr "一旦元素在字典中,我们想得到它, 我们遵循同样的步骤, 但以相反的顺序。 下面的代码显示如何实现这一点 :"

#: src/ch03-02-dictionaries.md:331 src/ch03-02-dictionaries.md:368
msgid "// Get value back\n"
msgstr "/ 将值调回\n"

#: src/ch03-02-dictionaries.md:334 src/ch03-02-dictionaries.md:371
msgid "// Search the value and assert it is not null\n"
msgstr "// 搜索值并声明它并非无效\n"

#: src/ch03-02-dictionaries.md:336 src/ch03-02-dictionaries.md:373
msgid "\"No value found\""
msgstr "“未找到值”"

#: src/ch03-02-dictionaries.md:340 src/ch03-02-dictionaries.md:377
msgid "// Verify we are having the right values\n"
msgstr "/核查我们是否拥有正确的值\n"

#: src/ch03-02-dictionaries.md:341 src/ch03-02-dictionaries.md:378
msgid "\"Expecting 8\""
msgstr "\"预期8\""

#: src/ch03-02-dictionaries.md:342 src/ch03-02-dictionaries.md:379
msgid "\"Expecting 9\""
msgstr "\"预期9\""

#: src/ch03-02-dictionaries.md:343 src/ch03-02-dictionaries.md:380
msgid "\"Expecting 10\""
msgstr "\"预期10\""

#: src/ch03-02-dictionaries.md:347
msgid "Here we:"
msgstr "我们在此:"

#: src/ch03-02-dictionaries.md:349
msgid "Read the value using `get`."
msgstr "使用 `get' 读取值。"

#: src/ch03-02-dictionaries.md:350
msgid "Verified it is non-null using the `match_nullable` function."
msgstr "使用“匹配_nellable' 函数验证为非null。"

#: src/ch03-02-dictionaries.md:351
msgid "Unwrapped the value inside the box and asserted it was correct."
msgstr "解开盒子内的价值,并声称它是正确的。"

#: src/ch03-02-dictionaries.md:353
msgid "The complete script would look like this:"
msgstr "完整的脚本会看起来像这样:"

#: src/ch03-02-dictionaries.md:385
msgid "Using Arrays inside Dictionaries"
msgstr "使用词典中的数组"

#: src/ch03-02-dictionaries.md:387
msgid ""
"In the previous section, we explored how to store and retrieve complex types"
" inside a dictionary using `Nullable<T>` and `Box<T>`. Now, let's take a "
"look at how to store an array inside a dictionary and dynamically modify its"
" contents."
msgstr ""
"在前一节中,我们探讨了如何在词典中使用“Nullallble<T”和“Box<T”在词典中存储和检索复杂类型。现在,让我们来看看如何在词典中存储阵列并动态修改其内容。"

#: src/ch03-02-dictionaries.md:389
msgid ""
"Storing arrays in dictionaries in Cairo is slightly different from storing "
"other types. This is because arrays are more complex data structures that "
"require special handling to avoid issues with memory copying and references."
msgstr "开罗词典中存储的阵列与其他类型的存储略有不同。 这是因为阵列是更复杂的数据结构, 需要特别处理, 以避免内存复制和引用方面的问题 。"

#: src/ch03-02-dictionaries.md:391
msgid ""
"First, let's look at how to create a dictionary and insert an array into it."
" This process is pretty straightforward and follows a similar pattern to "
"inserting other types of data:"
msgstr "首先,让我们看看如何创建字典, 并插入一个阵列。 这个过程非常直截了当, 并遵循类似的模式来插入其他类型的数据 :"

#: src/ch03-02-dictionaries.md:398
msgid "\"Array inserted successfully.\""
msgstr "\"光线成功插入\""

#: src/ch03-02-dictionaries.md:402
msgid ""
"However, attempting to read an array from the dictionary using the `get` "
"method will result in a compiler error. This is because `get` tries to copy "
"the array in memory, which is not possible for arrays (as we've already "
"mentioned in the [previous section](./ch03-02-dictionaries.md#dictionaries-"
"of-types-not-supported-natively), `Array<T>` does not implement the "
"`Copy<T>` trait):"
msgstr ""
"然而,试图使用`get' 方法从字典中读取一个阵列将导致编译器错误。 这是因为“ 开始尝试在记忆中复制阵列, 这对于阵列是不可能的( "
"正如我们在[前一节](./ch03-02- 字典. md# 词典- 类型- 不支持- 本地)中已经提到的, `Array < T} 不执行“ Copy "
"< T 特性 ” :"

#: src/ch03-02-dictionaries.md:411
msgid "\"Array: {:?}\""
msgstr "(反射: {? })"

#: src/ch03-02-dictionaries.md:415
msgid "// This will cause a compiler error\n"
msgstr "/ 这将导致编译器错误\n"

#: src/ch03-02-dictionaries.md:417
msgid "\"No value!\""
msgstr "\"没有价值!\""

#: src/ch03-02-dictionaries.md:424
msgid ""
"```shell\n"
"$ scarb cairo-run \n"
"   Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 (listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)\n"
"error: Trait has no implementation in context: core::traits::Copy::<core::nullable::Nullable::<core::array::Array::<core::integer::u8>>>\n"
" --> listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:12:20\n"
"    let val = dict.get(0); // This will cause a compiler error\n"
"                   ^*^\n"
"\n"
"error: could not compile `no_listing_15_dict_of_array_attempt_get` due to previous error\n"
"error: `scarb metadata` exited with error\n"
"\n"
"```"
msgstr ""
"拼写 no_ list_ 15_ dict_of_ array_ prevention_ get_ get v0.1.0 (列表/ch03- "
"common- communications/ no_ list_ 15_ dict_ preputy_ attle_ attle_ get_ "
"Scarb.tol) 错误: Trait 在上下文中未执行 : 核心 : traits: coppy: 核心 : < nolleble: < "
"colleple:: < colleple::: < core:: arrary:: Array: > cocle: integer: u8_ -- "
"列出/ch03- commoncounts/no_ list_ 15_ dict_ fread_ attlement_ lible: section_ "
"droad"

#: src/ch03-02-dictionaries.md:437
msgid ""
"To correctly read an array from the dictionary, we need to use dictionary "
"entries. This allows us to get a reference to the array value without "
"copying it:"
msgstr "要正确读取字典中的数组, 我们需要使用字典条目。 这样我们就可以在不复制数组值的情况下获得该数组值的引用 :"

#: src/ch03-02-dictionaries.md:449
msgid ""
"Note: We must convert the array to a `Span` before finalizing the entry, "
"because calling `NullableTrait::new(arr)` moves the array, thus making it "
"impossible to return it from the function."
msgstr ""
"注意 : 我们必须在最后敲定条目前将数组转换为 `span', 因为调用 `NullbleTrait:: new(rr)' 将数组移动, "
"从而无法从函数返回它 。"

#: src/ch03-02-dictionaries.md:451
msgid ""
"To modify the stored array, such as appending a new value, we can use a "
"similar approach. The following `append_value` function demonstrates this:"
msgstr "要修改存储的阵列,例如附加新值,我们可以使用类似的方法。"

#: src/ch03-02-dictionaries.md:462
msgid ""
"In the `append_value` function, we access the dictionary entry, dereference "
"the array, append the new value, and finalize the entry with the updated "
"array."
msgstr "在`附录_value' 函数中,我们访问字典条目,删减数组,附加新值,并与更新的数组一起完成条目的定稿。"

#: src/ch03-02-dictionaries.md:464
msgid ""
"Note: Removing an item from a stored array can be implemented in a similar "
"manner."
msgstr "注意: 从存储的数组中删除一项可以以类似方式执行 。"

#: src/ch03-02-dictionaries.md:466
msgid ""
"Below is the complete example demonstrating the creation, insertion, "
"reading, and modification of an array in a dictionary:"
msgstr "下面是显示字典中数组的创建、插入、读取和修改的完整示例:"

#: src/ch03-02-dictionaries.md:491
msgid "\"Before insertion: {:?}\""
msgstr "\"之前插入:{{{{}}}\""

#: src/ch03-02-dictionaries.md:495
msgid "\"After insertion: {:?}\""
msgstr "\"插入后:{{{:}}\""

#: src/ch03-02-dictionaries.md:499
msgid "{{#quiz ../quizzes/ch03-02-dictionaries.toml}}"
msgstr "///ch03-02 - 字典.toml"

#: src/ch04-00-understanding-ownership.md
msgid "Understanding Cairo's Ownership system"
msgstr "理解开罗所有权制度"

#: src/ch04-00-understanding-ownership.md
msgid ""
"Cairo is a language built around a linear type system that allows us to "
"statically ensure that in every Cairo program, a value is used exactly once."
" This linear type system helps prevent runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory "
"cell, are detected at compile time. This is achieved by implementing an "
"ownership system and forbidding copying and dropping values by default. In "
"this chapter, we’ll talk about Cairo's ownership system as well as "
"references and snapshots."
msgstr ""
"开罗是围绕线性类型系统构建的语言,它让我们能够静态地确保每个开罗方案都使用一个数值一次。 "
"这一线性类型系统通过确保在编译时检测出可能导致此类错误的操作,例如写两次到记忆单元格,从而帮助防止运行时间错误。 "
"这是通过实施所有权系统,禁止默认情况下复制和降低数值实现的。 在本章中,我们将讨论开罗的所有权系统以及参考和快照。"

#: src/ch04-01-what-is-ownership.md:1
msgid "Ownership Using a Linear Type System"
msgstr "使用线性类型系统的所有权"

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"Cairo uses a linear type system. In such a type system, any value (a basic "
"type, a struct, an enum) must be used and must only be used once. 'Used' "
"here means that the value is either _destroyed_ or _moved_."
msgstr ""
"开罗使用线性类型系统。 在这种类型系统中, 任何值( 基本类型、 支架、 enum) 都必须使用, 并且只能使用一次 。 “ 使用” "
"这里的意思是该值要么被销毁, 要么被销毁 。"

#: src/ch04-01-what-is-ownership.md:5
msgid "_Destruction_ can happen in several ways:"
msgstr "{\\fn方正黑体简体\\fs18\\b1\\bord1\\shad1\\3cH2F2F2F}[法"

#: src/ch04-01-what-is-ownership.md:7
msgid "a variable goes out of scope."
msgstr "a 变量超出范围。"

#: src/ch04-01-what-is-ownership.md:8
msgid "a struct is destructured."
msgstr "a 建筑结构被拆解。"

#: src/ch04-01-what-is-ownership.md:9
msgid "explicit destruction using `destruct()`."
msgstr "使用 \" 销毁() \" 进行明确销毁。"

#: src/ch04-01-what-is-ownership.md:11
msgid "_Moving_ a value simply means passing that value to another function."
msgstr "移动_一个值仅意味着将该值传递到另一个函数中。"

#: src/ch04-01-what-is-ownership.md:13
msgid ""
"This results in somewhat similar constraints to the Rust ownership model, "
"but there are some differences. In particular, the Rust ownership model "
"exists (in part) to avoid data races and concurrent mutable access to a "
"memory value. This is obviously impossible in Cairo since the memory is "
"immutable. Instead, Cairo leverages its linear type system for two main "
"purposes:"
msgstr ""
"这导致与Rust所有制模式相类似的限制,但有一些差异。 特别是,Rust所有制模式(部分)存在,以避免数据竞赛和同时变换存取记忆值。 "
"在开罗,这显然是不可能的,因为记忆是不可改变的。 相反,开罗利用其线型系统有两个主要目的:"

#: src/ch04-01-what-is-ownership.md:17
msgid "Ensuring that all code is provable and thus verifiable."
msgstr "确保所有守则都是可证实的,因而是可核查的。"

#: src/ch04-01-what-is-ownership.md:18
msgid "Abstracting away the immutable memory of the Cairo VM."
msgstr "总结开罗VM的永恒记忆"

#: src/ch04-01-what-is-ownership.md:20
msgid "Ownership"
msgstr "所有权所有权所有权"

#: src/ch04-01-what-is-ownership.md:22
msgid ""
"In Cairo, ownership applies to _variables_ and not to _values_. A value can "
"safely be referred to by many different variables (even if they are mutable "
"variables), as the value itself is always immutable. Variables however can "
"be mutable, so the compiler must ensure that constant variables aren't "
"accidentally modified by the programmer. This makes it possible to talk "
"about ownership of a variable: the owner is the code that can read (and "
"write if mutable) the variable."
msgstr ""
"在开罗,所有制适用于 "
"_可变变量_,而不是_values_。许多不同的变量可以安全地引用一个值(即使它们是可变变量),因为该值本身总是不可变的。但变量可以是可变的,因此编译者必须确保不变变量不会被程序员意外地修改。这样就可以谈论变量的所有权:所有者是能够读取变量(如果可变则写)的代码。"

#: src/ch04-01-what-is-ownership.md:26
msgid ""
"This means that variables (not values) follow similar rules to Rust values:"
msgstr "这意味着变量(不是数值)遵循与 Rust 值相似的规则:"

#: src/ch04-01-what-is-ownership.md:28
msgid "Each variable in Cairo has an owner."
msgstr "开罗的每个变数都有拥有者。"

#: src/ch04-01-what-is-ownership.md:29
msgid "There can only be one owner at a time."
msgstr "一次只能有一个拥有者。"

#: src/ch04-01-what-is-ownership.md:30
msgid "When the owner goes out of scope, the variable is destroyed."
msgstr "当所有者超出范围时,变量将被销毁。"

#: src/ch04-01-what-is-ownership.md:32
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() "
"{` code in examples, so if you’re following along, make sure to put the "
"following examples inside a main function manually. As a result, our "
"examples will be a bit more concise, letting us focus on the actual details "
"rather than boilerplate code."
msgstr ""
"既然我们已经过了基本的开罗语法,我们就不会把所有的“fn main () ” "
"代码都包含在示例中,所以如果你在跟踪的话,就一定要手工将以下示例放在主要函数中。 结果,我们的例子将更加简洁一些,让我们关注实际细节,而不是锅炉代码。"

#: src/ch04-01-what-is-ownership.md:34
msgid "Variable Scope"
msgstr "可变范围"

#: src/ch04-01-what-is-ownership.md:36
msgid ""
"As a first example of the linear type system, we’ll look at the _scope_ of "
"some variables. A scope is the range within a program for which an item is "
"valid. Take the following variable:"
msgstr "作为线性类型系统的第一个示例,我们将查看某些变量的“范围 ” 。 范围是某个项目有效的程序内的范围。 选择以下变量:"

#: src/ch04-01-what-is-ownership.md:44
msgid ""
"The variable `s` refers to a short string. The variable is valid from the "
"point at which it’s declared until the end of the current _scope_. Listing "
"4-1 shows a program with comments annotating where the variable `s` would be"
" valid."
msgstr ""
"变量`s'指短字符串。变量从宣布点起有效,一直到当前 _scope_结束。列出 4-1 显示一个程序,并附有注释,说明变量`s'在什么位置有效。"

#: src/ch04-01-what-is-ownership.md:49
msgid "//TAG: ignore_fmt\n"
msgstr "//TAG: 忽略_fmt\n"

#: src/ch04-01-what-is-ownership.md:51
msgid "// s is not valid here, it’s not yet declared\n"
msgstr "/ s 在这里无效, 尚未申报\n"

#: src/ch04-01-what-is-ownership.md:52
msgid ""
"// s is valid from this point forward\n"
"    // do stuff with s\n"
msgstr "/ s 从此点起有效\n"

#: src/ch04-01-what-is-ownership.md:54
msgid "// this scope is now over, and s is no longer valid\n"
msgstr "/ 这一范围现已结束, s不再有效\n"

#: src/ch04-01-what-is-ownership.md:58
msgid ""
"<span class=\"caption\">Listing 4-1: A variable and the scope in which it is"
" valid</span>"
msgstr "<span类=\"Caption\" > listing 4-1: 一个变量及其有效的范围 </span>"

#: src/ch04-01-what-is-ownership.md:60
msgid "In other words, there are two important points in time here:"
msgstr "换句话说,这里有两个重要时间点:"

#: src/ch04-01-what-is-ownership.md:62
msgid "When `s` comes _into_ scope, it is valid."
msgstr "当`s'到`into'范围时,它是有效的。"

#: src/ch04-01-what-is-ownership.md:63
msgid "It remains valid until it goes _out of_ scope."
msgstr "其有效期一直有效,直到它进入_超出_范围为止。"

#: src/ch04-01-what-is-ownership.md:65
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is similar to that in other programming languages. Now we’ll build on top of"
" this understanding by using the `Array` type we introduced in the previous "
"[\"Arrays\"](./ch03-01-arrays.md) section."
msgstr ""
"在这一点上,范围与变量有效时之间的关系与其他程序语言的关系相似。 "
"现在,我们将利用在前一个[“阵列”部分(./ch03-01-arrays.md)中引入的“阵列”类型(./ch03-01-arys.md),在这种理解的基础上再接再厉。"

#: src/ch04-01-what-is-ownership.md:69
msgid "Moving values"
msgstr "移动值"

#: src/ch04-01-what-is-ownership.md:71
msgid ""
"As said earlier, _moving_ a value simply means passing that value to another"
" function. When that happens, the variable referring to that value in the "
"original scope is destroyed and can no longer be used, and a new variable is"
" created to hold the same value."
msgstr ""
"如前所述,_move_ a value "
"仅意味着将该值传递到另一个函数。如果发生这种情况,在原始范围中提及该值的变量将被销毁,不能再使用,并创建一个新的变量以持有相同的值。"

#: src/ch04-01-what-is-ownership.md:73
msgid ""
"Arrays are an example of a complex type that is moved when passing it to "
"another function. Here is a short reminder of what an array looks like:"
msgstr "矩阵是一个复杂类型的例子,在将它传递到另一个函数时会移动。这里简短地提醒注意一个阵列的外观:"

#: src/ch04-01-what-is-ownership.md:84
msgid ""
"How does the type system ensure that the Cairo program never tries to write "
"to the same memory cell twice? Consider the following code, where we try to "
"remove the front of the array twice:"
msgstr "类型系统如何确保开罗程序从未尝试过两次写入相同的内存单元格? 考虑以下代码, 我们试图两次删除阵列的前端 :"

#: src/ch04-01-what-is-ownership.md:99
msgid ""
"In this case, we try to pass the same value (the array in the `arr` "
"variable) to both function calls. This means our code tries to remove the "
"first element twice, which would try to write to the same memory cell twice "
"- which is forbidden by the Cairo VM, leading to a runtime error. "
"Thankfully, this code does not actually compile. Once we have passed the "
"array to the `foo` function, the variable `arr` is no longer usable. We get "
"this compile-time error, telling us that we would need Array to implement "
"the Copy Trait:"
msgstr ""
"在此情况下, 我们试图将相同的值( ` arre' 变量中的数组) 传递给两个函数调用 。 这意味着我们的代码试图两次删除第一个元素, "
"两次试图将第一个元素写入同一个记忆单元格 - 开罗 VM 禁止的两次, 导致运行时间错误 。 幸运的是, 这个代码实际上没有编译 。 "
"一旦我们将数组传送到 ` foo' 函数, 变量` ` 将不再可用 。 我们得到了这个编译时间错误, 告诉我们需要用 Array 来执行副本 Trait"
" :"

#: src/ch04-01-what-is-ownership.md:125
msgid "The `Copy` Trait"
msgstr "`Copy` Trapit 悲剧"

#: src/ch04-01-what-is-ownership.md:127
msgid ""
"If a type implements the `Copy` trait, passing a value of that type to a "
"function does not move the value. Instead, a new variable is created, "
"referring to the same value. The important thing to note here is that this "
"is a completely free operation because variables are a Cairo abstraction "
"only and because _values_ in Cairo are always immutable. This, in "
"particular, conceptually differs from the Rust version of the `Copy` trait, "
"where the value is potentially copied in memory."
msgstr ""
"如果类型执行“可复制”特性, 将该类型值传递给函数不会移动值。 相反, 创建了一个新的变量, 指着相同的值。 这里需要注意的是, "
"这是一个完全自由的操作, 因为变量只是开罗的抽象, 而且开罗的 _ 值 总是不可改变的。 这在概念上与“ 可复制” 特性的 Rust 版本不同, "
"因为它的值有可能在记忆中复制 。"

#: src/ch04-01-what-is-ownership.md:130
msgid ""
"All basic types previously described in [\"Data Types\"](./ch02-02-data-"
"types.md) implement by default the `Copy` trait."
msgstr "在[“数据类型”](./ch02-02-dd)中描述的所有基本类型都默认地执行“复制”特性。"

#: src/ch04-01-what-is-ownership.md:132
msgid ""
"While Arrays and Dictionaries can't be copied, custom types that don't "
"contain either of them can be. You can implement the `Copy` trait on your "
"type by adding the `#[derive(Copy)]` annotation to your type definition. "
"However, Cairo won't allow a type to be annotated with Copy if the type "
"itself or any of its components doesn't implement the Copy trait."
msgstr ""
"虽然无法复制数组和字典, 但不包含其中任何一个的自定义类型也可以复制。 您可以在类型定义中添加“ [derive( Copy) ” 注释, "
"从而在类型上执行“ 复制” 特性 。 但是, 如果类型本身或其任何组件不执行复制特性, 开罗不允许对类型使用副本附加注释 。"

#: src/ch04-01-what-is-ownership.md:148
msgid "// do something with p\n"
msgstr "和P做点什么\n"

#: src/ch04-01-what-is-ownership.md:152
msgid ""
"In this example, we can pass `p1` twice to the foo function because the "
"`Point` type implements the `Copy` trait. This means that when we pass `p1` "
"to `foo`, we are actually passing a copy of `p1`, so `p1` remains valid. In "
"ownership terms, this means that the ownership of `p1` remains with the "
"`main` function. If you remove the `Copy` trait derivation from the `Point` "
"type, you will get a compile-time error when trying to compile the code."
msgstr ""
"在这个例子中,我们可以将`p1'两次传给fo函数,因为`point'类型执行`copy'特性,这意味着当我们将`p1'传递到`foo'时,我们实际上正在传递`p1',因此`p1'仍然有效,从所有权的角度来看,这意味着`p1'的所有权仍属于`main'函数。如果删除`point'类型产生的`compy'特性,那么在试图编纂代码时,你就会发现一个编译错误。"

#: src/ch04-01-what-is-ownership.md:155
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter "
"5](./ch05-00-using-structs-to-structure-related-data.md)._"
msgstr ""
"{\\fn黑体\\fs22\\bord1\\shad0\\3aHBE\\4aH00\\fscx67\\fscy66\\2cHFFFFFF\\3cH808080}不要担心`Struct'关键字。我们将在[第5章](./ch05-00-using-"
"structs-structs-to-"

#: src/ch04-01-what-is-ownership.md:160
msgid "Destroying Values - Example with FeltDict"
msgstr "销毁值 - 费尔特迪克特示例"

#: src/ch04-01-what-is-ownership.md:162
msgid ""
"The other way linear types can be _used_ is by being destroyed. Destruction "
"must ensure that the 'resource' is now correctly released. In Rust, for "
"example, this could be closing the access to a file, or locking a mutex. In "
"Cairo, one type that has such behaviour is `Felt252Dict`. For provability, "
"dicts must be 'squashed' when they are destructed. This would be very easy "
"to forget, so it is enforced by the type system and the compiler."
msgstr ""
"线性类型的另一种方式是销毁 。 销毁必须确保“ 资源” 现在被正确释放。 例如, 在 Rust 中, 这可能是关闭对文件的访问, 或者锁定哑巴 。 "
"在开罗, 一种具有类似行为的是“ Felt252Dict ” 。 对于可证实性, 定案在被销毁时必须被“ 压碎 ” 。 这会很容易忘记, "
"由类型系统和编译者强制执行 。"

#: src/ch04-01-what-is-ownership.md:166
msgid "No-op Destruction: the `Drop` Trait"
msgstr "禁止销毁:`拖累'"

#: src/ch04-01-what-is-ownership.md:168
msgid ""
"You may have noticed that the `Point` type in the previous example also "
"implements the `Drop` trait. For example, the following code will not "
"compile, because the struct `A` is not moved or destroyed before it goes out"
" of scope:"
msgstr "你可能注意到,上一个示例中的“点”类型也执行`滴滴'特性。例如,以下代码不会编译,因为`A` 支架在超出范围之前没有移动或销毁:"

#: src/ch04-01-what-is-ownership.md:175
msgid "// error: Variable not dropped.\n"
msgstr "/ 错误: 变量未下降 。\n"

#: src/ch04-01-what-is-ownership.md:179
msgid ""
"However, types that implement the `Drop` trait are automatically destroyed "
"when going out of scope. This destruction does nothing, it is a no-op - "
"simply a hint to the compiler that this type can safely be destroyed once "
"it's no longer useful. We call this \"dropping\" a value."
msgstr ""
"然而,实施`滴滴'特性的类型在超出范围时会自动销毁。这种销毁没有任何作用,只是向编译者暗示,一旦不再有用,这种类型就可安全销毁。我们称它为“删除”值。"

#: src/ch04-01-what-is-ownership.md:181
msgid ""
"At the moment, the `Drop` implementation can be derived for all types, "
"allowing them to be dropped when going out of scope, except for dictionaries"
" (`Felt252Dict`) and types containing dictionaries. For example, the "
"following code compiles:"
msgstr "目前, \" 减少 \" 执行可针对所有类型产生,允许在超出范围时予以删除,但词典(`Felt252Dict')和含有词典的类型除外。"

#: src/ch04-01-what-is-ownership.md:189
msgid "// Now there is no error.\n"
msgstr "/ 现在没有错误 。\n"

#: src/ch04-01-what-is-ownership.md:193
msgid "Destruction with a Side-effect: the `Destruct` Trait"
msgstr "具有副作用的销毁:`破坏'轨迹"

#: src/ch04-01-what-is-ownership.md:195
msgid ""
"When a value is destroyed, the compiler first tries to call the `drop` "
"method on that type. If it doesn't exist, then the compiler tries to call "
"`destruct` instead. This method is provided by the `Destruct` trait."
msgstr ""
"当一个值被销毁时, 编译者首先尝试在这种类型上调用“ 投放” 方法。 如果它不存在, 那么编译者则试图调用“ 销毁”, 由“ 毁损” 特性提供。"

#: src/ch04-01-what-is-ownership.md:197
msgid ""
"As said earlier, dictionaries in Cairo are types that must be \"squashed\" "
"when destructed, so that the sequence of access can be proven. This is easy "
"for developers to forget, so instead dictionaries implement the `Destruct` "
"trait to ensure that all dictionaries are _squashed_ when going out of "
"scope. As such, the following example will not compile:"
msgstr ""
"如前所述,开罗的字典在被摧毁时必须是“封隔”的字典,这样可以证明访问的顺序。 这对于开发者来说很容易忘记,因此字典执行“ 封隔” "
"特性,以确保所有字典在超出范围时都“封隔”。 因此,以下示例不会汇编:"

#: src/ch04-01-what-is-ownership.md:210
msgid "If you try to run this code, you will get a compile-time error:"
msgstr "如果您尝试运行此代码, 将会有一个编译时间错误 :"

#: src/ch04-01-what-is-ownership.md:227
msgid ""
"When `A` goes out of scope, it can't be dropped as it implements neither the"
" `Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the "
"`Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr ""
"当`A'超出范围时,它不能被丢弃,因为它既执行`Drop'(因为它既包含字典,也不能`Drop' ),也没有`Derive(Drop)'特性。"

#: src/ch04-01-what-is-ownership.md:236
msgid "// No error here\n"
msgstr "// 这里没有错误\n"

#: src/ch04-01-what-is-ownership.md:240
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically "
"`squashed`, and the program will compile."
msgstr "现在,当`A'超出范围时,其词典将自动`被压碎 ',程序将加以汇编。"

#: src/ch04-01-what-is-ownership.md:242
msgid "Copy Array Data with `clone`"
msgstr "复制有“ clone” 的阵列数据"

#: src/ch04-01-what-is-ownership.md:244
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common "
"method called `clone`. We’ll discuss method syntax in a dedicated section in"
" [Chapter 5](./ch05-03-method-syntax.md), but because methods are a common "
"feature in many programming languages, you’ve probably seen them before."
msgstr ""
"如果我们想深入复制`Array' 的数据,我们可以使用一种称为`crone'的共同方法。我们将在[第5章](./ch05-03-method-"
"syngy.md)的一个专门章节中讨论方法语法,但由于方法在许多编程语言中是一个共同特点,你可能已经见过了。"

#: src/ch04-01-what-is-ownership.md:246
msgid "Here’s an example of the `clone` method in action."
msgstr "以下是`核心'行动方法的例子。"

#: src/ch04-01-what-is-ownership.md:255
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being "
"executed and that code may be expensive. It’s a visual indicator that "
"something different is going on. In this case, the _value_ `arr1` refers to "
"is being copied, resulting in new memory cells being used, and a new "
"_variable_ `arr2` is created, referring to the new copied value."
msgstr ""
"当您看到“ 密钥” 的呼叫时, 您知道正在执行某些任意代码, 该代码可能非常昂贵。 这是一个不同事物正在发生的视觉指标 。 在此情况下, 正在复制 ` "
"rr1'指的值, 导致使用新的内存单元格, 并创建了一个新的“ 可变” “ rr2”, 指新的复制值 。"

#: src/ch04-01-what-is-ownership.md:260
msgid "Return Values and Scope"
msgstr "价值和回报范围"

#: src/ch04-01-what-is-ownership.md:262
msgid ""
"Returning values is equivalent to _moving_ them. Listing 4-2 shows an "
"example of a function that returns some value, with similar annotations as "
"those in Listing 4-1."
msgstr "返回值相当于_move_它们。列表 4-2 显示一个函数返回某种值的例子,其注释与列表 4-1 中的注释相似。"

#: src/ch04-01-what-is-ownership.md:272
msgid ""
"// gives_ownership moves its return\n"
"                                          // value into a1\n"
msgstr "/ 给予_ 所有权将其返回 // 值移动到 a1\n"

#: src/ch04-01-what-is-ownership.md:275
msgid "// a2 comes into scope\n"
msgstr "/ a2 进入范围\n"

#: src/ch04-01-what-is-ownership.md:277
msgid ""
"// a2 is moved into\n"
"                                          // takes_and_gives_back, which also\n"
"                                          // moves its return value into a3\n"
msgstr "/ / a2 被移动到 / 采取_ 和_ gives_ back, 并且 / 将返回值移动到 a3\n"

#: src/ch04-01-what-is-ownership.md:281
msgid ""
"// Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
msgstr "这里, a3 超出范围, 被丢弃。 a2 被移走, 所以没有发生 。 a1 脱离范围, 被丢弃 。\n"

#: src/ch04-01-what-is-ownership.md:284
msgid ""
"// gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
msgstr "/ 给予_ 所有权将将其 // 返回值移动到函数 / 调用它的函数 / 返回值\n"

#: src/ch04-01-what-is-ownership.md:288 src/ch04-01-what-is-ownership.md:296
msgid "// some_a comes into scope\n"
msgstr "/ 某些_a 进入范围\n"

#: src/ch04-01-what-is-ownership.md:290
msgid ""
"// some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr "/ some_a 被返回, // 将所有权移动到调用 // 函数\n"

#: src/ch04-01-what-is-ownership.md:294
msgid "// This function takes an instance some_a of A and returns it\n"
msgstr "/ 此函数使用 A 的  some_a 实例返回它\n"

#: src/ch04-01-what-is-ownership.md:298
msgid ""
"// some_a is returned and \n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr "/ some_a 被返回, // 将所有权移动到调用 // 函数\n"

#: src/ch04-01-what-is-ownership.md:304
msgid "<span class=\"caption\">Listing 4-2: Moving return values</span>"
msgstr "<span类=\"Caption\" > listing 4-2: 移动返回值 </span>"

#: src/ch04-01-what-is-ownership.md:306
msgid ""
"While this works, moving into and out of every function is a bit tedious. "
"What if we want to let a function use a value but not move the value? It’s "
"quite annoying that anything we pass in also needs to be passed back if we "
"want to use it again, in addition to any data resulting from the body of the"
" function that we might want to return as well."
msgstr ""
"虽然这个功能起作用了,但每个函数的进进出出都有点无聊。 如果我们想让函数使用一个值而不移动该值,那又如何? "
"如果我们想让一个函数使用一个值而不移动该值,那么我们所通过的任何东西如果想要再次使用,除了从函数体中得出的我们可能也希望返回的任何数据之外,也需要被回传,这很令人烦恼。"

#: src/ch04-01-what-is-ownership.md:308
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing "
"4-3."
msgstr "开罗确实让我们使用图普返回多个值,如清单4-3所示。"

#: src/ch04-01-what-is-ownership.md:320
msgid "// len() returns the length of an array\n"
msgstr "/ len () 返回数组的长度 。\n"

#: src/ch04-01-what-is-ownership.md:326
msgid "<span class=\"caption\">Listing 4-3: Returning many values</span>"
msgstr "<span类=\"Caption\" > listing 4-3: 返回许多值 </span>"

#: src/ch04-01-what-is-ownership.md:328
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be"
" common. Luckily for us, Cairo has two features for passing a value without "
"destroying or moving it, called _references_ and _snapshots_."
msgstr ""
"但对于一个应该常见的概念来说,这是太多的仪式和许多工作了。 "
"幸运的是,对于我们来说,开罗有两个特征,即不破坏或移动它而传递一个价值,即_references_和_snapshots_。"

#: src/ch04-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in previous Listing 4-3 is that we have to "
"return the `Array` to the calling function so we can still use the `Array` "
"after the call to `calculate_length`, because the `Array` was moved into "
"`calculate_length`."
msgstr ""
"上一个清单4-3中的图普尔代码问题在于,我们必须将`阵列'还给调用功能,这样我们仍然可以使用呼叫`计算'后`阵列 ',因为`阵列'被移至`计算'中。"

#: src/ch04-02-references-and-snapshots.md:8
msgid "Snapshots"
msgstr "抓图"

#: src/ch04-02-references-and-snapshots.md:10
msgid ""
"In the previous chapter, we talked about how Cairo's ownership system "
"prevents us from using a variable after we've moved it, protecting us from "
"potentially writing twice to the same memory cell. However, it's not very "
"convenient. Let's see how we can retain ownership of the variable in the "
"calling function using snapshots."
msgstr ""
"在前一章,我们讨论了开罗的拥有权系统如何阻止我们在移动后使用变量, 从而保护我们不会写作两次到同一个记忆细胞。 "
"但是,这不太方便。让我们看看我们如何在调用功能中使用快照来保留变量的所有权。"

#: src/ch04-02-references-and-snapshots.md:15
msgid ""
"In Cairo, a snapshot is an immutable view of a value at a certain point in "
"time. Recall that memory is immutable, so modifying a value actually creates"
" a new memory cell. The old memory cell still exists, and snapshots are "
"variables that refer to that \"old\" value. In this sense, snapshots are a "
"view \"into the past\"."
msgstr ""
"在开罗,快照是特定时间点值的不可改变的视图。 回顾记忆是不可改变的, 因此修改一个值实际上会创建一个新的记忆单元格。 旧的记忆单元格仍然存在, "
"抓照是提到“ 旧的” 值的变量。 从这个意义上讲, 抓照是“ 过去的” 视图。"

#: src/ch04-02-references-and-snapshots.md:20
msgid ""
"Here is how you would define and use a `calculate_length` function that "
"takes a snapshot of an array as a parameter instead of taking ownership of "
"the underlying value. In this example, the `calculate_length` function "
"returns the length of the array passed as a parameter. As we're passing it "
"as a snapshot, which is an immutable view of the array, we can be sure that "
"the `calculate_length` function will not mutate the array, and ownership of "
"the array is kept in the `main` function."
msgstr ""
"这里您将如何定义和使用“ 计算_ 长度” 函数, 该函数将一个阵列的快照作为参数, 而不是对底值的所有权。 在此示例中, “ 计算_ 长度” "
"函数返回以参数传递的阵列长度。 当我们把它作为快照通过时, 这是对阵列不可变的视图, 我们就可以确定, ` 计算_ 长度' 函数不会使阵列变形, "
"并且将阵列的所有权保留在` 主'函数中 。"

#: src/ch04-02-references-and-snapshots.md:31
msgid "// Take a snapshot of `arr1` at this point in time\n"
msgstr "此时此刻拍下`1'的快照\n"

#: src/ch04-02-references-and-snapshots.md:32
msgid "// Mutate `arr1` by appending a value\n"
msgstr "//通过附加一个值来 Mutat `rr1'的变音\n"

#: src/ch04-02-references-and-snapshots.md:35
msgid "// Calculate the length of the array when the snapshot was taken\n"
msgstr "/ 计算抓图拍摄时数组的长度\n"

#: src/ch04-02-references-and-snapshots.md:36
#: src/ch04-02-references-and-snapshots.md:67
msgid "// Calculate the current length of the array\n"
msgstr "/ 计算数组的当前长度\n"

#: src/ch04-02-references-and-snapshots.md:37
msgid "\"The length of the array when the snapshot was taken is {}\""
msgstr "\"拍片时的阵列长度是\""

#: src/ch04-02-references-and-snapshots.md:38
msgid "\"The current length of the array is {}\""
msgstr "\"阵列的当前长度是\""

#: src/ch04-02-references-and-snapshots.md:46
msgid ""
"Note: it is only possible to call the `len()` method on an array snapshot "
"because it is defined as such in the `ArrayTrait` trait. If you try to call "
"a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on "
"non-snapshot types."
msgstr ""
"注意 : 只能将“ len() ” 方法调用在阵列快照上, 因为它在“ ArrayTrait” 特性中被定义为此方法。 "
"如果您试图调用一种对快照上的快照没有定义的方法, 您将会得到一个编译错误。 但是, 您可以调用一些方法, 期待对非弹射类型进行快照。"

#: src/ch04-02-references-and-snapshots.md:48
msgid "The output of this program is:"
msgstr "此程序的产出为:"

#: src/ch04-02-references-and-snapshots.md:61
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note that we pass `@arr1` into "
"`calculate_length` and, in its definition, we take `@Array<u128>` rather "
"than `Array<u128>`."
msgstr "首先, 注意变量声明和函数返回值中的所有 tuple 代码都已删除 。 其次, 注意我们通过 `\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch04-02-references-and-snapshots.md:64
msgid "Let’s take a closer look at the function call here:"
msgstr "让我们更仔细地看一看函数调用这里 :"

#: src/ch04-02-references-and-snapshots.md:70
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because"
" a snapshot is an immutable view of a value at a specific point in time, the"
" usual rules of the linear type system are not enforced. In particular, "
"snapshot variables always implement the `Drop` trait, never the `Destruct` "
"trait, even dictionary snapshots."
msgstr ""
"rr1的语法让我们能够对`arr1' "
"中的价值做一个快照,因为快照是特定时间某个值的不可改变的视图,因此没有执行线性类型系统的常规规则,特别是,快照变量总是执行`滴滴'特性,从不执行`破坏'特性,甚至字典短照。"

#: src/ch04-02-references-and-snapshots.md:72
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type "
"of the parameter `arr` is a snapshot. Let’s add some explanatory "
"annotations:"
msgstr "同样,函数的签名用表示参数`arr'的类型是一个快照。让我们添加一些解释性说明:"

#: src/ch04-02-references-and-snapshots.md:76
msgid "// array_snapshot is a snapshot of an Array\n"
msgstr "/ 数组_ snapshot 是阵列的快照\n"

#: src/ch04-02-references-and-snapshots.md:79
msgid ""
"// Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` contains, the original `arr` can still be used.\n"
msgstr "/ 然而,因为它只是观察原始阵列`收发'中包含什么,原始`收发'仍然可以使用。\n"

#: src/ch04-02-references-and-snapshots.md:83
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any"
" function parameter’s scope, but the underlying value of the snapshot is not"
" dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to "
"return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""
"变量“ array_ snapshot” 有效的范围与任何函数参数的范围相同,但当“ array_ snapshot” "
"停止使用时,快照的基本值没有下降。当函数将快照作为参数而不是实际值时,我们不需要返回值,以恢复原始值的所有权,因为我们从未拥有过它。"

#: src/ch04-02-references-and-snapshots.md:85
msgid "Desnap Operator"
msgstr "Desnap 运算运算符"

#: src/ch04-02-references-and-snapshots.md:87
msgid ""
"To convert a snapshot back into a regular variable, you can use the `desnap`"
" operator `*`, which serves as the opposite of the `@` operator."
msgstr "要将快照转换为正则变量, 您可以使用“ desnap” 运算符 ”, 与 {% 运算符相反 。"

#: src/ch04-02-references-and-snapshots.md:89
msgid ""
"Only `Copy` types can be desnapped. However, in the general case, because "
"the value is not modified, the new variable created by the `desnap` operator"
" reuses the old value, and so desnapping is a completely free operation, "
"just like `Copy`."
msgstr ""
"只有`Copy'类型才能去除,但是,在一般情况下,由于价值没有改变,“Donnap'经营者创造的新变量重复了旧价值,因此,“Copy”是一种完全自由的操作,就像`Copy'一样。"

#: src/ch04-02-references-and-snapshots.md:91
msgid ""
"In the following example, we want to calculate the area of a rectangle, but "
"we don't want to take ownership of the rectangle in the `calculate_area` "
"function, because we might want to use the rectangle again after the "
"function call. Since our function doesn't mutate the rectangle instance, we "
"can pass the snapshot of the rectangle to the function, and then transform "
"the snapshots back into values using the `desnap` operator `*`."
msgstr ""
"在下面的例子中,我们想要计算矩形的区域, 但我们不想在“ 计算区域” 函数中拥有矩形, 因为我们可能想要在函数调用后再次使用矩形。 "
"由于我们的函数不会变形矩形实例, 我们可以将矩形的抓图传送到函数中, 然后使用 `desnap' 运算符将抓图转换为值 。"

#: src/ch04-02-references-and-snapshots.md:103
msgid "\"Area: {}\""
msgstr "\"地区: \""

#: src/ch04-02-references-and-snapshots.md:107
msgid ""
"// As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.\n"
"    // We need to transform the snapshots back into values using the desnap operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.\n"
msgstr ""
"作为矩形的缩影,它的字段也是字段类型的缩图。 / 我们需要使用 desnap 运算符将抓图转换为值 。 / / 只有当该类型可以复制时, 也就是 u64"
" 的情况。 / / 此处, \\ 用于乘法高度和宽度, 并用于删除抓图 。\n"

#: src/ch04-02-references-and-snapshots.md:115
msgid ""
"But, what happens if we try to modify something we’re passing as a snapshot?"
" Try the code in Listing 4-4. Spoiler alert: it doesn’t work!"
msgstr "但是,如果我们试图修改我们作为快照通过的东西呢?试试4-4列表中的代码。 破坏者警告:这行不通!"

#: src/ch04-02-references-and-snapshots.md:140
msgid ""
"<span class=\"caption\">Listing 4-4: Attempting to modify a snapshot "
"value</span>"
msgstr "<span类=“caption” > listing 4-4: 试图修改快照值 </span>"

#: src/ch04-02-references-and-snapshots.md:142
msgid "Here’s the error:"
msgstr "以下是错误:"

#: src/ch04-02-references-and-snapshots.md:162
msgid ""
"The compiler prevents us from modifying values associated to snapshots."
msgstr "编译者阻止我们修改与快照相关的值 。"

#: src/ch04-02-references-and-snapshots.md:164
msgid "Mutable References"
msgstr "可变引用"

#: src/ch04-02-references-and-snapshots.md:166
msgid ""
"We can achieve the behavior we want in Listing 4-4 by using a _mutable "
"reference_ instead of a snapshot. Mutable references are actually mutable "
"values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they "
"allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution. In Cairo, a "
"parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""
"我们可以通过使用 modable reference 而不是一个快照来实现我们在列表 4 - 4 中想要的行为。  Mudable reference "
"实际上是向函数结尾处暗含返回的函数传递变异值, 将所有权返回到调用上下文。 这样, 它们允许您转换所传递的值, 同时通过在执行结束时自动返回它的所有权 "
"。 在开罗, 参数可以使用 ` ref' 修饰符作为可变参考通过 。"

#: src/ch04-02-references-and-snapshots.md:169
msgid ""
"**Note**: In Cairo, a parameter can only be passed as _mutable reference_ "
"using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""
"** 注**:在开罗,如果变量与`mut'被宣布为可变变量,则只能使用`ref'修饰符,将参数作为可变参引_modable reference_通过。"

#: src/ch04-02-references-and-snapshots.md:171
msgid ""
"In Listing 4-5, we use a mutable reference to modify the value of the "
"`height` and `width` fields of the `Rectangle` instance in the `flip` "
"function."
msgstr "在清单4-5中,我们使用一个可变引用,以修改`翻转'函数中`矩形'实例的`高'和`宽'字段的价值。"

#: src/ch04-02-references-and-snapshots.md:183
msgid "\"height: {}, width: {}\""
msgstr "\"高度:,宽度: \""

#: src/ch04-02-references-and-snapshots.md:193
msgid ""
"<span class=\"caption\">Listing 4-5: Use of a mutable reference to modify a "
"value</span>"
msgstr "<span类=“caption” >Listing 4-5:使用可变引用修改值 </span>"

#: src/ch04-02-references-and-snapshots.md:195
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of "
"`rec` into `flip` with `ref rec`, and update the function signature to "
"accept a mutable reference with `ref rec: Rectangle`. This makes it very "
"clear that the `flip` function will mutate the value of the `Rectangle` "
"instance passed as parameter."
msgstr ""
"首先,我们把`rec'改为`mut',然后我们把`rec'变换为`flip',加上`ref recourt',并更新功能签名,以接受`ref "
"rec:矩形'的变换引用,这非常清楚地表明,`flip'函数将把`recangle'实例作为参数通过的数值变换。"

#: src/ch04-02-references-and-snapshots.md:197
msgid "The output of the program is:"
msgstr "程序输出为 :"

#: src/ch04-02-references-and-snapshots.md:209
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been"
" swapped."
msgstr "如预期的那样,`rec'变量的`高度'和`边缘'字段已被互换。"

#: src/ch04-02-references-and-snapshots.md:211
msgid "{{#quiz ../quizzes/ch04-02-references-and-snapshots.toml}}"
msgstr "Quiz./quizzes/ch04-02 - 参考 - - - - - 笔记本.toml"

#: src/ch04-02-references-and-snapshots.md:213
msgid "Small Recap"
msgstr "小型冲积"

#: src/ch04-02-references-and-snapshots.md:215
msgid ""
"Let’s recap what we’ve discussed about the linear type system, ownership, "
"snapshots, and references:"
msgstr "让我们回顾一下我们讨论的线性类型系统、所有权、快照和参考资料:"

#: src/ch04-02-references-and-snapshots.md:217
msgid "At any given time, a variable can only have one owner."
msgstr "在任何特定时间,变量只能有一个所有人。"

#: src/ch04-02-references-and-snapshots.md:218
msgid ""
"You can pass a variable by-value, by-snapshot, or by-reference to a "
"function."
msgstr "您可以通过变量的副值、副发照或引用函数。"

#: src/ch04-02-references-and-snapshots.md:219
msgid ""
"If you pass-by-value, ownership of the variable is transferred to the "
"function."
msgstr "如果按切换值计算,变量的所有权将转移到函数中。"

#: src/ch04-02-references-and-snapshots.md:220
msgid ""
"If you want to keep ownership of the variable and know that your function "
"won’t mutate it, you can pass it as a snapshot with `@`."
msgstr "如果您想要保留变量的所有权, 并且知道您的函数不会变异, 您可以通过@_@@@@@@wit:which"

#: src/ch04-02-references-and-snapshots.md:221
msgid ""
"If you want to keep ownership of the variable and know that your function "
"will mutate it, you can pass it as a mutable reference with `ref`."
msgstr "如果您想要保留变量的所有权, 并且知道您函数会改变变量, 您可以将变量作为“ ref” 的可变引用传递 。"

#: src/ch05-00-using-structs-to-structure-related-data.md
msgid ""
"A struct, or structure, is a custom data type that lets you package together"
" and name multiple related values that make up a meaningful group. If you’re"
" familiar with an object-oriented language, a struct is like an object’s "
"data attributes. In this chapter, we’ll compare and contrast tuples with "
"structs to build on what you already know and demonstrate when structs are a"
" better way to group data."
msgstr ""
"结构或结构是一种自定义的数据类型,它使您能够组合在一起,并命名组成一个有意义的组合的多个相关值。如果您熟悉一个面向对象的语言,则结构就像一个对象的数据属性。在本章中,我们将比较和比较图例和图例,以建立您已经知道的情况,并演示在构造是更好地组合数据的方法时。"

#: src/ch05-00-using-structs-to-structure-related-data.md
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called methods, to specify behavior associated with a struct type. Structs "
"and enums (discussed in the [next chapter](ch06-01-enums.md)) are the "
"building blocks for creating new types in your program’s domain to take full"
" advantage of Cairo's compile-time type checking."
msgstr ""
"我们将展示如何定义和即时配置结构。 我们将讨论如何定义相关功能, 特别是被称为方法的相关功能, 以指定与结构类型相关的行为。 Structs and "
"enums (在[下一章] (ch06-01-enums.md) 中讨论) 是创建新类型的基础, 以便充分利用开罗的编译时间类型检查 。"

#: src/ch05-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in the [Data Types](ch02-02-data-"
"types.md) section, in that both hold multiple related values. Like tuples, "
"the pieces of a struct can be different types. Unlike with tuples, in a "
"struct you’ll name each piece of data so it’s clear what the values mean. "
"Adding these names means that structs are more flexible than tuples: you "
"don’t have to rely on the order of the data to specify or access the values "
"of an instance."
msgstr ""
"Structs 与 [数据类型] (ch02-02-dd-datatype.md) 一节中讨论的tuples 类似 tiples 。 "
"两者都有多个相关值。 像 tuples 一样, 支架的碎片可以是不同的类型 。 与 tuples 不同, 在 支架中, 您会给每个数据命名名称, "
"这样可以清楚显示值的含义 。 添加这些名称意味着支架比tuples 更灵活: 您不必依靠数据的顺序来指定或访问实例的值 。"

#: src/ch05-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call fields. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""
"为了定义结构,我们输入关键字“支线”并命名整个支线。 支线的名称应描述将数据组合在一起的意义。 然后, 在卷括号内, "
"我们定义了我们称之为字段的数据的单位的名称和类型。 例如, 列出 5-1 显示存储用户账户信息的支线 。"

#: src/ch05-01-defining-and-instantiating-structs.md:20
msgid "<span class=\"caption\">Listing 5-1: A `User` struct definition</span>"
msgstr "<span类=“Caption” > listing 5-1:`用户'结构定义 </span>"

#: src/ch05-01-defining-and-instantiating-structs.md:22
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for"
" the type, and instances fill in that template with particular data to "
"create values of the type."
msgstr ""
"要在定义它后使用支架, 我们通过为每个字段指定具体值来创建支架。 我们通过说明支架的名称来创建一个例。 然后添加括号, 括号中包含 _key: "
"value_ 配对, 键是字段的名称, 值是我们要在这些字段中存储的数据。 我们不必按照在支架中声明的顺序来指定字段。 换句话说, "
"支架定义就像一个类型的一般模板, 并在模板中填写特定数据, 以创建该类型的值 。"

#: src/ch05-01-defining-and-instantiating-structs.md:25
msgid ""
"For example, we can declare two particular users as shown in Listing 5-2."
msgstr "例如,我们可以申报名单5-2中显示的两个特定用户。"

#: src/ch05-01-defining-and-instantiating-structs.md:40
#: src/ch05-01-defining-and-instantiating-structs.md:43
#: src/ch05-01-defining-and-instantiating-structs.md:65
#: src/ch05-01-defining-and-instantiating-structs.md:101
#: src/ch05-01-defining-and-instantiating-structs.md:137
#: src/ch05-01-defining-and-instantiating-structs.md:182
#: src/ch05-01-defining-and-instantiating-structs.md:219
msgid "\"someusername123\""
msgstr "\"某个用户名123\""

#: src/ch05-01-defining-and-instantiating-structs.md:40
#: src/ch05-01-defining-and-instantiating-structs.md:43
#: src/ch05-01-defining-and-instantiating-structs.md:65
#: src/ch05-01-defining-and-instantiating-structs.md:101
#: src/ch05-01-defining-and-instantiating-structs.md:137
#: src/ch05-01-defining-and-instantiating-structs.md:182
#: src/ch05-01-defining-and-instantiating-structs.md:219
msgid "\"someone@example.com\""
msgstr "\"某个@example.com\""

#: src/ch05-01-defining-and-instantiating-structs.md:49
msgid ""
"<span class=\"caption\">Listing 5-2: Creating two instances of the `User` "
"struct</span>"
msgstr "<span类=“caption” > listing 5-2: 创建两个`用户'支架 </span>实例"

#: src/ch05-01-defining-and-instantiating-structs.md:51
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access `user1`'s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email`"
" field of a mutable `User` instance."
msgstr ""
"为了从柱形中获取特定值,我们使用点符号。例如,为了访问“用户1”的电子邮件地址,我们使用“用户1.email ” "
"。如果实例是可变的,我们可以通过使用点符号和指定到特定字段来改变一个值。列出 5-3 显示如何改变可变的“用户”实例“电子邮件”字段中的值。"

#: src/ch05-01-defining-and-instantiating-structs.md:67
#: src/ch05-01-defining-and-instantiating-structs.md:103
#: src/ch05-01-defining-and-instantiating-structs.md:139
msgid "\"anotheremail@example.com\""
msgstr "(注:@example.com)"

#: src/ch05-01-defining-and-instantiating-structs.md:81
msgid ""
"<span class=\"caption\">Listing 5-3: Changing the value in the email field "
"of a `User` instance</span>"
msgstr "<span类=“caption” > listing 5-3: 更改`用户' 例 </span> 在电子邮件字段中的值"

#: src/ch05-01-defining-and-instantiating-structs.md:83
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to "
"mark only certain fields as mutable."
msgstr "开罗不允许我们只将某些领域标为可变领域。"

#: src/ch05-01-defining-and-instantiating-structs.md:85
msgid ""
"As with any expression, we can construct a new instance of the struct as the"
" last expression in the function body to implicitly return that new "
"instance."
msgstr "与任何表达式一样,我们可以构建一个新的构造实例,作为函数体中最后的表达式,以隐含地返回新的实例。"

#: src/ch05-01-defining-and-instantiating-structs.md:87
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""
"列表 5-4 "
"显示一个“建设_用户”功能,该功能以给定的电子邮件和用户名返回“用户”实例。“活动”字段获得“真”的值,“信号_in_count”获得“1”的值。"

#: src/ch05-01-defining-and-instantiating-structs.md:117
msgid ""
"<span class=\"caption\">Listing 5-4: A `build_user` function that takes an "
"email and username and returns a `User` instance.</span>"
msgstr ""
"<span类=“caption” > listing 5-4:`building_user' 函数,需要电子邮件和用户名并返回“用户”实例。 "
"</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:119
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""
"将功能参数命名为与构件字段相同的名称是有道理的,但必须重复“电子邮件”和“用户名”的字段名称和变量有点乏味。 "
"如果构件有更多的字段,重复每个名称会更令人烦恼。幸运的是,有一个方便的速记!"

#: src/ch05-01-defining-and-instantiating-structs.md:121
msgid "Using the Field Init Shorthand"
msgstr "使用 Field Init 速记"

#: src/ch05-01-defining-and-instantiating-structs.md:123
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the field init shorthand syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 5-5."
msgstr ""
"由于在5-4列表中参数名称和支架字段名称完全相同,我们可以使用缩略语法中的字段重写“建设用户”,使其行为完全相同,但不重复“用户名称”和“电子邮件”,如5-5列表所示。"

#: src/ch05-01-defining-and-instantiating-structs.md:153
msgid ""
"<span class=\"caption\">Listing 5-5: A `build_user` function that uses field"
" init shorthand because the `username` and `email` parameters have the same "
"name as struct fields.</span>"
msgstr ""
"<span类=“caption” > listing "
"5-5:一个使用字段的“建设_user”功能,因为“用户名称”和“email”参数的名称与阵列相同。 </span>"

#: src/ch05-01-defining-and-instantiating-structs.md:155
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""
"这里,我们正在创建一个`用户'系统的新实例,其字段名为`电子邮件 "
"',我们要将`电子邮件'字段值设置为`建设`用户'功能的`电子邮件'参数中的数值,因为`电子邮件'字段和`电子邮件'参数具有相同名称,我们只需写“电子邮件”而不是`电子邮件:电子邮件'。"

#: src/ch05-01-defining-and-instantiating-structs.md:157
msgid "Creating Instances from Other Instances with Struct Update Syntax"
msgstr "Struct 更新语法"

#: src/ch05-01-defining-and-instantiating-structs.md:159
msgid ""
"It’s often useful to create a new instance of a struct that includes most of"
" the values from another instance, but changes some. You can do this using "
"_struct update syntax_."
msgstr "创建一个包含来自其他实例的大多数值但会改变部分值的新结构实例通常是有益的。 您可以使用 _ struct 更新语法_ 来做到这一点 。"

#: src/ch05-01-defining-and-instantiating-structs.md:163
msgid ""
"First, in Listing 5-6 we show how to create a new `User` instance in `user2`"
" regularly, without the update syntax. We set a new value for `email` but "
"otherwise use the same values from `user1` that we created in Listing 5-2."
msgstr ""
"首先,在列出5-6时,我们说明如何在不更新语法的情况下,定期在“用户2”中创建一个新的“用户”实例,我们为“电子邮件”设定了一个新的值,但以其他方式使用我们在列出5-2时创建的“用户1”的相同值。"

#: src/ch05-01-defining-and-instantiating-structs.md:179
#: src/ch05-01-defining-and-instantiating-structs.md:216
msgid "// --snip--\n"
msgstr "- - - - - - - - - - - - - - - - -\n"

#: src/ch05-01-defining-and-instantiating-structs.md:188
#: src/ch05-01-defining-and-instantiating-structs.md:222
msgid "\"another@example.com\""
msgstr "\"另一个@ example. com\""

#: src/ch05-01-defining-and-instantiating-structs.md:197
msgid ""
"<span class=\"caption\">Listing 5-6: Creating a new `User` instance using "
"all but one of the values from `user1`</span>"
msgstr ""
"<span class=\"Caption\" > listing 5-6: "
"创建一个新的`用户'例,使用除“user1\\\\\\\\\\\\\\\\/span”所有值以外的一个值"

#: src/ch05-01-defining-and-instantiating-structs.md:199
msgid ""
"Using struct update syntax, we can achieve the same effect with less code, "
"as shown in Listing 5-7. The syntax `..` specifies that the remaining fields"
" not explicitly set should have the same value as the fields in the given "
"instance."
msgstr ""
"使用 Struct 更新语法, 我们可以以更少的代码实现同样的效果, 如列表 5-7 所示。 语法 `.'规定, "
"尚未明确设定的剩余字段应与特定实例中的字段具有相同价值 。"

#: src/ch05-01-defining-and-instantiating-structs.md:229
msgid ""
"<span class=\"caption\">Listing 5-7: Using struct update syntax to set a new"
" `email` value for a `User` instance but to use the rest of the values from "
"`user1`</span>"
msgstr ""
"<span类=“Caption” > Listing 5-7: 使用 strutct 更新语法来设置“ 用户” 实例的新“ 电子邮件” 值, 但要使用“"
" 用户” 的其余值"

#: src/ch05-01-defining-and-instantiating-structs.md:232
msgid ""
"The code in Listing 5-7 also creates an instance of `user2` that has a "
"different value for `email` but has the same values for the `username`, "
"`active`, and `sign_in_count` fields as `user1`. The `..user1` part must "
"come last to specify that any remaining fields should get their values from "
"the corresponding fields in `user1`, but we can choose to specify values for"
" as many fields as we want in any order, regardless of the order of the "
"fields in the struct’s definition."
msgstr ""
"列表 5-7 "
"中的代码还创建了一个“用户2”的例子,该例子对“电子邮件”有不同的价值,但对“用户名称”、“活动”和“签名_in_count”字段的数值与“用户1”相同。"
" "
"`.用户1'部分必须放在最后,以具体说明任何剩余的字段都应从`用户1'中的相应字段中获取其值,但我们可以选择按任何顺序为尽可能多的字段指定值,而不管结构定义中字段的顺序如何。"

#: src/ch05-01-defining-and-instantiating-structs.md:240
msgid ""
"Note that the struct update syntax uses `=` like an assignment; this is "
"because it moves the data, just as we saw in the [\"Moving "
"Values\"](ch04-01-what-is-ownership.md#moving-values)<!-- ignore --> "
"section. In this example, we can no longer use `user1` as a whole after "
"creating `user2` because the `ByteArray` in the `username` field of `user1` "
"was moved into `user2`. If we had given `user2` new `ByteArray` values for "
"both `email` and `username`, and thus only used the `active` and "
"`sign_in_count` values from `user1`, then `user1` would still be valid after"
" creating `user2`. Both `active` and `sign_in_count` are types that "
"implement the `Copy` trait, so the behavior we discussed in the [\"`Copy` "
"Trait\"](ch04-01-what-is-ownership.md#the-copy-trait)<!-- ignore --> section"
" would apply."
msgstr ""
"请注意, 树枝更新语法使用  类似任务 ; 这是因为它移动了数据, 正如我们在 [“ 移动值 ” (ch04-01-what- what- is- "
"own- own- value) <. md# moving- ignion- value) <! - 忽略 - > 一节中看到的那样。 在此示例中, "
"在创建“ 用户2” 之后, 我们不能再使用整个“ 用户1”, 因为“ 用户1 ” 的“ 用户名” 字段中的“ 用户 ” 被移动到“ 用户2 ” 。 "
"如果我们给“ 电子邮件” 和“ 用户名” (ch04-01- what- byarray) 提供了“ ” 新的“ 用户2 新的“ ytearray” "
"值, 并且因此只使用了“ 用户1” 的` 和` 信号_ 计算'值'。 用户1 创建用户2 之后, “ 用户1'用户1'将仍然有效。 “ 。 “ 和` "
"发送_ 计'是实施` 的“ 的“ 类型, 因此我们在“ IP IP IP IP - IP- IP- IP IP 中讨论的“ 中讨论 - IPS- h- "
"h) IPS- h) 节中讨论的行为—— 。"

#: src/ch05-01-defining-and-instantiating-structs.md:249
msgid "{{#quiz ../quizzes/ch05-01-defining-and-instantiating-structs.toml}}"
msgstr "Quiz./quizzes/ch05-01-定义和确认-结构.toml_"

#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr "为了了解我们何时可能想要使用支架,让我们写一个计算矩形区域的程序。 我们从使用单一变量开始,然后重新构思这个程序,直到我们使用支架。"

#: src/ch05-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the "
"width and height of a rectangle specified in pixels and calculate the area "
"of the rectangle. Listing 5-8 shows a short program with one way of doing "
"exactly that in our project’s _src/lib.cairo_."
msgstr ""
"让我们用刀疤来做一个新工程,称为_rectangles_,它将以像素表示矩形的宽度和高度,并计算矩形的面积。列出 5-8 将显示一个短程序, "
"其一种方法就是在项目_src/lib.cairo_中这样做 。"

#: src/ch05-02-an-example-program-using-structs.md:14
#: src/ch05-02-an-example-program-using-structs.md:56
#: src/ch05-02-an-example-program-using-structs.md:86
#: src/ch05-03-method-syntax.md:28 src/ch05-03-method-syntax.md:70
msgid "\"Area is {}\""
msgstr "\"区域是\""

#: src/ch05-02-an-example-program-using-structs.md:22
msgid ""
"<span class=\"caption\">Listing 5-8: Calculating the area of a rectangle "
"specified by separate width and height variables.</span>"
msgstr "<span class=\"Caption\" > listing 5-8: 以不同的宽度和高度变量计算矩形区域。 </span>"

#: src/ch05-02-an-example-program-using-structs.md:24
msgid "Now run the program with `scarb cairo-run`:"
msgstr "现在用“scarb cairo-run”运行程序:"

#: src/ch05-02-an-example-program-using-structs.md:36
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr "该代码成功地找出矩形区域,将每个维度都称为`地区'功能,但我们可以做更多工作,使该代码清晰易读。"

#: src/ch05-02-an-example-program-using-structs.md:38
msgid "The issue with this code is evident in the signature of `area`:"
msgstr "\" 地区 \" 的签字明显表明了这一代码的问题:"

#: src/ch05-02-an-example-program-using-structs.md:44
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our"
" program that the parameters are related. It would be more readable and more"
" manageable to group width and height together. We’ve already discussed one "
"way we might do that in the [Tuple Section of Chapter 2](ch02-02-data-"
"types.html#the-tuple-type)."
msgstr ""
"` 区域' 函数应该计算一个矩形的面积, 但是我们写的函数有两个参数, 而在我们的程式中任何地方都不清楚这些参数是相关的。 "
"将宽度和高度组合在一起比较容易读, 比较容易管理。 我们已经在 [第2章图解部分] (ch02-02- data- types.html#the-"
"tumple- type- type) 中讨论过一种方法可以做到这一点 。"

#: src/ch05-02-an-example-program-using-structs.md:46
msgid "Refactoring with Tuples"
msgstr "与图例重构"

#: src/ch05-02-an-example-program-using-structs.md:48
msgid "Listing 5-9 shows another version of our program that uses tuples."
msgstr "列出5 -9显示另一个使用图普尔的节目版本。"

#: src/ch05-02-an-example-program-using-structs.md:65
msgid ""
"<span class=\"caption\">Listing 5-9: Specifying the width and height of the "
"rectangle with a tuple.</span>"
msgstr "<span class=\"Caption\" > listing 5- 9: 指定矩形的宽度和高度 。 </span>"

#: src/ch05-02-an-example-program-using-structs.md:67
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is"
" less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""
"以某种方式说,这个程序更好。 图例让我们添加一点结构,我们现在只通过一个论点。 "
"但另一种方式是,这个说法不太清楚:图例不列出其元素,所以我们必须在图例中加入索引,使我们的计算变得不那么明显。"

#: src/ch05-02-an-example-program-using-structs.md:69
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but"
" if we want to calculate the difference, it would matter! We would have to "
"keep in mind that `width` is the tuple index `0` and `height` is the tuple "
"index `1`. This would be even harder for someone else to figure out and keep"
" in mind if they were to use our code. Because we haven’t conveyed the "
"meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""
"混合宽度和高度对于计算区域并不重要,但如果我们想计算差异,那将很重要! 我们必须记住,`宽'是图普尔指数`0 ',`高'是图普尔指数`1'。 "
"如果有人使用我们的代码,就更难弄清楚并记住。因为我们没有传达我们数据在代码中的含义,因此现在更容易引入错误。"

#: src/ch05-02-an-example-program-using-structs.md:71
msgid "Refactoring with Structs: Adding More Meaning"
msgstr "使用 Structs 重新描述: 添加更多含义"

#: src/ch05-02-an-example-program-using-structs.md:73
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts."
msgstr "我们用支架来给数据贴上标签来添加含义。 我们可以将我们使用的象牙变成一个支架,上面有整个名称和零件名称。"

#: src/ch05-02-an-example-program-using-structs.md:94
msgid ""
"<span class=\"caption\">Listing 5-10: Defining a `Rectangle` struct.</span>"
msgstr "<span类=“Caption” > listing 5-10: 定义“矩形”结构。 </span>"

#: src/ch05-02-an-example-program-using-structs.md:96
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u64`. Then, in `main`, we created a particular instance of `Rectangle`"
" that has a width of `30` and a height of `10`. Our `area` function is now "
"defined with one parameter, which we’ve named `rectangle` which is of type "
"`Rectangle` struct. We can then access the fields of the instance with dot "
"notation, and it gives descriptive names to the values rather than using the"
" tuple index values of `0` and `1`."
msgstr ""
"在此,我们定义了“矩形”并命名为“矩形”。在卷轴括号内,我们将字段定义为“圆形”和“高”,两者都有`64'类型。然后,在`主要'中,我们创建了一个“矩形”的特例,其宽度为`30',高度为`10'。我们的`区域'功能现在用一个参数来定义,我们称之为`矩形',该参数属于`矩形'类型。然后,我们可以用点记号访问实例的字段,它给数值提供描述性的名称,而不是使用`0'和`1'的图普指数值。"

#: src/ch05-02-an-example-program-using-structs.md:98
msgid "{{#quiz ../quizzes/ch05-02-an-example-program-using-structs.toml}}"
msgstr ""
"Quiz./quizzes/ch05-02 - a-example-programme-useproducts-"
"structs.toml_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________"

#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a name, they can have parameters and a return value, and they contain "
"some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a struct (or an enum "
"which we cover in [Chapter 6](./ch06-01-enums.md)), and their first "
"parameter is always `self`, which represents the instance of the type the "
"method is being called on."
msgstr ""
"_Methods_与函数相似:我们用`fn'关键字和名称宣布它们,它们可以有参数和返回值,它们包含一些代码,当该方法从别处调用时,这些代码会运行。与函数不同,方法是在[第6章](./ch06-01-enums.md)中我们所覆盖的树枝(或树枝)的背景下定义的,而它们的第一个参数总是`self',它代表了所使用方法类型的实例。"

#: src/ch05-03-method-syntax.md:5
msgid "Defining Methods"
msgstr "界定方法"

#: src/ch05-03-method-syntax.md:7
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter and instead make an `area` method defined on the `Rectangle` "
"struct, as shown in Listing 5-11"
msgstr "让我们改变“区域”函数,即将“矩形”实例作为参数,而将“区域”方法定义为“矩形”构造上定义的“区域”方法,如列表 5-11所示。"

#: src/ch05-03-method-syntax.md:32
msgid "Listing 5-11: Defining an `area` method on the `Rectangle` struct."
msgstr "列出5-11:界定`矩形'构造上的`区域'方法。"

#: src/ch05-03-method-syntax.md:34
msgid ""
"To define the function within the context of `Rectangle`, we start an `impl`"
" (implementation) block for a trait `RectangleTrait` that defines the "
"methods that can be called on a `Rectangle` instance. As impl blocks can "
"only be defined for traits and not types, we need to define this trait first"
" - but it's not meant to be used for anything else."
msgstr ""
"为了在`矩形'的背景下界定函数,我们为`矩形Trait'的特性启动一个`impl`(实施)块,用于界定可称为`矩形'实例的方法,因为矩形区块只能根据特性而不是类型来定义,我们需要首先界定这一特性,但并非指用于其他任何东西。"

#: src/ch05-03-method-syntax.md:36
msgid ""
"Everything within this `impl` block will be associated with the `Rectangle` "
"type. Then we move the `area` function within the `impl` curly brackets and "
"change the first (and in this case, only) parameter to be `self` in the "
"signature and everywhere within the body. In `main`, where we called the "
"`area` function and passed `rect1` as an argument, we can instead use "
"_method syntax_ to call the `area` method on our `Rectangle` instance. The "
"method syntax goes after an instance: we add a dot followed by the method "
"name, parentheses, and any arguments."
msgstr ""
"在`主要'中,我们称`区域'函数为`区域'函数,并将`区域'函数称为`区域'方法。在`区域'函数中,我们可以用`区域'语法作为参数。在`主要'中,我们把`区域'函数称为`区域'函数,并传过`区域'函数,作为论证。在`区域'实例中,我们可以将`区域'函数称为`区域'方法。方法语法以实例为例:我们增加一个点,然后是方法名称、括号和任何参数。"

#: src/ch05-03-method-syntax.md:38
msgid ""
"In the signature for `area`, we use `self: @Rectangle` instead of "
"`rectangle: @Rectangle`. Methods must have a parameter named `self`, for "
"their first parameter, and the type of `self` indicates the type that method"
" can be called on. Methods can take ownership of `self`, but `self` can also"
" be passed by snapshot or by reference, just like any other parameter."
msgstr ""
"在“区域”的签名中,我们使用`区域'的“自己:@Rectangle”而不是`rectangle:@Rectangle'。方法必须有一个第一个参数的`自我'参数,而`自我'类型表示该方法可以使用的类型。方法可以拥有`自己'的所有权,但`自我'也可以像任何其他参数一样,通过快照或参考传递。"

#: src/ch05-03-method-syntax.md:41
msgid ""
"There is no direct link between a type and a trait. Only the type of the "
"`self` parameter of a method defines the type from which this method can be "
"called. That means, it is technically possible to define methods on multiple"
" types in a same trait (mixing `Rectangle` and `Circle` methods, for "
"example). But **this is not a recommended practice** as it can lead to "
"confusion."
msgstr ""
"类型和特性之间没有直接联系,只有方法的`自我'参数类型才能界定该方法的称呼类型,也就是说,在技术上可以确定同一特性(例如混合`链形'和`环形'方法)的多种类型方法。"

#: src/ch05-03-method-syntax.md:43
msgid ""
"The main reason for using methods instead of functions, in addition to "
"providing method syntax, is for organization. We’ve put all the things we "
"can do with an instance of a type in one `impl` block rather than making "
"future users of our code search for capabilities of `Rectangle` in various "
"places in the library we provide."
msgstr ""
"除了提供方法语法外,使用方法代替功能的主要原因是组织,我们已经将我们所能做的所有事情都放在一个`隐性'区块中,而不是让未来的用户使用我们的代码搜索,以寻找我们提供的图书馆中各个地方的`连接'能力。"

#: src/ch05-03-method-syntax.md:45
msgid "The `generate_trait` Attribute"
msgstr "`generate_trait' 属性"

#: src/ch05-03-method-syntax.md:47
msgid ""
"If you are familiar with Rust, you may find Cairo's approach confusing "
"because methods cannot be defined directly on types. Instead, you must "
"define a [trait](./ch08-02-traits-in-cairo.md) and an implementation of this"
" trait associated with the type for which the method is intended. However, "
"defining a trait and then implementing it to define methods on a specific "
"type is verbose, and unnecessary: the trait itself will not be reused."
msgstr ""
"如果您熟悉Rust, 您可能会发现开罗的做法令人困惑, 因为方法无法直接根据类型来定义。 相反, 您必须定义一个[ trit] (./ ch08-02-"
" tratits- in- cairo. md), 以及该特性的实施与该方法所针对的类型相关联。 但是, "
"定义一个特性然后实施该特性来定义特定类型的方法是verbose, 并且没有必要: 特性本身不会被重新使用 。"

#: src/ch05-03-method-syntax.md:50
msgid ""
"So, to avoid defining useless traits, Cairo provides the `#[generate_trait]`"
" attribute to add above a trait implementation, which tells to the compiler "
"to generate the corresponding trait definition for you, and let's you focus "
"on the implementation only. Both approaches are equivalent, but it's "
"considered a best practice to not explicitly define traits in this case."
msgstr ""
"因此,为了避免定义无用特性,开罗提供了“[遗传_trait]”属性,在特性执行之上添加一个特性执行,该属性要求汇编者为您生成相应的特性定义,而让我们只关注执行。这两种方法都是等效的,但认为最佳做法是在此情况下没有明确界定特性。"

#: src/ch05-03-method-syntax.md:52
msgid "The previous example can also be written as follows:"
msgstr "前一个例子也可以写如下:"

#: src/ch05-03-method-syntax.md:75
msgid ""
"Let's use this `#[generate_trait]` in the following chapters to make our "
"code cleaner."
msgstr "让我们在以下各章中用这个“[遗传_trait]”来清理我们的代码。"

#: src/ch05-03-method-syntax.md:77
msgid "Snapshots and References"
msgstr "抓图和参考资料"

#: src/ch05-03-method-syntax.md:79
msgid ""
"As the `area` method does not modify the calling instance, `self` is "
"declared as a snapshot of a `Rectangle` instance with the `@` snapshot "
"operator. But, of course, we can also define some methods receiving a "
"mutable reference of this instance, to be able to modify it."
msgstr ""
"由于`地区'方法并不改变呼叫实例,因此`自我'被宣布为与`区域'快速操作员的`链形'实例的快照,但是,当然,我们也可以确定一些方法,从中可变换引用,以便能够修改它。"

#: src/ch05-03-method-syntax.md:81
msgid ""
"Let's write a new method `scale` which resizes a rectangle of a `factor` "
"given as parameter:"
msgstr "让我们写出一种“比例”的新方法,以调整给定参数的“要素”矩形的大小:"

#: src/ch05-03-method-syntax.md:98
msgid "\"The new size is (width: {}, height: {})\""
msgstr "\"新的尺寸是(宽度:, 高度: )\""

#: src/ch05-03-method-syntax.md:102
msgid ""
"It is also possible to define a method which takes ownership of the instance"
" by using just `self` as the first parameter but it is rare. This technique "
"is usually used when the method transforms `self` into something else and "
"you want to prevent the caller from using the original instance after the "
"transformation."
msgstr ""
"也可以确定一种方法,即仅将`自我'作为第一个参数,从而获得实例的所有权,但这是罕见的。当该方法将`自己'转化为其他东西时,通常使用这种技术,而你却想阻止呼叫者在变换后使用原始实例。"

#: src/ch05-03-method-syntax.md:104
msgid ""
"Look at the [Understanding Ownership](ch04-00-understanding-ownership.md) "
"chapter for more details about these important notions."
msgstr "关于这些重要概念的更多细节,请看[了解所有权](ch04-00-了解所有权.md)一章。"

#: src/ch05-03-method-syntax.md:106
msgid "Methods with Several Parameters"
msgstr "若干参数方法"

#: src/ch05-03-method-syntax.md:108
msgid ""
"Let’s practice using methods by implementing another method on the "
"`Rectangle` struct. This time we want to write the method `can_hold` which "
"accepts another instance of `Rectangle` and returns `true` if this rectangle"
" can fit completely within self; otherwise, it should return false."
msgstr ""
"让我们通过在`矩形'构造上采用另一种方法来实践方法。 这次我们要写出“ 能够'hold'” 的方法,该方法接受另一例`矩形'并返回`真实 "
"',如果这个矩形可以完全适合自己; 否则,它应该返回假的。"

#: src/ch05-03-method-syntax.md:132
msgid "\"Can rect1 hold rect2? {}\""
msgstr "直肠1可以保持直肠2吗?"

#: src/ch05-03-method-syntax.md:133
msgid "\"Can rect1 hold rect3? {}\""
msgstr "直肠1可以保持直肠3吗?"

#: src/ch05-03-method-syntax.md:137
msgid "Here, we expect that `rect1` can hold `rect2` but not `rect3`."
msgstr "在这里,我们期望`rect1'能够保持`rect2',但不能维持`rect3'。"

#: src/ch05-03-method-syntax.md:139
msgid "Associated functions"
msgstr "相关职能"

#: src/ch05-03-method-syntax.md:141
msgid ""
"We call _associated functions_ all functions that are defined inside an "
"`impl` block that are associated to a specific type. While this is not "
"enforced by the compiler, it is a good practice to keep associated functions"
" related to the same type in the same `impl` block - for example, all "
"functions related to `Rectangle` will be grouped in the same `impl` block "
"for `RectangleTrait`."
msgstr ""
"我们称“关联函数”为“与特定类型相关的“内嵌块”内定义的所有函数。虽然汇编者没有强制实施,但将同一类型的相关函数保留在同一“内嵌块”中是一种良好做法,例如,与“红心”有关的所有功能将分组在同一“内嵌块”中,用于“红心trait”的“内嵌块”。"

#: src/ch05-03-method-syntax.md:143
msgid ""
"Methods are a special kind of associated function, but we can also define "
"associated functions that don’t have `self` as their first parameter (and "
"thus are not methods) because they don’t need an instance of the type to "
"work with, but are still associated with that type."
msgstr ""
"方法是一种特殊的关联功能,但我们也可以将没有`自我'作为第一个参数(因此不是方法)的相关功能界定为它们的第一个参数(因此不是方法),因为它们不需要某种类型的工作实例,但仍然与该类型相关联。"

#: src/ch05-03-method-syntax.md:145
msgid ""
"Associated functions that aren’t methods are often used for constructors "
"that will return a new instance of the type. These are often called `new`, "
"but `new` isn’t a special name and isn’t built into the language. For "
"example, we could choose to provide an associated function named `square` "
"that would have one dimension parameter and use that as both width and "
"height, thus making it easier to create a square `Rectangle` rather than "
"having to specify the same value twice:"
msgstr ""
"没有方法的相关函数通常用于返回同类新实例的构造者。这些函数通常被称为“新”,但“新”不是特殊名称,没有包含在语言中。例如,我们可以选择提供名为“方形”的关联函数,该函数具有一个维度参数,同时使用宽度和高度,从而更容易创建正方形的“矩形”,而不是两次指定相同的值:"

#: src/ch05-03-method-syntax.md:153
msgid ""
"Let's create the function `new` which creates a `Rectangle` from a `width` "
"and a `height`, `square` which creates a square `Rectangle` from a `size` "
"and `avg` which computes the average of two `Rectangle` instances:"
msgstr ""
"让我们创建函数`新',从`圆'和`高'、`方形'产生`连 ',从`大小'和`avg'产生`连'方形,从`连'和`线'产生`连'方形`连 "
"',计算两个`连'实例的平均数:"

#: src/ch05-03-method-syntax.md:182
msgid "\"The average Rectangle of {:?} and {:?} is {:?}\""
msgstr "\"平均矩形 {{:?}和{{{}是{}}}。\""

#: src/ch05-03-method-syntax.md:190
msgid ""
"To call the `square` associated function, we use the `::` syntax with the "
"struct name; `let sq = Rectangle::square(3);` is an example. This function "
"is namespaced by the struct: the `::` syntax is used for both associated "
"functions and namespaces created by modules. We’ll discuss modules in "
"[Chapter 7](./ch07-02-defining-modules-to-control-scope.md)."
msgstr ""
"要调用`quare' 相关函数,我们使用`:`带有结构名称的语法;`let sq "
"=矩形::sqare(3);`就是一个例子。此函数由结构间隔:`:`语法用于相关函数和模块创建的命名空间。我们将在[第7章](./ch07-02-defining-"
"modules-to- control-scope.md)中讨论模块。"

#: src/ch05-03-method-syntax.md:196
msgid ""
"Note that the `avg` function could also be written as a method with `self` "
"as the first rectangle. In this case, instead of using the method with "
"`RectangleTrait::avg(@rect1, @rect2)`, it would be called with "
"`rect1.avg(rect2)`."
msgstr ""
"请注意, `avg' 函数也可以用`self'作为第一个矩形的一种方法写成。 在这种情况下, 与其使用`RectangleTrait:::avg "
"(@rect1,@rect2)'的方法, 不如用`rect1.avg(rect2)'来称呼它。"

#: src/ch05-03-method-syntax.md:198
msgid "Multiple Traits and `impl` Blocks"
msgstr "多重轨迹和“impl”块"

#: src/ch05-03-method-syntax.md:200
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For "
"example, the following code is equivalent to the code shown in the _Methods "
"with several parameters_ section, which has each method in its own `trait` "
"and `impl` blocks."
msgstr ""
"允许每个支架有多个`trait'和`impl'区块,例如,以下代码相当于在`Methods'中显示的具有若干参数的`Methods'区块的代码,该区块在自己的`trait'和`impl'区块中有每种方法。"

#: src/ch05-03-method-syntax.md:219
msgid ""
"There’s no strong reason to separate these methods into multiple `trait` and"
" `impl` blocks here, but this is valid syntax."
msgstr "没有理由将这些方法分为多个`trait'和`impl'区块,但这是有效的语法。"

#: src/ch05-03-method-syntax.md:222
msgid "{{#quiz ../quizzes/ch05-03-method-syntax.toml}}"
msgstr "QQZ./Qzzes/ch05-03-方法-语法.toml"

#: src/ch06-00-enums-and-pattern-matching.md
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. "
"Enums allow you to define a type by enumerating its possible _variants_. "
"First, we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called "
"`Option`, which expresses that a value can be either something or nothing. "
"Finally, we’ll look at how pattern matching in the `match` expression makes "
"it easy to run different code for different values of an enum."
msgstr ""
"在此章中, 我们将查看_ 数字_, 也称为_ enums_ 。 英文允许您通过列举其可能的 _ variants_ 来定义某类型。 首先, "
"我们将定义并使用 enum 来显示一个 enum 如何将含义与数据一起编码。 接下来, 我们将探索一个特别有用的符号, 叫做 “ option ”, "
"表示一个值可以是某物, 也可以是某物。 最后, 我们将查看“ match ” 表达式的匹配模式如何使得对一个 enum 的不同值使用不同的代码变得容易 "
"。"

#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type "
"that consists of a fixed set of named values, called _variants_. Enums are "
"useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""
"Enums, 简称为“ 数字 ”, 是定义自定义数据类型的一种方法, 该自定义数据类型由固定的一组命名值组成, 称为 _ variants_ 。 "
"Enums 可用于代表每个值不同且具有特定含义的相关值的集合。"

#: src/ch06-01-enums.md:5
msgid "Enum Variants and Values"
msgstr "Enum 变式和价值"

#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr "以下是一个简单的例子:"

#: src/ch06-01-enums.md:19
msgid ""
"In this example, we've defined an enum called `Direction` with four "
"variants: `North`, `East`, `South`, and `West`. The naming convention is to "
"use PascalCase for enum variants. Each variant represents a distinct value "
"of the `Direction` type. In this particular example, variants don't have any"
" associated value. One variant can be instantiated using this syntax:"
msgstr ""
"在这个例子中,我们用四个变式界定了称为`方向'的昆虫:`北'、`东'、`南方'和`西'。命名公约是使用帕斯卡尔-"
"卡西格来表示昆虫变异。每种变式代表`方向'类型的独特价值。在这一具体例子中,变式没有任何相关价值。一个变式可以使用这一语法即时转换:"

#: src/ch06-01-enums.md:36
msgid ""
"Now let's imagine that our variants have associated values, that store the "
"exact degree of the direction. We can define a new `Direction` enum:"
msgstr "现在让我们想象一下,我们的变体有相关的值, 储存方向的确切程度。 我们可以定义一个新的“ 方向” 指针 :"

#: src/ch06-01-enums.md:52
msgid "and instantiate it as follows:"
msgstr "并按下列方式进行即时处理:"

#: src/ch06-01-enums.md:68
msgid ""
"In this code, each variant is associated with a `u128` value, representing "
"the direction in degrees. In the next example, we will see that it is also "
"possible to associate different data types with each variant."
msgstr "在本代码中,每个变量都与`u128'值相关联,代表了度的方向,在下一个实例中,我们将看到也可以将不同数据类型与每个变量联系起来。"

#: src/ch06-01-enums.md:70
msgid ""
"It's easy to write code that acts differently depending on the variant of an"
" enum instance, in this example to run specific code according to a "
"direction. You can learn more about it in the [Match Control Flow "
"Construct](./ch06-02-the-match-control-flow-construct.md) section."
msgstr ""
"很容易根据昆虫实例的变体, 写出不同动作的代码。 在这个示例中, 您可以按照一个方向运行特定的代码。 您可以在 [ Match Control "
"Struit] (./ ch06-02- the- match- control- flow- construct. md) 部分了解更多关于它的信息 "
"。"

#: src/ch06-01-enums.md:74
msgid "Enums Combined with Custom Types"
msgstr "与自定义类型合并"

#: src/ch06-01-enums.md:76
msgid ""
"Enums can also be used to store more interesting custom data associated with"
" each variant. For example:"
msgstr "Enums也可以用来储存与每种变式相关的更有趣的自定义数据。"

#: src/ch06-01-enums.md:87
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo`, and "
"`Move`, all with different types:"
msgstr "在这个例子中,`Message'enum有三种变式:`iit'、`Echo'和`move ',所有这些变式都具有不同类型:"

#: src/ch06-01-enums.md:89
msgid "`Quit` doesn't have any associated value."
msgstr "`不'没有任何相关价值。"

#: src/ch06-01-enums.md:90
msgid "`Echo` is a single `felt252`."
msgstr "`Echo'是一个单一的`felt252'。"

#: src/ch06-01-enums.md:91
msgid "`Move` is a tuple of two `u128` values."
msgstr "\" 移动 \" 是两个`u128'价值的图例。"

#: src/ch06-01-enums.md:93
msgid ""
"You could even use a Struct or another enum you defined inside one of your "
"enum variants."
msgstr "您甚至可以使用您在其中一种昆虫变体中定义的 struct 或其它昆虫 。"

#: src/ch06-01-enums.md:95
msgid "Trait Implementations for Enums"
msgstr "Enums 轨迹实施"

#: src/ch06-01-enums.md:97
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. "
"This allows you to define methods and behaviors associated with the enum. "
"Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""
"在开罗, 您可以定义特性, 并用于您的自定义 。 这样您就可以定义 与 enum 相关的方法和行为 。 下面是用来定义特性, 并将其用于 以前的 “ "
"Message ’ enum ” 的示例 :"

#: src/ch06-01-enums.md:107 src/ch06-01-enums.md:133
msgid "\"quitting\""
msgstr "\"告别\""

#: src/ch06-01-enums.md:108 src/ch06-01-enums.md:134
msgid "\"echoing {}\""
msgstr "\"选择\" \"选择\""

#: src/ch06-01-enums.md:109 src/ch06-01-enums.md:135
msgid "\"moving from {} to {}\""
msgstr "\"从到\""

#: src/ch06-01-enums.md:115
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here "
"is how it could be used to process a Quit message:"
msgstr "在这个例子中,我们实施了`信件'的`处理'特性。"

#: src/ch06-01-enums.md:147
msgid "Running this code would print `quitting`."
msgstr "运行此代码将打印“ 降级 ” 。"

#: src/ch06-01-enums.md:149
msgid "The `Option` Enum and Its Advantages"
msgstr "`可选'环境及其优势"

#: src/ch06-01-enums.md:151
msgid ""
"The `Option` enum is a standard Cairo enum that represents the concept of an"
" optional value. It has two variants: `Some: T` and `None`. `Some: T` "
"indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr "“可选”是代表可选价值概念的一个标准开罗会议,有两个变式:`某些:T'和`无'。 “有些:T'表示`T'类有价值,而`无'则表示没有价值。"

#: src/ch06-01-enums.md:160
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent "
"the possibility of a value being absent, making your code more expressive "
"and easier to reason about. Using `Option` can also help prevent bugs caused"
" by using uninitialized or unexpected `null` values."
msgstr ""
"“Option' "
"enum”很有帮助,因为它使您能够明确表达缺少值的可能性,从而使您的代码更能表达,更便于解释。使用“Option”也可以帮助防止由于使用未初始化或意外的“null”值而导致的错误。"

#: src/ch06-01-enums.md:162
msgid ""
"To give you an example, here is a function which returns the index of the "
"first element of an array with a given value, or `None` if the element is "
"not present."
msgstr "要给您举一个例子, 这里是一个函数, 它返回一个数组的第一个元素的索引, 并带有给定值, 如果元素不存在, 则返回“ 无 ” 。"

#: src/ch06-01-enums.md:164
msgid "We are demonstrating two approaches for the above function:"
msgstr "为履行上述职能,我们正在展示两种办法:"

#: src/ch06-01-enums.md:166
msgid "Recursive approach with `find_value_recursive`."
msgstr "使用“find_value_recursive”的递归方法。"

#: src/ch06-01-enums.md:167
msgid "Iterative approach with `find_value_iterative`."
msgstr "\" 确定价值 \" 的迭代方法。"

#: src/ch06-01-enums.md:199
msgid ""
"Enums can be useful in many situations, especially when using the `match` "
"flow construct that we just used. We will describe it in the next section."
msgstr "在许多情况下,特别是当使用我们刚刚使用的“匹配”流量结构时,Enums可能是有用的,我们将在下一节加以描述。"

#: src/ch06-01-enums.md:201
msgid ""
"Other enums are used very often, such as the `Result` enum, allowing to "
"handle errors gracefully. We will explain the `Result` enum in detail in the"
" [\"Error Handling\"](./ch09-02-recoverable-errors.md#the-result-enum) "
"chapter."
msgstr ""
"其他昆虫经常使用,例如`Result' enum, 允许优雅地处理错误。我们将在[“错误处理”]章(./ch09-02-可恢复-errors. "
"md#the- 结果-enum)中详细解释`Result' enum。"

#: src/ch06-01-enums.md:203
msgid "{{#quiz ../quizzes/ch06-01-enums.toml}}"
msgstr ""
"Quiz./quizzes/ch06-01-enums.toml_________________________________________________________________________________________________________________________________________________________________________________________________________________________"

#: src/ch06-02-the-match-control-flow-construct.md:3
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of "
"`match` comes from the expressiveness of the patterns and the fact that the "
"compiler confirms that all possible cases are handled."
msgstr ""
"开罗有一个叫“匹配”的极强控制流程结构,使您能够将一个数值与一系列模式进行比较,然后执行基于模式匹配的代码。模式可以由字面价值、变量名称、通配符和许多其他事物组成。“匹配”的力量来自模式的清晰度以及编译者确认所有可能的案件都得到处理的事实。"

#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Think of a `match` expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the "
"value “fits”, the value falls into the associated code block to be used "
"during execution."
msgstr ""
"将“ 匹配” 的表达方式想象成像一枚硬币分拣机:硬币滑下一条轨道,上面有各种大小的洞,每一枚硬币都会从它所碰到的第一个洞中掉下来。 "
"同样,数值以匹配的方式穿透每个图案,在第一个图案中,值为“适值 ”, 值则从执行时使用的相关代码块中掉下来。"

#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Speaking of coins, let’s use them as an example using `match`! We can write "
"a function that takes an unknown US coin and, in a similar way as the "
"counting machine, determines which coin it is and returns its value in "
"cents, as shown in Listing 6-1."
msgstr ""
"说到硬币,让我们用`匹配'来作为例子!我们可以写一个函数,用一个未知的美国硬币,并以与计数机器类似的方式,决定哪个硬币,并如《名单》6-1所示,以美分返回其价值。"

#: src/ch06-02-the-match-control-flow-construct.md:27
msgid ""
"<span class=\"caption\">Listing 6-1: An enum and a `match` expression that "
"has the variants of the enum as its patterns</span>"
msgstr ""
"<span类=“caption” > listing 6-1: 以 enum 变量为模式 </span> 的“ match” 表达式和“ match” "
"表达式"

#: src/ch06-02-the-match-control-flow-construct.md:29
msgid ""
"Let’s break down the `match` expression in the `value_in_cents` function. "
"First, we list the `match` keyword followed by an expression, which in this "
"case is the value `coin`. This seems very similar to a conditional "
"expression used with the `if` statement, but there’s a big difference: with "
"`if`, the condition needs to evaluate to a boolean value, but here it can be"
" any type. The type of `coin` in this example is the `Coin` enum that we "
"defined on the first line."
msgstr ""
"让我们拆分`value_in_cents' 函数中的`match'表达式。 "
"首先,我们列出`match'关键字,然后列出一个表达式,在此为`coin'值。这似乎与`if'语句中使用的有条件表达式非常相似,但有一个很大的区别:与`if'相比,条件需要评估到布尔值,但这里它可以是任何类型。例子中的`coin'类型是我们在第一行定义的`coin'enum。"

#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with"
" a comma."
msgstr ""
"下一个是“匹配”的手臂,一个手臂有两个部分:一个图案和一些代码。第一个手臂的图案是“coin:Penny”和“%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"

#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in the order they are given. If a pattern "
"matches the value, the code associated with that pattern is executed. If "
"that pattern doesn’t match the value, execution continues to the next arm, "
"much as in a coin-sorting machine. We can have as many arms as we need: in "
"the above example, our `match` has four arms."
msgstr ""
"当“匹配”表达式执行时,它将结果值与每个手臂的图案进行比较,按给定顺序排列。如果一个图案与值相符,则执行与该图案相关的代码。如果该图案与值不匹配,处决将持续到下一个手臂,就像硬币分拣机一样。我们可以拥有我们所需要的武器数量:在以上例子中,我们的“匹配”有四只手臂。"

#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire match expression."
msgstr "与每个臂相关的代码是一个表达式, 匹配臂中表达式的后值是整个匹配表达式返回的值 。"

#: src/ch06-02-the-match-control-flow-construct.md:37
msgid ""
"We don’t typically use curly brackets if the `match` arm code is short, as "
"it is in our example where each arm just returns a value. If you want to run"
" multiple lines of code in a `match` arm, you must use curly brackets, with "
"a comma following the arm. For example, the following code prints “Lucky "
"penny!” every time the method is called with a `Coin::Penny`, but still "
"returns the last value of the block, `1`:"
msgstr ""
"如果`匹配'武器代码很短,我们通常不使用卷括号,就像我们的例子那样,每个手臂都返回一个值。如果你想在`匹配'武器中运行多行代码,则必须使用卷括号,在手臂后面有一个逗号。例如,每次使用“Coin:Penny',但仍然返回区块的最后值,`1':"

#: src/ch06-02-the-match-control-flow-construct.md:43
msgid "\"Lucky penny!\""
msgstr "\"幸运便士!\""

#: src/ch06-02-the-match-control-flow-construct.md:53
msgid "Patterns That Bind to Values"
msgstr "绑绑在价值上的模式"

#: src/ch06-02-the-match-control-flow-construct.md:55
msgid ""
"Another useful feature of `match` arms is that they can bind to the parts of"
" the values that match the pattern. This is how we can extract values out of"
" enum variants."
msgstr "`匹配'武器的另一个有用的特征是,它们能够与符合模式的值部分捆绑在一起,这就是我们如何从昆虫变异体中提取值。"

#: src/ch06-02-the-match-control-flow-construct.md:57
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it."
" From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information"
" to our `enum` by changing the `Quarter` variant to include a `UsState` "
"value stored inside it, which we’ve done in Listing 6-2."
msgstr ""
"举例来说,让我们改变我们的一个昆虫变种,以在其中保留数据。从1999年到2008年,美国将50个州中的每一个州的设计都不同。其他硬币都没有国家设计,因此只有四分之一国家有这种额外价值。我们可以将“四角”变种中包括一个储存在其中的“Us"
" State”值,我们已在6-2清单中这样做,以此将这一信息添加到我们的`enum'变种中。"

#: src/ch06-02-the-match-control-flow-construct.md:61
msgid "// Debug so we can inspect the state in a minute\n"
msgstr "调试 所以我们可以检查 州在一分钟内\n"

#: src/ch06-02-the-match-control-flow-construct.md:76
msgid ""
"<span class=\"caption\">Listing 6-2: A `Coin` enum in which the `Quarter` "
"variant also holds a `UsState` value</span>"
msgstr ""
"<span类=`Caption' > listing 6-2:`Coin' enum, 其中`Fround'变式也持有`Usstate' 值 "
"</span>"

#: src/ch06-02-the-match-control-flow-construct.md:78
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of"
" the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""
"让我们想象一下,一个朋友试图收集所有50个州的季度。 "
"当我们用硬币类型来排序我们松散的零钱时,我们也会点出每个季度的关联国名称,这样,如果我们的朋友没有,他们就可以把它添加到他们的收藏中。"

#: src/ch06-02-the-match-control-flow-construct.md:80
msgid ""
"In the `match` expression for this code, we add a variable called `state` to"
" the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that"
" quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""
"在本代码的`匹配'表达式中,我们添加一个变量,称为`状态 ',该变量与变量` "
"Coin:Quarter'的值相符。当一个`coin:Quarter'匹配时,`state'变量将与该季度的值挂钩。然后,我们可以在该手臂的代码中使用`状态"
" ',例如:"

#: src/ch06-02-the-match-control-flow-construct.md:89
msgid "\"State quarter from {:?}!\""
msgstr "\"国家季度 {{{}}? }!\""

#: src/ch06-02-the-match-control-flow-construct.md:96
msgid ""
"Because `state` is an `UsState` enum which implements the `Debug` trait, we "
"can print `state` value with `println!` macro."
msgstr "因为`国家'是执行`调试'特性的`国家 ',所以我们可以用`println!'宏来印刷`国家'价值。"

#: src/ch06-02-the-match-control-flow-construct.md:98
msgid ""
"Note: `{:?}` is a special formatting syntax that allows to print a debug "
"form of the parameter passed to the `println!` macro. You can find more "
"information about it in [Appendix C](./appendix-03-derivable-"
"traits.html#debug-for-printing-and-debugging)."
msgstr ""
"注:{{{{{{}}}}{}}}{}}}是特殊格式的语法,可以打印通过“println!' 宏” 的参数的调试形式。您可以在[附录C] "
"(./ppendix-03-diivable-traits.html#debug- for-printing-and-"
"debuging)中找到更多关于它的信息。"

#: src/ch06-02-the-match-control-flow-construct.md:100
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` "
"would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with "
"each of the match arms, none of them match until we reach "
"`Coin::Quarter(state)`. At that point, the binding for `state` will be the "
"value `UsState::Alaska`. We can then use that binding in `println!` macro, "
"thus getting the inner state value out of the `Coin` enum variant for "
"`Quarter`."
msgstr ""
"如果我们将`价值'(Coin::Queen(Us State:Alaska))称为`价值 ',`coin'将是`coin:Queen(Us "
"State:Alaska) "
"',当我们将该数值与每件匹配的军火进行比较时,在达到`coin:Quel(state)'之前,没有任何一个匹配。此时,`国家'的约束力将是`Us "
"State:Alaska'的数值。然后,我们可以在`println!'宏观中使用该约束力,从而将`Coin' enum变体的内值从`comin' "
"变体中获取出来。"

#: src/ch06-02-the-match-control-flow-construct.md:104
msgid "Matching with `Option<T>`"
msgstr "与“可选<T}”匹配"

#: src/ch06-02-the-match-control-flow-construct.md:106
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same."
msgstr ""
"在上一节中,我们希望在使用`可选'时,从`某些`案例'中取出`内值';我们也可以像我们在`可选'中所做的那样,用`匹配'处理`可选'T';我们不用比较硬币,而是比较`可选'T'的变体,但`可选'表达方式仍然一样。"

#: src/ch06-02-the-match-control-flow-construct.md:108
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if "
"there’s a value inside, adds `1` to that value. If there is no value inside,"
" the function should return the `None` value and not attempt to perform any "
"operations."
msgstr ""
"让我们假设我们想要写入一个函数, 该函数需要` 选项< u8 ', 如果内部有值, 则该值增加` 1'。 如果内部没有值, 该函数应该返回“ 无” 值,"
" 而不是试图执行任何操作 。"

#: src/ch06-02-the-match-control-flow-construct.md:110
msgid ""
"This function is very easy to write, thanks to `match`, and will look like "
"Listing 6-3."
msgstr "3⁄4 ̄ ̧漯B"

#: src/ch06-02-the-match-control-flow-construct.md:127
msgid ""
"<span class=\"caption\">Listing 6-3: A function that uses a `match` "
"expression on an `Option<u8>`</span>"
msgstr "<span类=“caption” >Listing 6-3:在“option<u8>_/span>上使用“match”表达式的函数"

#: src/ch06-02-the-match-control-flow-construct.md:129
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call"
" `plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each `match` arm:"
msgstr ""
"让我们更详细地检查`plus_one'的第一次执行。当我们称之为`plus_1(5)'时,`plus_1'体中的变量`x'将具有`some(5)'的值。然后,我们将该值与每个`match'臂作比较:"

#: src/ch06-02-the-match-control-flow-construct.md:135
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does!"
" We have the same variant. The `val` binds to the value contained in "
"`Option::Some`, so `val` takes the value `5`. The code in the `match` arm is"
" then executed, so we add `1` to the value of `val` and create a new "
"`Option::Some` value with our total `6` inside. Because the first arm "
"matched, no other arms are compared."
msgstr ""
"`可选:某些(5)`值是否与`可选:某些(val)` "
"值匹配?它确实如此?我们有相同的变式。`val'与`可选:某些`,因此`val'值与`可选:某些`5'值挂钩。然后执行`相匹配'臂中的代码,因此我们在`val'值中添加`1'值,并创建一个新的`可选:某些`值与我们的`6'内总值相匹配。因为第一个手臂匹配,没有其他手臂被比较。"

#: src/ch06-02-the-match-control-flow-construct.md:137
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where"
" `x` is `Option::None`. We enter the `match` and compare to the first arm:"
msgstr "现在让我们来考虑一下我们主要功能中的第二通`加一 ',其中`x'是`可选:无'。"

#: src/ch06-02-the-match-control-flow-construct.md:143
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so "
"we continue to the next arm:"
msgstr "`可选:某种(val)`价值与`可选:无'模式不符,因此我们继续下一臂:"

#: src/ch06-02-the-match-control-flow-construct.md:149
msgid ""
"It matches! There’s no value to add to, so the matching construct ends and "
"returns the `Option::None` value on the right side of `=>`."
msgstr "匹配! 没有附加值, 因此匹配的构造结尾和返回“ 选项: 没有” 的值, 在 {} 的右侧 。"

#: src/ch06-02-the-match-control-flow-construct.md:151
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Cairo code: `match` against an enum, bind a variable to the"
" data inside, and then execute code based on it. It’s a bit tricky at first,"
" but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""
"将“ 匹配” 和 “ enum ” 组合在一起在许多情况下是有用的。 您将在开罗代码中看到很多这样的模式 : “ 匹配” 与 enum 匹配, "
"将变量绑在内部数据中, 然后根据它执行代码。 一开始有点棘手, 但是一旦习惯了, 你就会希望你拥有所有语言的这种模式。 它始终是用户最喜爱的 。"

#: src/ch06-02-the-match-control-flow-construct.md:153
msgid "Matches Are Exhaustive"
msgstr "火柴已耗尽"

#: src/ch06-02-the-match-control-flow-construct.md:155
msgid ""
"There’s one other aspect of `match` we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr "我们需要讨论“匹配”的另一个方面:武器模式必须涵盖所有可能性。 想想我们的“ 附加一” 功能的这一版本,它有一个错误,不会编译:"

#: src/ch06-02-the-match-control-flow-construct.md:165
msgid ""
"We didn’t handle the `None` case, so this code will cause a bug. Luckily, "
"it’s a bug Cairo knows how to catch. If we try to compile this code, we’ll "
"get this error:"
msgstr "我们没有处理`无'案,所以这个代码会造成错误。 幸运的是,它是一个虫子开罗知道如何捕捉。 如果我们试图编集这个代码,我们会得到这个错误:"

#: src/ch06-02-the-match-control-flow-construct.md:181
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the [billion-dollar "
"mistake](https://en.wikipedia.org/wiki/Null_pointer#History) discussed "
"earlier impossible."
msgstr ""
"开罗知道我们没有覆盖所有可能的案例, 甚至知道我们忘记了哪些模式! 开罗的火柴是详尽无遗的: 我们必须用尽所有最后的可能性才能使代码有效。 特别是“ "
"Option<T ” 的情况, "
"开罗阻止我们忘记明确处理`无'案件,它保护我们不认为我们有价值当我们可能无效时,从而使得先前讨论的[十亿美元错误](https://en.wikipedia.org/wiki/Null_pointer#History)变得不可能。"

#: src/ch06-02-the-match-control-flow-construct.md:185
msgid "Catch-all with the `_` Placeholder"
msgstr "与占居者"

#: src/ch06-02-the-match-control-flow-construct.md:187
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. `_` is a special pattern "
"that matches any value and does not bind to that value. You can use it by "
"simply adding a new arm with `_` as the pattern for the last arm of the "
"`match` expression."
msgstr "使用 enums, 我们也可以对几个特定值采取特殊行动, 但对于所有其他值则采取一个默认动作 。\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch06-02-the-match-control-flow-construct.md:191
msgid ""
"Imagine we have a vending machine that only accepts Dime coins. We want to "
"have a function that processes inserted coins and returns `true` only if the"
" coin is accepted."
msgstr "想象一下我们有一个只接受 Dime 硬币的自动售货机。 我们希望有一个功能, 只有当硬币被接受时, 才能处理插入硬币和返回“ 真实” 。"

#: src/ch06-02-the-match-control-flow-construct.md:194
msgid "Here's a `vending_machine_accept` function that implements this logic:"
msgstr "以下是一个执行这一逻辑的`前置_机器_接受'功能:"

#: src/ch06-02-the-match-control-flow-construct.md:205
msgid ""
"This example also meets the exhaustiveness requirement because we’re "
"explicitly ignoring all other values in the last arm; we haven’t forgotten "
"anything."
msgstr "这个例子也符合详尽无遗的要求, 因为我们显然忽略了最后一只手臂的所有其他价值;"

#: src/ch06-02-the-match-control-flow-construct.md:207
msgid ""
"There's no catch-all pattern in Cairo that allows you to use the value of "
"the pattern."
msgstr "开罗没有一刀切的模式 让你可以使用这个模式的价值"

#: src/ch06-02-the-match-control-flow-construct.md:213
msgid "Multiple Patterns with the `|` Operator"
msgstr "使用 {} 运算符的多重模式"

#: src/ch06-02-the-match-control-flow-construct.md:215
msgid ""
"In `match` expressions, you can match multiple patterns using the `|` "
"syntax, which is the pattern _or_ operator."
msgstr "在“匹配”表达式中,您可以使用 \\\\ 语法来匹配多个模式,即模式 _ or_ 运算符。"

#: src/ch06-02-the-match-control-flow-construct.md:217
msgid ""
"For example, in the following code we modified the `vending_machine_accept` "
"function to accept both `Dime` and `Quarter` coins in a single arm:"
msgstr "例如,在以下代码中,我们修改了`自动机能'功能,以接受单臂中的`硬币'和`硬币':"

#: src/ch06-02-the-match-control-flow-construct.md:228
msgid "Matching Tuples"
msgstr "匹配图例"

#: src/ch06-02-the-match-control-flow-construct.md:230
msgid "It is possible to match tuples. Let's introduce a new `DayType` enum:"
msgstr "我们来介绍一个新的“DayType' enum:"

#: src/ch06-02-the-match-control-flow-construct.md:242
msgid ""
"Now, let's suppose that our vending machine accepts any coin on weekdays, "
"but only accepts quarters and dimes on weekends and holidays. We can modify "
"the `vending_machine_accept` function to accept a tuple of a `Coin` and a "
"`Weekday` and return `true` only if the given coin is accepted on the "
"specified day:"
msgstr ""
"现在,让我们假设我们的自动售货机在工作日接受任何硬币,但在周末和节假日只接受硬币和硬币。我们可以修改`自动机 "
"接受'功能,以接受`coin'和`weekday'的金币,只有特定硬币在规定日期被接受时才能返回`正':"

#: src/ch06-02-the-match-control-flow-construct.md:255
msgid ""
"Writing `(_, _)` for the last arm of a tuple matching pattern might feel "
"superfluous. Hence, we can use the `_ =>` syntax if we want, for example, "
"that our vending machine only accepts quarters on weekdays:"
msgstr ""
"写'(_,_)'表示图普匹配模式最后一臂可能感到多余。 因此,如果我们想要,比如说,我们的自动售货机在工作日只接受季度, 我们可以使用    语法 :"

#: src/ch06-02-the-match-control-flow-construct.md:266
msgid "Matching `felt252` and Integer Variables"
msgstr "匹配“felt252”和整数变量"

#: src/ch06-02-the-match-control-flow-construct.md:268
msgid ""
"You can also match `felt252` and integer variables. This is useful when you "
"want to match against a range of values. However, there are some "
"restrictions:"
msgstr "您也可以匹配“felt252” 和整数变量。当您想要匹配一系列数值时,这有用。但是,有些限制是:"

#: src/ch06-02-the-match-control-flow-construct.md:271
msgid ""
"Only integers that fit into a single `felt252` are supported (i.e. `u256` is"
" not supported)."
msgstr "只支持适合单一`felt252'的整数(即`u256'不支持)。"

#: src/ch06-02-the-match-control-flow-construct.md:272
msgid "The first arm must be 0."
msgstr "第一个手臂必须是0。"

#: src/ch06-02-the-match-control-flow-construct.md:273
msgid ""
"Each arm must cover a sequential segment, contiguously with other arms."
msgstr "每个手臂必须覆盖相继部分,与其他手臂相连。"

#: src/ch06-02-the-match-control-flow-construct.md:275
msgid ""
"Imagine we’re implementing a game where you roll a six-sided die to get a "
"number between 0 and 5. If you have 0, 1 or 2 you win. If you have 3, you "
"can roll again. For all other values you lose."
msgstr ""
"想象一下,我们正在玩一个游戏,在游戏中,你滚动一个六面式的死,以获得一个0到5之间的数字。如果你赢了 0, 1 或 2。如果你有 3, 你可以再次滚动。"
" 对于所有其他失去的数值,你都会输掉。"

#: src/ch06-02-the-match-control-flow-construct.md:278
msgid "Here's a match that implements that logic:"
msgstr "这是符合逻辑的一对:"

#: src/ch06-02-the-match-control-flow-construct.md:283
msgid "\"you won!\""
msgstr "\"你赢了!\""

#: src/ch06-02-the-match-control-flow-construct.md:284
msgid "\"you can roll again!\""
msgstr "\"你可以再次滚动!\""

#: src/ch06-02-the-match-control-flow-construct.md:285
msgid "\"you lost...\""
msgstr "\"你迷路了...\" \"你迷路了...\""

#: src/ch06-02-the-match-control-flow-construct.md:290
msgid "{{#quiz ../quizzes/ch06-02-match.toml}}"
msgstr "Quiz./quizzes/ch06-02-match.toml"

#: src/ch06-02-the-match-control-flow-construct.md:292
msgid ""
"These restrictions are planned to be relaxed in future versions of Cairo."
msgstr "计划在今后版本的开罗会议上放宽这些限制。"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:3
msgid "`if let`"
msgstr "`如果`"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:5
msgid ""
"The `if let` syntax lets you combine `if` and `let` into a less verbose way "
"to handle values that match one pattern while ignoring the rest. Consider "
"the program in Listing 6-4 that matches on an `Option::Some<u8>` value in "
"the `config_max` variable but only wants to execute code if the value is "
"`Option::Some` variant."
msgstr ""
"`如果'语法允许您将`if'和`let'合并为一种较不含糊的方式来处理匹配一个模式而忽略其他模式的值。在“选项:`配置'变量中的某些<u8'值”中,在列出"
" 6-4 中考虑匹配该选项的程序,但只有在值为`选项:某些`变量:某些`变量”时,才想要执行代码。"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:11
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:33
msgid "\"The maximum is configured to be {}\""
msgstr "\"最大值被配置为\""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:17
msgid ""
"<span class=\"caption\">Listing 6-4: A `match` that only cares about "
"executing code when the value is `Option::Some`</span>"
msgstr "<span类=“caption” > listing 6-4: 只在值为`可选值: Some/span> 时才关注执行代码的“匹配”"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:20
msgid ""
"If the value is `Option::Some`, we print out the value in the `Option::Some`"
" variant by binding the value to the variable `max` in the pattern. We don’t"
" want to do anything with the `None` value. To satisfy the `match` "
"expression, we have to add `_ => ()` after processing just one variant, "
"which is annoying boilerplate code to add."
msgstr ""
"如果值是`可选的:某些人',我们打印出`可选的:某些人'中的值,将该值与该图案中的`最大'变量捆绑在一起。我们不想用`无'值做任何事情。为了满足`匹配'表达式,我们必须在只处理一个变方后添加"
"    () `,这是一个令人烦恼的锅炉代码。"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:26
msgid ""
"Instead, we could write this in a shorter way using `if let`. The following "
"code behaves the same as the `match` in Listing 6-4:"
msgstr "相反,我们可以用`如果允许'用更短的写法。以下代码的行为与6-4清单中的`匹配'相同:"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:39
msgid ""
"The syntax `if let` takes a pattern and an expression separated by an equal "
"sign. It works the same way as a `match`, where the expression is given to "
"the `match` and the pattern is its first arm. In this case, the pattern is "
"`Option::Some(max)`, and `max` binds to the value inside `Option::Some`. We "
"can then use `max` in the body of the `if let` block in the same way we used"
" `max` in the corresponding `match` arm. The code in the `if let` block "
"isn’t run if the value doesn’t match the pattern."
msgstr ""
"语法 `如果让我们' 采用一个模式和一个以等号分隔的表达式,它与`匹配'相同,“匹配'的表达式为`匹配 "
"',而该模式是其第一个臂,在此情况下,该模式是`可选的:某些(最大) ',“最大”与`可选的:某些'内值相关。然后,我们可以在`如果'的体中使用`最大 "
"',与我们在相应的`匹配'臂中使用的`最大'相同。如果`允许'区号的代码不运行,如果值与该模式不匹配,则该`允许'区内的代码不运行。"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:47
msgid ""
"Using `if let` means less typing, less indentation, and less boilerplate "
"code. However, you lose the exhaustive checking that `match` enforces. "
"Choosing between `match` and `if let` depends on what you’re doing in your "
"particular situation and whether gaining conciseness is an appropriate "
"trade-off for losing exhaustive checking."
msgstr ""
"使用`如果'的意思是减少打字、减少缩进和减少锅炉牌码,但是,你失去了`匹配'强制执行的详尽检查,在`匹配'和`如果'之间作出选择取决于你在特定情况下正在做些什么,以及取得简洁是否是对失去彻底检查的适当权衡。"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:53
msgid ""
"In other words, you can think of `if let` as syntactic sugar for a `match` "
"that runs code when the value matches one pattern and then ignores all other"
" values."
msgstr "换句话说,你可以将“如果”视为“配对”的同义糖,当值符合一种模式,然后忽略所有其他的值时,该配对会运行代码。"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:56
msgid ""
"We can include an `else` with an `if let`. The block of code that goes with "
"`else` is the same as the block of code that would go with the `_` case in "
"the `match` expression. Recall the `Coin` enum definition in Listing 6-2, "
"where the `Quarter` variant also held a `UsState` value. If we wanted to "
"count all non-quarter coins we see while also announcing the state of the "
"quarters, we could do that with a `match` expression, like this:"
msgstr ""
"我们可以包括`如果`的话'`else'的`else'。配有`else'的编码块与`match'表达式中与`catch'表达式中的`couin'enum "
"定义的编码块相同。回顾第6-2号列表中的`coin'enum定义,其中`sstate'变体也持有`Us "
"State'价值。如果我们想计算我们所看到的所有非季度硬币,同时宣布季度状态,我们可以使用“match'表达式,例如:"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:76
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:97
msgid "\"You got a quarter!\""
msgstr "\"你得到了一个25美分!\""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:82
msgid "Or we could use an `if let` and `else` expression, like this:"
msgstr "或者我们可以使用`如果'和`else'的表达方式,像这样:"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:101
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:120
#: src/ch11-08-printing.md:59 src/ch11-08-printing.md:112
#: src/ch11-08-printing.md:130 src/ch11-08-printing.md:156
msgid "\"{}\""
msgstr "\"\" \"\" \"\" \"\""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:106
msgid ""
"If you have a situation in which your program has logic that is too verbose "
"to express using `match`, remember that `if let` is in your Cairo toolbox as"
" well."
msgstr "如果您的方案有逻辑性, 无法用“ 匹配” 表达, 请记住, “ 如果让” 也存在于您的开罗工具箱中 。"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:109
msgid "`while let`"
msgstr "`同时让我们 '"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:111
msgid ""
"The `while let` syntax is similar to the `if let` syntax, but it allows you "
"to loop over a collection of values and execute a block of code for each "
"value that matches a specified pattern. In the case below, the pattern is "
"`Option::Some(x)`, which matches any `Some` variant of the `Option` enum."
msgstr ""
"`让我们'语法与`如果`语法相似,但允许您绕过一个数值集,对每个与特定模式相符的值执行一组代码,在下文中,该模式为`备选:some(x)',与`可选'范围的任何`某些`变量'相匹配。"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:124
msgid ""
"Using `while let` provides a more concise and idiomatic way of writing this "
"loop compared to a traditional `while` loop with explicit pattern matching "
"or handling of the `Option` type. However, as with `if let`, you lose the "
"exhaustive checking that a `match` expression provides, so you need to be "
"careful to handle any remaining cases outside the `while let` loop if "
"necessary."
msgstr ""
"与传统的`循环'相比,使用`让我们'提供更简洁、更专门的方式来撰写这一循环,而传统的`循环'则对`可选'类型有明确的匹配或处理方式,然而,与`如果'一样,如果`如果"
" ',你就会失去`相匹配'表达方式所提供的详尽检查,所以你需要小心处理`不参与'的剩余案件,如有必要,则不参与 \" 循环 \" 。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"As you write large programs, organizing your code will become increasingly "
"important. By grouping related functionality and separating code with "
"distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""
"当您写入大型程序时, 组织您的代码将变得日益重要。 通过组合相关功能和区分具有不同特性的代码, 您将澄清在哪里找到执行特定特性的代码, "
"以及到哪里去改变功能是如何运作的。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"The programs we’ve written so far have been in one module in one file. As a "
"project grows, you should organize code by splitting it into multiple "
"modules and then multiple files. As a package grows, you can extract parts "
"into separate crates that become external dependencies. This chapter covers "
"all these techniques."
msgstr ""
"到目前为止,我们所写的程序一直以一个模块在一个文件中存在。随着工程的成长,你应该组织代码,将其分为多个模块,然后是多个文件。随着软件包的成长,你可以将部件分离成成为外部依赖的单箱。本章涵盖了所有这些技术。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse code at a higher level: once you’ve implemented an operation, other "
"code can call your code without having to know how the implementation works."
msgstr "我们亦会讨论封装执行细节, 让您重新使用更高层次的代码: 一旦您实施了操作, 其他代码可以连用您的代码, 而不必知道执行方式如何运作 。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a set of names that are defined as “in scope”. When reading, writing, and "
"compiling code, programmers and compilers need to know whether a particular "
"name at a particular spot refers to a variable, function, struct, enum, "
"module, constant, or other item and what that item means. You can create "
"scopes and change which names are in or out of scope. You can’t have two "
"items with the same name in the same scope."
msgstr ""
"一个相关的概念是范围:代码书写时的嵌套环境有一套名称,被定义为“范围” "
"。读、写和编译代码时,程序员和编译员需要知道特定地点的特定名称是否指变量、函数、构造、内容、模块、常数或其他项,以及该项的含义。您可以创建范围,改变哪些名称在范围之内或之外。在同一范围内,您不能有两个名称相同的项目。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"Cairo has a number of features that allow you to manage your code’s "
"organization. These features, sometimes collectively referred to as the "
"_module system_, include:"
msgstr "开罗有许多特点,使您能够管理您的代码组织。这些特点有时统称为_模块系统,包括:"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Packages:** A Scarb feature that lets you build, test, and share crates."
msgstr "** 包件:** 使你能够制造、测试和分享箱箱的刀疤特征。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Crates:** A tree of modules that corresponds to a single compilation unit."
" It has a root directory, and a root module defined at the _lib.cairo_ file "
"under this directory."
msgstr ""
"** Crates:** 一棵模块树, 与一个单一的汇编单位相对应。 它有一个根目录, 以及在本目录下 _lib.cairo_ 文件定义的根模块 。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Modules** and **use:** Let you control the organization and scope of "
"items."
msgstr "** 模块** 和** use:** 请控制项目的组织和范围。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Paths:** A way of naming an item, such as a struct, function, or module."
msgstr "** 命名项目的方式,如支架、函数或模块。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and explain how to use them to manage scope. By the end, you should have a "
"solid understanding of the module system and be able to work with scopes "
"like a pro!"
msgstr ""
"在本章中,我们将涵盖所有这些特征,讨论它们互动的方式,并解释如何使用它们来管理范围。 "
"最后,你应该对模块系统有扎实的了解,并且能够用像专业一样的范围工作!"

#: src/ch07-01-packages-and-crates.md:3
msgid "What is a Crate?"
msgstr "克洛特是什么? 克洛特是什么? What is a Crate?"

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is a subset of a package that is used in the actual Cairo "
"compilation. This includes:"
msgstr "板条箱是实际开罗汇编中使用的包件的子集。 这包括:"

#: src/ch07-01-packages-and-crates.md:7
msgid ""
"The package source code, identified by the package name and the crate root, "
"which is the main entry point of the package."
msgstr "软件包源代码, 由软件包名称和箱根识别, 这是软件包的主要切入点 。"

#: src/ch07-01-packages-and-crates.md:8
msgid ""
"A subset of the package metadata that identifies crate-level settings of the"
" Cairo compiler, for example, the `edition` field in the _Scarb.toml_ file."
msgstr "用于确定开罗汇编者箱级设置的包件元数据的一个子集,例如,_Scarb.toml_文件中的`dition'字段。"

#: src/ch07-01-packages-and-crates.md:10
msgid ""
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as will be discussed in the subsequent "
"sections."
msgstr "Crates可以包含模块,模块可以在与箱一起汇编的其他文件中定义,将在随后各节中讨论。"

#: src/ch07-01-packages-and-crates.md:12
msgid "What is the Crate Root?"
msgstr "克洛特根是什么? 克洛特根吗?"

#: src/ch07-01-packages-and-crates.md:14
msgid ""
"The crate root is the _lib.cairo_ source file that the Cairo compiler starts"
" from and makes up the root module of your crate. We’ll explain modules in "
"depth in the [\"Defining Modules to Control Scope\"](./ch07-02-defining-"
"modules-to-control-scope.md) chapter."
msgstr ""
"箱根是开罗编译器从_lib.cairo_源文件开始并组成您的箱根模块。我们将在[“控制范围定义模块”](./ch07-02-定义模块到控制范围.md)章中深入解释模块。"

#: src/ch07-01-packages-and-crates.md:18
msgid "What is a Package?"
msgstr "什么是包?"

#: src/ch07-01-packages-and-crates.md:20
msgid "A Cairo package is a directory (or equivalent) containing:"
msgstr "开罗软件包是一个目录(或相当的),载有:"

#: src/ch07-01-packages-and-crates.md:22
msgid "A _Scarb.toml_ manifest file with a `[package]` section."
msgstr "A_Scarb.toml_带有`[包装]'部分的清单文件。"

#: src/ch07-01-packages-and-crates.md:23
msgid "Associated source code."
msgstr "相关源代码。"

#: src/ch07-01-packages-and-crates.md:25
msgid ""
"This definition implies that a package might contain other packages, with a "
"corresponding _Scarb.toml_ file for each package."
msgstr "这一定义意味着包件可能包含其他包件,每个包件都有相应的_Scarb.toml_文件。"

#: src/ch07-01-packages-and-crates.md:27
msgid "Creating a Package with Scarb"
msgstr "创建带有疤疤的软件包"

#: src/ch07-01-packages-and-crates.md:29
msgid ""
"You can create a new Cairo package using the Scarb command-line tool. To "
"create a new package, run the following command:"
msgstr "您可以使用 Scarb 命令行工具创建一个新的开罗软件包。要创建新软件包,请运行以下命令:"

#: src/ch07-01-packages-and-crates.md:35
msgid ""
"This command will generate a new package directory named _my_package_ with "
"the following structure:"
msgstr "此命令将产生名为_my_ package_的新软件包目录, 其结构如下:"

#: src/ch07-01-packages-and-crates.md:44
msgid ""
"_src/_ is the main directory where all the Cairo source files for the "
"package will be stored."
msgstr "_src/_是存储软件包所有开罗源文件的主目录。"

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"_lib.cairo_ is the default root module of the crate, which is also the main "
"entry point of the package."
msgstr "_lib.cairo_是箱子的默认根模块,也是软件包的主要切入点。"

#: src/ch07-01-packages-and-crates.md:46
msgid ""
"_Scarb.toml_ is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, "
"version, and authors. You can find documentation about it on the [Scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""
"_Scarb.toml_是包件清单文件,其中载有包件的元数据和配置选项,例如依赖关系、包件名称、版本和作者。 您可以在[Scarb "
"参考文献(https://docs.swmansion.com/scarb/docs/ "
"reference/manifest.html)上找到关于它的文件。"

#: src/ch07-01-packages-and-crates.md:48
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"edition = \"2023_11\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"@toml [包] 名称 = \" my_package\" 版本 = \"0.1.0\" 版本 = \"2023_11\" [依赖性] #foo = "
"{路径 = \"供应商/foo\" } * * * = \"2023_11\" 版本 = \"2023_11\" [依赖性] # foo = { 路径 "
"= \"供应商/foo\" = * * *"

#: src/ch07-01-packages-and-crates.md:58
msgid ""
"As you develop your package, you may want to organize your code into "
"multiple Cairo source files. You can do this by creating additional _.cairo_"
" files within the _src_ directory or its subdirectories."
msgstr ""
"开发您的软件包时, 您可能想要将您的代码组织成多个开罗源文件。 您可以在 _ src_ 目录或其子目录中创建额外的 _. cairo_ 文件, "
"从而做到这一点 。"

#: src/ch07-01-packages-and-crates.md:60
msgid "{{#quiz ../quizzes/ch07-01-packages-crates.toml}}"
msgstr "/ quizzes/ch07-01-packages-crates.toml"

#: src/ch07-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system, namely _paths_ that allow you to name items and the `use` keyword "
"that brings a path into scope."
msgstr "在本节中,我们将讨论模块和模块系统的其他部分,即_paths_,使您能够命名项目和“使用”关键字,从而将路径带入范围。"

#: src/ch07-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when "
"you’re organizing your code in the future. Then we’ll explain each of the "
"rules in detail."
msgstr "首先,我们将从一个规则清单开始,以方便参考。 当你组织未来的代码时。 然后我们将详细解释其中的每一项规则。"

#: src/ch07-02-defining-modules-to-control-scope.md:11
msgid "Modules Cheat Sheet"
msgstr "模块热制表"

#: src/ch07-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` "
"keyword work in the compiler, and how most developers organize their code. "
"We’ll be going through examples of each of these rules throughout this "
"chapter, but this is a great place to refer to as a reminder of how modules "
"work. You can create a new Scarb project with `scarb new backyard` to follow"
" along."
msgstr ""
"在此, 我们快速引用模块、 路径和“ 使用” 关键字在汇编器中是如何工作的, 以及大多数开发者是如何组织代码的。 "
"我们将在本章整个章节中尝试其中每一条规则的例子, 但这是一个很好的地方, 可以用来提醒模块是如何运作的。 您可以创建一个新的“ 剪切新后院” 的疤痕项目"
" 。"

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first "
"looks in the crate root file (_src/lib.cairo_) for code to compile."
msgstr "** 从箱根开始**:在编集箱时,编译者首先查看箱根文件(_src/lib.cairo_),以编译代码。"

#: src/ch07-02-defining-modules-to-control-scope.md:21
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; "
"say, you declare a “garden” module with `mod garden;`. The compiler will "
"look for the module’s code in these places:"
msgstr ""
"** 宣告模块**:在箱根文件中,您可以宣布新的模块;比如,您可以宣布一个“花园”模块,配有“花园模式”;`。汇编者将在这些地方查找模块代码:"

#: src/ch07-02-defining-modules-to-control-scope.md:25
msgid ""
"Inline, within curly brackets that replace the semicolon following `mod "
"garden`."
msgstr "内括号内,以 \" 模式花园 \" 之后的分号取代分号。"

#: src/ch07-02-defining-modules-to-control-scope.md:28
msgid "// crate root file (src/lib.cairo)\n"
msgstr "/ 箱根文件 (src/lib.cairo)\n"

#: src/ch07-02-defining-modules-to-control-scope.md:30
msgid "// code defining the garden module goes here\n"
msgstr "定义花园模块的代码在这里\n"

#: src/ch07-02-defining-modules-to-control-scope.md:34
msgid "In the file _src/garden.cairo_."
msgstr "在文件_src/garden.cairo_中。"

#: src/ch07-02-defining-modules-to-control-scope.md:36
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can "
"declare submodules. For example, you might declare `mod vegetables;` in "
"_src/garden.cairo_. The compiler will look for the submodule’s code within "
"the directory named for the parent module in these places:"
msgstr ""
"** 定义子模块**:在除箱根以外的任何文件中,您都可以申报子模块。例如,您可以在 _src/garden.cairo_中声明“现代蔬菜 ” "
"。汇编器将在这些地方指定父模块的目录中查找子模块的代码 :"

#: src/ch07-02-defining-modules-to-control-scope.md:41
msgid ""
"Inline, directly following `mod vegetables`, within curly brackets instead "
"of the semicolon."
msgstr "内括号内,直接附在`现代蔬菜'之后,放在卷括号内,而不是分号内。"

#: src/ch07-02-defining-modules-to-control-scope.md:45
msgid "// src/garden.cairo file\n"
msgstr "/ scrc/garden.cairo文件\n"

#: src/ch07-02-defining-modules-to-control-scope.md:47
msgid "// code defining the vegetables submodule goes here\n"
msgstr "给蔬菜子模块下定义的代码就在这里\n"

#: src/ch07-02-defining-modules-to-control-scope.md:51
msgid "In the file _src/garden/vegetables.cairo_."
msgstr "文件_src/garden/vegetables.cairo_。"

#: src/ch07-02-defining-modules-to-control-scope.md:53
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can "
"refer to code in that module from anywhere else in that same crate, using "
"the path to the code. For example, an `Asparagus` type in the `vegetables` "
"submodule would be found at `backyard::garden::vegetables::Asparagus`."
msgstr ""
"** "
"模块中的代码**:一旦模块是您箱中的一部分,您可以使用代码路径从同一箱中其他任何地方引用该模块中的代码。例如,在“蔬菜”子模块中的“Asparagus”类型将在“后院:园艺:蔬菜:Asparagus”中找到。"

#: src/ch07-02-defining-modules-to-control-scope.md:57
msgid ""
"**Private vs public**: Code within a module is private from its parent "
"modules by default. This means that it may only be accessed by the current "
"module and its descendants. To make a module public, declare it with `pub "
"mod` instead of `mod`. To make items within a public module public as well, "
"use `pub` before their declarations. Cairo also provides the `pub(crate)` "
"keyword, allowing an item or module to be only visible within the crate in "
"which the definition is included."
msgstr ""
"** 私人对公共**:一个模块内的代码默认是其母模块的私有代码,这意味着只有当前模块及其后代才能访问该模块。要公开模块,以`pub "
"mod'而不是`mod'宣布该模块。要公开公共模块内的项目,在发布之前也使用`pub'。开罗还提供了“pub(crate)”关键词,允许某个项目或模块仅在包含定义的箱子内可见。"

#: src/ch07-02-defining-modules-to-control-scope.md:59
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to items to reduce repetition of long paths. In any scope that can refer to "
"`backyard::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use backyard::garden::vegetables::Asparagus;` and from then on you only "
"need to write `Asparagus` to make use of that type in the scope."
msgstr ""
"** "
"`使用'关键词**:在范围范围内,`使用'关键词为减少长路重复的项目创造捷径。在任何可提及`后院:园林::蔬菜::Asparagus'的任何范围内,你可以用`后院:园林:蔬菜:Asparagus;'创建一个捷径,从此以后,您只需在范围内使用“Asparagus”。"

#: src/ch07-02-defining-modules-to-control-scope.md:65
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The "
"crate’s directory, also named `backyard`, contains these files and "
"directories:"
msgstr "在这里,我们创建了一个名为`后院'的箱子,用以说明这些规则。"

#: src/ch07-02-defining-modules-to-control-scope.md:78
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr "本案中的箱根文件是_src/lib.cairo_,包含:"

#: src/ch07-02-defining-modules-to-control-scope.md:88
msgid "\"I'm growing {:?}!\""
msgstr ""
"\"我正在成长♪♪♪♪♪♪♪♪♪♪我正在成长♪♪♪♪♪♪我正在成长♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪我正在成长♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪"

#: src/ch07-02-defining-modules-to-control-scope.md:92
msgid ""
"The `pub mod garden;` line imports the `garden` module. Using `pub` to make "
"`garden` publicly accessible, or `pub(crate)` if you really want to make "
"`garden` only available for your crate, is optional to run our program here,"
" as the `main` function resides in the same module as `pub mod garden;` "
"declaration. Nevertheless, not declaring `garden` as `pub` will make it not "
"accessible from any other package. This line tells the compiler to include "
"the code it finds in _src/garden.cairo_, which is:"
msgstr ""
"`pub mod花园;`线条进口`garden' 模块;使用`pub'使`garden'向公众开放,或`pub(crate) "
"',如果你真想将`garden'只供你的箱子使用,就可选择在这里运行我们的程序,因为`主要'功能与`pub "
"mod花园;`声明'一样,存在于同一个模块中。然而,不宣布`garden'为`pub'将使它无法从任何其他软件包中检索。"

#: src/ch07-02-defining-modules-to-control-scope.md:95
msgid "<span class=\"filename\">Filename: src/garden.cairo</span>"
msgstr "<span类=\"filename\" >Filename: src/garden.cairo </span>"

#: src/ch07-02-defining-modules-to-control-scope.md:101
msgid ""
"Here, `pub mod vegetables;` means the code "
"in _src/garden/vegetables.cairo_ is included too. That code is:"
msgstr "这里,`pub mod 蔬菜;'是指_src/garden/vegetables.cairo_中的代码也包括在内。"

#: src/ch07-02-defining-modules-to-control-scope.md:108
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us bring the `Asparagus` "
"type into scope, so we can use it in the `main` function."
msgstr "`使用花园::蔬菜::Asparagus;`让我们将`Asparagus'类型纳入范围,这样我们就可以在`主要'功能中使用。"

#: src/ch07-02-defining-modules-to-control-scope.md:111
msgid ""
"Now let’s get into the details of these rules and demonstrate them in "
"action!"
msgstr "现在让我们讨论这些规则的细节,"

#: src/ch07-02-defining-modules-to-control-scope.md:113
msgid "Grouping Related Code in Modules"
msgstr "模块中分组相关代码"

#: src/ch07-02-defining-modules-to-control-scope.md:115
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse. Modules also allow us to control the privacy of items, because code "
"within a module is private by default. Private items are internal "
"implementation details not available for outside use. We can choose to make "
"modules and the items within them public, which exposes them to allow "
"external code to use and depend on them."
msgstr ""
"_Modules_让我们在箱内组织可读性和易于再利用的代码。模块还允许我们控制项目的隐私,因为模块中的代码默认是私有的。私有项目是内部执行细节,外部无法使用。我们可以选择将模块和其中的项目公开,让它们使用外部代码并依赖它们。"

#: src/ch07-02-defining-modules-to-control-scope.md:121
msgid ""
"As an example, let’s write a library crate that provides the functionality "
"of a restaurant. We’ll define the signatures of functions but leave their "
"bodies empty to concentrate on the organization of the code, rather than the"
" implementation of a restaurant."
msgstr "举例来说,让我们写一个提供餐厅功能的图书馆箱。 我们将定义功能的签名,但让身体空空无一人,专心于代码的组织,而不是餐厅的实施。"

#: src/ch07-02-defining-modules-to-control-scope.md:126
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as "
"_front of house_ and others as _back of house_. Front of house is where "
"customers are; this encompasses where the hosts seat customers, servers take"
" orders and payment, and bartenders make drinks. Back of house is where the "
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do "
"administrative work."
msgstr ""
"在餐饮业中,餐馆的某些部分被称为“前门”,其他部分称为“后门”,而其他部分则称为“后门”。 "
"住前门是顾客所在的地方;这包括接待座位顾客、服务员接受订单和付款以及酒保饮酒的地方。 后门是厨师和厨师在厨房工作的地方,洗碗者清洁,管理人员做行政工作。"

#: src/ch07-02-defining-modules-to-control-scope.md:133
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested modules. Create a new package named _restaurant_ by running `scarb "
"new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to "
"define some modules and function signatures. Here’s the front of house "
"section:"
msgstr ""
"要以这种方式构建我们的箱子, 我们可以将其功能组织成嵌入的模块。 通过运行“ 碎纸新餐厅” 创建一个名为 restaurant 的新软件包; 然后将列表"
" 7-1 中的代码输入 _src/lib.cairo_ 以定义某些模块和功能签名。 下面是房子区域前面的部分 :"

#: src/ch07-02-defining-modules-to-control-scope.md:157
msgid ""
"<span class=\"caption\">Listing 7-1: A `front_of_house` module containing "
"other modules that then contain functions</span>"
msgstr ""
"<span类=“Caption” > listing 7-1: “front_of_house” 模块,包含其他模块,然后包含函数 </span>"

#: src/ch07-02-defining-modules-to-control-scope.md:159
msgid ""
"We define a module with the `mod` keyword followed by the name of the module"
" (in this case, `front_of_house`). The body of the module then goes inside "
"curly brackets. Inside modules, we can place other modules, as in this case "
"with the modules `hosting` and `serving`. Modules can also hold definitions "
"for other items, such as structs, enums, constants, traits, and functions."
msgstr ""
"我们定义模块时使用“模式”关键字,然后是模块的名称(此处指的是`front_of_house')。模块的正文放在卷轴内。在模块内,我们可以放置其他模块,如模块“托管”和`serve'。模块还可以保留其他项目的定义,如结构、圆柱、常数、特性和函数。"

#: src/ch07-02-defining-modules-to-control-scope.md:165
msgid ""
"By using modules, we can group related definitions together and name why "
"they’re related. Programmers using this code can navigate the code based on "
"the groups rather than having to read through all the definitions, making it"
" easier to find the definitions relevant to them. Programmers adding new "
"functionality to this code would know where to place the code to keep the "
"program organized."
msgstr ""
"通过使用模块,我们可以将相关定义组合在一起,并命名它们为何相关。 "
"使用此代码的程序员可以浏览基于组的代码,而不必阅读所有定义,这样更容易找到与其相关的定义。 "
"在代码中添加新功能的程序员将知道如何设置代码以保持程序的组织。"

#: src/ch07-02-defining-modules-to-control-scope.md:171
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The "
"reason for this name is that the content of this file forms a module named "
"after the crate name at the root of the crate’s module structure, known as "
"the _module tree_."
msgstr ""
"早些时候,我们曾提到,_src/lib.cairo_被称为箱根。之所以使用这个名称,是因为这个文件的内容组成了一个模块,以箱模块结构根部的箱名命名,称为_module"
" tree_。"

#: src/ch07-02-defining-modules-to-control-scope.md:174
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr "列表 7-2 显示列表 7-1 结构的模块树 。"

#: src/ch07-02-defining-modules-to-control-scope.md:188
msgid ""
"<span class=\"caption\">Listing 7-2: The module tree for the code in Listing"
" 7-1</span>"
msgstr "<span类=\"Caption\" > listing 7-2: 7-1 </span> 列表中的代码模块树"

#: src/ch07-02-defining-modules-to-control-scope.md:190
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example, `hosting` nests inside `front_of_house`. The tree also shows that "
"some modules are _siblings_ to each other, meaning they’re defined in the "
"same module; `hosting` and `serving` are siblings defined within "
"`front_of_house`. If module A is contained inside module B, we say that "
"module A is the _child_ of module B and that module B is the _parent_ of "
"module A. Notice that the entire module tree is rooted under the explicit "
"name of the crate _restaurant_."
msgstr ""
"这棵树展示了模块内部的一些巢穴;例如,“主巢”位于`前屋'内。这棵树还显示,一些模块彼此为_siblings_siblings_,意思是它们在同一模块中的定义;`主巢'和`服务'是在`前屋'内定义的兄弟姐妹。如果模块B中包含模块A,我们说模块A是模块B的_child_,模块B是模块A的_own_own_。请注意,整个模块树植根于_restaurant_的明显名称。"

#: src/ch07-02-defining-modules-to-control-scope.md:198
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your "
"computer; this is a very apt comparison! Just like directories in a "
"filesystem, you use modules to organize your code. And just like files in a "
"directory, we need a way to find our modules."
msgstr ""
"模块树可能会提醒您您在计算机上的文件系统目录树; 这是一个非常合适的比较 。 就像文件系统中的目录一样, 您使用模块来组织您的代码。 "
"就像目录中的文件一样, 我们需要找到我们的模块 。"

#: src/ch07-02-defining-modules-to-control-scope.md:203
msgid "{{#quiz ../quizzes/ch07-02-defining-modules-to-control-scope.toml}}"
msgstr "Quiz./quizzes/ch07-02-确定模块-控制范围-toml_"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr "要显示开罗在模块树中找到项目的位置, 我们使用路径的方式与在浏览文件系统时使用路径的方式相同。 要调用函数, 我们需要知道它的路径 。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr "一条路径可以采取两种形式:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"An _absolute path_ is the full path starting from a crate root. The absolute"
" path begins with the crate name."
msgstr "绝对路径_absolute 路径是从箱根开始的完整路径。绝对路径从箱名开始。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:8
msgid "A _relative path_ starts from the current module."
msgstr "相对路徑 _ 从当前模块开始 。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:10
msgid ""
"Both absolute and relative paths are followed by one or more identifiers "
"separated by double colons (`::`)."
msgstr "绝对路径和相对路径后面都有一个或几个识别符,用双冒号分隔(`:')。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:12
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the "
"restaurant we used in the last chapter. We have a crate named _restaurant_ "
"in which we have a module named `front_of_house` that contains a module "
"named `hosting`. The `hosting` module contains a function named "
"`add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr ""
"为了说明这个概念,让我们回顾一下我们在最后一章中使用的餐馆的列表7-1的例子。我们有一个名为_restaurant的箱子,其中我们有一个名为`front_of_house'的模块,其中包括一个名为`东道'的模块。`东道'模块包含一个名为`add_to_waitlist'"
" 的函数。我们要从`eat_at_restaurant'函数中调用`add_to_waitlist' "
"函数。我们需要告诉开罗通往`add_to_waitlist'函数的路径,以便它能找到它。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:35
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:100
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:126
msgid "// Absolute path\n"
msgstr "/ 绝对路径\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:38
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:103
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:129
msgid "// Relative path\n"
msgstr "/ 相对路径\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:43
msgid ""
"<span class=\"caption\">Listing 7-3: Calling the `add_to_waitlist` function "
"using absolute and relative paths</span>"
msgstr ""
"<span类=“caption” > listing 7-3:使用绝对和相对路径 </span>调用`add_to_waitlist' 函数"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:45
msgid ""
"The `eat_at_restaurant` function is part of our library's public API, so we "
"mark it with the `pub` keyword. We’ll go into more detail about `pub` in "
"the [\"Exposing Paths with the `pub` Keyword\"](./ch07-03-paths-for-"
"referring-to-an-item-in-the-module-tree.md#exposing-paths-with-the-pub-"
"keyword) section."
msgstr ""
"`eat_at_restaurant' "
"功能是我们图书馆公开的API的一部分,因此我们用`pub'关键字标记它。我们将更详细地介绍[“用`pub`关键词'来扩展路径” "
"(./ch07-03-paths-for-referring-a-unit- in-the-module-tree.md#exposing-paths-"
" with-pub-keeyword) 一节中的`pub'部分。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:47
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function"
" is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute "
"paths start from the crate root, which you need to refer to by using the "
"crate name. You can imagine a filesystem with the same structure: we’d "
"specify the path _/front_of_house/hosting/add_to_waitlist_ to run the "
"_add_to_waitlist_ program; using the crate name to start from the crate root"
" is like using a slash (`/`) to start from the filesystem root in your "
"shell."
msgstr ""
"我们第一次在`eat_at_restaurant'中调用`add_to_waitlist' "
"函数时,我们使用绝对路径。“add_to_waitlist”函数在同一个箱子中被定义为`eat_at_restaurant'。在开罗,绝对路径从箱根开始,您需要用箱名来参考。你可以想象一个具有相同结构的文件系统:我们指定了运行_add_to_waitlist_程序的路径_/front_house/"
" hosting/add_to_waitlist_;使用箱名从箱根开始,就像用斜线(`/`)来启动外壳中的文件系统根。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:51
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path "
"starts with `front_of_house`, the name of the module defined at the same "
"level of the module tree as `eat_at_restaurant`. Here the filesystem "
"equivalent would be using the path "
"_./front_of_house/hosting/add_to_waitlist_. Starting with a module name "
"means that the path is relative to the current module."
msgstr ""
"第二次我们调用“add_to_waitlist”时,我们使用一个相对路径。路径以“front_of_house”开始,即模块树同一层次定义的“eat_at_restaurant”模块的名称。在这里,文件系统等同将使用路径"
" _./front_house/ hosting/add_to_waitlist_。从模块名称开始,意味着路径与当前模块相对。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:53
msgid ""
"Let’s try to compile Listing 7-3 and find out why it won’t compile yet! We "
"get the following error:"
msgstr "让我们试着编集列表 7-3, 并找出为什么它还没有编成! 我们发现以下错误 :"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:78
msgid ""
"The error messages say that module `hosting` and the `add_to_waitlist` "
"function are not visible. In other words, we have the correct paths for the "
"`hosting` module and the `add_to_waitlist` function, but Cairo won’t let us "
"use them because it doesn’t have access to them. In Cairo, all items "
"(functions, methods, structs, enums, modules, and constants) are private to "
"parent modules by default. If you want to make an item like a function or "
"struct private, you put it in a module."
msgstr ""
"错误信息中说模块“ 托管” 和“ add_to_ waitlist” 功能不可见。 换句话说, 我们拥有“ 托管” 模块和“ add_to_ "
"waitlist” 功能的正确路径, 但是开罗不允许我们使用它们, 因为它无法访问它们。 在开罗, 所有项目( 函数、 方法、 支架、 enum、 "
"模块和常数) 都默认是父模块的私有。 如果您想要将一个像函数或支架这样的项目设为私有, 您可以将其放入模块 。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:80
msgid ""
"Items in a parent module can’t use the private items inside child modules, "
"but items in child modules can use the items in their ancestor modules. This"
" is because child modules wrap and hide their implementation details, but "
"the child modules can see the context in which they’re defined. To continue "
"with our metaphor, think of the privacy rules as being like the back office "
"of a restaurant: what goes on in there is private to restaurant customers, "
"but office managers can see and do everything in the restaurant they "
"operate."
msgstr ""
"家长模块中的项目不能使用儿童模块中的私人项目,但儿童模块中的项目可以使用其祖先模块中的私人项目。 "
"这是因为儿童模块包扎并隐藏其实施细节,但儿童模块可以看到它们被定义的背景。 "
"继续我们的比喻,将隐私规则想象成餐馆的后台:那里是私人餐厅,但办公室经理可以看到和做他们经营的餐馆的一切。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:82
msgid ""
"Cairo chose to have the module system function this way so that hiding inner"
" implementation details is the default. That way, you know which parts of "
"the inner code you can change without breaking outer code. However, Cairo "
"does give you the option to expose inner parts of child modules’ code to "
"outer ancestor modules by using the `pub` keyword to make an item public."
msgstr ""
"开罗选择了模块系统以这种方式运行, 以便隐藏内部执行细节是默认的。 这样, 您就可以知道内部代码的哪些部分可以在不破解外码的情况下更改。 但是, "
"开罗确实允许您使用“ pub” 关键字将儿童模块代码的内部部分暴露在外祖先模块中, 从而将项目公之于众 。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:86
msgid "Exposing Paths with the `pub` Keyword"
msgstr "用`pub' 关键字揭开路径"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:88
msgid ""
"Let’s return to the previous error that told us the `hosting` module and the"
" `add_to_waitlist` function are not visible. We want the `eat_at_restaurant`"
" function in the parent module to have access to the `add_to_waitlist` "
"function in the child module, so we mark the `hosting` module with the `pub`"
" keyword, as shown in Listing 7-4."
msgstr ""
"让我们回到之前告诉我们的`托管'模块和`add_to_waitlist'功能不可见的错误,我们希望父模块中的`eat_at_restaurant'功能能够进入儿童模块中的`add_to_waitlist'功能,因此我们将“托管”模块标为`pub'关键字,如7-4列表所示。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:108
msgid ""
"<span class=\"caption\">Listing 7-4: Declaring the `hosting` module as `pub`"
" to use it from `eat_at_restaurant`</span>"
msgstr ""
"<span类=“Caption” > listing 7-4: "
"宣布`托管'模块为`pub',以便从`eat_at_restaurand__restaurant_/span>使用该模块"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:110
msgid "Unfortunately, the code in Listing 7-4 still results in an error."
msgstr "不幸的是,7-4清单中的代码仍然出错。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:112
msgid ""
"What happened? Adding the `pub` keyword in front of `mod hosting;` makes the"
" module public. With this change, if we can access `front_of_house`, we can "
"access `hosting`. But the contents of `hosting` are still private; making "
"the module public doesn’t make its contents public. The `pub` keyword on a "
"module only lets code in its ancestor modules refer to it, not access its "
"inner code. Because modules are containers, there’s not much we can do by "
"only making the module public; we need to go further and choose to make one "
"or more of the items within the module public as well."
msgstr ""
"发生什么了? 在“模式主机”前添加“pub”关键字; ` 将模块公之于众; 使模块公之于众。 有了这一变化,如果我们能够访问“ 前门', "
"我们就可以访问“ 托管” 。 但是“ 托管” 的内容仍然是私有的; 让模块公之于众并不公布其内容。 模块上的“ pub” "
"关键字只允许其祖先模块中的代码指向它, 而不是访问其内部代码。 由于模块是容器, 仅仅将模块公之于众, 我们无法做多少事; 我们需要更进一步, "
"并选择在模块中将一个或多个项目公之于众。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:114
msgid ""
"Let’s also make the `add_to_waitlist` function public by adding the `pub` "
"keyword before its definition, as in Listing 7-5."
msgstr "让我们也公布“add_to_waitlist”功能,"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:127
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:130
msgid "// ✅ Compiles\n"
msgstr "汇编\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:134
msgid ""
"<span class=\"caption\">Listing 7-5: Declaring the `hosting` module as `pub`"
" to use it from `eat_at_restaurant`</span>"
msgstr ""
"<span类=“Caption” > listing 7-5: "
"宣布`托管'模块为`pub',以便从`eat_at_restaurand__restaurant_/span>使用该模块"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:136
msgid ""
"Now the code will compile! To see why adding the `pub` keyword lets us use "
"these paths in `add_to_waitlist` with respect to the privacy rules, let’s "
"look at the absolute and the relative paths."
msgstr ""
"现在代码将编译! 要了解为什么添加“ pub' 关键字”, 让我们在“ add_to_ waitlist” 中用这些路径来表达隐私规则, "
"让我们看看绝对路径和相对路径 。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:138
msgid ""
"In the absolute path, we start with the crate root, the root of our crate’s "
"module tree. The `front_of_house` module is defined in the crate root. While"
" `front_of_house` isn’t public, because the `eat_at_restaurant` function is "
"defined in the same module as `front_of_house` (that is, `front_of_house` "
"and `eat_at_restaurant` are siblings), we can refer to `front_of_house` from"
" `eat_at_restaurant`. Next is the `hosting` module marked with `pub`. We can"
" access the parent module of `hosting`, so we can access `hosting` itself. "
"Finally, the `add_to_waitlist` function is marked with `pub` and we can "
"access its parent module, so this function call works!"
msgstr ""
"在绝对路径中,我们先从板箱根开始,即我们的板箱模块树的根根开始,在板箱根中定义了`front_of_house' "
"模块。虽然`front_of_house'模块并不公开,因为`eat_at_restaurant'功能在模块中被定义为`front_of_house'(即`front_house'和`eat_at_restaurant'是兄弟姐妹),我们可以从`eat_at_restaurant'中提及`for_house'前方`house'模块。下一个是`东道方'模块,标记为`pub'。我们可以访问`东道方'的母模块,因此我们可以访问`东道方'本身。最后,`ad_to_waitlist'函数以`pub'标有`add_to_wait'功能,我们可以访问其母模块,因此此功能调用!"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:140
msgid ""
"In the relative path, the logic is the same as the absolute path except for "
"the first step: rather than starting from the crate root, the path starts "
"from `front_of_house`. The `front_of_house` module is defined within the "
"same module as `eat_at_restaurant`, so the relative path starting from the "
"module in which `eat_at_restaurant` is defined works. Then, because "
"`hosting` and `add_to_waitlist` are marked with `pub`, the rest of the path "
"works, and this function call is valid!"
msgstr ""
"在相对路径中,逻辑与绝对路径相同,但第一步除外:路径不是从箱根开始,而是从`front_of_house'开始。`front_of_house'模块在“eat_at_restaurant”同一个模块中被定义为`eat_at_restaurant"
" "
"',因此从`at_at_restaurant'定义“eat_at_restaurant”的模块开始的相对路径。然后,由于`东道'和`add_to_waitlist'被标记为`pub"
" ',即路径的其余工作,而此函数呼叫是有效的!"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:142
msgid "{{#quiz ../quizzes/ch07-03-paths-in-module-tree-1.toml}}"
msgstr "Quiz./quizzes/ch07-03 -paths -in-module-treet-1.toml"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:144
msgid "Starting Relative Paths with `super`"
msgstr "“ 超级” 的起始相对路径"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:146
msgid ""
"We can construct relative paths that begin in the parent module, rather than"
" the current module or the crate root, by using `super` at the start of the "
"path. This is like starting a filesystem path with the `..` syntax. Using "
"`super` allows us to reference an item that we know is in the parent module,"
" which can make rearranging the module tree easier when the module is "
"closely related to the parent, but the parent might be moved elsewhere in "
"the module tree someday."
msgstr ""
"我们可以在路径的起始处使用“ super”, 而不是当前模块或箱根, 来构造从父模块开始的相对路径, 而不是当前模块或箱根。 这就像在路径的起始处使用 "
"`. ` 语法 启动文件系统路径一样。 使用“ super ”, 允许我们引用我们所知道的在父模块中的项目, 这样当模块与父模块密切关联时, "
"可以更容易地重新排列模块树, 但将来可能会在模块树中将父树移到别处 。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:148
msgid ""
"Consider the code in Listing 7-6 that models the situation in which a chef "
"fixes an incorrect order and personally brings it out to the customer. The "
"function `fix_incorrect_order` defined in the `back_of_house` module calls "
"the function `deliver_order` defined in the parent module by specifying the "
"path to `deliver_order` starting with `super`:"
msgstr ""
"列表 7-6 中的代码可以模拟厨师设置错误顺序并亲自将其带给客户的情形。 “ 后院” 模块中定义的函数“ fix_ in 更正_ order ” "
"将父模块中定义的函数“ deliver_order”称为“ deliver_order ”, 具体指明“ deliver_order” 的路径, 以“ "
"超级” 开头的路径 :"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:165
msgid ""
"<span class=\"caption\">Listing 7-6: Calling a function using a relative "
"path starting with `super`</span>"
msgstr "<span类=“ caption” > listing 7-6: 使用从“ europe_\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:167
msgid ""
"Here you can see directly that you access a parent's module easily using "
"`super`, which wasn't the case previously. Note that the `back_of_house` is "
"kept private, as external users are not supposed to interact with the back "
"of house directly."
msgstr ""
"这里您可以直接看到您使用“ 超级” 很容易地访问父/母模块, 而以前的情况并非如此。 请注意, ` 后院' 是私密的, "
"因为外部用户不应该直接与家庭后院互动 。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:170
msgid "Making Structs and Enums Public"
msgstr "公诸于众"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:172
msgid ""
"We can also use `pub` to designate structs and enums as public, but there "
"are a few extra details to consider when using `pub` with structs and enums."
msgstr "我们还可以使用`插件'来指定构件和钉子为公开的,但在使用构件和钉子的`构件'时,还可以考虑一些额外的细节。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:174
msgid ""
"If we use `pub` before a struct definition, we make the struct public, but "
"the struct’s fields will still be private. We can make each field public or "
"not on a case-by-case basis."
msgstr "如果我们在结构定义之前使用`插件 ',我们就将结构公之于众,但结构的字段仍将是私有的,我们可以在个案基础上将每个领域公之于众或不公之于众。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:175
msgid ""
"In contrast, if we make an enum public, all of its variants are then public."
" We only need the `pub` before the `enum` keyword."
msgstr "与此相反,如果我们将一个大通版公诸于众,它的所有变异版就都公开了,我们只需要在“大通”关键字之前的`pub'。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:177
msgid ""
"There’s one more situation involving `pub` that we haven’t covered, and that"
" is our last module system feature: the `use` keyword. We’ll cover `use` by "
"itself first, and then we’ll show how to combine `pub` and `use`."
msgstr ""
"还有一种情况涉及 \" 我们尚未覆盖的 \" 插件,这是我们模块系统最后一个特点: \" 使用关键词 \",我们先自行覆盖 \" 使用 "
"\",然后展示如何将 \" 插件 \" 和 \" 使用 \" 结合起来。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:179
msgid "{{#quiz ../quizzes/ch07-03-paths-in-module-tree-2.toml}}"
msgstr ""
"Quiz./quizzes/ch07-03-paths-in-module-toml-toml__BAR__BAR__BAR_ "
"/quizzes/ch07-03-paths-in-module-tree-2.toml_BAR__BAR_ "
"/quiz/quizzes/ch07-03-paths- in-module-tree-2.toml_BAR_"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can "
"create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr ""
"写出调用函数的路径可能会感到不方便和重复。 "
"幸运的是,有一个方法可以简化这个过程:我们可以创造一条通往使用“使用”关键字的路径的捷径,然后在范围中的任何地方使用较短的名称。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 7-7, we bring the `restaurant::front_of_house::hosting` module "
"into the scope of the `eat_at_restaurant` function so we only have to "
"specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in"
" `eat_at_restaurant`."
msgstr ""
"在清单7-7中,我们把`restaurant::front_of_house:: "
"hosting'模块纳入`eat_at_restaurant'功能的范围,因此我们只需具体说明`东道:add_to_waitlist'即可在`eat_at_restaurant'中称为`add_to_waitlist'函数。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:13
msgid ""
"// Assuming \"front_of_house\" module is contained in a crate called \"restaurant\", as mentioned in the section \"Defining Modules to Control Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in the use statement\n"
msgstr ""
"/ "
"假设“家用前方”模块包含在“确定控制范围模块”一节中提到的称为“雷斯塔乌兰特”的箱中/如果路径是在同一箱中创建的,则“雷斯塔乌兰特”在使用语句中是可选的。\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:25
msgid "// ✅ Shorter path\n"
msgstr "/ /  缩短路径\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid ""
"<span class=\"caption\">Listing 7-7: Bringing a module into scope with "
"`use`</span>"
msgstr "<span类=“caption” > listing 7-7: 将模块带入“ use_/span” 的范围"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:31
msgid ""
"Adding `use` and a path in a scope is similar to creating a symbolic link in"
" the filesystem. By adding `use restaurant::front_of_house::hosting;` in the"
" crate root, `hosting` is now a valid name in that scope, just as though the"
" `hosting` module had been defined in the crate root."
msgstr ""
"添加“使用”和“范围中的路径”类似于在文件系统中创建符号链接。通过添加“使用餐厅:Front_of_house:: "
"hosting”;`在箱根中,`托管'现在在此范围内是一个有效名称,就像在箱根中定义了`托管'模块一样。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:33
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-8 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile:"
msgstr ""
"请注意,`使用'只为`使用'发生的特定范围创造捷径。列出 7-8 "
"将`eat_at_restaurant'函数移动为名为`客户'的新儿童模块,该模块的范围与`使用'语句不同,因此函数体不会汇编:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:54
msgid ""
"<span class=\"caption\">Listing 7-8: A `use` statement only applies in the "
"scope it’s in.</span>"
msgstr "<span类=“caption” > listing 7-8:`使用'说明仅适用于其范围。 </span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr "编译器错误显示快捷键不再适用于“客户”模块:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:75
msgid "Creating Idiomatic `use` Paths"
msgstr "创建“使用”路径"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
msgid ""
"In Listing 7-7, you might have wondered why we specified `use "
"restaurant::front_of_house::hosting` and then called "
"`hosting::add_to_waitlist` in `eat_at_restaurant` rather than specifying the"
" `use` path all the way out to the `add_to_waitlist` function to achieve the"
" same result, as in Listing 7-9."
msgstr ""
"在清单7-7中,你可能想知道我们为什么在`eat_at_restaurant'中指定`使用餐厅:前门:接待 "
"',然后称之为`托管:add_to_waitlist "
"',而不是像在清单7-9中指明`add_to_waitlist'功能那样,通过`add_to_waitlist'通向`add_to_waitlist'功能的`使用'路径来实现同样的结果。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:97
msgid ""
"<span class=\"caption\">Listing 7-9: Bringing the `add_to_waitlist` function"
" into scope with `use`, which is unidiomatic</span>"
msgstr ""
"<span类=“caption” > listing 7-9: 将`add_to_to_waitlist' 功能带入`use'的范围,即单元 "
"</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:99
msgid ""
"Although both Listing 7-7 and 7-9 accomplish the same task, Listing 7-7 is "
"the idiomatic way to bring a function into scope with `use`. Bringing the "
"function’s parent module into scope with `use` means we have to specify the "
"parent module when calling the function. Specifying the parent module when "
"calling the function makes it clear that the function isn’t locally defined "
"while still minimizing repetition of the full path. The code in Listing 7-9 "
"is unclear as to where `add_to_waitlist` is defined."
msgstr ""
"虽然列出7-7和7-9的任务都相同,但列出7-7是将函数带入“使用”范围的独特方式。将函数的母模块带入“使用”意味着我们必须在调用该函数时指定母模块。调用该函数时指定母模块,表明该函数不是本地定义的,同时仍然尽量减少完整路径的重复。列出7-9中的代码不清楚“添加_to_waitlist”在哪里定义。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:107
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items "
"with `use`, it’s idiomatic to specify the full path. Listing 7-10 shows the "
"idiomatic way to bring the core library’s `BitSize` trait into the scope, "
"allowing to call `bits` method to retrieve the size in bits of a type."
msgstr ""
"另一方面,在带入支架、支架、特性和其他有`使用'的物品时,具体说明整个路径是独特的。列出7-10显示了将核心图书馆的`BitSize'特性带入范围的独特方法,允许调用`bits'方法来检索某类型位数的大小。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:114
msgid "\"A u8 variable has {} bits\""
msgstr "u8 变量有  位元"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"<span class=\"caption\">Listing 7-10: Bringing `BitSize` trait into scope in"
" an idiomatic way</span>"
msgstr "<span class=\"Caption\" > listing 7-10:将`BitSize'特性以单行方式带入范围 </span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:120
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has emerged in the Rust community, and folks have gotten used to reading and"
" writing Rust code this way. As Cairo shares many idioms with Rust, we "
"follow this convention as well."
msgstr ""
"发自开罗 — — 与鲁斯特有着许多共同点 — — 也遵循了这项公约。 "
"其背后没有强有力的理由:在鲁斯特社区出现的只是公约,人们也习惯了这样阅读和撰写鲁斯特代码。 开罗与鲁斯特有着许多共同点,因此我们也遵循了这项公约。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:124
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Cairo doesn’t allow that."
msgstr ""
"校对:Portnoy、Portnoy、Flickr、Flickr、Flickr、Flickr、Flickr、Flickr、Flickr、Flickr、Flickr、Flickr、Finland"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid "Providing New Names with the `as` Keyword"
msgstr "以`作为'关键字提供新名称"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:129
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: after the path, we can specify `as` and"
" a new local name, or _alias_, for the type. Listing 7-11 shows how you can "
"rename an import with `as`:"
msgstr ""
"对于将两种同名同名的“使用”纳入同一范围的问题,还有另一种解决办法:在路径之后,我们可以指定“作为”和该类型的新的本地名称,或_alias_。列出 "
"7-11 显示您如何用“作为”重新命名导入:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:139
msgid "// ArrayTrait was renamed to Arr\n"
msgstr "/ 阵列Trait 重新命名为 Arr\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:144
msgid ""
"<span class=\"caption\">Listing 7-11: Renaming a trait when it’s brought "
"into scope with the `as` keyword</span>"
msgstr ""
"<span class=“caption” > listing 7-11: 将“span” 类作为关键词 </span> 重新命名其范围时的特性"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:146
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now "
"access the trait's methods with the `Arr` identifier."
msgstr ""
"在这里,我们用“ArrayTrait”这一别名将“ArrayTrait”带入了范围,我们现在可以使用“ArrayTrait”识别符访问该特性的方法。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:148
msgid "Importing Multiple Items from the Same Module"
msgstr "从同一个模块导入多个项目"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:150
msgid ""
"When you want to import multiple items (like functions, structs or enums) "
"from the same module in Cairo, you can use curly braces `{}` to list all of "
"the items that you want to import. This helps to keep your code clean and "
"easy to read by avoiding a long list of individual `use` statements."
msgstr "当您想要从开罗的同一个模块中导入多个项目(类似函数、支架或 enums) 时,您可以使用卷尾括号 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:155
msgid ""
"The general syntax for importing multiple items from the same module is:"
msgstr "从同一个模块导入多个项目的一般语法是:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:161
msgid ""
"Here is an example where we import three structures from the same module:"
msgstr "以下是我们从同一个模块导入三个结构的例子:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:164
msgid ""
"// Assuming we have a module called `shapes` with the structures `Square`, "
"`Circle`, and `Triangle`.\n"
msgstr "/ 假设我们有一个称为`形状'的单元,其结构为`结构'、`环绕'和`三角'。\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:182
msgid ""
"// We can import the structures `Square`, `Circle`, and `Triangle` from the "
"`shapes` module like this:\n"
msgstr "我们可以从这种“形状”模块中进口“平方”、“圆圈”和“三角形”结构,例如:\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:185
msgid ""
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
msgstr "现在,我们可以在我们的代码中直接使用`平方'、`圆圈'和`三角'。\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:190
#: src/ch17-01-general-recommendations.md:143
#: src/ch17-01-general-recommendations.md:148
msgid "// ...\n"
msgstr "/.....\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:195
msgid ""
"<span class=\"caption\">Listing 7-12: Importing multiple items from the same"
" module</span>"
msgstr "<span类=\"Caption\" > listing 7-12: 从同一个模块导入多个项目 </span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:197
msgid "Re-exporting Names in Module Files"
msgstr "在模块文件中重新导出名称"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:199
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in the new scope can be imported as if it had been defined in that code’s "
"scope. This technique is called _re-exporting_ because we’re bringing an "
"item into scope, but also making that item available for others to bring "
"into their scope, with the `pub` keyword."
msgstr ""
"当我们用“使用”关键字将一个名称带入范围时,新范围中可用的名称可以仿照该代码的范围所定义的那样导入。这种技术被称为`re-export "
"',因为我们正在将一个项目带入范围,但也使该物品可供其他人使用,用“pub”关键字带入范围。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:204
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the "
"restaurant example:"
msgstr "例如,让我们再出口餐厅中的`add_to_waitlist'功能,例如:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:222
msgid ""
"<span class=\"caption\">Listing 7-13: Making a name available for any code "
"to use from a new scope with `pub use`</span>"
msgstr ""
"<span类=“caption” > listing 7- 13: 为任何代码提供名称, 以便从新范围中使用“ pub use_/span” 。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path "
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this `pub"
" use` has re-exported the `hosting` module from the root module, external "
"code can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""
"更改前,外部代码必须使用路径`restaurant::front_of_house:: "
"hosting::add_to_waitlist()'来调用`add_to_waitlist()' "
"函数,以此称呼`add_to_waitlist()'功能。 现在,由于这个`pub "
"use'已从根模块中再导出`东道'模块,外部代码现在可以使用路径`restaurant:: hosting:add_to_waitlist()'。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:229
msgid ""
"Re-exporting is useful when the internal structure of your code is different"
" from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `pub use`, we can write our code with one structure but expose a"
" different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library."
msgstr ""
"当您的代码的内部结构与程序员如何称呼您的代码会想到域不同时,再出口是有用的。 比如,在这个餐馆的隐喻中,餐馆的老板会想到“前门 ” 和“后门 ” 。 "
"但是,访问餐馆的顾客可能不会用这些术语来考虑餐厅的零件。有了“pub use ”, 我们就可以用一个结构来写我们的代码,但暴露不同的结构。 "
"这样做,我们的图书馆就为图书馆的编程员和叫图书馆的编程员组织得井然有序了。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:238
msgid "Using External Packages in Cairo with Scarb"
msgstr "在开罗使用带有刀疤的外部软件包"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:240
msgid ""
"You might need to use external packages to leverage the functionality "
"provided by the community. Scarb allows you to use dependencies by cloning "
"packages from their Git repositories. To use an external package in your "
"project with Scarb, simply declare the Git repository URL of the dependency "
"you want to add in a dedicated `[dependencies]` section in your _Scarb.toml_"
" configuration file. Note that the URL might correspond to the main branch, "
"or any specific commit, branch or tag. For this, you will have to pass an "
"extra `rev`, `branch`, or `tag` field, respectively. For example, the "
"following code imports the main branch of _alexandria_math_ crate from "
"_alexandria_ package:"
msgstr ""
"您可能需要使用外部软件包来利用社区提供的功能。 Scarb 允许您使用来自 Git 仓库的克隆软件包来使用依赖性。 要在与 Scarb "
"的工程中使用外部软件包, 只需声明您想要在您的 _ Scarb.toml_ 配置文件的专用“ [依赖性] ” 部分中添加的依赖性 Git 仓库 URL "
"。 请注意, URL 可能与主分支或任何特定承诺、 分支或标签相对应。 为此, 您需要通过一个额外的“ rev” 、 “ branch” 或“ Tag”"
" 字段。 例如, 以下代码从 _ alexandria_ 软件包导入主分支 :"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:244
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:251
msgid "\"https://github.com/keep-starknet-strange/alexandria.git\""
msgstr "“https://github.com/keep-starknet-strange/alexandria.git”"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:247
msgid ""
"while the following code imports a specific branch (which is deprecated and "
"should not be used):"
msgstr "当下列代码进口一个特定分支(该分支已折旧,不应使用):"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:251
msgid "\"cairo-v2.3.0-rc0\""
msgstr "\"cairo-v2.3.0-rc0\" \"cairo-v2.3.0-rc0\""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:254
msgid ""
"If you want to import multiple packages in your project, you need to create "
"only one `[dependencies]` section and list all the desired packages beneath "
"it. You can also specify development dependencies by declaring a `[dev-"
"dependencies]` section."
msgstr ""
"如果您想要在您的工程中导入多个软件包, 您只需要创建一个“ [依赖性] ” 区域, 并列出其下所有想要的软件包。 您也可以通过声明一个“ [依赖性] "
"区域来指定开发依赖性。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:256
msgid ""
"After that, simply run `scarb build` to fetch all external dependencies and "
"compile your package with all the dependencies included."
msgstr "在此之后,只需运行`碳碳结构 ',以获取所有外部依赖物,并将你的软件包与包括的所有依赖物一起汇编成册。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:258
msgid ""
"Note that it is also possible to add dependencies with the `scarb add` "
"command, which will automatically edit the _Scarb.toml_ file for you. For "
"development dependencies, just use the `scarb add --dev` command."
msgstr ""
"请注意,也可以在“carb add ” 命令中添加依赖性,该命令将自动编辑您所需的 _Scarb.toml_文件。对于开发依赖性,请使用“sccarb "
"add -- dev” 命令。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:260
msgid ""
"To remove a dependency, simply remove the corresponding line from your "
"_Scarb.toml_ file, or use the `scarb rm` command."
msgstr "要删除依赖性,只需从您的 _Scarb.toml_文件中删除相应的线条,或使用“sccarb rm”命令。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:262
msgid "{{#quiz ../quizzes/ch07-04-bringing-paths-into-scope.toml}}"
msgstr "Quiz./quizzes/ch07-04-bringing-paths-in-scope.toml-toml-"

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file. When modules get large, you might want to move their definitions to a "
"separate file to make the code easier to navigate."
msgstr ""
"到目前为止, 本章中的所有示例都在一个文件中定义了多个模块。 当模块变大时, 您可能想要将其定义移动到一个单独的文件中, 以使代码更容易导航 。"

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-7 that had multiple "
"restaurant modules. We’ll extract modules into files instead of having all "
"the modules defined in the crate root file. In this case, the crate root "
"file is _src/lib.cairo_."
msgstr ""
"例如,让我们从有多个餐厅模块的7-7列表中的代码开始。 我们将将模块提取到文件中, 而不是在箱根文件中定义所有模块。 在这种情况下, 箱根文件是 "
"_src/lib.cairo_ 。"

#: src/ch07-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the"
" code inside the curly brackets for the `front_of_house` module, leaving "
"only the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains"
" the code shown in Listing 7-14. Note that this won’t compile until we "
"create the _src/front_of_house.cairo_ file."
msgstr ""
"首先,我们将将`front_of_house' "
"模块提取到自己的文件中。删除`front_of_house'模块括号内的代码,只留下`mod_fof_house;'声明,这样_src/lib.cairo_就包含列表"
" 7-14 中的代码。请注意,在创建_src/front_house.cairo_文件之前,这不会汇编。"

#: src/ch07-05-separating-modules-into-different-files.md:30
msgid ""
"<span class=\"caption\">Listing 7-14: Declaring the `front_of_house` module "
"whose body will be in _src/front_of_house.cairo_</span>"
msgstr ""
"<span class=\"caption\" > listing 7-14: 宣布`front_of_house' "
"模块,其身体将位于_src/front_of_house.cairo__/span>"

#: src/ch07-05-separating-modules-into-different-files.md:32
msgid ""
"Next, place the code that was in the curly brackets into a new file named "
"_src/front_of_house.cairo_, as shown in Listing 7-15. The compiler knows to "
"look in this file because it came across the module declaration in the crate"
" root with the name `front_of_house`."
msgstr ""
"下一步,将卷括号中的代码放在名为 _src/front_of_house.cairo_的新文件中,如列表 "
"7-15所示。汇编者知道在文件中查看,因为它在箱根中发现了名为`front_of_house' 的模块声明。"

#: src/ch07-05-separating-modules-into-different-files.md:37
#: src/ch07-05-separating-modules-into-different-files.md:63
msgid "<span class=\"filename\">Filename: src/front_of_house.cairo</span>"
msgstr "<span类=\"filename\" >Filename: src/front_of_house.cairo </span>"

#: src/ch07-05-separating-modules-into-different-files.md:45
msgid ""
"<span class=\"caption\">Listing 7-15: Definitions inside the "
"`front_of_house` module in _src/front_of_house.cairo_</span>"
msgstr ""
"<span class=\"Caption\" > listing 7-15: "
"在_src/front_of_house.cairo_/span的“前屋”模块中的定义"

#: src/ch07-05-separating-modules-into-different-files.md:47
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your module tree. Once the compiler knows the file is part of the project "
"(and knows where in the module tree the code resides because of where you’ve"
" put the `mod` statement), other files in your project should refer to the "
"loaded file’s code using a path to where it was declared, as covered in the "
"[\"Paths for Referring to an Item in the Module Tree\"](./ch07-03-paths-for-"
"referring-to-an-item-in-the-module-tree.md) chapter. In other words, `mod` "
"is _not_ an “include” operation that you may have seen in other programming "
"languages."
msgstr ""
"请注意,您只需在模块树中使用`mod' 声明_once_ 装入文件即可。 "
"一旦汇编者知道文件是项目的一部分(并知道代码在模块树中的位置,因为您已经将`mod' "
"声明放在哪里),您项目中的其他文件就应该参照已装入文件的代码,使用“提到模块树中某个项目的路径” (./ch07-03-paths-refor-"
"referring-an-emit-in-the-module-tree.md) 章节中包含的路径。换句话说,`mod` is_ not__ a "
"“include” 操作,您可以用其他编程语言看到 。"

#: src/ch07-05-separating-modules-into-different-files.md:55
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit different because `hosting` is a child module of `front_of_house`, not "
"of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case "
"_src/front_of_house/_."
msgstr ""
"下一步,我们将将“主办”模块提取到自己的文件中。由于“主办”是一个“前屋”而不是“根”模块的儿童模块,因此程序略有不同。我们将将“主办”文件放置在模块树中为其祖先命名的新目录中,这里是"
" _src/front_of_house/_。"

#: src/ch07-05-separating-modules-into-different-files.md:60
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain "
"only the declaration of the `hosting` module:"
msgstr "为了开始移动`东道 ',我们将 _src/front_of_house.cairo_改为只包含`东道'模块声明:"

#: src/ch07-05-separating-modules-into-different-files.md:69
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ "
"to contain the definitions made in the `hosting` module:"
msgstr "然后我们创建一个_src/front_of_house_目录和一个文件_ hosting.cairo_,以包含`托管'模块中的定义:"

#: src/ch07-05-separating-modules-into-different-files.md:72
msgid "<span class=\"filename\">Filename: src/front_of_house/hosting.cairo</span>"
msgstr "<span类=\"filename\" >Filename: src/front_of_house/ hosting.cairo </span>"

#: src/ch07-05-separating-modules-into-different-files.md:78
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would"
" expect the _hosting.cairo_ code to be in a `hosting` module declared in the"
" crate root, and not declared as a child of the `front_of_house` module. The"
" compiler’s rules for which files to check for which modules’ code means the"
" directories and files more closely match the module tree."
msgstr ""
"如果我们相反地在 _src_目录中插入 _hosting.cairo_, "
"编纂者会期望该代码在“wosting.cairo_”模块中,该模块在箱根中被宣布为“winding”模块,而不是被宣布为“front_of_house”模块的子模块。对于哪个模块代码代表更接近模块树的目录和文件,编纂者要检查哪个模块代码的文件规则。"

#: src/ch07-05-separating-modules-into-different-files.md:84
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains the same. The function calls in `eat_at_restaurant` will work "
"without any modification, even though the definitions live in different "
"files. This technique lets you move modules to new files as they grow in "
"size."
msgstr ""
"我们已将每个模块的代码移到一个单独的文件, 模块树也保持不变。 调用“ eat_ at_ restaurant” 的函数将不作任何修改, "
"即使定义存在于不同的文件中。 此技术允许您将模块移到新文件, 因为它们在大小上不断增大 。"

#: src/ch07-05-separating-modules-into-different-files.md:89
msgid ""
"Note that the `use restaurant::front_of_house::hosting;` statement in "
"_src/lib.cairo_ also hasn’t changed, nor does `use` have any impact on what "
"files are compiled as part of the crate. The `mod` keyword declares modules,"
" and Cairo looks in a file with the same name as the module for the code "
"that goes into that module."
msgstr ""
"请注意, ` 使用餐厅: : Front_of_house:: hosting;` "
"in_src/lib.cairo_中的语句'也没有改变,使用'也不会对作为箱子的一部分汇编的文件产生任何影响。 `mod' 关键词声明模块, "
"开罗则在与该模块代码模块相同的名称的文件中查看 。"

#: src/ch07-05-separating-modules-into-different-files.md:99
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules"
" so you can refer to items defined in one module from another module. You "
"can do this by specifying absolute or relative paths. These paths can be "
"brought into scope with a `use` statement so you can use a shorter path for "
"multiple uses of the item in that scope. Module code is **private** by "
"default."
msgstr ""
"开罗允许您将一个软件包分成多个箱和一个箱分成多个模块,这样您就可以参考另一个模块中一个模块中定义的项目。您可以通过指定绝对路径或相对路径来做到这一点。这些路径可以用“使用”语句引入范围,这样您就可以使用较短的路径来在该范围中多用该项目。默认情况下,模块代码是"
" ** 私有** 。"

#: src/ch07-05-separating-modules-into-different-files.md:105
msgid "{{#quiz ../quizzes/ch07-05-separate-modules.toml}}"
msgstr ""
"QQZ./Qizes/ch07-05-eparate-modules.toml_BAR__BAR_QQQZZes/ch07-05-eparate-"
"modules.toml_BAR__BAR__BAR_ QQQZZ./quizzes/ch07-05-smoules.toml_BAR_"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Cairo, one such tool is generics: abstract "
"stand-ins for concrete types or other properties. We can express the "
"behavior of generics or how they relate to other generics without knowing "
"what will be in their place when compiling and running the code."
msgstr ""
"每种编程语言都有有效处理概念重叠的工具。 在开罗,这种工具之一是通用工具:具体类型或其他属性的抽象备用。 "
"我们可以表达通用语言的行为,或者它们与其他通用语言的关系,而不知道在编译和运行代码时它们的位置。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Functions can take parameters of some generic type, instead of a concrete "
"type like `u32` or `bool`, in the same way a function takes parameters with "
"unknown values to run the same code on multiple concrete values. In fact, "
"we’ve already used generics in [Chapter 6](./ch06-01-enums.html#the-option-"
"enum-and-its-advantages) with `Option<T>`."
msgstr ""
"函数可以采用某种通用类型的参数,而不是“ u32” 或“bool” "
"等具体类型的参数,就像函数以未知值的参数对多个混凝土值运行相同的代码一样。事实上,我们已经在[第6章](./ch06-01-enums.html#the-"
"option-enum-and-its-advantages)和“option<T}”中使用了通用的参数。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"In this chapter, you’ll explore how to define your own types, functions, and"
" traits with generics."
msgstr "在本章中,您将探索如何定义自己的类型、功能和通用特性。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication. Upon compilation, the "
"compiler creates a new definition for each concrete type that replaces a "
"generic type, reducing development time for the programmer, but code "
"duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which "
"will cause contract size to increment."
msgstr ""
"通用域名允许我们用代表多种类型的占位符替换特定类型, 以消除代码重复。 汇编者在编译时为每个具体类型设定了新的定义, 以取代通用类型, "
"缩短程序员的开发时间, 但是在编译级别上仍然存在代码重复。 如果您正在签订 Starknet 合同, 并使用通用的多类型合同, 从而导致合同的递增, "
"这可能很重要 。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You"
" can combine traits with generic types to constrain a generic type to accept"
" only those types that have a particular behavior, as opposed to just any "
"type."
msgstr "然后学习如何使用特征来定义一般行为。 您可以将特征和普通类型结合起来, 限制普通类型, 仅接受特定行为类型, 而不是任何类型。"

#: src/ch08-00-generic-types-and-traits.md
msgid "Removing Duplication by Extracting a Function"
msgstr "通过提取函数来消除重复"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication. Before diving into "
"generics syntax, let’s first look at how to remove duplication in a way that"
" doesn’t involve generic types by extracting a function that replaces "
"specific values with a placeholder that represents multiple values. Then "
"we’ll apply the same technique to extract a generic function! By learning "
"how to identify duplicated code that can be extracted into a function, "
"you'll start to recognize instances where generics can be used to reduce "
"duplication."
msgstr ""
"通用参数允许我们用代表多种类型的占位符替换特定类型, 以删除代码重复。 在跳入通用语法之前, 让我们首先研究如何通过提取一个函数, "
"以代表多个值的占位符取代特定值, 从而不包含通用类型, 来消除重复。 然后我们用同样的技术来提取一个通用函数 。 "
"通过学习如何识别可提取到函数中的重复代码, 您将开始识别可以使用通用代码来减少重复的实例 。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We begin with a short program that finds the largest number in an array of "
"`u8`:"
msgstr "我们从一个短程序开始,它发现在一系列`u8'中数量最多:"

#: src/ch08-00-generic-types-and-traits.md
msgid "\"The largest number is {}\""
msgstr "\"人数最多的是\"\""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We store an array of `u8` in the variable `number_list` and extract the "
"first number in the array in a variable named `largest`. We then iterate "
"through all the numbers in the array, and if the current number is greater "
"than the number stored in `largest`, we update the value of `largest`. "
"However, if the current number is less than or equal to the largest number "
"seen so far, the variable doesn’t change, and the code moves on to the next "
"number in the list. After considering all the numbers in the array, "
"`largest` should contain the largest number, which in this case is 100."
msgstr ""
"我们将`u8'的阵列存放在变量`序号_列表'中,并在名为`最大'的变量中提取数组的第一个数字。然后我们通过数组中的所有数字进行循环,如果当前数字大于`最大'中储存的数字,我们就更新`最大'的值。然而,如果当前数字小于或等于迄今看到的最大数字,则该变量没有变化,代码移到列表中的下一个数字。在考虑了数组中的所有数字后,`最大'应该包含最大数字,在这种情况下是100。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We've now been tasked with finding the largest number in two different "
"arrays of numbers. To do so, we can choose to duplicate the previous code "
"and use the same logic at two different places in the program, as follows:"
msgstr "我们现在的任务是在两个不同的数字阵列中找到最大的数字。为了这样做,我们可以选择重复以前的代码,并在程序的两个不同地方使用同样的逻辑,如下:"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Although this code works, duplicating code is tedious and error-prone. We "
"also have to remember to update the code in multiple places when we want to "
"change it."
msgstr "虽然该代码有效, 但重复代码是乏味和易出错的。 当我们想更改代码时, 我们还必须记住要在多个地方更新代码 。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"To eliminate this duplication, we’ll create an abstraction by defining a "
"function that operates on any array of `u8` passed in a parameter. This "
"solution makes our code clearer and lets us express the concept of finding "
"the largest number in an array abstractly."
msgstr ""
"为了消除这种重复,我们将通过界定在参数中通过的任何“u8”阵列上运作的功能来创造一种抽象的概念。 "
"这一解决方案使我们的代码更加清晰,让我们抽象地表达在数列中找到最大数字的概念。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"To do that, we extract the code that finds the largest number into a "
"function named `largest`. Then we call the function to find the largest "
"number in the two arrays. We could also use the function on any other array "
"of `u8` values we might have in the future."
msgstr ""
"为此,我们将发现最大数字的代码提取成一个名为“最大”的函数。然后我们调用该函数以找到两个阵列中最大的数字。我们还可以将该函数用于我们今后可能拥有的任何其他“u8”数值阵列上。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"The largest function has a parameter called `number_list`, passed by "
"reference, which represents any concrete array of `u8` values we might pass "
"into the function. As a result, when we call the function, the code runs on "
"the specific values that we pass in."
msgstr ""
"最大函数有一个称为`编号列表'的参数,通过引用通过,该参数代表着我们可能传递到函数中的任何“u8”值的具体阵列。因此,当我们调用该函数时,代码以我们通过的具体值运行。"

#: src/ch08-00-generic-types-and-traits.md
msgid "In summary, here are the steps we took to change the code:"
msgstr "简而言之,我们为修改守则采取了以下步骤:"

#: src/ch08-00-generic-types-and-traits.md
msgid "Identify duplicate code."
msgstr "识别重复代码 。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Extract the duplicate code into the body of the function and specify the "
"inputs and return values of that code in the function signature."
msgstr "将重复代码提取到函数正文中,并在函数签名中指定该代码的输入值和返回值。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Update the two instances of duplicated code to call the function instead."
msgstr "更新两个重复代码实例, 代之以调用该函数 。"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Next, we’ll use these same steps with generics to reduce code duplication. "
"In the same way that the function body can operate on an abstract `Array<T>`"
" instead of specific `u8` values, generics allow code to operate on abstract"
" types."
msgstr ""
"接下来,我们将使用这些带有通用名词的相同步骤来减少代码重复。 同样,通用名词也可以使用抽象的“Array<T ” 来操作,而不是特定的“u8” 值。 "
"通用名词允许代码在抽象类型上操作。"

#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs"
" and functions, which we can then use with many different concrete data "
"types. In Cairo, we can use generics when defining functions, structs, "
"enums, traits, implementations and methods. In this chapter, we are going to"
" take a look at how to effectively use generic types with all of them."
msgstr ""
"我们使用通用术语来为项目申报设定定义,例如结构和功能,然后我们可以用许多不同的具体数据类型来使用这些定义。 "
"在开罗,我们可以使用通用术语来定义功能、结构、单元、特性、执行和方法。 在本章中,我们将研究如何有效地使用通用类型和所有类型。"

#: src/ch08-01-generic-data-types.md:5
msgid ""
"Generics allow us to write reusable code that works with many types, thus "
"avoiding code duplication, while enhancing code maintainability."
msgstr "通用代码使我们能够编写可重复使用的代码,该代码使用多种类型,从而避免代码重复,同时加强代码的可维护性。"

#: src/ch08-01-generic-data-types.md:7
msgid "Generic Functions"
msgstr "通用函数"

#: src/ch08-01-generic-data-types.md:9
msgid ""
"Making a function generic means it can operate on different types, avoiding "
"the need for multiple, type-specific implementations. This leads to "
"significant code reduction and increases the flexibility of the code."
msgstr "使一项功能具有通用性意味着它可以在不同类型上运作,避免需要多重的、特定类型的实施,从而导致大量减少代码并增加代码的灵活性。"

#: src/ch08-01-generic-data-types.md:11
msgid ""
"When defining a function that uses generics, we place the generics in the "
"function signature, where we would usually specify the data types of the "
"parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If "
"we need to perform this operation for lists of different types, then we "
"would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr ""
"当定义一个使用非专利的函数时,我们会在函数签名中放置非通用函数, 我们通常会在此指定参数和返回值的数据类型。 例如, 想象我们想要创建一个函数, "
"给两个“ 阵列” 项带来两个“ 阵列”, 返回最大的函数。 如果我们需要为不同类型的列表执行此操作, 那么我们就必须每次重新定义该函数。 幸运的是, "
"我们一旦使用通用参数和返回值执行该函数, 就可以执行其他任务 。"

#: src/ch08-01-generic-data-types.md:14
msgid "// Specify generic type T between the angulars\n"
msgstr "/ 指定方形之间的通用类型 T\n"

#: src/ch08-01-generic-data-types.md:27
msgid ""
"// There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
msgstr "/ 没有必要具体说明T的具体类型,因为 / / 是由汇编者推断的\n"

#: src/ch08-01-generic-data-types.md:33
msgid ""
"The `largest_list` function compares two lists of the same type and returns "
"the one with more elements and drops the other. If you compile the previous "
"code, you will notice that it will fail with an error saying that there are "
"no traits defined for dropping an array of a generic type. This happens "
"because the compiler has no way to guarantee that an `Array<T>` is droppable"
" when executing the `main` function. In order to drop an array of `T`, the "
"compiler must first know how to drop `T`. This can be fixed by specifying in"
" the function signature of `largest_list` that `T` must implement the `Drop`"
" trait. The correct function definition of `largest_list` is as follows:"
msgstr ""
"`最大列表'函数比较了同一类型的两个列表, 返回了含有更多元素的列表, 并击落了另一个。 如果您编译了上一个代码, 您将会注意到它会因错误而失败, "
"错误中说没有为丢弃一个通用类型的阵列而定义特性。 发生这种情况的原因是, 编译者无法保证在执行“ 主要” 函数时“ Array< T” 是可下载的 。 "
"为了投下一个` T'的阵列, 编译者必须首先知道如何丢弃` T'。 这可以通过在` 最大列表'函数的函数签名中指定` T'必须执行` Drop' 特性。"
" “ 大列表” 的正确功能定义如下:"

#: src/ch08-01-generic-data-types.md:45
msgid ""
"The new `largest_list` function includes in its definition the requirement "
"that whatever generic type is placed there, it must be droppable. This is "
"what we call _trait bounds_. The `main` function remains unchanged, the "
"compiler is smart enough to deduce which concrete type is being used and if "
"it implements the `Drop` trait."
msgstr ""
"新的 \" 最大清单 \" "
"功能的定义包括以下要求:无论放在哪里的通用类型,它必须是可投放的。这就是我们所称的`trait边框'。`主要'功能保持不变,汇编者足够聪明,可以推断使用的是哪种具体类型,如果它执行`滴滴'特性。"

#: src/ch08-01-generic-data-types.md:47
msgid "Constraints for Generic Types"
msgstr "通用类型限制"

#: src/ch08-01-generic-data-types.md:49
msgid ""
"When defining generic types, it is useful to have information about them. "
"Knowing which traits a generic type implements allows us to use it more "
"effectively in a function's logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this "
"previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compiler's requirements, we can also add constraints to benefit our function"
" logic."
msgstr ""
"在界定通用类型时,掌握有关通用类型的信息是有益的。了解通用类型工具的特性,使我们能够在功能逻辑中更有效地使用该功能,而代价是限制该功能可以使用的通用类型。我们以前曾看到过这方面的一个例子,在`大列表'的通用论据中增加了`TDrop'执行。虽然增加`TDrop'是为了满足汇编者的要求,但我们也可以增加一些制约,以利我们的功能逻辑。"

#: src/ch08-01-generic-data-types.md:51
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, to "
"find the smallest element among them. Initially, we know that for an element"
" of type `T` to be comparable, it must implement the `PartialOrd` trait. The"
" resulting function would be:"
msgstr ""
"想象一下,如果有一份`T'类的通用元素清单,我们想要找到其中最小元素。起初,我们知道,要使`T'类的元素具有可比性,它必须具有`部分命令'特性。"

#: src/ch08-01-generic-data-types.md:54
msgid ""
"// Given a list of T get the smallest one\n"
"// The PartialOrd trait implements comparison operations for T\n"
msgstr "/ 部分字母特性执行T类的比较操作。\n"

#: src/ch08-01-generic-data-types.md:57
msgid ""
"// This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
msgstr "这是通过迭代//通知中最小的元素, 即我们使用稀释 (*) 操作员\n"

#: src/ch08-01-generic-data-types.md:61
msgid "// The index we will use to move through the list\n"
msgstr "/ 用于在列表中移动的索引\n"

#: src/ch08-01-generic-data-types.md:64
msgid "// Iterate through the whole list storing the smallest\n"
msgstr "/ 通过整个列表循环 存储最小的\n"

#: src/ch08-01-generic-data-types.md:79
msgid ""
"// We need to specify that we are passing a snapshot of `list` as an "
"argument\n"
msgstr "我们需要具体说明,我们正在以`清单'为论据简略描述一下`清单'\n"

#: src/ch08-01-generic-data-types.md:85
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and "
"returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so"
" we are not required to implement the `Drop` trait for `T` as well. Why does"
" it not compile then?"
msgstr ""
"`小型'函数使用通用类型`T "
"',用于执行`部分字母'特性,将`Array<T'缩影作为参数,并返回最小元素的复制件。由于该参数属于'Array<T'类型,因此我们不再需要在执行结束时丢弃该参数,因此我们不必也执行`T'的`滴滴'特性。为什么它当时没有编译?"

#: src/ch08-01-generic-data-types.md:87
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element,"
" and unless `PartialOrd` is implemented for `@T` we need to desnap the "
"element using `*`. The `*` operation requires a copy from `@T` to `T`, which"
" means that `T` needs to implement the `Copy` trait. After copying an "
"element of type `@T` to `T`, there are now variables with type `T` that need"
" to be dropped, requiring `T` to implement the `Drop` trait as well. We must"
" then add both `Drop` and `Copy` traits implementation for the function to "
"be correct. After updating the `smallest_element` function the resulting "
"code would be:"
msgstr ""
"在`清单'上编制索引时,数值导致指数元素的断裂,除非`部分Ord'为`T'执行`部分Ord "
"',我们需要使用```T'来取消该元素。该操作要求从`T'复制一份到`T "
"',这意味着`T'需要执行`Copy'特性。在将`T'类型`T'类型要素复制到`T'之后,现在有需要删除的`T'类型的变量,需要`T'执行`Drop'特性。然后,我们必须增加`Drop'和`Copy'特性执行,以使函数正确。在更新`Smest_emint'函数后,由此产生的代码将:"

#: src/ch08-01-generic-data-types.md:108
msgid "Anonymous Generic Implementation Parameter (`+` Operator)"
msgstr "匿名通用执行参数(接线员)"

#: src/ch08-01-generic-data-types.md:110
msgid ""
"Until now, we have always specified a name for each implementation of the "
"required generic trait: `TPartialOrd` for `PartialOrd<T>`, `TDrop` for "
"`Drop<T>`, and `TCopy` for `Copy<T>`."
msgstr ""
"迄今为止,我们一直为每个执行所需的通用特性指定名称:`部分Ord < T'的`PartialOrd'、`Drop < T'的`TDrop'和`Copy "
"< T'的`TCopy'。"

#: src/ch08-01-generic-data-types.md:112
msgid ""
"However, most of the time, we don't use the implementation in the function "
"body; we only use it as a constraint. In these cases, we can use the `+` "
"operator to specify that the generic type must implement a trait without "
"naming the implementation. This is referred to as an _anonymous generic "
"implementation parameter_."
msgstr ""
"然而,大部分时间, 我们不使用函数机体中的执行; 我们只使用它作为制约。 在这些情况下, 我们可以使用 {{} {} {} "
"操作员来指定通用类型必须执行特性而不命名执行 。 这被称为 匿名通用执行参数_ 。"

#: src/ch08-01-generic-data-types.md:114
msgid ""
"For example, `+PartialOrd<T>` is equivalent to `impl TPartialOrd: "
"PartialOrd<T>`."
msgstr "例如,“PartialOrd<T”相当于“impl TpartialOrd:部分rord<T”。"

#: src/ch08-01-generic-data-types.md:116
msgid "We can rewrite the `smallest_element` function signature as follows:"
msgstr "我们可以重写“最小元素”功能签字如下:"

#: src/ch08-01-generic-data-types.md:134
msgid "Structs"
msgstr "条迹"

#: src/ch08-01-generic-data-types.md:136
msgid ""
"We can also define structs to use a generic type parameter for one or more "
"fields using the `<>` syntax, similar to function definitions. First, we "
"declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct "
"definition where we would otherwise specify concrete data types. The next "
"code example shows the definition `Wallet<T>` which has a `balance` field of"
" type `T`."
msgstr ""
"我们还可以使用与函数定义相似的  语法来定义用于一个或多个字段的通用类型参数。 首先,我们声明在圆形名称之后方格括号中的类型参数名称。 "
"然后,我们使用结构定义中的通用类型,否则我们将指定具体的数据类型。 下一个代码示例显示定义“Wallet < T ”, 该定义含有“T”类“平衡”字段。"

#: src/ch08-01-generic-data-types.md:149
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically."
" It is equivalent to writing the following code:"
msgstr "上述代码自动产生“瓦利特”型号的“裁剪”特性,相当于写入以下代码:"

#: src/ch08-01-generic-data-types.md:163
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and "
"instead define our own `WalletDrop` implementation. Notice that we must "
"define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying"
" that the struct `Wallet<T>` is droppable as long as `T` is also droppable."
msgstr ""
"我们避免使用`衍生'宏观来`削减'执行`瓦利特 "
"',而是定义我们自己的`瓦利特德罗普执行';我们注意到,我们必须像功能一样,为`瓦利特德罗普确定另外一种通用类型的`瓦利特德罗普 "
"',说`T'也执行`减少'特性;我们基本上说,只要`T'也可以下降,“瓦利特`塔'建筑就可下降。"

#: src/ch08-01-generic-data-types.md:165
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and "
"we want that field to be different than `T` but generic as well, we can "
"simply add another generic type between the `<>`:"
msgstr ""
"最后,如果我们想在`瓦莱特'中增加一个代表其地址的字段,并且我们希望该字段与`T'不同,但同样是一般性的,我们可以简单地在_________之间增加另一个通用类型:_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________"

#: src/ch08-01-generic-data-types.md:179
msgid ""
"We add to the `Wallet` struct definition a new generic type `U` and then "
"assign this type to the new field member `address`. Notice that the `derive`"
" attribute for the `Drop` trait works for `U` as well."
msgstr ""
"在`瓦利特'结构定义中,我们加上一个新的通用类型`U',然后将这种类型分配给新的外地成员`地址',注意`耕地'特性的`衍生'属性也用于`U'。"

#: src/ch08-01-generic-data-types.md:183
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. For example the `Option<T>` enum provided by the Cairo core "
"library:"
msgstr ""
"正如我们对待树枝时所做的那样,我们可以将昆虫定义为在其变式中保留通用数据类型。 例如开罗核心图书馆提供的“Option<T enum ” :"

#: src/ch08-01-generic-data-types.md:192
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: "
"`Some`, which holds one value of type `T` and `None` that doesn't hold any "
"value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic "
"type `T` we can use this abstraction with any type."
msgstr ""
"`Option<T'enum是属于`T'类的通用概念,有两种变式:`一些 ',它具有`T'类和`无'类的单一价值,不具有任何价值;通过`Option "
"<T'和`无 ',我们有可能表达可选价值的抽象概念,并且因为该数值具有通用的`T'类,我们可以使用这种抽象,任何类型。"

#: src/ch08-01-generic-data-types.md:194
msgid ""
"Enums can use multiple generic types as well, like the definition of the "
"`Result<T, E>` enum that the core library provides:"
msgstr "Enums也可以使用多种通用类型,例如核心图书馆提供的`Result<T,E enum'的定义:"

#: src/ch08-01-generic-data-types.md:203 src/ch09-02-recoverable-errors.md:16
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two "
"variants: `Ok` which holds the value of type `T` and `Err` which holds the "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (by returning a value "
"of type `T`) or fail (by returning a value of type `E`)."
msgstr ""
"`Result<T, E enum有两种通用类型,即`T'和`E ',还有两种变式:`Ok ',其价值为`T'和`Err ',其价值为`E "
"',这一定义方便地使用`Result'enum,只要我们有一个可能成功(返回`T'类价值)或失败(返回`E'类价值)的操作,即使用`Result'enum。"

#: src/ch08-01-generic-data-types.md:205
msgid "Generic Methods"
msgstr "通用方法"

#: src/ch08-01-generic-data-types.md:207
msgid ""
"We can implement methods on structs and enums, and use the generic types in "
"their definitions, too. Using our previous definition of `Wallet<T>` struct,"
" we define a `balance` method for it:"
msgstr "我们可以对建筑和建筑实施方法,并使用其定义中的通用类型。我们用我们先前的“瓦莱特”和“瓦莱特”的定义,为它界定了一种“平衡”方法:"

#: src/ch08-01-generic-data-types.md:231
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which "
"defines a method that returns the value of the field `balance` from "
"`Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. "
"Note that you need to include a generic type in both definitions of the "
"trait and the implementation."
msgstr ""
"我们首先使用通用类型“T”来定义“WalletTrait<T”特性,界定一种从“Wallet”中返回字段“平衡”价值的方法,然后我们为“WalletImpl<T”中的特性提供一种执行方法。请注意,在特性定义和执行定义中,需要包括一种通用类型。"

#: src/ch08-01-generic-data-types.md:233
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only for `Wallet<u128>` "
"instances rather than `Wallet<T>`. In the code example, we define an "
"implementation for wallets which have a concrete type of `u128` for the "
"`balance` field."
msgstr ""
"在界定该类型方法时,我们还可以具体说明对通用类型的限制,例如,我们只能对“Wallet<u128}”案例而不是“Wallet<T}”案例实施方法。在代码中,我们定义了对“平衡”字段具体类型为“u128”的钱包实施方法。"

#: src/ch08-01-generic-data-types.md:240
msgid "/// Generic trait for wallets\n"
msgstr "// 钱包的通用特性\n"

#: src/ch08-01-generic-data-types.md:251
msgid "/// Trait for wallets of type u128\n"
msgstr "// 用于 u128 类型钱包的 trit\n"

#: src/ch08-01-generic-data-types.md:272
msgid ""
"The new method `receive` increments the size of `balance` of any instance of"
" a `Wallet<u128>`. Notice that we changed the `main` function making `w` a "
"mutable variable in order for it to be able to update its balance. If we "
"were to change the initialization of `w` by changing the type of `balance` "
"the previous code wouldn't compile."
msgstr ""
"新的方法`收到'增加`平衡'的大小,相当于`Wallet<u128'的任何实例`平衡'的大小,通知我们改变了`主要'功能,使`w'变异变量能够更新其平衡,如果我们改变`w'的初始化,改变`平衡'的类型,以前的代码不会编译。"

#: src/ch08-01-generic-data-types.md:274
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. "
"Using the past implementation from `Wallet<U, V>` we are going to define a "
"trait that picks two wallets of different generic types and creates a new "
"one with a generic type of each. First, let's rewrite the struct definition:"
msgstr ""
"开罗也允许我们在通用特性内定义通用方法。 使用“ Wallet< U, V, V” 中的过去实施方法, 我们将定义一个特性, "
"选择两种不同通用类型的钱包, 并创建一个新的通用类型。 首先, 让我们重写结构定义 :"

#: src/ch08-01-generic-data-types.md:283
msgid ""
"Next, we are going to naively define the mixup trait and implementation:"
msgstr "接下来,我们将天真地界定混杂的特点和执行:"

#: src/ch08-01-generic-data-types.md:286
msgid "// This does not compile!\n"
msgstr "/这没有汇编!\n"

#: src/ch08-01-generic-data-types.md:299
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` "
"method which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` "
"creates a new `Wallet<T1, U2>`. As `mixup` signature specifies, both `self` "
"and `other` are getting dropped at the end of the function, which is why "
"this code does not compile. If you have been following from the start until "
"now you would know that we must add a requirement for all the generic types "
"specifying that they will implement the `Drop` trait for the compiler to "
"know how to drop instances of `Wallet<T, U>`. The updated implementation is "
"as follows:"
msgstr ""
"我们正在创建一种特性“WalletMixTrait<T1, U1 ”和“Mixup<T2, U2 ”方法,其中给出了“Wallet<T1, U1 "
"}和“Wallet<T2, U2 }”和“Wallet<T2, U2 }”的示例。正如“Wallet<T1, U2 "
"}”的签名所指明的,“自我”和“其他”都在功能的结尾处被丢弃,这就是为什么本代码没有编译的原因。如果你从开始到现在一直遵循,你就会知道,我们必须对所有通用类型增加一项要求,说明它们将执行“Drop”特性,让编译者知道如何投放“Wallet<T,"
" U ” 。更新后的执行情况如下:"

#: src/ch08-01-generic-data-types.md:317
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl`"
" declaration. Then we do the same for `T2` and `U2`, this time as part of "
"`mixup` signature. We can now try the `mixup` function:"
msgstr ""
"我们添加了“T1”和“U1”的要求,以便在“瓦利特混合化Impl”声明上可以删除。然后,我们作为“混合”签字的一部分,对“T2”和“U2”也这样做。我们现在可以尝试“混合”功能:"

#: src/ch08-01-generic-data-types.md:331
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, "
"u8>` instance."
msgstr ""
"我们首先创造两个例子:一个是“Wallet<bool, u128”,另一个是“Wallet<felt252, "
"u8”。然后,我们称之为“混合”并创建一个新的“Wallet<bool, u8”实例。"

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"A trait defines a set of methods that can be implemented by a type. These "
"methods can be called on instances of the type when this trait is "
"implemented. A trait combined with a generic type defines functionality a "
"particular type has and can share with other types. We can use traits to "
"define shared behavior in an abstract way. We can use _trait bounds_ to "
"specify that a generic type can be any type that has certain behavior."
msgstr ""
"特性定义了能够用某类型执行的一套方法。 这些方法可以使用该特性执行时的类型实例。 特性与通用类型结合, 定义了特定类型拥有并且可以与其他类型共享的功能。"
" 我们可以使用特性来抽象地定义共同的行为。 我们可以使用 trait 界限_ 来指定一个通用类型可以是任何具有某种行为的类型。"

#: src/ch08-02-traits-in-cairo.md:7
msgid ""
"Note: Traits are similar to a feature often called interfaces in other "
"languages, although with some differences."
msgstr "注:轨迹与其他语言通常称为界面的特征相似,但有一些差异。"

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"While traits can be written to not accept generic types, they are most "
"useful when used with generic types. We already covered generics in the "
"[previous chapter](./ch08-01-generic-data-types.md), and we will use them in"
" this chapter to demonstrate how traits can be used to define shared "
"behavior for generic types."
msgstr ""
"虽然特征可以写成不接受通用类型,但在使用通用类型时最有用。 我们已经在[前一章](./ch08-01-generic- data-"
"types.md)中涵盖了通用类型,我们将在本章中使用这些特征来说明如何使用这些特征来界定通用类型的共同行为。"

#: src/ch08-02-traits-in-cairo.md:13
msgid "Defining a Trait"
msgstr "定义Trait"

#: src/ch08-02-traits-in-cairo.md:15
msgid ""
"A type’s behavior consists of the methods we can call on that type. "
"Different types share the same behavior if we can call the same methods on "
"all of those types. Trait definitions are a way to group method signatures "
"together to define a set of behaviors necessary to accomplish some purpose."
msgstr ""
"一种类型的行为包括我们可以要求使用的方法。 不同类型的行为相同,如果我们可以对所有类型都使用同样的方法。 "
"Trait定义是一种将方法签名组合在一起的方法,以定义实现某种目的所需的一系列行为。"

#: src/ch08-02-traits-in-cairo.md:17
msgid ""
"For example, let’s say we have a struct `NewsArticle` that holds a news "
"story in a particular location. We can define a trait `Summary` that "
"describes the behavior of something that can summarize the `NewsArticle` "
"type."
msgstr ""
"例如,我们可以说,我们有一个在特定地点有新闻故事的“新闻文章”结构,我们可以定义一个“摘要”特征,描述可以总结“新闻文章”类型的东西的行为。"

#: src/ch08-02-traits-in-cairo.md:34
msgid "\"{:?} by {:?} ({:?})\""
msgstr ""
"\"{{{{{{{{{{{{}}by "
"{{{}}}}{{{{{{}}}}}{{{}}}{{}}}{{{}}}}by{{{{}}}}}}}}{{{{{{{}}}}}}}{{{{{{{{}}}}}}}}}}}({{{{{}}}}}}}}}}\"。"

#: src/ch08-02-traits-in-cairo.md:41
msgid ""
"Here, we declare a trait using the `trait` keyword and then the trait’s "
"name, which is `Summary` in this case. We’ve also declared the trait as "
"`pub` so that crates depending on this crate can make use of this trait too,"
" as we’ll see in a few examples."
msgstr ""
"在此,我们用`trait'关键词,然后用该特性的名称,即本案中的`摘要'来宣布一个特性,我们还宣布该特性为`pub "
"',以便依赖这一箱的箱子也能使用这一特性,我们将在几个例子中看到这一点。"

#: src/ch08-02-traits-in-cairo.md:44
msgid ""
"Inside the curly brackets, we declare the method signatures that describe "
"the behaviors of the types that implement this trait, which in this case is "
"`fn summarize(self: @NewsArticle) -> ByteArray;`. After the method "
"signature, instead of providing an implementation within curly brackets, we "
"use a semicolon."
msgstr ""
"在括弧内,我们声明描述执行该特性的类型的行为的方法签字,在这种情况下,该签字是`fn摘要(本身:@NewsArray) - > "
"ByteArray;`。在方法签字之后,我们使用分号,而不是在括弧内提供执行。"

#: src/ch08-02-traits-in-cairo.md:46
msgid ""
"Note: the `ByteArray` type is the type used to represent strings in Cairo."
msgstr "注:`ByteAray'类型是开罗用于表示字符串的类型。"

#: src/ch08-02-traits-in-cairo.md:48
msgid ""
"As the trait is not generic, the `self` parameter is not generic either and "
"is of type `@NewsArticle`. This means that the `summarize` method can only "
"be called on instances of `NewsArticle`."
msgstr ""
"由于特性不是通用的,“自我”参数也不是通用的,属于“News article”类型,这意味着“概述”方法只能根据“News Artices”的情况使用。"

#: src/ch08-02-traits-in-cairo.md:50
msgid ""
"Now, consider that we want to make a media aggregator library crate named "
"_aggregator_ that can display summaries of data that might be stored in a "
"`NewsArticle` or `Tweet` instance. To do this, we need a summary from each "
"type, and we’ll request that summary by calling a summarize method on an "
"instance of that type. By defining the `Summary` trait on generic type `T`, "
"we can implement the `summarize` method on any type we want to be able to "
"summarize."
msgstr ""
"现在,考虑一下,我们要制作一个名为 _aggator_ "
"的媒体聚合库箱,该箱可以显示可能存储在`NewsArt'或`Tweet'实例中的数据摘要。要做到这一点,我们需要每个类型的摘要,我们将通过在这类实例中使用一个摘要方法来请求汇总。通过定义通用类型`T'的`摘要'特性,我们可以在任何类型中执行“摘要”方法,我们希望能够总结的任何类型。"

#: src/ch08-02-traits-in-cairo.md:68 src/ch08-02-traits-in-cairo.md:145
#: src/ch08-02-traits-in-cairo.md:222
msgid "\"{} by {} ({})\""
msgstr "()\""

#: src/ch08-02-traits-in-cairo.md:82 src/ch08-02-traits-in-cairo.md:159
#: src/ch08-02-traits-in-cairo.md:236
msgid "\"{}: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:91 src/ch08-02-traits-in-cairo.md:168
#: src/ch08-02-traits-in-cairo.md:245
msgid "\"Cairo has become the most popular language for developers\""
msgstr "\"Cairo已经成为开发商最流行的语言\""

#: src/ch08-02-traits-in-cairo.md:92 src/ch08-02-traits-in-cairo.md:169
#: src/ch08-02-traits-in-cairo.md:246
msgid "\"Worldwide\""
msgstr "\"世界范围\""

#: src/ch08-02-traits-in-cairo.md:93 src/ch08-02-traits-in-cairo.md:170
#: src/ch08-02-traits-in-cairo.md:247
msgid "\"Cairo Digger\""
msgstr "\"凯罗·迪格尔\""

#: src/ch08-02-traits-in-cairo.md:94 src/ch08-02-traits-in-cairo.md:171
#: src/ch08-02-traits-in-cairo.md:248
msgid "\"Cairo is a new programming language for zero-knowledge proofs\""
msgstr "\"开罗是零知识证明的新编程语言\""

#: src/ch08-02-traits-in-cairo.md:98 src/ch08-02-traits-in-cairo.md:175
#: src/ch08-02-traits-in-cairo.md:252
msgid "\"EliBenSasson\""
msgstr "\"伊利本萨森\""

#: src/ch08-02-traits-in-cairo.md:99 src/ch08-02-traits-in-cairo.md:176
#: src/ch08-02-traits-in-cairo.md:253
msgid ""
"\"Crypto is full of short-term maximizing projects. \\n @Starknet and "
"@StarkWareLtd are about long-term vision maximization.\""
msgstr "“Crypto充满了短期最大化项目。\\n @starknet和@starkWareLtd都是关于长期愿景最大化的。"

#: src/ch08-02-traits-in-cairo.md:102 src/ch08-02-traits-in-cairo.md:179
#: src/ch08-02-traits-in-cairo.md:256
msgid "// Tweet instantiation\n"
msgstr "/ 微调即时\n"

#: src/ch08-02-traits-in-cairo.md:104 src/ch08-02-traits-in-cairo.md:181
#: src/ch08-02-traits-in-cairo.md:258
msgid "\"New article available! {}\""
msgstr "\"有新文章!\""

#: src/ch08-02-traits-in-cairo.md:105 src/ch08-02-traits-in-cairo.md:182
#: src/ch08-02-traits-in-cairo.md:259
msgid "\"New tweet! {}\""
msgstr "\"新的推特!\""

#: src/ch08-02-traits-in-cairo.md:111
msgid ""
"<span class=\"caption\">A `Summary` trait that consists of the behavior "
"provided by a `summarize` method</span>"
msgstr "<span类=“Caption” > > A`摘要'特性,由`摘要'方法 </span>提供的行为构成"

#: src/ch08-02-traits-in-cairo.md:113
msgid ""
"Each type implementing this trait must provide its own custom behavior for "
"the body of the method. The compiler will enforce that any type that "
"implements the `Summary` trait will have the method `summarize` defined with"
" this signature exactly."
msgstr ""
"执行该特性的每一种类型都必须为该方法的体体提供自己的习惯行为。 汇编者将强制要求, 执行“ 摘要” 特性的任何类型都将有精确的“ 概要” 方法, "
"由此签名来定义 。"

#: src/ch08-02-traits-in-cairo.md:115
msgid ""
"A trait can have multiple methods in its body: the method signatures are "
"listed one per line and each line ends in a semicolon."
msgstr "特征在身体上可以有多种方法:方法特征每行列出一个,每一行以分号结尾。"

#: src/ch08-02-traits-in-cairo.md:117
msgid "Implementing a Trait on a Type"
msgstr "执行一种类型上的轨迹"

#: src/ch08-02-traits-in-cairo.md:119
msgid ""
"Now that we’ve defined the desired signatures of the `Summary` trait’s "
"methods, we can implement it on the types in our media aggregator. The "
"following code shows an implementation of the `Summary` trait on the "
"`NewsArticle` struct that uses the headline, the author, and the location to"
" create the return value of `summarize`. For the `Tweet` struct, we define "
"`summarize` as the username followed by the entire text of the tweet, "
"assuming that tweet content is already limited to 280 characters."
msgstr ""
"既然我们已经定义了`摘要'特性方法的预期特征,我们可以在媒体聚合器中将它作为类型加以执行,以下代码显示“摘要”特性在使用头条标题、作者和创建`摘要'返回价值的地点的`新文章'结构上的执行。关于`摘要'结构,我们将`摘要'定义为用户名,然后是整个推文的全文,假设推文内容已经限于280个字符。"

#: src/ch08-02-traits-in-cairo.md:188
msgid ""
"Implementing a trait on a type is similar to implementing regular methods. "
"The difference is that after `impl`, we put a name for the implementation, "
"then use the `of` keyword, and then specify the name of the trait we are "
"writing the implementation for. If the implementation is for a generic type,"
" we place the generic type name in the angle brackets after the trait name."
msgstr ""
"在某类型上实施特性与执行常规方法相似,不同之处在于,在“简化”之后,我们为实施设置了名称,然后使用“关键字”的名称,然后指定正在写入执行的特性的名称。如果执行是通用类型,则在特性名称之后将通用类型名称置于括号内。"

#: src/ch08-02-traits-in-cairo.md:193
msgid ""
"Note that for the trait method to be accessible, there must be an "
"implementation of that trait visible from the scope where the method is "
"called. If the trait is `pub` and the implementation is not, and the "
"implementation is not visible in the scope where the trait method is called,"
" this will cause a compilation error."
msgstr ""
"请注意,要便于使用特性方法,必须执行该特性,从该方法的名称范围中可以看出。如果该特性是`pub',而该特性不是`pub',而该特性方法的名称范围中无法看到该特性方法,则会造成编译错误。"

#: src/ch08-02-traits-in-cairo.md:195
msgid ""
"Within the `impl` block, we put the method signatures that the trait "
"definition has defined. Instead of adding a semicolon after each signature, "
"we use curly brackets and fill in the method body with the specific behavior"
" that we want the methods of the trait to have for the particular type."
msgstr ""
"在“简化”块内,我们把特质定义定义所定义的方法符号放入其中。我们不是在每次签名后添加分号,而是使用卷括号,在方法体中填充我们想要特定类型特质方法的具体行为。"

#: src/ch08-02-traits-in-cairo.md:200
msgid ""
"Now that the library has implemented the `Summary` trait on `NewsArticle` "
"and `Tweet`, users of the crate can call the trait methods on instances of "
"`NewsArticle` and `Tweet` in the same way we call regular methods. The only "
"difference is that the user must bring the trait into scope as well as the "
"types. Here’s an example of how a crate could use our `aggregator` crate:"
msgstr ""
"既然图书馆已经实施了`新闻组'和`新闻组'上的`摘要'特性,箱内的用户可以用我们所称的常规方法同样的方式将特性方法称为`新闻组'和`网络组'。唯一的区别是,用户必须把特性纳入范围和类型。"

#: src/ch08-02-traits-in-cairo.md:265
msgid "This code prints the following:"
msgstr "此代码打印如下 :"

#: src/ch08-02-traits-in-cairo.md:279
msgid ""
"Other crates that depend on the _aggregator_ crate can also bring the "
"`Summary` trait into scope to implement `Summary` on their own types."
msgstr "依赖_聚合箱的其他箱子也可以将`摘要'特性带入范围,以在自己的类型上实施`摘要'。"

#: src/ch08-02-traits-in-cairo.md:304
msgid "Managing and Using External Trait"
msgstr ""
"管理和利用外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外的外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外外"

#: src/ch08-02-traits-in-cairo.md:306
msgid ""
"To use traits methods, you need to make sure the correct "
"traits/implementation(s) are imported. In some cases you might need to "
"import not only the trait but also the implementation if they are declared "
"in separate modules. If `CircleGeometry` implementation was in a separate "
"module/file named _circle_, then to define `boundary` method on `Circle` "
"struct, we'd need to import `ShapeGeometry` trait in the _circle_ module."
msgstr ""
"要使用特性方法, 您需要确保导入正确的特性/ 执行 。 在某些情况下, 您需要导入的不仅是特性/ 执行, 如果在不同的模块中声明, "
"您可能需要导入这些特性/ 执行 。 如果“ 环形测量” 的实施是在名为 _ 环形 的单独模块/ 文件中进行, 然后定义“ 环形” 构造上的“ 边界” "
"方法, 我们需要在 _ 环形 模块中导入“ 形状” 特性 。"

#: src/ch08-02-traits-in-cairo.md:309
msgid ""
"If the code was organized into modules like this, where the implementation "
"of a trait was defined in a different module than the trait itself, "
"explicitly importing the relevant trait or implementation is required."
msgstr "如果该代码是按这种模块编排的,那么在不同的模块中与特性本身不同地界定了特性的实施,则需要明确输入相关特性或实施。"

#: src/ch08-02-traits-in-cairo.md:312
msgid ""
"// Here T is an alias type which will be provided during implementation\n"
msgstr "此处T是实施期间将提供的别名类型。\n"

#: src/ch08-02-traits-in-cairo.md:319
msgid ""
"// Importing ShapeGeometry is required to implement this trait for "
"Rectangle\n"
msgstr "/ 执行矩形的这一特性需要导入形状结构测量法。\n"

#: src/ch08-02-traits-in-cairo.md:328
msgid ""
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"    // to implement the trait for that type\n"
msgstr "/ 执行在 < 矩形 > / / 执行该类型特性的矩形构造通道\n"

#: src/ch08-02-traits-in-cairo.md:341
msgid ""
"// Importing ShapeGeometry is required to implement this trait for Circle\n"
msgstr "/ 需要进口形状结构测量法来实施此圆形特性\n"

#: src/ch08-02-traits-in-cairo.md:349
msgid ""
"// Implementation CircleGeometry passes in <Circle>\n"
"    // to implement the imported trait for that type\n"
msgstr "在 < 环环圈 > // 用于执行该类型的进口特性的执行圆形构造通行证// 用于执行该类型的进口特性\n"

#: src/ch08-02-traits-in-cairo.md:366
msgid "\"Rectangle area: {}\""
msgstr "\"赤色区域: \""

#: src/ch08-02-traits-in-cairo.md:366
msgid "//35\n"
msgstr "/35 /35\n"

#: src/ch08-02-traits-in-cairo.md:367
msgid "\"Rectangle boundary: {}\""
msgstr "\"龙形边界: \""

#: src/ch08-02-traits-in-cairo.md:367
msgid "//24\n"
msgstr "/24\n"

#: src/ch08-02-traits-in-cairo.md:370
msgid "\"Circle area: {}\""
msgstr "\"圆圈区域: \""

#: src/ch08-02-traits-in-cairo.md:370
msgid "//78\n"
msgstr "/78 /78\n"

#: src/ch08-02-traits-in-cairo.md:371
msgid "\"Circle boundary: {}\""
msgstr ""
"“圆圈边界:_________________________________________________________________________________________________________________________________________________________________________"

#: src/ch08-02-traits-in-cairo.md:371
msgid "//31\n"
msgstr "/31\n"

#: src/ch08-02-traits-in-cairo.md:375
msgid ""
"Note that in this example, `CircleGeometry` and `RectangleGeometry` "
"implementations don't need to be declared as `pub`. Indeed, `ShapeGeometry` "
"trait, which is public, is used to print the result in the `main` function. "
"The compiler will find the appropriate implementation for the "
"`ShapeGeometry` public trait, regardless of the implementation visibility."
msgstr ""
"请注意,在这个例子中,`环形计量'和`矩形计量'执行不需要被宣布为`pub "
"',事实上,`ShapeGhophat'特性是公开的,用来印刷`主要'功能的结果,汇编者将找到`ShapeGhophat'公共特性的适当执行,而不论执行的能见度如何。"

#: src/ch08-02-traits-in-cairo.md:377
msgid "Impl Aliases"
msgstr "Impl 别名"

#: src/ch08-02-traits-in-cairo.md:379
msgid ""
"Implementations can be aliased when imported. This is most useful when you "
"want to instantiate generic implementations with concrete types. For "
"example, let's say we define a trait `Two` that is used to return the value "
"`2` for a type `T`. We can write a trivial generic implementation of `Two` "
"for all types that implement the `One` trait, simply by adding twice the "
"value of `one` and returning it. However, in our public API, we may only "
"want to expose the `Two` implementation for the `u8` and `u128` types."
msgstr ""
"导入时可以用别名来表示执行。当您想要用具体类型即刻执行通用执行时,这是非常有用的。例如,让我们说,我们定义一个特性`二 "
"',用来返回`T'类的`2'值。我们可以就所有类型实施`一个'特性的`二 "
"',简单地将`一个'的值增加一倍,然后将其还原。然而,在我们公开的API中,我们可能只想揭露`u8'和`u128'类的`两个`执行'。"

#: src/ch08-02-traits-in-cairo.md:400
msgid ""
"<span class=\"caption\"> Listing 8-1: Using impl aliases to instantiate "
"generic impls with concrete types</span>"
msgstr "<span类=“caption” > 列表 8-1:使用光化别名即时化具有具体类型 </span> 的通用 Indipls"

#: src/ch08-02-traits-in-cairo.md:402
msgid ""
"We can define the generic implementation in a private module, use an impl "
"alias to instantiate the generic implementation for these two concrete "
"types, and make these two implementations public, while keeping the generic "
"implementation private and unexposed. This way, we can avoid code "
"duplication using the generic implementation, while keeping the public API "
"clean and simple."
msgstr ""
"我们可以在私人模块中定义通用实施,用插头别名来即时执行这两种具体类型的通用实施,并公开这两种实施,同时将通用实施私密和未暴露。 "
"这样,我们可以避免使用通用实施代码的重复,同时保持公共API的简洁和简单化。"

#: src/ch08-02-traits-in-cairo.md:404
msgid "Negative Impls"
msgstr "负负因数"

#: src/ch08-02-traits-in-cairo.md:406
msgid ""
"Note: This is still an experimental feature and can only be used if "
"`experimental-features = [\"negative_impls\"]` is enabled in your "
"_Scarb.toml_ file, under the `[package]` section."
msgstr ""
"注意:这仍然是一个实验性特征,只有在“[包装]”部分下您的 "
"_Scarb.toml_文件启用了`实验性地物=[“阴性_impls'’'`实验性地物'的情况下,才能使用。"

#: src/ch08-02-traits-in-cairo.md:408
msgid ""
"Negative implementations, also known as negative traits or negative bounds, "
"are a mechanism that allows you to express that a type does not implement a "
"certain trait when defining the implementation of a trait over a generic "
"type. Negative impls enable you to write implementations that are applicable"
" only when another implementation does not exist in the current scope."
msgstr ""
"负执行(又称负特性或负边框)是一种机制,它允许您表达一种类型在定义对普通类型实施特性时不执行某种特性。负内径使您能够写入仅在目前范围内不存在另一种执行时才适用的执行。"

#: src/ch08-02-traits-in-cairo.md:410
msgid ""
"For example, let's say we have a trait `Producer` and a trait `Consumer`, "
"and we want to define a generic behavior where all types implement the "
"`Consumer` trait by default. However, we want to ensure that no type can be "
"both a `Consumer` and a `Producer`. We can use negative impls to express "
"this restriction."
msgstr ""
"例如,让我们说,我们有一个`制造者'和`消费者'的特性,我们想界定一种通用行为,即所有类型都默认地实施`消费者'的特性,然而,我们想确保任何类型都不能既是`消费者'又是`生产者"
" ',我们可以用负分泌来表达这种限制。"

#: src/ch08-02-traits-in-cairo.md:412
msgid ""
"In Listing 8-2, we define a `ProducerType` that implements the `Producer` "
"trait, and two other types, `AnotherType` and `AThirdType`, which do not "
"implement the `Producer` trait. We then use negative impls to create a "
"default implementation of the `Consumer` trait for all types that do not "
"implement the `Producer` trait."
msgstr ""
"在清单8-2中,我们定义了一种`生产者'特性的`生产者'类型,以及另外两种不执行`生产者'特性的`其他类型'和`第三类型'的`生产者'特性的`生产者'类型,然后我们用负分母来为不执行`生产者'特性的所有类型创建默认执行`消费者'特性的`消费者'类型。"

#: src/ch08-02-traits-in-cairo.md:440
msgid "\"{:?} consumed value: {}\""
msgstr ""
"\"{{:}消费值:____________________________________________________________________________________________________________________________"

#: src/ch08-02-traits-in-cairo.md:450
msgid ""
"// producer.consumer(production); Invalid: ProducerType does not implement "
"Consumer\n"
msgstr ""
"/ 生产者. 消费者(生产); 无效: 生产者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- "
"消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- "
"消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- "
"消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- "
"消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 生产者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- "
"消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 生产者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- "
"消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者- 消费者-\n"

#: src/ch08-02-traits-in-cairo.md:456
msgid ""
"<span class=\"caption\"> Listing 8-2: Using negative impls to enforce that a"
" type cannot implement both `Producer` and `Consumer` traits "
"simultaneously</span>"
msgstr ""
"<span类=“Caption” > Listing 8-2:使用负墨漏强制要求某类型不能同时执行 </span> \" 和 \" 开户'特性 \" 。"

#: src/ch08-02-traits-in-cairo.md:458
msgid ""
"In the `main` function, we create instances of `ProducerType`, "
"`AnotherType`, and `AThirdType`. We then call the `produce` method on the "
"`producer` instance and pass the result to the `consume` method on the "
"`another_type` and `third_type` instances. Finally, we try to call the "
"`consume` method on the `producer` instance, which results in a compile-time"
" error because `ProducerType` does not implement the `Consumer` trait."
msgstr ""
"在`主要'函数中,我们创建了`生产机类型'、`另一类类型'和`第三类类型'实例,然后我们将`生产机类型'实例称为`生产方法 "
"',并将结果传递给`另一类类型'和`第三类类型'实例的`集成方法';最后,我们试图将`生产机类型'实例称为`集成方法 "
"',结果产生编译时间错误,因为`生产机类型'不执行`消费机类型'特性。"

#: src/ch08-02-traits-in-cairo.md:460
msgid "{{#quiz ../quizzes/ch08-02-traits.toml}}"
msgstr "Quiz./quizzes/ch08-02-traits.toml"

#: src/ch09-00-error-handling.md
msgid "Error handling"
msgstr "错误处理错误处理"

#: src/ch09-00-error-handling.md
msgid ""
"In this chapter, we will explore various error handling techniques provided "
"by Cairo, which not only allow you to address potential issues in your code,"
" but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as "
"pattern matching with the `Result` enum, using the `?` operator for more "
"ergonomic error propagation, and employing the `unwrap` or `expect` methods "
"for handling recoverable errors, you'll gain a deeper understanding of "
"Cairo's error handling features. These concepts are crucial for building "
"robust applications that can effectively handle unexpected situations, "
"ensuring your code is ready for production."
msgstr ""
"在本章中,我们将探讨开罗提供的各种错误处理技术,这些技术不仅使您能够解决代码中的潜在问题,而且还使创建适应性强和可维持的程序更加容易。通过研究管理错误的不同方法,例如与`Result'"
" enum 匹配的模式,使用`?' "
"运算器进行更多的人类工程错误传播,以及使用`unlop'或`预期'方法处理可回收错误,您将更深入地了解开罗的错误处理功能。这些概念对于建立能够有效处理意外情况的稳健应用程序至关重要,确保您的代码可以制作。"

#: src/ch09-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with `panic`"
msgstr "“panic” 的无法恢复错误"

#: src/ch09-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in"
" runtime errors. While the `panic` function from the core library doesn't "
"provide a resolution for these errors, it does acknowledge their occurrence "
"and terminates the program. There are two primary ways that a panic can be "
"triggered in Cairo: inadvertently, through actions causing the code to panic"
" (e.g., accessing an array beyond its bounds), or deliberately, by invoking "
"the `panic` function."
msgstr ""
"在开罗,程序执行期间可能会出现意外问题,导致运行时间错误。 虽然核心图书馆的“ 普通” 功能不能为这些错误提供解决方案, "
"但它确实承认了这些错误的发生并终止了程序。 开罗有两种主要方式可以引发恐慌: 无意中, 导致代码恐慌的行动( 例如, 访问超出其界限的阵列), 或故意,"
" 引用“ 普通” 功能 。"

#: src/ch09-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The "
"`panic` function takes an array as an argument, which can be used to provide"
" an error message and performs an unwind process where all variables are "
"dropped and dictionaries squashed to ensure the soundness of the program to "
"safely terminate the execution."
msgstr ""
"当发生恐慌时,它会导致程序突然终止。“panic”函数将一个阵列作为参数,用于提供错误信息,并进行一个无线进程,即所有变量被丢弃,词典被压碎,以确保程序稳妥,安全终止执行。"

#: src/ch09-01-unrecoverable-errors-with-panic.md:7
msgid ""
"Here is how we can call `panic` from inside a program and return the error "
"code `2`:"
msgstr "下面我们如何从程序内称为`panic'并返回错误代码`2':"

#: src/ch09-01-unrecoverable-errors-with-panic.md:18
#: src/ch09-01-unrecoverable-errors-with-panic.md:58
msgid "\"This line isn't reached\""
msgstr "\"这条线没有达到\""

#: src/ch09-01-unrecoverable-errors-with-panic.md:22
msgid "Running the program will produce the following output:"
msgstr "运行程序将产生以下产出:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:33
msgid ""
"As you can notice in the output, the call to `println!` macro is never "
"reached, as the program terminates after encountering the `panic` statement."
msgstr "正如您在输出中注意到的那样,“println!” 宏的号召从未达到,因为程序在遇到“panic” 语句后终止。"

#: src/ch09-01-unrecoverable-errors-with-panic.md:35
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use"
" the `panic_with_felt252` function. This function serves as an abstraction "
"of the array-defining process and is often preferred due to its clearer and "
"more concise expression of intent. By using `panic_with_felt252`, developers"
" can panic in a one-liner by providing a `felt252` error message as an "
"argument, making the code more readable and maintainable."
msgstr ""
"开罗的另一种更普通的恐慌应对办法是使用`panic_with_felt252'功能,作为阵列定义过程的抽象,由于表达的意向更清楚、更简洁,这一功能往往更可取。通过使用`panic_with_felt252"
" ',开发商可以通过提供“felt252”错误信息作为论据,在单行中制造恐慌,使代码更易读、更便于维护。"

#: src/ch09-01-unrecoverable-errors-with-panic.md:37
msgid "Let's consider an example:"
msgstr "举个例子:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:47
msgid ""
"Executing this program will yield the same error message as before. In that "
"case, if there is no need for an array and multiple values to be returned "
"within the error, `panic_with_felt252` is a more succinct alternative."
msgstr ""
"执行此程序将产生与以前相同的错误消息。 在此情况下, 如果在错误中不需要返回一个数组和多个值, `panic_ without_felt252' "
"是更简洁的替代方案 。"

#: src/ch09-01-unrecoverable-errors-with-panic.md:49 src/ch11-05-macros.md:29
msgid "`panic!` Macro"
msgstr "`西班牙人!'宏观"

#: src/ch09-01-unrecoverable-errors-with-panic.md:51
msgid ""
"`panic!` macro can be really helpful. The previous example returning the "
"error code `2` shows how convenient `panic!` macro is. There is no need to "
"create an array and pass it as an argument like with the `panic` function."
msgstr ""
"`panic!' 宏确实有用, 返回错误代号` 2' 的上一个示例显示“panic!' 宏多么方便。 不需要创建阵列, 将其作为“ panic” "
"函数的参数传递 。"

#: src/ch09-01-unrecoverable-errors-with-panic.md:56
msgid "\"2\""
msgstr "\"2\" \"2\" \"2\" \"2\""

#: src/ch09-01-unrecoverable-errors-with-panic.md:62
msgid ""
"Unlike the `panic_with_felt252` function, using `panic!` allows the input, "
"which is ultimately the panic error, to be a literal longer than 31 bytes. "
"This is because `panic!` takes a string as a parameter. For example, the "
"following line of code will successfully compile:"
msgstr ""
"与`panic_with_felt252' 函数不同的是,使用`panic!' "
"允许输入(即最终的恐慌错误)在字面上超过31字节。这是因为`panic!'将字符串作为一个参数。例如,以下的代码行将成功编译 :"

#: src/ch09-01-unrecoverable-errors-with-panic.md:65
msgid "\"the error for panic! macro is not limited to 31 characters anymore\""
msgstr "\"惊慌的错误! 宏不再局限于31个字符\""

#: src/ch09-01-unrecoverable-errors-with-panic.md:68
msgid "`nopanic` Notation"
msgstr "`无西班牙人'标记"

#: src/ch09-01-unrecoverable-errors-with-panic.md:70
msgid ""
"You can use the `nopanic` notation to indicate that a function will never "
"panic. Only `nopanic` functions can be called in a function annotated as "
"`nopanic`."
msgstr "您可以使用“空泛”符号表示函数永远不会惊慌,只有“空泛”函数才可以在附加注释的“空泛”函数中调用“空泛”函数。"

#: src/ch09-01-unrecoverable-errors-with-panic.md:80
msgid ""
"This function will always return `42` and is guaranteed to never panic. "
"Conversely, the following function is not guaranteed to never panic:"
msgstr "此函数将总是返回'42 ',并且保证永远不惊慌。 相反,以下函数不能保证永远不惊慌:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:88
msgid ""
"If you try to compile this function that includes code that may panic, you "
"will get the following error:"
msgstr "如果您试图编译包含可能恐慌的代码的此函数, 就会有以下错误:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:108
msgid ""
"Note that there are two functions that may panic here, `assert` and equality"
" with `==`. We usually don't use `assert` function in practice and use "
"`assert!` macro instead. We will discuss `assert!` macro in more detail in "
"the [Testing Cairo Programs](./ch10-01-how-to-write-tests.md#checking-"
"results-with-the-assert-macro) chapter."
msgstr ""
"请注意,这里可能有两个功能,即`资产'和`平等'。我们通常不在实践中使用`资产'功能,而是使用`资产!'宏观。我们将在[试验开罗方案](./ch10-01-how-"
"to-writ-test-tests. md# checking-results-with-assert-macro)章节中更详细地讨论`资产!'宏观。"

#: src/ch09-01-unrecoverable-errors-with-panic.md:112
msgid "`panic_with` Attribute"
msgstr "`带有`属性的`西班牙语 '"

#: src/ch09-01-unrecoverable-errors-with-panic.md:114
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an "
"`Option` or `Result`. This attribute takes two arguments, which are the data"
" that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will "
"panic if the function returns `None` or `Err`, with the given data as the "
"panic error."
msgstr ""
"您可以使用“ panic_ with'属性” 来标记返回“ option” 或“Result” 的函数。 此属性需要两个参数, "
"即作为恐慌原因传递的数据以及包装函数的名称。 这将为附加说明的函数创建一个折叠符, 如果函数返回“ 无” 或“ 错误”, 且给定的数据为恐慌错误, "
"则会恐慌 。"

#: src/ch09-01-unrecoverable-errors-with-panic.md:116
#: src/appendix-03-derivable-traits.md:38
msgid "Example:"
msgstr "示例:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:129
msgid "// this returns None\n"
msgstr "/ 此返回 / 返回无\n"

#: src/ch09-01-unrecoverable-errors-with-panic.md:130
msgid "// this panics with 'value is 0'\n"
msgstr "/ 这种惊慌与“ 值为 0 ” 。\n"

#: src/ch09-01-unrecoverable-errors-with-panic.md:134
msgid "{{#quiz ../quizzes/ch09-01-unrecoverable-errors-with-panic.toml}}"
msgstr ""
"Quiz./quizzes/ch09-01-无法复原的用西班牙语的毒气.toml_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________"

#: src/ch09-02-recoverable-errors.md:1
msgid "Recoverable Errors with `Result`"
msgstr "“Result”的可恢复错误"

#: src/ch09-02-recoverable-errors.md:3
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to add two large integers "
"and the operation overflows because the sum exceeds the maximum "
"representable value, you might want to return an error or a wrapped result "
"instead of causing undefined behavior or terminating the process."
msgstr ""
"大多数错误并不严重,以至于要求程序完全停止。 有时,当函数失败时,它的原因很容易解释和回应。 "
"例如,如果试图添加两个大整数和操作溢出,因为数字超过最大可代表值,你可能想要返回错误或包包的结果,而不是造成不确定的行为或终止过程。"

#: src/ch09-02-recoverable-errors.md:5
msgid "The `Result` Enum"
msgstr "`成果'元体"

#: src/ch09-02-recoverable-errors.md:7
msgid ""
"Recall from [Generic data types](./ch08-01-generic-data-types.md#enums) "
"section in Chapter 8 that the `Result` enum is defined as having two "
"variants, `Ok` and `Err`, as follows:"
msgstr ""
"从第8章[地球数据类型](./ch08-01-generic-data-types.md#enums)一节中回顾,`Result' "
"enum的定义是,`Result' enum有两个变式,`Ok'和`Err ',如下:"

#: src/ch09-02-recoverable-errors.md:20
msgid "The `ResultTrait`"
msgstr "`Result Trait '"

#: src/ch09-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>`"
" enum, such as unwrapping values, checking whether the `Result` is `Ok` or "
"`Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr ""
"`ResultTrait'特性提供了与`Result<T, E enum'合作的方法,例如解开数值,检查`Result'是`Ok'或`Err "
"',用自定义信息惊慌失措。"

#: src/ch09-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to "
"extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` "
"variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior "
"when the `Result` is in the `Err` variant. The `expect` method allows you to"
" provide a custom error message (as a `felt252` value) that will be used "
"when panicking, giving you more control and context over the panic. On the "
"other hand, the `unwrap` method panics with a default error message, "
"providing less information about the cause of the panic."
msgstr ""
"`预期'和`unbrap'方法相似,因为它们都试图从`Result<T,E'在`Ok'变方中提取`T'类的价值,如果`Result'是`Ok(x) "
"',两种方法都返回`x'值。但是,这两种方法之间的关键区别在于,当`Result'在`错误'变方中时,它们的行为。`预期'方法允许你提供自定义错误信息(作为`felt252'值),在恐慌时使用该信息,使你对恐慌有更多的控制权和上下文。另一方面,`unwack`方法的恐慌以默认错误信息返回。"

#: src/ch09-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` methods have the exact opposite behavior. "
"If the `Result` is `Err(x)`, both methods return the value `x`. However, the"
" key difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control "
"and context over the panic. On the other hand, the `unwrap_err` method "
"panics with a default error message, providing less information about the "
"cause of the panic."
msgstr ""
"`Expect_er'和`unwrap_er'方法具有完全相反的行为,如果`Result'是`Err(x) "
"',两种方法都返回了`x'值,但这两种方法之间的关键区别在于`Result:Ok()'。`expect_er'方法允许您提供自定义错误信息(作为`felt252'值),在恐慌时使用,使您对恐慌有更多的控制和上下文。另一方面,`unlop_err'方法以默认错误信息返回了`x'值,减少了关于恐慌原因的信息。"

#: src/ch09-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the "
"first four methods signatures. This syntax represents generic type "
"constraints in the Cairo language, as seen in the previous chapter. These "
"constraints indicate that the associated functions require an implementation"
" of the `Drop` trait for the generic types `T` and `E`, respectively."
msgstr ""
"仔细阅读者可能注意到前四种方法的签名中的“Drop<T”和“Drop<E”,该语法代表了开罗语言的通用类型限制,如前一章所述,这些限制表明,相关功能要求分别实施“T”和“E”通用类型“Drop”特性。"

#: src/ch09-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by "
"the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr "最后,`is_ok'和`is_err'方法是`resultTrait'特性提供的效用功能,以检查`result' enum值的变体。"

#: src/ch09-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the"
" `Result` is the `Ok` variant, meaning the operation was successful. If the "
"`Result` is the `Err` variant, it returns `false`."
msgstr ""
"`是`ok'对`Result<T,E 值和返回`t'进行截图,如果`Result'是`Ok` "
"变体,意味着操作成功。如果`Result'是`Err'变体,则返回`false'。"

#: src/ch09-02-recoverable-errors.md:49
msgid ""
"`is_err` takes a snapshot of a `Result<T, E>` value and returns `true` if "
"the `Result` is the `Err` variant, meaning the operation encountered an "
"error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr ""
"`是`err'采取`Result<T,E "
"值和返回`ret'如果`Result'是`err'变体,即操作遇到错误。如果`Result'是`Ok'变体,则返回`false'。"

#: src/ch09-02-recoverable-errors.md:51
msgid ""
"These methods are helpful when you want to check the success or failure of "
"an operation without consuming the `Result` value, allowing you to perform "
"additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr ""
"当您想要在不消耗`Result' 值的情况下检查操作的成败,从而允许您进行额外的操作或根据变量作出决定而无需解开变量时,这些方法会很有帮助。"

#: src/ch09-02-recoverable-errors.md:53
msgid ""
"You can find the implementation of the `ResultTrait` "
"[here](https://github.com/starkware-"
"libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr ""
"你可以找到`ResultTrait'[此处](https://github.com/starkware-"
"libs/cairo/blob/main/corelib/src/legation.cairo#L20)的执行情况。"

#: src/ch09-02-recoverable-errors.md:55
msgid ""
"It is always easier to understand with examples. Have a look at this "
"function signature:"
msgstr "示例总是容易理解的。请查看此函数签名 :"

#: src/ch09-02-recoverable-errors.md:61
msgid ""
"It takes two `u128` integers, `a` and `b`, and returns a `Result<u128, "
"u128>` where the `Ok` variant holds the sum if the addition does not "
"overflow, and the `Err` variant holds the overflowed value if the addition "
"does overflow."
msgstr ""
"它需要两个`u128'整数,`a'和`b',并返回一个`Result<u128, u128 "
"',其中`Ok'变式持有未溢出时的金额,而`Err'变式持有未溢出时的溢出值。"

#: src/ch09-02-recoverable-errors.md:63
msgid "Now, we can use this function elsewhere. For instance:"
msgstr "现在,我们可以在别处使用此函数。例如:"

#: src/ch09-02-recoverable-errors.md:75
msgid ""
"Here, it accepts two `u128` integers, `a` and `b`, and returns an "
"`Option<u128>`. It uses the `Result` returned by `u128_overflowing_add` to "
"determine the success or failure of the addition operation. The `match` "
"expression checks the `Result` from `u128_overflowing_add`. If the result is"
" `Ok(r)`, it returns `Option::Some(r)` containing the sum. If the result is "
"`Err(r)`, it returns `Option::None` to indicate that the operation has "
"failed due to overflow. The function does not panic in case of an overflow."
msgstr ""
"在此,它接受两个`u128'整数,`a'和`b',并返回一个`option<u128'。它使用`u128_overflowing_add'返回的`Result'来决定添加操作的成败。`match'表达式检查`u128_overflowing_add'中的`result'。如果结果为`Ok(r)"
" ',它返回包含该金额的`option:oma(r)'。如果结果为`rr(r) "
"',它返回`opp:no'来表示操作因溢出而失败。如果溢出,该功能不会引起恐慌。"

#: src/ch09-02-recoverable-errors.md:77
msgid "Let's take another example:"
msgstr "让我们举另一个例子:"

#: src/ch09-02-recoverable-errors.md:88
msgid ""
"In this example, the `parse_u8` function takes a `felt252` and tries to "
"convert it into a `u8` integer using the `try_into` method. If successful, "
"it returns `Result::Ok(value)`, otherwise it returns `Result::Err('Invalid "
"integer')`."
msgstr ""
"在此示例中, `parse_ u8' 函数需要一个`felt252', 并试图使用` try_ into' 方法将其转换为`u8' 整数, 如果成功, "
"它返回`Result::: Ok(价值) ', 否则它返回`Result:Err(“无效整数”)' 。"

#: src/ch09-02-recoverable-errors.md:90
msgid "Our two test cases are:"
msgstr "我们的两个测试案例是:"

#: src/ch09-02-recoverable-errors.md:107
msgid "// should not panic\n"
msgstr "不应该惊慌\n"

#: src/ch09-02-recoverable-errors.md:115
msgid "// should panic\n"
msgstr "/应该惊慌\n"

#: src/ch09-02-recoverable-errors.md:123
msgid ""
"Don't worry about the `#[cfg(test)]` attribute for now. We'll explain in "
"more detail its meaning in the next [Testing Cairo Programs](./ch10-01-how-"
"to-write-tests.md) chapter."
msgstr ""
"不要担心 @[cfg(test)]`属性。我们将在下一章[测试开罗方案](./ch10-01-hoow-to-write-stests. "
"md)中更详细地解释其含义。"

#: src/ch09-02-recoverable-errors.md:125
msgid ""
"`#[test]` attribute means the function is a test function, and "
"`#[should_panic]` attribute means this test will pass if the test execution "
"panics."
msgstr "`[测试]`属性是指函数是一个测试函数,`[shall_panic]’属性是指当测试执行恐慌时该测试会通过。"

#: src/ch09-02-recoverable-errors.md:127
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the"
" `unwrap` method not to panic. The second test function attempts to convert "
"a value that is out of the `u8` range, expecting the `unwrap` method to "
"panic with the error message `Invalid integer`."
msgstr ""
"第一项测试从`felt252'有效转换为`u8',预期`unbrap'方法不会惊慌;第二项测试功能试图转换“u8”范围以外的数值,预计`unbrap'方法会用错误信息`无效整数'惊慌失措。"

#: src/ch09-02-recoverable-errors.md:132
msgid "The `?` Operator"
msgstr "`?`接线员"

#: src/ch09-02-recoverable-errors.md:134
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator "
"is used for more idiomatic and concise error handling. When you use the `?` "
"operator on a `Result` or `Option` type, it will do the following:"
msgstr ""
"我们谈论的最后一个操作员是`?'操作员。`?'操作员用于更专门和简洁的错误处理。当您在`Result'或`option'类型上使用``?'操作员时,它将采取以下行动:"

#: src/ch09-02-recoverable-errors.md:136
msgid ""
"If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the "
"inner value `x` directly."
msgstr "如果数值为`Result::Ok(x)'或`Option:some(x) ',则该数值将直接返回内值`x'。"

#: src/ch09-02-recoverable-errors.md:137
msgid ""
"If the value is `Result::Err(e)` or `Option::None`, it will propagate the "
"error or `None` by immediately returning from the function."
msgstr "如果数值为`Result:Err(e)'或`Option:No`,则该数值会通过立即从函数返回而传播错误或`none'。"

#: src/ch09-02-recoverable-errors.md:139
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let"
" the calling function deal with them."
msgstr "`?'操作员在想暗中处理错误并让调用功能处理错误时是有用的。"

#: src/ch09-02-recoverable-errors.md:146 src/ch09-02-recoverable-errors.md:166
msgid "// DO SOMETHING\n"
msgstr "做点什么\n"

#: src/ch09-02-recoverable-errors.md:152
msgid ""
"We can see that `do_something_with_parse_u8` function takes a `felt252` "
"value as input and calls `parse_u8` function. The `?` operator is used to "
"propagate the error, if any, or unwrap the successful value."
msgstr ""
"我们可以看到,`Do_ something_with_parse_u8' 函数以“felt252” 值作为输入,称为`parse_u8' "
"函数。`?'运算符被用来传播错误(如果有的话)或解开成功值。"

#: src/ch09-02-recoverable-errors.md:154
msgid "And with a little test case:"
msgstr "并用一个小的测试案例:"

#: src/ch09-02-recoverable-errors.md:178
msgid "\"Result: {}\""
msgstr "(成绩: )"

#: src/ch09-02-recoverable-errors.md:179
msgid "\"Error: {}\""
msgstr "\"错误: \""

#: src/ch09-02-recoverable-errors.md:186
msgid "The console will print the error `Invalid Integer`."
msgstr "控制台将打印错误“ 无效的整数 ” 。"

#: src/ch09-02-recoverable-errors.md:190
msgid ""
"We saw that recoverable errors can be handled in Cairo using the `Result` "
"enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is "
"generic, with types `T` and `E` representing the successful and error "
"values, respectively. The `ResultTrait` provides methods for working with "
"`Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or"
" `Err`, and panicking with custom messages."
msgstr ""
"我们看到,在开罗可以使用`Result' enum处理可收回的错误,该`Result'enum有两个变式:`Ok'和`Err'。`Result < "
"T,E enum是通用的,分别代表成功和错误值的`T'和`E'类型。`ResultTrait'提供了处理`Result < "
"T,E的工作方法,例如未包装值,检查结果是否为`Ok'或`Err ',以及用自定义信息惊慌失措。"

#: src/ch09-02-recoverable-errors.md:192
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use "
"pattern matching to handle the success or failure of an operation. The `?` "
"operator can be used to implicitly handle errors by propagating the error or"
" unwrapping the successful value. This allows for more concise and clear "
"error handling, where the caller is responsible for managing errors raised "
"by the called function."
msgstr ""
"要处理可回收错误, 函数可以返回“ Result” 类型, 并使用匹配模式处理操作的成败。 `?'操作员可以通过传播错误或解封成功值来暗中处理错误。 "
"这样可以进行更简洁、更明确的错误处理, 由调用者负责管理调用函数引起的错误。"

#: src/ch09-02-recoverable-errors.md:194
msgid "{{#quiz ../quizzes/ch09-02-error-handling-result.toml}}"
msgstr "./quizzes/ch09-02-error-error-leaking-result.toml"

#: src/ch10-00-testing-cairo-programs.md
msgid ""
"Correctness in our programs is the extent to which our code does what we "
"intend it to do. Cairo is designed with a high degree of concern about the "
"correctness of programs, but correctness is complex and not easy to prove. "
"Cairo's linear type system shoulders a huge part of this burden, but the "
"type system cannot catch everything. As such, Cairo includes support for "
"writing tests."
msgstr ""
"我们的程序的正确性在于我们的代码在多大程度上做了我们想要做的事情。 开罗的设计高度关注程序的正确性,但正确性是复杂而不容易证明的。 "
"开罗的线性系统承担着这一负担的一大部分,但类型系统无法抓住一切。 因此,开罗包括了对写作测试的支持。"

#: src/ch10-00-testing-cairo-programs.md
msgid ""
"Testing is a complex skill: although we can’t cover every detail about how "
"to write good tests in one chapter, we’ll discuss the mechanics of Cairo's "
"testing facilities. We’ll talk about the annotations and macros available to"
" you when writing your tests, the default behavior and options provided for "
"running your tests, and how to organize tests into unit tests and "
"integration tests."
msgstr ""
"测试是一种复杂的技能:虽然我们无法在一章中涵盖如何写好测试的每一个细节,但我们还是会讨论开罗测试设施的机械学。 "
"我们将讨论您在写测试时可用的说明和宏、运行测试的默认行为和选项,以及如何将测试组织成单位测试和整合测试。"

#: src/ch10-01-how-to-write-tests.md:3 src/ch10-01-how-to-write-tests.md:17
msgid "The Anatomy of a Test Function"
msgstr "测试函数解剖学"

#: src/ch10-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these"
" three actions:"
msgstr "测试是开罗的功能,用于核查非测试代码是否以预期的方式运作。"

#: src/ch10-01-how-to-write-tests.md:7
msgid "Set up any needed data or state."
msgstr "设置所需的数据或状态 。"

#: src/ch10-01-how-to-write-tests.md:8
msgid "Run the code you want to test."
msgstr "运行您想要测试的代码 。"

#: src/ch10-01-how-to-write-tests.md:9
msgid "Assert the results are what you expect."
msgstr "保证结果就是你所期望的"

#: src/ch10-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides for writing tests that take these "
"actions, which include:"
msgstr "让我们看看开罗为采取这些行动提供了书面测试,其中包括:"

#: src/ch10-01-how-to-write-tests.md:13
msgid "`#[test]` attribute."
msgstr "[测试]`属性。"

#: src/ch10-01-how-to-write-tests.md:14
msgid ""
"`assert!`, `assert_eq!`, `assert_ne!`, `assert_lt!`, `assert_le!`, "
"`assert_gt!` and `assert_ge!` macros."
msgstr ""
"`assrt!'、`assrt_eq!'、`assrt_ne!'、`assrt_lt!'、`assrt_le!'、`assrt_gt!'和`assrt_ge!'宏观。"

#: src/ch10-01-how-to-write-tests.md:15
msgid "`#[should_panic]` attribute."
msgstr "`[应_panic]'属性。"

#: src/ch10-01-how-to-write-tests.md:19
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the "
"`#[test]` attribute. Attributes are metadata about pieces of Cairo code; one"
" example is the `#[derive()]` attribute we used with structs in [Chapter "
"5](ch05-01-defining-and-instantiating-structs.md). To change a function into"
" a test function, add `#[test]` on the line before `fn`. When you run your "
"tests with the `scarb cairo-test` command, Scarb runs Cairo's test runner "
"binary that runs the annotated functions and reports on whether each test "
"function passes or fails."
msgstr ""
"最简单的是,开罗的测试是一个函数,带有`[测试]'属性的附加说明。属性是开罗代码的元数据;一个例子是[第5章](ch05-01-定义-定义-和验证-"
"structs.md)中使用的“[衍生 属性”属性。要将函数转换为测试函数,请在`fn'之前的线上添加“[测试]”。当您使用“scarb cairo-"
"stest' 命令”进行测试时,Scarb运行开罗的测试选手二进库,该选手运行附加说明的函数,并报告每个测试函数是否通过或失败。"

#: src/ch10-01-how-to-write-tests.md:21
msgid ""
"Let's create a new project called _adder_ using Scarb with the command "
"`scarb new adder`:"
msgstr "让我们创建一个名为 _adder_的新工程, 使用带有命令“ 切除新添加器” 的刀疤 :"

#: src/ch10-01-how-to-write-tests.md:30
msgid ""
"In _lib.cairo_, let's remove the existing content and add a `tests` module "
"containing the first test, as shown in Listing 10-1."
msgstr "在 _lib.cairo_中,让我们删除现有内容,并添加一个包含第一个测试的“测试”模块,如清单10-1所示。"

#: src/ch10-01-how-to-write-tests.md:40 src/ch10-01-how-to-write-tests.md:73
#: src/ch10-01-how-to-write-tests.md:97 src/ch10-01-how-to-write-tests.md:749
#: src/ch10-01-how-to-write-tests.md:786 src/ch10-02-test-organization.md:25
msgid "\"result is not 4\""
msgstr "\"结果不是4\""

#: src/ch10-01-how-to-write-tests.md:45
msgid "<span class=\"caption\">Listing 10-1: A simple test function</span>"
msgstr "<span类=\"Caption\" > listing 10-1: 一个简单的测试函数 </span>"

#: src/ch10-01-how-to-write-tests.md:47
msgid ""
"Note the `#[test]` annotation: this attribute indicates this is a test "
"function, so the test runner knows to treat this function as a test. We "
"might also have non-test functions to help set up common scenarios or "
"perform common operations, so we always need to indicate which functions are"
" tests."
msgstr ""
"注意 {[ test] ` 注释: 此属性表示这是一个测试函数, 所以测试运行者知道将此函数作为测试处理 。 "
"我们还可能有非测试函数来帮助设置共同的假想或执行共同操作, 所以我们总是需要指出哪些函数是测试 。"

#: src/ch10-01-how-to-write-tests.md:49
msgid ""
"We use the `#[cfg(test)]` attribute for the `tests` module, so that the "
"compiler knows the code it contains needs to be compiled only when running "
"tests. This is actually not an option: if you put a simple test with the "
"`#[test]` attribute in a _lib.cairo_ file, it will not compile. We will talk"
" more about the `#[cfg(test)]` attribute in the next [Testing "
"Organization](ch10-02-test-organization.md) section."
msgstr ""
"我们使用`测试'模块的 {{{[cfg(test)]}}`属性,这样汇编者才知道它所包含的代码只有在运行测试时才需要编译。这实际上不是一个选项:如果在 "
"_lib.cairo_文件中用 {[test] 属性进行简单测试,它就不会编译。我们将在下一个[测试组织] (ch10-02-test-"
"orgection.md) 部分更多地讨论“{[cfg(test)]’’属性。"

#: src/ch10-01-how-to-write-tests.md:51
msgid ""
"The example function body uses the `assert!` macro, which contains the "
"result of adding 2 and 2, which equals 4. This assertion serves as an "
"example of the format for a typical test. We'll explain in more detail how "
"`assert!` works later in this chapter. Let’s run it to see that this test "
"passes."
msgstr ""
"示例函数主体使用`assirt!' 宏, 其中包括增加2和2的结果, 等于 4 。 此声明是典型测试格式的一个例子。 "
"我们将更详细地解释`assirt!' 如何在本章后面部分起作用。 让我们运行它,看看这个测试是否通过。"

#: src/ch10-01-how-to-write-tests.md:53
msgid ""
"The `scarb cairo-test` command runs all tests found in our project, and "
"shows the following output:"
msgstr "`scarb cairo-test'命令运行我们项目中发现的所有测试,并显示以下产出:"

#: src/ch10-01-how-to-write-tests.md:63
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 "
"test`. The next line shows the name of the test function, called `it_works`,"
" and that the result of running that test is `ok`. The test runner also "
"provides an estimation of the gas consumption. The overall summary `test "
"result: ok.` means that all the tests passed, and the portion that reads `1 "
"passed; 0 failed` totals the number of tests that passed or failed."
msgstr ""
"\" scarb cairo-test \" 编译并运行了测试,我们看到了 \" 运行1号测试 \" "
"的线条。下一行显示测试函数的名称,称为`it_works ',测试结果为`ok ',测试运行结果也提供了气体消耗量的估计。总体摘要 \" "
"测试结果:OK. \" 是指所有测试都通过,以及部分内容为`1号通过;0号失败 \" 的测试总数为通过或失败的测试总数。"

#: src/ch10-01-how-to-write-tests.md:65
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically "
"Requested](#ignoring-some-tests-unless-specifically-requested) section later"
" in this chapter. Because we haven’t done that here, the summary shows `0 "
"ignored`. We can also pass an argument to the `scarb cairo-test` command to "
"run only a test whose name matches a string; this is called filtering and "
"we’ll cover that in the [Running Single Tests](#running-single-tests) "
"section. Since we haven’t filtered the tests being run, the end of the "
"summary shows `0 filtered out`."
msgstr ""
"可以将测试标记为忽略,这样它不会在某个特定情况下运行;我们将在本章后面的[具体要求之外的忽略某些测试]部分(#ignoring- some-tests-"
"除非具体要求的)部分中涵盖这一点。由于我们没有这样做,摘要显示“没有忽略”。我们也可以向`scarb cairo-"
"test'命令提出一个论点,只运行一个与字符串相符的测试;这被称为过滤,我们将覆盖在[运行单测试](#运行-sing-le-"
"tests)部分中。由于我们没有过滤正在运行的测试,摘要的结尾显示“无过滤 ” 。"

#: src/ch10-01-how-to-write-tests.md:67
msgid ""
"Let’s start to customize the test to our own needs. First change the name of"
" the `it_works` function to a different name, such as `exploration`, like "
"so:"
msgstr "让我们开始根据我们自己的需求定制测试。 首先将“it_works” 函数的名称更改为不同的名称, 如“ 探索”, 类似 :"

#: src/ch10-01-how-to-write-tests.md:77
msgid ""
"Then run `scarb cairo-test` again. The output now shows `exploration` "
"instead of `it_works`:"
msgstr "然后再次运行“scarb cairo-test” 。 现在的输出显示“ 探索”, 而不是“it_ works ” :"

#: src/ch10-01-how-to-write-tests.md:87
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a"
" new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. Enter the new test as a function named `another`, "
"so your _src/lib.cairo_ file looks like in Listing 10-2."
msgstr ""
"现在,我们将添加另一个测试, 但这次我们将做一个失败的测试! 当测试函数中的某些内容出现恐慌时, 测试就会失败 。 每次测试都是在一条新线中运行, "
"当主线看到测试线索已经死亡时, 测试就会被标记为失败 。 输入新测试时, 函数名称为“ another ”, 所以您的 _ src/lib.cairo_"
" 文件在 Listing 10-2 中看起来类似 。"

#: src/ch10-01-how-to-write-tests.md:103
msgid "\"Make this test fail\""
msgstr "\"让这个测试失败\""

#: src/ch10-01-how-to-write-tests.md:109
msgid ""
"<span class=\"caption\">Listing 10-2: Adding a second test in _lib.cairo_ "
"that will fail</span>"
msgstr "<span class=\"caption\" > listing -10: 在 _lib.cairo_ 添加第二个失败测试 </span>"

#: src/ch10-01-how-to-write-tests.md:111
msgid "Run `scarb cairo-test` and you will see the following output:"
msgstr "运行'scarb cairo-test ',您将看到以下输出 :"

#: src/ch10-01-how-to-write-tests.md:113
msgid ""
"```shell\n"
"$ scarb cairo-test \n"
"     Running cairo-test listing_08_03\n"
"   Compiling test(listings/ch10-testing-cairo-programs/listing_10_02/Scarb.toml)\n"
"    Finished release target(s) in 1 second\n"
"testing listing_08_03 ...\n"
"running 2 tests\n"
"test listing_08_03::tests::exploration ... ok (gas usage est.: 22540)\n"
"test listing_08_03::tests::another ... fail (gas usage est.: 24810)\n"
"failures:\n"
"   listing_08_03::tests::another - Panicked with \"Make this test fail\".\n"
"\n"
"\n"
"```"
msgstr ""
"@jshell $ scarb cairo- test running cairo- test list_08_03 Comping test( "
"lists/ch10- test-cairo- programs/ list_10_02/Scarb.toml) 1 第二次测试列表_08_03 "
"中已完成的释放目标_02/Scarb.toml) 运行 2 个测试列表_ 08_ 03: tests::: 勘探... ok. (气体使用日期: 最晚:"
" 22540) 测试列表_08_ 03: 测试: 其它失败(气体使用日期: 24810) 失败: list_ 08_ 03:: 测试: 其它: "
"atests: another - Panicked with \" make this test apot.\" ~"

#: src/ch10-01-how-to-write-tests.md:128
msgid ""
"Instead of `ok`, the line `adder::another` shows `fail`. A new section "
"appears between the individual results and the summary. It displays the "
"detailed reason for each test failure. In this case, we get the details that"
" `another` failed because it panicked with `\"Make this test fail\"` error."
msgstr ""
"而不是`ok', `adder::another' "
"显示`fail'。在单个结果和摘要之间出现新的一节,显示每次测试失败的详细原因。在此情况下,我们得到的细节是`另一个'失败,因为它惊慌失措,`让这个测试失败'错误。"

#: src/ch10-01-how-to-write-tests.md:130
msgid ""
"The summary line is displayed at the end: overall, our test result is "
"`FAILED`. We had one test pass and one test fail."
msgstr "总线在结尾处显示:总体而言,我们的测试结果为 \" FAILED \",我们有一个测试通过,一个测试失败。"

#: src/ch10-01-how-to-write-tests.md:132
msgid ""
"Now that you’ve seen what the test results look like in different scenarios,"
" let’s look at some functions that are useful in tests."
msgstr "现在你们已经看到测试结果在不同情景中是什么样子, 让我们来看看在测试中有用的一些功能。"

#: src/ch10-01-how-to-write-tests.md:134
msgid "Checking Results with the `assert!` Macro"
msgstr "与“Assrt!” 宏核对结果"

#: src/ch10-01-how-to-write-tests.md:136
msgid ""
"The `assert!` macro, provided by Cairo, is useful when you want to ensure "
"that some condition in a test evaluates to `true`. We give the `assert!` "
"macro the first argument that evaluates to a boolean. If the value is "
"`true`, nothing happens and the test passes. If the value is `false`, the "
"`assert!` macro calls `panic()` to cause the test to fail with a message we "
"defined as the second argument. Using the `assert!` macro helps us check "
"that our code is functioning in the way we intended."
msgstr ""
"开罗提供的`Asrt!'宏观,在确保测试中的某些条件对`真'进行评估时,非常有用。我们给`Asrt!'宏观第一个参数对布林进行评价,如果价值是`真',就不会发生任何情况,测试通过。如果价值是`假',那么`Asrt!'宏观调用`panic()'以使我们定义为第二个参数的电文使测试失败。我们使用`assrt!'宏观帮助我们检查我们的代码是否以我们预想的方式运作。"

#: src/ch10-01-how-to-write-tests.md:138
msgid ""
"Remember in [Chapter 5](./ch05-03-method-syntax.md), we used a `Rectangle` "
"struct and a `can_hold` method, which are repeated here in Listing 10-3. "
"Let’s put this code in the _src/lib.cairo_ file, then write some tests for "
"it using the `assert!` macro."
msgstr ""
"记住[第5章](./ch05-03-method-syngaty.md),我们使用了`矩形'支架和`Can_hold'方法,在列表 "
"10-3中重复了这些方法。让我们把这个代码放入_src/lib.cairo_文件,然后用`assrt!'宏写一些测试。"

#: src/ch10-01-how-to-write-tests.md:160
msgid ""
"<span class=\"caption\">Listing 10-3: Using the `Rectangle` struct and its "
"`can_hold` method from Chapter 5</span>"
msgstr "<span类=“Caption” > listing 10-3: 使用第5章 </span>中的`矩形'结构及其`Can_hold'方法"

#: src/ch10-01-how-to-write-tests.md:162
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case "
"for the `assert!` macro. We can write a test that exercises the `can_hold` "
"method by creating a `Rectangle` instance that has a width of `8` and a "
"height of `7` and asserting that it can hold another `Rectangle` instance "
"that has a width of `5` and a height of `1`."
msgstr ""
"`Can_hold'方法返回`bool "
"',这意味着它是`assrt!'宏的完美应用案例。我们可以写一个测试,通过创建宽度为`8'和高度为`7'的`Rectangle'实例,并主张它可以持有另一个宽度为`5'和高度为`1'的`Rectangle'实例。"

#: src/ch10-01-how-to-write-tests.md:191 src/ch10-01-how-to-write-tests.md:204
#: src/ch10-01-how-to-write-tests.md:251 src/ch10-01-how-to-write-tests.md:264
msgid "\"rectangle cannot hold\""
msgstr "纠结无法支撑"

#: src/ch10-01-how-to-write-tests.md:210
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the `assert!` macro and "
"passed it the result of calling `larger.can_hold(@smaller)`. This expression"
" is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""
"我们把测试命名为`大'Can_hold_smaler "
"',我们创建了我们所需要的两个`矩形'实例,然后我们称之为`Assert!'宏观,通过称之为`大.can_hold(@smaler)'的结果,这个表达方式应该返回`真实"
" ',所以我们的测试应该通过。让我们找出答案!"

#: src/ch10-01-how-to-write-tests.md:220
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr "我们再加一个测试, 认为一个较小的矩形不能维持一个更大的矩形:"

#: src/ch10-01-how-to-write-tests.md:270
msgid ""
"<span class=\"caption\">Listing 10-4: Adding another test in _lib.cairo_ "
"that will pass</span>"
msgstr "<span class=\"caption\" > listing 10-4:在 _lib.cairo_中添加另一个通过 </span>的测试"

#: src/ch10-01-how-to-write-tests.md:272
msgid ""
"Because the correct result of the `can_hold` method, in this case, is "
"`false`, we need to negate that result before we pass it to the `assert!` "
"macro. As a result, our test will pass if `can_hold` returns `false`:"
msgstr ""
"由于`Can-hold'方法(在本案中)的正确结果是`false',我们需要在将结果转嫁给`assrt!'宏观之前否定这一结果,因此,如果`can-"
"hold'return`false':"

#: src/ch10-01-how-to-write-tests.md:288
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the `>` sign with a `<` sign when it compares"
" the widths:"
msgstr ""
"现在让我们看看在代码中引入一个错误时我们的测试结果会怎样。 我们将改变“ 能够” 方法的实施方式, 比较宽度时用 {{} 符号替换 {} 符号 : @ "
"{} = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="
" = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="
" = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="
" = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="
" = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="
" = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="
" = ="

#: src/ch10-01-how-to-write-tests.md:298
msgid "Running the tests now produces the following:"
msgstr "正在运行的测试现在产生以下结果:"

#: src/ch10-01-how-to-write-tests.md:300
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 2 tests\n"
"test adder::tests::larger_can_hold_smaller ... fail (gas usage est.: 57610)\n"
"test adder::tests::smaller_cannot_hold_larger ... ok (gas usage est.: 55140)\n"
"failures:\n"
"   adder::larger_can_hold_smaller - Panicked with \"rectangle cannot hold\".\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"shell $ scarb cairo- 测试添加器... 运行 2 个测试添加器 :: 测试 :: larger_ can_ hold_ "
"smaller... 失败( 气体使用量 : 57610 ) 测试添加器 : 测试 :: 测试 :: 最小_ cannot_ hold_ "
"larger... ok( 气体使用量 : 55140 ) 失败 : 添加器 : 放大_ can_ hold_ smaller - 被“ 矩形无法保持”"
" 粉碎 错误: 测试结果 : FAILED. 1 成功; 1 失败; 0 忽略 {"

#: src/ch10-01-how-to-write-tests.md:312
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false` (`8` "
"is not less than `5`) in the `larger_can_hold_smaller` test. Notice that the"
" `smaller_cannot_hold_larger` test still passes: to make this test fail, the"
" height comparison should also be modified in `can_hold` method, replacing "
"the `>` sign with a `<` sign."
msgstr ""
"我们的测试抓住了错误! 因为`大宽度'是`8 ',`小宽度'是`5 "
"',因此`能够'持有现在返回`false'(`8'不小于`5')的宽度比较在`大可'持有`小点'的测试中。请注意,`小可'持有`大点'的测试仍然通过:要使这一测试失败,也应修改`能够'持有方法中的高度比较,用`标记'取代`标志'。"

#: src/ch10-01-how-to-write-tests.md:316
msgid "Testing Equality and Comparisons with the `assert_xx!` Macros"
msgstr "测试平等和与`Assirt_xx!'宏观的比较"

#: src/ch10-01-how-to-write-tests.md:318
msgid "`assert_eq!` and `assert_ne!` Macros"
msgstr "\" Assert_eq! \" 和 \" Assrt_ne! \" 宏"

#: src/ch10-01-how-to-write-tests.md:320
msgid ""
"A common way to verify functionality is to test for equality between the "
"result of the code under test and the value you expect the code to return. "
"You could do this using the `assert!` macro and passing it an expression "
"using the `==` operator. However, this is such a common test that the "
"standard library provides a pair of macros — `assert_eq!` and `assert_ne!` —"
" to perform this test more conveniently. These macros compare two arguments "
"for equality or inequality, respectively. They’ll also print the two values "
"if the assertion fails, which makes it easier to see _why_ the test failed; "
"conversely, the `assert!` macro only indicates that it got a `false` value "
"for the `==` expression, without printing the values that led to the `false`"
" value."
msgstr ""
"验证功能的一个常见方式是测试测试的代码结果与您期望的代码返回值之间的平等性。 您可以使用“ assrt! 宏” 进行测试, 并使用“ {} {} {} "
"{} {} {} {} {}} {}}} 运算符传递一个表达方式。然而,这是一个常见的检验方法, 标准图书馆提供一对宏——` assrt_eq!} 和`"
" assrt_ne!>, 以更方便地进行这一测试。 这些宏分别比较了两个平等或不平等的参数。 如果声明失败, 它们也会打印这两个值, 从而更容易看到_ "
"whis_ 测试失败; 反之, “ assrt! } 宏观只表示它得到了`false'值, 而没有打印导致“ false” 值。"

#: src/ch10-01-how-to-write-tests.md:331
msgid ""
"In Listing 10-5, we write a function named `add_two` that adds `2` to its "
"parameter, then we test this function using `assert_eq!` and `assert_ne!` "
"macros."
msgstr ""
"在列出 10-5 时,我们写入一个名为`add_ two' 的函数,该函数在其参数中增加`2',然后用`assrt_eq!'和`assrt_ne!' "
"宏测试该函数。"

#: src/ch10-01-how-to-write-tests.md:357
msgid ""
"<span class=\"caption\">Listing 10-5: Testing the function `add_two` using "
"`assert_eq!` and `assert_ne!` macros</span>"
msgstr ""
"<span类=`caption' > listing 10-5:使用`assrt_eq!'和`assrt_ne!'宏 "
"</span>测试函数`add_二'。"

#: src/ch10-01-how-to-write-tests.md:359
msgid "Let’s check that it passes!"
msgstr "让我们检查它是否通过!"

#: src/ch10-01-how-to-write-tests.md:370
msgid ""
"In the `it_adds_two` test, we pass `4` as argument to `assert_eq!` macro, "
"which is equal to the result of calling `add_two(2)`. The line for this test"
" is `test adder::tests::it_adds_two ... ok`, and the `ok` text indicates "
"that our test passed."
msgstr ""
"在`it_adds_2'测试中,我们通过`4'作为`assert_eq!'宏观的论证,这等于调用`add_2(2)'的结果。该测试的直线是`测试添加器::it_adds_2`ok"
" ',而`ok'文本表明我们的测试已经通过。"

#: src/ch10-01-how-to-write-tests.md:373
msgid ""
"In the `wrong_check` test, we pass `0` as argument to `assert_ne!` macro, "
"which is not equal to the result of calling `add_two(2)`. Tests that use the"
" `assert_ne!` macro will pass if the two values we give it are _not_ equal "
"and fail if they’re equal. This macro is most useful for cases when we’re "
"not sure what a value _will_ be, but we know what the value definitely "
"_shouldn’t_ be. For example, if we’re testing a function that is guaranteed "
"to change its input in some way, but how the input is changed depends on the"
" day of the week that we run our tests, the best thing to assert might be "
"that the output of the function is not equal to the input."
msgstr ""
"在`错误_检查'测试中,我们通过`0'作为`assirt_ne!'宏观的论证,这不等于调用`add_2(2)'的结果。使用`assirt_ne!'的测试,如果我们给出的两种值是平等的,那么该宏就会通过。当我们不确定什么值是`会是'时,这个宏最有用,但我们知道一定的值是什么。例如,如果我们正在测试一个保证以某种方式改变输入的函数,但如何改变输入取决于我们进行测试的一周的一天,那么最好的说法是,函数的输出并不等于输入。"

#: src/ch10-01-how-to-write-tests.md:382
msgid ""
"Let’s introduce a bug into our code to see what `assert_eq!` looks like when"
" it fails. Change the implementation of the `add_two` function to instead "
"add `3`:"
msgstr ""
"让我们在代码中引入一个错误, 来查看“ assert_ eq! ” 当它失败时看起来是什么。 更改“ add_ two” 函数的功能执行, 代之以添加 "
"3 :"

#: src/ch10-01-how-to-write-tests.md:391
msgid "Run the tests again:"
msgstr "再次运行测试 :"

#: src/ch10-01-how-to-write-tests.md:393
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 2 tests\n"
"test adder::tests::wrong_check ... ok (gas usage est.: 132000)\n"
"test adder::tests::it_adds_two ... fail (gas usage est.: 166800)\n"
"failures:\n"
"   adder::tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` failed.\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"贝壳 $ carb cairo 测试添加器... 运行 2 个测试添加器 : 测试 : wrong_ check... ok (气体使用量 : "
"132000) 测试添加器 : 测试 :: it_ adds_ two... 失败 (气体使用量 : 166800) 失败 : 添加器 : 测试 :: "
"测试 :: it_ adds_ two - 被“ 保证 4 = 添加_ 2 (2) ” 失败 。 4 : 4 添加_ two (2): 5 错误 : "
"测试结果 : FAILED. 1 passed; 1 失败; 0 忽略 *"

#: src/ch10-01-how-to-write-tests.md:407
msgid ""
"Our test caught the bug! The `it_adds_two` test failed with the following "
"message: ``Panicked with \"assertion `4 == add_two(2)` failed``. It tells us"
" that the assertion that failed was `` \"assertion `left == right` failed`` "
"and the `left` and `right` values are printed on the next lines as `left: "
"left_value` and `right: right_value`. This helps us start debugging: the "
"`left` argument was `4` but the `right` argument, where we had `add_two(2)`,"
" was `5`. You can imagine that this would be especially helpful when we have"
" a lot of tests going on."
msgstr ""
"我们的测试抓住了错误! `it_ adds_ two' 测试失败了, 其电文如下: “ 以`assertion'4 = add_ 2 = = add_ "
"2 = = 失败了。 它告诉我们, 失败的断言是`assertion'left = right'`faild'和`left'和`right'= "
"value'。 这帮助我们开始调试:`left'参数是`4 ',而`正确的'论点,我们在那里`addad_ 2 "
"(2)'和`left'和`right'值是`5'。 我们可以想象,当我们进行大量测试时,这将特别有用。"

#: src/ch10-01-how-to-write-tests.md:415
msgid ""
"Note that in some languages and test frameworks, the parameters for equality"
" assertion functions are called `expected` and `actual`, and the order in "
"which we specify the arguments matters. However, in Cairo, they’re called "
"`left` and `right`, and the order in which we specify the value we expect "
"and the value the code produces doesn’t matter. We could write the assertion"
" in this test as `assert_eq!(add_two(2), 4)`, which would result in the same"
" failure message that displays `` assertion failed: `(left == right)` ``."
msgstr ""
"请注意,在某些语言和测试框架中,平等主张功能的参数被称为`预期的'和`实际的',以及我们具体说明争论事项的顺序,然而,在开罗,这些参数被称为`左'和`右"
" ',以及我们具体说明我们期望的价值和代码产生的价值的顺序并不重要。 我们可以将这一测试中的主张写成`assert_eq!(add_2(2),4) "
"',这将导致与显示“断言失败”的失败信息相同:`(left = right)`。"

#: src/ch10-01-how-to-write-tests.md:423
msgid ""
"Here is a simple example comparing two structs, showing how to use "
"`assert_eq!` and `assert_ne!` macros:"
msgstr "以下是比较两个支架的简单例子,显示如何使用`assrt_eq!'和`assrt_ne!'宏:"

#: src/ch10-01-how-to-write-tests.md:440
msgid "\"{:?},{:?} should be equal\""
msgstr "{{:}}{{}}}应该平等。}"

#: src/ch10-01-how-to-write-tests.md:442
msgid "\"{:?},{:?} should not be equal\""
msgstr "\"{{:}}{{}}}不应该是平等的。\""

#: src/ch10-01-how-to-write-tests.md:446
msgid ""
"Under the surface, `assert_eq!` and `assert_ne!` macros use the operators "
"`==` and `!=`, respectively. They both take snapshots of values as "
"arguments. When the assertions fail, these macros print their arguments "
"using debug formatting (`{:?}` syntax), which means the values being "
"compared must implement `PartialEq` and `Debug` traits. All primitive types "
"and most of the core library types implement these traits. For structs and "
"enums that you define yourself, you’ll need to implement `PartialEq` to "
"assert equality of those types. You’ll also need to implement `Debug` to "
"print the values when the assertion fails. Because both traits are "
"derivable, this is usually as straightforward as adding the `#[derive(Drop, "
"Debug, PartialEq)]` annotation to your struct or enum definition. See "
"[Appendix C](./appendix-03-derivable-traits.md) for more details about these"
" and other derivable traits."
msgstr "在表面之下,`Assert_eq!'和`Assert_eq.'和`Assert_ne!'宏分别使用操作员'和'{}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Assert_eq\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch10-01-how-to-write-tests.md:457
msgid "`assert_lt!`, `assert_le!`, `assert_gt!` and `assert_ge!` Macros"
msgstr "`assrt_lt!'、`assrt_le!'、`assrt_gt!'和`assrt_ge!'宏"

#: src/ch10-01-how-to-write-tests.md:459
msgid "Comparisons in tests can be done using the `assert_xx!` macros:"
msgstr "可以用`assirt_xx!' 宏进行测试比较:"

#: src/ch10-01-how-to-write-tests.md:461
msgid ""
"`assert_lt!` checks if a given value is lower than another value, and "
"reverts otherwise."
msgstr "`assirt_lt!' 检查给定值是否低于另一个值,并反转其他值。"

#: src/ch10-01-how-to-write-tests.md:462
msgid ""
"`assert_le!` checks if a given value is lower or equal than another value, "
"and reverts otherwise."
msgstr "`assrt_le!'检查给定价值是否低于或等于其他价值,并反弹。"

#: src/ch10-01-how-to-write-tests.md:463
msgid ""
"`assert_gt!` checks if a given value is greater than another value, and "
"reverts otherwise."
msgstr "`assrt_gt!'检查给定值是否大于其他值,然后反转。"

#: src/ch10-01-how-to-write-tests.md:464
msgid ""
"`assert_ge!` checks if a given value is greater or equal than another value,"
" and reverts otherwise."
msgstr "`assirt_ge!'检查给定价值是否大于或等于其他价值,并反弹。"

#: src/ch10-01-how-to-write-tests.md:466
msgid "Listing 10-6 demonstrates how to use these macros:"
msgstr "列表 10-6 演示如何使用这些宏:"

#: src/ch10-01-how-to-write-tests.md:504
msgid "\"{:?},{:?} should be lower or equal\""
msgstr "\"{{:}}{{}}}应该更低或相等\""

#: src/ch10-01-how-to-write-tests.md:509
msgid ""
"<span class=\"caption\">Listing 10-6: Example of tests that use the "
"`assert_xx!` macros for comparisons</span>"
msgstr "<span类=“caption” > listing 10-6:使用`assirt_xx!'`宏比较 </span>的测试示例"

#: src/ch10-01-how-to-write-tests.md:511
msgid ""
"In this example, we roll a `Dice` struct multiple times and compare the "
"results. We need to manually implement the `PartialOrd` trait for our struct"
" so that we can compare `Dice` instances with `lt`, `le`, `gt` and `ge` "
"functions, which are used by `assert_lt!`, `assert_le!`, `assert_gt!` and "
"`assert_ge!` macros, respectively. We also need to derive the `Copy` trait "
"on our `Dice` struct to use the instantiated structs multiple times, as the "
"comparison functions take ownership of the variables."
msgstr ""
"在这个例子中,我们滚动了`Dice'多次支架并比较结果,我们需要手动执行`Partial Ord' "
"特性,以便我们能够将`Dice'实例与`lt'、`le'、`gt'和`ge'功能进行比较,这些功能被`assrt_lt!'、`assrt_le!'、`assirt_gt!'和`assirt_ge!'"
" 宏大分别使用。我们还需要从我们的`Dice'中获取`Copy'特性,以便使用即时支架多次,因为比较功能要掌握变量的所有权。"

#: src/ch10-01-how-to-write-tests.md:513
msgid "Adding Custom Failure Messages"
msgstr "添加自定义失败消息"

#: src/ch10-01-how-to-write-tests.md:515
msgid ""
"You can also add a custom message to be printed with the failure message as "
"optional arguments to `assert!`, `assert_eq!`, and `assert_ne!` macros. Any "
"arguments specified after the required arguments are passed along to the "
"`format!` macro (discussed in the "
"[Printing](./ch11-08-printing.md#formatting) chapter), so you can pass a "
"format string that contains `{}` placeholders and values to go in those "
"placeholders. Custom messages are useful for documenting what an assertion "
"means; when a test fails, you’ll have a better idea of what the problem is "
"with the code."
msgstr ""
"您也可以在“ assrt! ” 、 “assrt_eq!” 和“assrt_ne!” 宏中添加一个用失败信息打印的自定义电文,作为“assrt!” 、 "
"“assrt_eq!” 和“assrt_ne!” 宏。在必要参数之后指定的任何参数都传递到“format!” 宏(在 [printing] "
"(./ch11-08-printing.md#formatting) 章中讨论), 这样您就可以通过一个包含 占位符和值的格式字符串, "
"以在这些占位符中输入。 自定义电文有助于记录一个声明的含义; 当测试失败时, 您将更清楚地了解代码的问题是什么 。"

#: src/ch10-01-how-to-write-tests.md:523
msgid ""
"Let’s add a custom failure message composed of a format string with a "
"placeholder filled in with the actual value we got from the `add_two` "
"function:"
msgstr "让我们添加由格式字符串组成的自定义失败信息,其中含有一个占位符,以我们从`add_ two' 函数中获得的实际值填充:"

#: src/ch10-01-how-to-write-tests.md:530
msgid "\"Expected {}, got add_two(2)={}\""
msgstr "\"预期...,加了两(2)...\""

#: src/ch10-01-how-to-write-tests.md:534
msgid "Now when we run the test, we’ll get a more informative error message:"
msgstr "当我们进行测试时, 我们将会收到更多信息错误信息:"

#: src/ch10-01-how-to-write-tests.md:536
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 1 test\n"
"test adder::tests::it_adds_two ... fail (gas usage est.: 590230)\n"
"failures:\n"
"   adder::tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` failed: Expected 4, got add_two(2)=5\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"贝壳 $ carb cairo 测试添加器... 运行 1 个测试添加器 : 测试 :: 测试 : it_ adds_ two... 失败 (气体使用率"
" : 590230 ) 失败 : 添加 : 测试 : 测试 : it_ adds_ two - 被“ assertion'4 ” 困扰 : 添加 _ 2"
" (2) 失败 : 预测 4 添加 _ 2 (2)= 5 : 4 添加_ 2 (2): 5 错误 : 测试结果 : FAILED. 0 passed; "
"1 失败; 0 忽略 *"

#: src/ch10-01-how-to-write-tests.md:549
msgid ""
"We can see the value we actually got in the test output, which would help us"
" debug what happened instead of what we were expecting to happen."
msgstr "我们可以看到我们实际在测试输出中得到的价值, 这将有助于我们调试所发生的事情, 而不是我们预期会发生的事情。"

#: src/ch10-01-how-to-write-tests.md:554
msgid "Checking for panics with `should_panic`"
msgstr "与`应该'的`西班牙'检查惊慌症"

#: src/ch10-01-how-to-write-tests.md:556
msgid ""
"In addition to checking return values, it’s important to check that our code"
" handles error conditions as we expect. For example, consider the `Guess` "
"type in Listing 10-7:"
msgstr "除了检查返回值之外,还必须检查我们的代码是否按照预期处理错误条件。例如,在列出 10-7 中考虑“建议”类型:"

#: src/ch10-01-how-to-write-tests.md:573 src/ch10-01-how-to-write-tests.md:625
msgid "\"Guess must be >= 1 and <= 100\""
msgstr "Guess must be  1 and  100\" \"guess must be  1 and  100\""

#: src/ch10-01-how-to-write-tests.md:581
msgid ""
"<span class=\"caption\">Listing 10-7: `Guess` struct and its `new` "
"method</span>"
msgstr "<span类=“Caption” > listing 10-7:`Guess`struct及其`新'方法</span>"

#: src/ch10-01-how-to-write-tests.md:583
msgid ""
"Other code that uses `Guess` depends on the guarantee that `Guess` instances"
" will contain only values between `1` and `100`. We can write a test that "
"ensures that attempting to create a `Guess` instance with a value outside "
"that range panics."
msgstr ""
"使用`建议'的其他代码取决于保证`建议'实例只包含`1'和`100'之间的数值,我们可以写一个测试,确保试图创建`建议'实例,其数值超出恐慌范围。"

#: src/ch10-01-how-to-write-tests.md:585
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr "我们这样做的方法是将属性`应该'泛泛地'添加到我们的测试功能中。如果函数恐慌中的代码通过测试;如果函数中的代码不惊慌,测试就会失败。"

#: src/ch10-01-how-to-write-tests.md:600
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result to see that"
" this test passes:"
msgstr "我们把“{{[应_panic]’ ” 属性放在“{[测试]’ 属性之后,放在其应用的测试函数之前。让我们看看结果,看看这个测试是否通过了:"

#: src/ch10-01-how-to-write-tests.md:610
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the `new` function will panic if the value is greater than `100`:"
msgstr "现在让我们在代码中引入一个错误, 取消如果值超过“ 100”, “ 新” 功能会恐慌的条件 :"

#: src/ch10-01-how-to-write-tests.md:635
msgid "When we run the test, it will fail:"
msgstr "当我们进行测试时,它就会失败:"

#: src/ch10-01-how-to-write-tests.md:648
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]` attribute. "
"The failure we got means that the code in the test function did not cause a "
"panic."
msgstr "但当我们看测试功能时,我们看到它带有`[应该_panic]'属性的附加说明。 我们的失败意味着测试功能中的代码没有引起恐慌。"

#: src/ch10-01-how-to-write-tests.md:650
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional"
" `expected` parameter to the `#[should_panic]` attribute. The test harness "
"will make sure that the failure message contains the provided text. For "
"example, consider the modified code for `GuessImpl` in Listing 10-8 where "
"the `new` function panics with different messages depending on whether the "
"value is too small or too large:"
msgstr ""
"使用`应该_panic' 的测试可以是不精确的。即使测试恐慌的原因不同于我们预期的原因,`应该_panic' "
"的测试也会通过。为了使`应该_panic'的测试更加精确,我们可以在 {[应该_panic] "
"属性中添加一个可选的`预期的'参数。测试工具将确保失败信息包含所提供的文本。例如,在列出 10-8 "
"的列表中,“新”功能以不同信息产生恐慌,视值是否太小或太大而定。"

#: src/ch10-01-how-to-write-tests.md:667 src/ch10-01-how-to-write-tests.md:702
msgid "\"Guess must be >= 1\""
msgstr "猜想必是\"1\""

#: src/ch10-01-how-to-write-tests.md:669 src/ch10-01-how-to-write-tests.md:681
#: src/ch10-01-how-to-write-tests.md:700 src/ch10-01-how-to-write-tests.md:714
msgid "\"Guess must be <= 100\""
msgstr "猜想必是100"

#: src/ch10-01-how-to-write-tests.md:690
msgid ""
"<span class=\"caption\">Listing 10-8: `new` implementation that panics with "
"different error messages</span>"
msgstr "<span class=\" caption\" > listing 10-8:`新的'执行,以不同的错误信息产生恐慌 </span>"

#: src/ch10-01-how-to-write-tests.md:692
msgid ""
"The test will pass because the value we put in the `should_panic` "
"attribute’s `expected` parameter is the string that the `Guess::new` method "
"panics with. We need to specify the entire panic message that we expect."
msgstr ""
"测试将会通过, 因为我们在`应该' 泛域属性的`预期'参数中输入的值是`建议:新` 方法恐慌的字符串。 我们需要具体说明我们期待的全部恐慌信息 。"

#: src/ch10-01-how-to-write-tests.md:694
msgid ""
"To see what happens when a `should_panic` test with an expected message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the `if value < 1` and the `else if value > 100` blocks:"
msgstr ""
"为了看到在`应该_panic' 测试与预期电文失败时会发生什么,让我们再次将`如果值 < 1'和`else 如果值 > "
"100'区块的体体互换,从而将一个错误引入我们的代码:"

#: src/ch10-01-how-to-write-tests.md:721
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr "当我们这次进行`应该`泛美'测试时,它将失败:"

#: src/ch10-01-how-to-write-tests.md:723
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing guess ...\n"
"running 1 test\n"
"test guess::tests::greater_than_100 ... fail (gas usage est.: 26690)\n"
"failures:\n"
"   guess::tests::greater_than_100 - Panicked with \"Guess must be >= 1\".\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"jell $ warb cairo- test test guess... 运行一次测试猜测 :: tests:: "
"greater_than_100... 失败(气体使用率最高: 26690) 失败 : guess::: tests::: greater_than_ "
"100 - 被“ Guess must be # # 1” 包围 错误: 测试结果 : FAILED. 0 passed; 1 失败; 0 忽略 {}"

#: src/ch10-01-how-to-write-tests.md:733
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string. The "
"panic message that we did get in this case was `Guess must be >= 1`. Now we "
"can start figuring out where our bug is!"
msgstr ""
"失败信息显示,这次测试确实和我们预期的一样惊慌,但恐慌信息没有包括预期的字符串。我们在这个案例中得到的惊慌信息是`Guess必须是 #% 1'。 "
"现在我们可以开始弄清楚我们的错误在哪里了!"

#: src/ch10-01-how-to-write-tests.md:735
msgid "Running Single Tests"
msgstr "正在运行的单次测试"

#: src/ch10-01-how-to-write-tests.md:737
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working"
" on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing `scarb"
" cairo-test` an option `-f` (for \"filter\"), followed by the name of the "
"test you want to run as an argument."
msgstr ""
"有时,运行一个完整的测试套件需要很长时间。如果您在特定区域进行代码测试,您可能想要只运行与该代码相关的测试。您可以选择通过“scarb cairo-"
"test” 选项进行哪些测试,一个选项是 `-f' (“过滤器”),然后是您想要作为参数运行的测试的名称。"

#: src/ch10-01-how-to-write-tests.md:739
msgid ""
"To demonstrate how to run a single test, we’ll first create two test "
"functions, as shown in Listing 10-9, and choose which ones to run."
msgstr "为了演示如何进行单一测试, 我们将首先建立两个测试功能, 如列表 10- 9 所示,"

#: src/ch10-01-how-to-write-tests.md:755
msgid "\"result is not 5\""
msgstr "\"结果不是5\""

#: src/ch10-01-how-to-write-tests.md:760
msgid ""
"<span class=\"caption\">Listing 10-9: Two tests with two different "
"names</span>"
msgstr "<span类=\"Caption\" > listing 10-9:两次试验,名称两个不同 </span>"

#: src/ch10-01-how-to-write-tests.md:762
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that "
"test using the `-f` flag:"
msgstr "我们可以将任何测试功能的名称传递给`Cairo-test',仅使用`f'旗进行测试:"

#: src/ch10-01-how-to-write-tests.md:772
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t "
"match that name. The test output lets us know we had one more test that "
"didn’t run by displaying `1 filtered out;` at the end."
msgstr ""
"只有一个名为`add_ 2_和_ 2' 的测试运行; 另一个测试与该名称不匹配。 测试输出让我们知道我们还有另一个测试没有通过显示 `1 "
"过滤出来;'在结尾处。"

#: src/ch10-01-how-to-write-tests.md:774
msgid ""
"We can also specify part of a test name, and any test whose name contains "
"that value will be run."
msgstr "我们还可以指定测试名称的一部分, 任何名称包含该值的测试都将运行 。"

#: src/ch10-01-how-to-write-tests.md:776
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr "忽略某些试验,除非有具体要求"

#: src/ch10-01-how-to-write-tests.md:778
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you"
" might want to exclude them during most runs of `scarb cairo-test`. Rather "
"than listing as arguments all tests you do want to run, you can instead "
"annotate the time-consuming tests using the `#[ignore]` attribute to exclude"
" them, as shown here:"
msgstr ""
"有时候,一些特定的测试执行起来可能非常费时,所以在大多数`scarb cairo-"
"test'的运行过程中,你可能想排除它们。你不用列出所有您想要运行的测试作为参数,而是用`[ignore] 属性来说明耗时测试,以排除它们,如下文所示:"

#: src/ch10-01-how-to-write-tests.md:791
msgid "// code that takes an hour to run\n"
msgstr "需要一小时运行的代码\n"

#: src/ch10-01-how-to-write-tests.md:796
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""
"在`````之后,我们在我们想要排除的测试中加入```````````````````````````[举 ``[举 "
"`线。现在当我们进行测试时,``它`工作'在运行,但`昂贵的`检验'没有':"

#: src/ch10-01-how-to-write-tests.md:807
msgid "The `expensive_test` function is listed as ignored."
msgstr "`昂贵的测试'功能被列为被忽略。"

#: src/ch10-01-how-to-write-tests.md:809
msgid ""
"When you’re at a point where it makes sense to check the results of the "
"ignored tests and you have time to wait for the results, you can run `scarb "
"cairo-test --include-ignored` to run all tests, whether they’re ignored or "
"not."
msgstr ""
"当您处在检查被忽略的测试结果是有道理的并且您有时间等待结果的时候,您可以运行“ccarb cairo-test-including-"
"ignored”来运行所有测试,不管它们是否被忽略。"

#: src/ch10-01-how-to-write-tests.md:811
msgid "Testing Recursive Functions or Loops"
msgstr "测试递归函数或循环"

#: src/ch10-01-how-to-write-tests.md:813
msgid ""
"When testing recursive functions or loops, the test is instantiated by "
"default with a maximum amount of gas that it can consume. This prevents "
"running infinite loops or consuming too much gas, and can help you benchmark"
" the efficiency of your implementations. This value is assumed reasonably "
"large enough, but you can override it by adding the "
"`#[available_gas(<Number>)]` attribute to the test function. The following "
"example shows how to use it:"
msgstr ""
"当测试递归函数或循环时,该测试会默认地以其消耗的气体最大数量即时进行。这样可以防止运行无限循环或消耗过多气体,并且可以帮助您测量执行效率。这个数值被合理假定为足够大,但您可以通过在测试函数中添加"
" {[可获取_gas( < number > )'属性来覆盖它。以下示例显示如何使用它 :"

#: src/ch10-01-how-to-write-tests.md:834
msgid "\"result is not 55\""
msgstr "\"结果不是55\""

#: src/ch10-01-how-to-write-tests.md:839
msgid "Benchmarking the Gas Usage of a Specific Operation"
msgstr "确定具体行动使用天然气的基准"

#: src/ch10-01-how-to-write-tests.md:841
msgid ""
"When you want to benchmark the gas usage of a specific operation, you can "
"use the following pattern in your test function."
msgstr "当您想要对特定操作的气体使用量进行基准测试时,您可以在测试函数中使用以下模式。"

#: src/ch10-01-how-to-write-tests.md:846 src/ch10-01-how-to-write-tests.md:873
msgid "/// code we want to bench.\n"
msgstr "/ 代码,我们想坐以待毙。\n"

#: src/ch10-01-how-to-write-tests.md:847
msgid "\"{}\\n\""
msgstr "\"n\" \"n\" \"n\""

#: src/ch10-01-how-to-write-tests.md:850
msgid ""
"The following example shows how to use it to test the gas function of the "
"`sum_n` function above."
msgstr "以下示例显示如何使用它测试上面`sum_n'函数的气体函数。"

#: src/ch10-01-how-to-write-tests.md:875
msgid "\"consumed gas: {}\\n\""
msgstr "(消耗气体:n)"

#: src/ch10-01-how-to-write-tests.md:880
msgid ""
"The value printed when running `scarb cairo-test` is the amount of gas that "
"was consumed by the benchmarked operation."
msgstr "运行 \" 碎屑测试 \" 时打印的价值是基准作业消耗的天然气数量。"

#: src/ch10-01-how-to-write-tests.md:892
msgid ""
"Here, the gas usage of the `sum_n` function is `80690` (decimal "
"representation of the hex number). The total amount consumed by the test is "
"slightly higher at `140100`, due to some extra steps required to run the "
"entire test function."
msgstr ""
"此处,`总'函数的气体使用量为`80690'(十六进制数字的十进制表示),由于整个试验函数运行需要一些额外步骤,试验消耗的总金额略高,为`140100'。"

#: src/ch10-01-how-to-write-tests.md:894
msgid "{{#quiz ../quizzes/ch10-01-how_to_write_tests.toml}}"
msgstr "Quiz./quizzes/ch10-01-how_write_tests.toml_toml_"

#: src/ch10-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and "
"integration tests. Unit tests are small and more focused, testing one module"
" in isolation at a time, and can test private functions. Integration tests "
"use your code in the same way any other external code would, using only the "
"public interface and potentially exercising multiple modules per test."
msgstr ""
"我们将考虑两大类的测试:单位测试和集成测试。单位测试规模小,重点更突出,一次单独测试一个模块,可以测试私人功能。整合测试使用与其它任何外部代码相同的方式使用您的代码,只使用公共界面,并且每个测试可能使用多个模块。"

#: src/ch10-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr "两种测试的写作都很重要, 以确保您的图书馆的片段能按照您所期望的那样, 单独地和一起地做。"

#: src/ch10-02-test-organization.md:7
msgid "Unit Tests"
msgstr "单位测试"

#: src/ch10-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the"
" rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the `src` directory in each file with the"
" code that they’re testing."
msgstr ""
"单位测试的目的是在与代码其余部分分开的情况下测试每个代码单位,以便快速确定代码在哪些方面和在哪些方面没有达到预期效果。 "
"单位测试将在每个文件的`src'目录中加上它们正在测试的代码。"

#: src/ch10-02-test-organization.md:11
msgid ""
"The convention is to create a module named `tests` in each file to contain "
"the test functions and to annotate the module with `#[cfg(test)]` attribute."
msgstr "常规是在每个文件中创建一个名为“测试”的模块,以包含测试功能,并用 {[cfg(test)]} 属性对模块进行注释。"

#: src/ch10-02-test-organization.md:13
msgid "The Tests Module and `#[cfg(test)]`"
msgstr "测试模块和{{{[fcg(test)]}`"

#: src/ch10-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and"
" run the test code only when you run `scarb cairo-test`, not when you run "
"`scarb cairo-run`. This saves compile time when you only want to build the "
"library and saves space in the resulting compiled artifact because the tests"
" are not included. You’ll see that because integration tests go in a "
"different directory, they don’t need the `#[cfg(test)]` annotation. However,"
" because unit tests go in the same files as the code, you’ll use "
"`#[cfg(test)]` to specify that they shouldn’t be included in the compiled "
"result."
msgstr ""
"{{[cfg(test)]>`测试模块上的批注指示开罗只有在运行`scarb cairo-test'时才编辑和运行测试代码,而不是运行`scarb "
"cairo-"
"run'时。这只节省了您想要建造图书馆和保存空间的时间,因为测试不包括此结果所编成的文物。您会看到,由于整合测试在不同的目录中进行,所以他们不需要\\{[cfg(test)]`批注。然而,由于单位测试在与代码相同的文档中进行,您会使用{{[cfg(test)]’来指定它们不应包含在汇编的结果中。}"

#: src/ch10-02-test-organization.md:17
msgid ""
"Recall that when we created the new _adder_ project in the first section of "
"this chapter, we wrote this first test:"
msgstr "回顾当我们在本章第一节创建新的_adder_项目时,我们写了第一个测试:"

#: src/ch10-02-test-organization.md:30
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the "
"following item should only be included given a certain configuration option."
" In this case, the configuration option is `test`, which is provided by "
"Cairo for compiling and running tests. By using the `cfg` attribute, Cairo "
"compiles our test code only if we actively run the tests with `scarb cairo-"
"test`. This includes any helper functions that might be within this module, "
"in addition to the functions annotated with `#[test]`."
msgstr ""
"属性 `cfg' 表示配置, 并告诉开罗, 下项只应包含一个特定配置选项。 在此情况下, 配置选项是“ 测试 ”, 由开罗提供用于汇编和运行测试。 "
"开罗使用 `cfg' 属性, 只有在我们积极使用 scrab cairo- test 进行测试时, 才会编集我们的测试代码 。 "
"这包括本模块中可能包含的任何辅助功能, 除了“ [test] ” 附加说明的功能之外 。"

#: src/ch10-02-test-organization.md:32
msgid "Integration Tests"
msgstr "整合试验"

#: src/ch10-02-test-organization.md:34
msgid ""
"Integration tests use your library in the same way any other code would. "
"Their purpose is to test whether many parts of your library work together "
"correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is "
"important as well. To create integration tests, you first need a `tests` "
"directory."
msgstr ""
"整合测试使用您的图书馆的方式与其它代码相同。 整合测试的目的是测试您图书馆的许多部分是否正确合作。 整合时,正确运行的代码单位本身可能会有问题, "
"因此测试覆盖整合代码也很重要 。 要创建整合测试, 您首先需要“ 测试” 目录 。"

#: src/ch10-02-test-organization.md:36
msgid "The _tests_ Directory"
msgstr "测试目录(_T)"

#: src/ch10-02-test-organization.md:48
msgid "First of all, add the following code in your _lib.cairo_ file:"
msgstr "首先,在您的 _lib.cairo_ 文件中添加以下代码:"

#: src/ch10-02-test-organization.md:50
msgid "<span class=\"caption\">Filename: src/lib.cairo</span>"
msgstr "<span类=“ caption” >Filename: src/lib.cairo </span>"

#: src/ch10-02-test-organization.md:61
msgid ""
"Note that we still need to use the `#[cfg(test)]` attribute here, because we"
" are in the _lib.cairo_ file of the _src_ directory. Then, create a "
"_tests.cairo_ file and fill it as follows:"
msgstr ""
"请注意,我们仍然需要在此使用 {{{[cfg(test)]}}`属性,因为我们在 "
"_src_目录的_lib.cairo_文件中。然后,创建一个_tests.cairo_文件,并填写如下:"

#: src/ch10-02-test-organization.md:64
msgid "<span class=\"caption\">Filename: src/tests.cairo</span>"
msgstr "<span类=“ caption” >Filename: src/tests.cairo </span>"

#: src/ch10-02-test-organization.md:70
msgid ""
"Finally, enter this code into the _src/tests/integration_tests.cairo_ file:"
msgstr "最后,将此代码输入 _src/ tests/ complete_ tests.cairo_ 文件 :"

#: src/ch10-02-test-organization.md:72
msgid "<span class=\"caption\">Filename: src/tests/integration_tests.cairo</span>"
msgstr ""
"<span class=\"caption\" > Filename: src/ tests/ international_ tests.cairo "
"</span> /span> 类: src/ tests/ international_ tests.cairo </span>"

#: src/ch10-02-test-organization.md:79
msgid "\"internal_adder failed\""
msgstr "“ 内部 - adder 失败 ”"

#: src/ch10-02-test-organization.md:83
msgid ""
"We need to bring our tested functions into each test file scope. For that "
"reason we add `use adder::it_adds_two` at the top of the code, which we "
"didn’t need in the unit tests."
msgstr ""
"我们需要将测试过的函数引入每个测试文件范围。 因此,我们需要在代码的顶端添加“ 使用添加器 : it_ adds_ two ”, "
"而在单位测试中我们不需要。"

#: src/ch10-02-test-organization.md:85
msgid ""
"Then, to run all of our integration tests, we can just add a filter to only "
"run tests whose path contains \"integration_tests\"."
msgstr "然后,为了运行我们所有的整合测试, 我们可以在只运行路径包含“整合测试”的测试中添加一个过滤器。"

#: src/ch10-02-test-organization.md:100
msgid ""
"The result of the tests is the same as what we've been seeing: one line for "
"each test."
msgstr "测试结果和我们所看到的一样 每个测试一行"

#: src/ch10-02-test-organization.md:102
msgid "{{#quiz ../quizzes/ch10-02-testing-organization.toml}}"
msgstr "Quiz./quizzes/ch10-02-测试组织.toml"

#: src/ch11-00-advanced-features.md
msgid "Advanced Features"
msgstr "高级特征"

#: src/ch11-00-advanced-features.md
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr "现在,让我们来学习一下开罗提供的更先进的特色。"

#: src/ch11-01-custom-data-structures.md:3
msgid ""
"When you first start programming in Cairo, you'll likely want to use arrays "
"(`Array<T>`) to store collections of data. However, you will quickly realize"
" that arrays have one big limitation - the data stored in them is immutable."
" Once you append a value to an array, you can't modify it."
msgstr ""
"当您首次在开罗启动编程时, 您可能想要使用数组 (`Array<T}) 来存储数据收藏。 但是, 您会很快意识到数组有一个很大的限制, "
"其中存储的数据是不可变的。 一旦您将一个数值附加到一个数组中, 您就不能修改它 。"

#: src/ch11-01-custom-data-structures.md:8
msgid ""
"This can be frustrating when you want to use a mutable data structure. For "
"example, say you're making a game where the players have a level, and they "
"can level up. You might try to store the level of the players in an array:"
msgstr ""
"当您想要使用可变数据结构时, 这可能令人沮丧。 例如, 说您正在做一个游戏, 玩家有一个级别, 并且他们可以平整。 "
"您可能会尝试将玩家的级别存储在一个阵列中 :"

#: src/ch11-01-custom-data-structures.md:16
msgid ""
"But then you realize you can't increase the level at a specific index once "
"it's set. If a player dies, you cannot remove it from the array unless he "
"happens to be in the first position."
msgstr "但随后你就会意识到,一旦设定了特定的索引,你就不能提高它的水平。如果玩家死亡,除非他恰好处于第一个位置,否则你不能从数组中移除它。"

#: src/ch11-01-custom-data-structures.md:20
msgid ""
"Fortunately, Cairo provides a handy built-in [dictionary "
"type](./ch03-02-dictionaries.md) called `Felt252Dict<T>` that allows us to "
"simulate the behavior of mutable data structures. Let's first explore how to"
" create a struct that contains, among others, a `Felt252Dict<T>`."
msgstr ""
"幸运的是,开罗提供了一个称为“Felt252Dict<T”的便携内置[字典类型](./ch03-02-字典.md),使我们能够模拟可变数据结构的行为。让我们首先探索如何创建包含“Felt252Dict<T”等内容的支架。"

#: src/ch11-01-custom-data-structures.md:23
msgid ""
"Note: Several concepts used in this chapter were already presented earlier "
"in the book. We recommend checking out the following chapters if you need to"
" revise them: [Structs](ch05-00-using-structs-to-structure-related-data.md),"
" [Methods](./ch05-03-method-syntax.md), [Generic types](./ch08-00-generic-"
"types-and-traits.md), [Traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"注:本书早些时候已经介绍了本章中使用的若干概念。如果需要修改这些概念,我们建议检查以下各章:[Structs](ch05-00-useing-"
"structs-structs-to-结构相关数据.md),[方法](.ch05-03-method-"
"syngy.md),[基因类型](./ch08-00-generic-type-types-and-"
"traits.md),[traits](./ch08-02-traits-in-cairo.md)。"

#: src/ch11-01-custom-data-structures.md:29
msgid "Dictionaries as Struct Members"
msgstr "作为严格成员的字典词典"

#: src/ch11-01-custom-data-structures.md:31
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly "
"interacting with them may not be entirely seamless. Let's try implementing a"
" custom _user database_ that will allow us to add users and query them. We "
"will need to define a struct to represent the new type and a trait to define"
" its functionality:"
msgstr ""
"将字典定义为结构成员在开罗是可能的, 但与它们进行正确互动可能不是完全无缝的。 让我们尝试执行一个自定义的用户数据库, 以便我们添加用户并查询它们。 "
"我们需要定义一个结构来代表新类型, 以及定义其功能的特性 :"

#: src/ch11-01-custom-data-structures.md:46
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic"
" over the balances of the users, giving major flexibility to whoever uses "
"our data type. Its two members are:"
msgstr "我们的新类型“UsrDatabase<T ” 是一个用户数据库,通用于用户平衡,给使用我们数据类型的人很大的灵活性。"

#: src/ch11-01-custom-data-structures.md:48
msgid "`users_updates`, the number of users updates in the dictionary."
msgstr "\" 用户更新 \",即字典中更新的用户数量。"

#: src/ch11-01-custom-data-structures.md:49
msgid "`balances`, a mapping of each user to its balance."
msgstr "`平衡 ',即每个用户的平衡图。"

#: src/ch11-01-custom-data-structures.md:51
msgid ""
"The database core functionality is defined by `UserDatabaseTrait`. The "
"following methods are defined:"
msgstr "数据库核心功能由 \" UserDatabaseTrait \" 界定。"

#: src/ch11-01-custom-data-structures.md:53
msgid "`new` for easily creating new `UserDatabase` types."
msgstr "`新 ',便于创建新的`用户数据库'类型。"

#: src/ch11-01-custom-data-structures.md:54
msgid "`update_user` to update the balance of users in the database."
msgstr "`更新用户 ',以更新数据库中用户的平衡。"

#: src/ch11-01-custom-data-structures.md:55
msgid "`get_balance` to find user's balance in the database."
msgstr "`找到`平衡'在数据库中找到用户的余额。"

#: src/ch11-01-custom-data-structures.md:57
msgid ""
"The only remaining step is to implement each of the methods in "
"`UserDatabaseTrait`, but since we are working with [Generic "
"types](./ch08-00-generic-types-and-traits.md) we also need to correctly "
"establish the requirements of `T` so it can be a valid `Felt252Dict<T>` "
"value type:"
msgstr ""
"剩下的唯一步骤是执行`用户DatabaseTrait'的每一种方法,但由于我们正在与[基因类型](./ch08-00-generic-type-"
"types-and-traits.md)合作,我们还需要正确确定`T'的要求,以便它成为有效的`Felt252Dict<T}值类型:"

#: src/ch11-01-custom-data-structures.md:59
msgid ""
"`T` should implement the `Copy<T>` since it's required for getting values "
"from a `Felt252Dict<T>`."
msgstr "`T'应该执行`Copy<T',因为从`Felt252Dict<T'获取数值是必需的。"

#: src/ch11-01-custom-data-structures.md:60
msgid ""
"All value types of a dictionary implement the `Felt252DictValue<T>`, our "
"generic type should do as well."
msgstr "字典的所有值类型都执行“Felt252DictValue<T,我们的通用类型也应这样做。"

#: src/ch11-01-custom-data-structures.md:61
msgid ""
"To insert values, `Felt252DictTrait<T>` requires all value types to be "
"droppable (implement the `Drop<T>` trait)."
msgstr "要插入值,“Felt252DictTrait<T”要求所有值类型都可投放(执行“滴滴<T”特性)。"

#: src/ch11-01-custom-data-structures.md:63
msgid ""
"The implementation, with all restrictions in place, would be as follows:"
msgstr "执行工作将按下列方式执行,并实行所有限制:"

#: src/ch11-01-custom-data-structures.md:67
#: src/ch11-01-custom-data-structures.md:112
msgid "// Creates a database\n"
msgstr "/ 创建数据库\n"

#: src/ch11-01-custom-data-structures.md:72
#: src/ch11-01-custom-data-structures.md:117
msgid "// Get the user's balance\n"
msgstr "获得用户的余额\n"

#: src/ch11-01-custom-data-structures.md:77
#: src/ch11-01-custom-data-structures.md:122
msgid "// Add a user\n"
msgstr "/ 添加用户\n"

#: src/ch11-01-custom-data-structures.md:85
msgid ""
"Our database implementation is almost complete, except for one thing: the "
"compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since"
" it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait. "
"Since it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are"
" forced to implement the `Destruct<T>` trait manually (refer to the "
"[Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for more "
"information). Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` "
"definition won't work because of the use of [Generic "
"types](./ch08-00-generic-types-and-traits.md) in the struct definition. We "
"need to code the `Destruct<T>` trait implementation by ourselves:"
msgstr ""
"除了一件事以外,我们的数据库实施几乎是完整的:编译者不知道如何使“用户数据库<T ” 超出范围,因为它没有执行“滴滴<T 特性”或“销毁<T 特性” "
"。由于它作为成员拥有“Felt252Dict<T ”,因此无法丢弃,因此我们被迫在结构定义中使用“销毁” (./ch08-00-generic-"
"type-type-andrits.md) 的手工特性(指[所有者] (ch04-01-what-what-own-own-"
"own.md#d-droft-trait) 一章,以获取更多信息。在“用户数据库<T 定义” 之前,使用“ 发送(destruction) "
"定义不会起作用,因为在结构定义中使用[Generic类型] (./ch08-00-generic-ty-ty-ty-and.md) "
"。我们需要将“设计<T 执行” 定义编码:"

#: src/ch11-01-custom-data-structures.md:97
msgid ""
"Implementing `Destruct<T>` for `UserDatabase` was our last step to get a "
"fully functional database. We can now try it out:"
msgstr "实施`为`用户数据库'实施“破坏<T'”是我们获得一个功能齐全的数据库的最后一步。"

#: src/ch11-01-custom-data-structures.md:147
msgid "\"Expected 40\""
msgstr "\"预期40\""

#: src/ch11-01-custom-data-structures.md:148
msgid "\"Expected 0\""
msgstr "\"预期0\""

#: src/ch11-01-custom-data-structures.md:156
msgid "Simulating a Dynamic Array with Dicts"
msgstr "用 Dicts 模拟动态阵列"

#: src/ch11-01-custom-data-structures.md:158
msgid ""
"First, let's think about how we want our mutable dynamic array to behave. "
"What operations should it support?"
msgstr "首先,让我们想一想我们如何让变异的动态阵列行为。它应该支持什么行动?"

#: src/ch11-01-custom-data-structures.md:161
msgid "It should:"
msgstr "它应当:"

#: src/ch11-01-custom-data-structures.md:163
msgid "Allow us to append items at the end."
msgstr "允许我们在末尾附加项目。"

#: src/ch11-01-custom-data-structures.md:164
msgid "Let us access any item by index."
msgstr "让我们以指数方式查阅任何项目。"

#: src/ch11-01-custom-data-structures.md:165
msgid "Allow setting the value of an item at a specific index."
msgstr "允许在特定索引中设定项目值。"

#: src/ch11-01-custom-data-structures.md:166
msgid "Return the current length."
msgstr "返回当前长度 。"

#: src/ch11-01-custom-data-structures.md:168
msgid "We can define this interface in Cairo like:"
msgstr "我们可以将开罗的这个界面定义为:"

#: src/ch11-01-custom-data-structures.md:181
msgid ""
"This provides a blueprint for the implementation of our dynamic array. We "
"named it _Vec_ as it is similar to the `Vec<T>` data structure in Rust."
msgstr "这是执行动态阵列的蓝图。 我们命名它为 _Vec_, 因为它类似于 Rust 中的“Vec<T ” 数据结构 。"

#: src/ch11-01-custom-data-structures.md:184
msgid "Implementing a Dynamic Array in Cairo"
msgstr "在开罗实施动态阵列"

#: src/ch11-01-custom-data-structures.md:186
msgid ""
"To store our data, we'll use a `Felt252Dict<T>` which maps index numbers "
"(felts) to values. We'll also store a separate `len` field to track the "
"length."
msgstr ""
"为了存储我们的数据, 我们将使用“ Felt252Dict<T” 来绘制值的索引编号( felts) 。 我们还会存储一个单独的“ len” "
"字段来跟踪长度 。"

#: src/ch11-01-custom-data-structures.md:189
msgid ""
"Here is what our struct looks like. We wrap the type `T` inside `Nullable` "
"pointer to allow using any type `T` in our data structure, as explained in "
"the [Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-"
"supported-natively) section:"
msgstr ""
"这就是我们结构的外形。我们把`T'型号包在`Nullble'指针内,以便在我们的数据结构中使用任何类型的`T "
"',正如[字典](./ch03-02-词典.md#词典-类型不支持-本地)部分所解释的:"

#: src/ch11-01-custom-data-structures.md:200
msgid ""
"Since we again have `Felt252Dict<T>` as a struct member, we need to "
"implement the `Destruct<T>` trait to tell the compiler how to make "
"`NullableVec<T>` go out of scope."
msgstr ""
"由于我们再次拥有“Felt252Dict<T”作为支架成员,我们需要实施“破坏<T”特性,告诉汇编者如何使“NullbleVec<T”超出范围。"

#: src/ch11-01-custom-data-structures.md:210
msgid ""
"The key thing that makes this vector mutable is that we can insert values "
"into the dictionary to set or update values in our data structure. For "
"example, to update a value at a specific index, we do:"
msgstr "使矢量变异的关键在于 我们可以在字典中插入值, 以设置或更新数据结构中的值。 例如, 要在特定索引中更新值, 我们做 :"

#: src/ch11-01-custom-data-structures.md:216
#: src/ch11-01-custom-data-structures.md:245
#: src/ch11-01-custom-data-structures.md:254
msgid "\"Index out of bounds\""
msgstr "\"内分泌出界\""

#: src/ch11-01-custom-data-structures.md:221
msgid ""
"This overwrites the previously existing value at that index in the "
"dictionary."
msgstr "此溢出在字典中该索引上先前存在的值 。"

#: src/ch11-01-custom-data-structures.md:223
msgid ""
"While arrays are immutable, dictionaries provide the flexibility we need for"
" modifiable data structures like vectors."
msgstr "虽然阵列是不可变的,但词典提供了我们所需要的灵活性,用于可变数据结构,如矢量。"

#: src/ch11-01-custom-data-structures.md:226
msgid ""
"The implementation of the rest of the interface is straightforward. The "
"implementation of all the methods defined in our interface can be done as "
"follow :"
msgstr "其余接口的实施是直截了当的。"

#: src/ch11-01-custom-data-structures.md:263
msgid ""
"The full implementation of the `Vec` structure can be found in the "
"community-maintained library [Alexandria](https://github.com/keep-starknet-"
"strange/alexandria/tree/main/packages/data_structures/src)."
msgstr ""
"在社区图书馆[Alexandria](https://github.com/keep-starknet-"
"strange/alexandria/tree/main/packages/data_strucs/src)中可以找到 \" Vec \" "
"结构的充分实施情况。"

#: src/ch11-01-custom-data-structures.md:268
msgid "Simulating a Stack with Dicts"
msgstr "模拟带有二进制的堆叠"

#: src/ch11-01-custom-data-structures.md:270
msgid ""
"We will now look at a second example and its implementation details: a "
"Stack."
msgstr "我们现在将研究第二个例子及其执行细节:一个堆叠。"

#: src/ch11-01-custom-data-structures.md:272
msgid ""
"A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new "
"element and removal of an existing element takes place at the same end, "
"represented as the top of the stack."
msgstr ""
"Stack 是一个 LIFO( Last- in, first- out) 收藏。 插入新元素和删除现有元素发生在同一端, 以堆叠的顶部表示 。"

#: src/ch11-01-custom-data-structures.md:276
msgid "Let us define what operations we need to create a stack:"
msgstr "让我们界定我们需要什么行动来创造堆叠:"

#: src/ch11-01-custom-data-structures.md:278
msgid "Push an item to the top of the stack."
msgstr "将一个项目推到堆叠的顶端 。"

#: src/ch11-01-custom-data-structures.md:279
msgid "Pop an item from the top of the stack."
msgstr "从堆叠顶部弹出一个项 。"

#: src/ch11-01-custom-data-structures.md:280
msgid "Check whether there are still any elements in the stack."
msgstr "检查堆栈中是否还有元素 。"

#: src/ch11-01-custom-data-structures.md:282
msgid "From these specifications we can define the following interface :"
msgstr "根据这些规格,我们可以界定以下界面:"

#: src/ch11-01-custom-data-structures.md:292
msgid "Implementing a Mutable Stack in Cairo"
msgstr "在开罗实施一个 Mutabable堆堆"

#: src/ch11-01-custom-data-structures.md:294
msgid ""
"To create a stack data structure in Cairo, we can again use a "
"`Felt252Dict<T>` to store the values of the stack along with a `usize` field"
" to keep track of the length of the stack to iterate over it."
msgstr ""
"要在开罗创建堆叠数据结构, 我们可以再次使用“ Felt252Dict<T ” 来存储堆叠的值, 并同时存储“ 启用” 字段, 以跟踪堆叠在堆叠上的长度"
" 。"

#: src/ch11-01-custom-data-structures.md:298
msgid "The Stack struct is defined as:"
msgstr "Stack 支架的定义是:"

#: src/ch11-01-custom-data-structures.md:307
msgid ""
"Next, let's see how our main functions `push` and `pop` are implemented."
msgstr "接下来,让我们看看我们的主要职能“推”和“波”是如何落实的。"

#: src/ch11-01-custom-data-structures.md:330
msgid ""
"The code uses the `insert` and `get` methods to access the values in the "
"`Felt252Dict<T>`. To push an element to the top of the stack, the `push` "
"function inserts the element in the dict at index `len` and increases the "
"`len` field of the stack to keep track of the position of the stack top. To "
"remove a value, the `pop` function decreases the value of `len` to update "
"the position of the stack top and then retrieves the last value at position "
"`len`."
msgstr ""
"代码使用“插入”和“获取”方法来访问“Felt252Dict<T”中的值。要将元素推到堆叠的顶部,“推”功能在索引“ len” "
"上插入刻录器中的元素,并增加堆叠的“ len” 字段以跟踪堆叠顶部的位置。要删除一个值,“po” 函数会降低“ len” "
"值以更新堆叠顶部的位置,然后在位置“ len” 上检索最后的值。"

#: src/ch11-01-custom-data-structures.md:337
msgid ""
"The full implementation of the Stack, along with more data structures that "
"you can use in your code, can be found in the community-maintained "
"[Alexandria](https://github.com/keep-starknet-"
"strange/alexandria/tree/main/packages/data_structures/src) library, in the "
"\"data_structures\" crate."
msgstr ""
"可在社区维护的[Alexandria]图书馆(https://github.com/keep-starknet-"
"strange/alexandria/tree/main/packages/data_结构/src)中找到“数据结构”软件库的全面实施以及可在代码中使用的更多数据结构。"

#: src/ch11-01-custom-data-structures.md:343
msgid "{{#quiz ../quizzes/ch11-01-custom-structs.toml}}"
msgstr "Quiz./quizzes/ch11-01-海关结构.toml"

#: src/ch11-01-custom-data-structures.md:347
msgid ""
"Well done! Now you have knowledge of arrays, dictionaries and even custom "
"data structures. While Cairo's memory model is immutable and can make it "
"difficult to implement mutable data structures, we can fortunately use the "
"`Felt252Dict<T>` type to simulate mutable data structures. This allows us to"
" implement a wide range of data structures that are useful for many "
"applications, effectively hiding the complexity of the underlying memory "
"model."
msgstr ""
"做得好! 现在您掌握了阵列、 字典甚至自定义的数据结构的知识。 虽然开罗的记忆模型是不可改变的, 并且可能难以执行可变数据结构, 但幸运的是, "
"我们可以使用“ Felt252Dict<T ” 类型来模拟可变数据结构。 这使我们能够实施一系列对许多应用都有用的数据结构, "
"有效地隐藏基本内存模型的复杂性 。"

#: src/ch11-02-smart-pointers.md:3
msgid ""
"A pointer is a general concept for a variable that contains a memory "
"address. This address refers to, or “points at,” some other data. While "
"pointers are a powerful feature, they can also be a source of bugs and "
"security vulnerabilities. For example, a pointer can reference an unassigned"
" memory cell, which means that attempting to access the data at that address"
" would cause the program to crash, making it unprovable. To prevent such "
"issues, Cairo uses _Smart Pointers_."
msgstr ""
"指针是包含内存地址的变量的一般概念。 此地址指的是或“ 点点点 ” 的其他一些数据 。 虽然指针是一个强大的特征, 它们也可能是错误和安全弱点的来源。 "
"例如, 指针可以引用一个未指派的内存单元格, 这意味着试图访问该地址的数据会导致程序崩溃, 使其无法证明。 为了防止出现这些问题, 开罗使用 _ "
"Smart Pointers_ 。"

#: src/ch11-02-smart-pointers.md:5
msgid ""
"Smart pointers are data structures that act like a pointer, but also have "
"additional metadata and capabilities. The concept of smart pointers isn’t "
"unique to Cairo: smart pointers originated in C++ and exist in other "
"languages like Rust as well. In the specific case of Cairo, smart pointers "
"ensure that memory is not addressed in an unsafe way that could cause a "
"program to be unprovable, by providing a safe way to access memory through "
"strict type checking and ownership rules."
msgstr ""
"聪明的指针指针是像指针一样的数据结构,但也具有额外的元数据和能力。 聪明的指针概念不是开罗独有的:聪明的指针起源于C++,也存在于鲁斯特等其他语言中。 "
"在开罗的具体案例中,聪明的指针确保记忆不会以不安全的方式处理,从而通过严格的类型检查和所有制规则提供安全获取内存的途径,从而使程序无法被证实。"

#: src/ch11-02-smart-pointers.md:7
msgid ""
"Though we didn’t call them as such at the time, we’ve already encountered a "
"few smart pointers in this book, including `Felt252Dict<T>` and `Array<T>` "
"in Chapter 3. Both these types count as smart pointers because they own a "
"memory segment and allow you to manipulate it. They also have metadata and "
"extra capabilities or guarantees. Arrays keep track of their current length "
"to ensure that existing elements are not overwritten, and that new elements "
"are only appended to the end."
msgstr ""
"虽然我们当时没有这样称呼它们,但我们在这本书中已经遇到过几个聪明的指针,包括第3章中的“Felt252Dict<T”和“Array<T”。 "
"这两种类型都算作智能指针,因为它们拥有一个内存部分并允许你操纵它。它们也有元数据和额外能力或保证。 "
"阵列跟踪它们的当前长度,以确保现有元素不被覆盖,新元素仅附在结尾处。"

#: src/ch11-02-smart-pointers.md:9
msgid ""
"The Cairo VM memory is composed by multiple segments that can store data, "
"each identified by a unique index. When you create an array, you allocate a "
"new segment in the memory to store the future elements. The array itself is "
"just a pointer to that segment where the elements are stored."
msgstr ""
"开罗 VM "
"内存由多个区块组成,这些区块可以存储数据,每个区块由独特的索引识别。当您创建一个数组时,在内存中分配一个新的区块以存储未来元素。数组本身只是存储元素的该区块的指针。"

#: src/ch11-02-smart-pointers.md:11
msgid "The `Box<T>` Type to Manipulate Pointers"
msgstr "调控指针的“ ox< T} 类型”"

#: src/ch11-02-smart-pointers.md:13
msgid ""
"The principal smart pointer type in Cairo is a _box_, denoted as `Box<T>`. "
"Manually defining boxes allow you to store data in a specific memory segment"
" of the Cairo VM called the _boxed segment_. This segment is dedicated to "
"store all boxed values, and what remains in the execution segment is only a "
"pointer to the boxed segment. Whenever you instantiate a new pointer "
"variable of type `Box<T>`, you append the data of type `T` to the boxed "
"segment."
msgstr ""
"开罗的主要智能指针类型为 _box_, 称为“ Box< T ” 。 手定义框允许您将数据存储于开罗 VM 中名为 _boxed 段的特定内存部分中。 "
"此部分专门用于存储所有框中值, 执行部分中保留的数据仅是框中段的指针。 每当您将“ Box< T ” 类型中的新指针变量立即添加到框中段中, 您就会将“"
" T” 类型中的数据附加到框中段中 。"

#: src/ch11-02-smart-pointers.md:15
msgid ""
"Boxes have very little performance overhead, other than writing their inner "
"values to the boxed segment. But they don’t have many extra capabilities "
"either. You’ll use them most often in these situations:"
msgstr "框中除了将内值写到框框段外,没有多少性能管理。 但是它们也没有很多额外能力。 在这样的情况下,你会最经常地使用它们:"

#: src/ch11-02-smart-pointers.md:17
msgid ""
"When you have a type whose size can’t be known at compile time and you want "
"to use a value of that type in a context that requires an exact size"
msgstr "当您拥有一种类型, 其大小无法在编译时间得知时, 您想要在需要精确大小的上下文中使用该类型的值时"

#: src/ch11-02-smart-pointers.md:18
msgid ""
"When you have a large amount of data and you want to transfer ownership but "
"ensure the data won’t be copied when you do so"
msgstr "当您拥有大量数据并且想要转让所有权,但当您想要转移所有权时,您要确保当数据被复制时数据不会被复制"

#: src/ch11-02-smart-pointers.md:20
msgid ""
"We’ll demonstrate the first situation in the [“Enabling Recursive Types with"
" Boxes”](./ch11-02-smart-pointers.md#enabling-recursive-types-with-nullable-"
"boxes) section. In the second case, transferring ownership of a large amount"
" of data can take a long time because the data is copied around in memory. "
"To improve performance in this situation, we can store the large amount of "
"data in the boxed segment using a box type. Then, only the small amount of "
"pointer data is copied around in memory, while the data it references stays "
"in one place on the boxed segment."
msgstr ""
"我们将展示第一种情形,即[“用盒子帮助递归类型 ” (./ch11-02-智能点 。 md#ed#enbling-recurive-type- "
"with-nellable-boxes) "
"部分。在第二种情况下,大量数据的所有权转移需要很长时间,因为数据在记忆中被复制。在这种情形下,为了改进性能,我们可以使用盒式类型将大量数据存储在框式部分中。然后,只有少量的指针数据被复制到记忆中,而它提到的数据则留在框式部分的一个地方。"

#: src/ch11-02-smart-pointers.md:25
msgid "Using a `Box<T>` to Store Data in the Boxed Segment"
msgstr "使用 `Box<T} 将数据存储在框框片段"

#: src/ch11-02-smart-pointers.md:27
msgid ""
"Before we discuss the boxed segment storage use cases for `Box<T>`, we’ll "
"cover the syntax and how to interact with values stored within a `Box<T>`."
msgstr "在讨论“Box<T”的框框段储存使用案例之前, 我们将先讨论语法以及如何与“Box<T”中储存的值互动。"

#: src/ch11-02-smart-pointers.md:29
msgid ""
"Listing 11-1 shows how to use a box to store a value in the boxed segment:"
msgstr "列表 11-1 显示如何使用框框在框框段中存储值 :"

#: src/ch11-02-smart-pointers.md:34
msgid "\"b = {}\""
msgstr "\"b = \""

#: src/ch11-02-smart-pointers.md:38
msgid ""
"<span class=\"caption\">Listing 11-1: Storing a `u128` value in the boxed "
"segment using a box</span>"
msgstr "<span类=“Caption” > listing 11-1: 使用框 </span> 在框框段中存储“u128”值"

#: src/ch11-02-smart-pointers.md:40
msgid ""
"We define the variable `b` to have the value of a `Box` that points to the "
"value `5`, which is stored in the boxed segment. This program will print `b "
"= 5`; in this case, we can access the data in the box similar to how we "
"would if this data was simply in the execution memory. Putting a single "
"value in a box isn’t very useful, so you won’t use boxes by themselves in "
"this way very often. Having values like a single `u128` in the execution "
"memory, where they’re stored by default, is more appropriate in the majority"
" of situations. Let’s look at a case where boxes allow us to define types "
"that we wouldn’t be allowed to if we didn’t have boxes."
msgstr ""
"我们定义了变量`b', 以便拥有“Box”的价值, 它指向储存在框框中部分的`5' 值, 这个程序将打印“b = 5 ” ; 在这种情况下, "
"我们可以访问框中的数据, 类似于如果数据只是执行记忆中的数据, 我们如何访问框中的数据。 在框中放一个单值并不十分有用, "
"所以您不会经常以这种方式使用框子。 在大多数情况下, 执行内存中的数值像一个“ u128 ” 一样, 在默认存储时更合适。 "
"让我们看看一个箱子允许我们定义类型, 如果我们没有框的话, 我们就不会被允许使用。"

#: src/ch11-02-smart-pointers.md:42
msgid "Enabling Recursive Types with Nullable Boxes"
msgstr "启用带有无符号框的递递递性类型"

#: src/ch11-02-smart-pointers.md:46
msgid "Using Boxes to Improve Performance"
msgstr "使用方框改进业绩"

#: src/ch11-02-smart-pointers.md:48
msgid ""
"Passing pointers between functions allows you to reference data without "
"copying the data itself. Using boxes can improve performance as it allows "
"you to pass a pointer to some data from one function to another, without the"
" need to copy the entire data in memory before performing the function call."
" Instead of having to write `n` values into memory before calling a "
"function, only a single value is written, corresponding to the pointer to "
"the data. If the data stored in the box is very large, the performance "
"improvement can be significant, as you would save `n-1` memory operations "
"before each function call."
msgstr ""
"函数之间的传递指针允许您在不复制数据本身的情况下引用数据。 使用框可以提高性能, 因为它允许您将一个指针从一个函数传送到另一个函数, "
"无需在运行函数调用前将全部数据复制到记忆中, 而不必在调用函数前将“n” 值写入内存, 而不是在调用一个函数前将“n” 值写入内存, "
"而是写成一个单一的值, 与数据指针相对应。 如果存储在框中的数据非常大, 性能改进可以显著, 因为您可以在每次调用前保存“ n-1” 内存操作 。"

#: src/ch11-02-smart-pointers.md:50
msgid ""
"Let's take a look at the code in Listing 11-2, which shows two ways of "
"passing data to a function: by value and by pointer."
msgstr "让我们看看11-2列表中的代码, 它显示了将数据传输到函数的两种方式: 数值和指针。"

#: src/ch11-02-smart-pointers.md:61 src/ch11-02-smart-pointers.md:66
msgid "\"{} is shopping today and bought {} items\""
msgstr "\"今天买东西买东西\""

#: src/ch11-02-smart-pointers.md:70
msgid "\"Eli\""
msgstr "\"伊丽\""

#: src/ch11-02-smart-pointers.md:73
msgid "\"Uri\""
msgstr "\"乌里\""

#: src/ch11-02-smart-pointers.md:78
msgid ""
"<span class=\"caption\">Listing 11-2: Storing large amounts of data in a box"
" for performance.</span>"
msgstr "<span类=“caption” > listing 11-2: 在用于性能的框中存储大量数据 。 </span>"

#: src/ch11-02-smart-pointers.md:80
msgid "The `main` function includes 2 function calls:"
msgstr "`主要'职能包括2个职能电话:"

#: src/ch11-02-smart-pointers.md:82
msgid "`pass_data` that takes a variable of type `Cart`."
msgstr "\" pass_data \",采用 \" Cart \" 类型变量。"

#: src/ch11-02-smart-pointers.md:83
msgid "`pass_pointer` that takes a pointer of type `Box<Cart>`."
msgstr "`通过'指针 ',指针为`Box<Cart'。"

#: src/ch11-02-smart-pointers.md:85
msgid ""
"When passing data to a function, the entire data is copied into the last "
"available memory cells right before the function call. Calling `pass_data` "
"will copy all 3 fields of `Cart` to memory, while `pass_pointer` only "
"requires the copy of the `new_box` pointer which is of size 1."
msgstr ""
"当将数据传送到函数时,整个数据将被复制到函数调用前最后可用的内存单元格中。调用“pass_data”将把“Cart”的所有3个字段复制到内存,而“pass_pointer”只要求"
" 1 大小的“new_box”指针副本。"

#: src/ch11-02-smart-pointers.md:94
msgid ""
"The illustration above demonstrates how the memory behaves in both cases. "
"The first instance of `Cart` is stored in the execution segment, and we need"
" to copy all its fields to memory before calling the `pass_data` function. "
"The second instance of `Cart` is stored in the boxed segment, and the "
"pointer to it is stored in the execution segment. When calling the "
"`pass_pointer` function, only the pointer to the struct is copied to memory "
"right before the function call. In both cases, however, instantiating the "
"struct will store all its values in the execution segment: the boxed segment"
" can only be filled with data taken from the execution segment."
msgstr ""
"以上插图说明了这两种情况下的内存情况。第一个`Cart'实例存储在执行部分,我们需要在调用`pass_data' "
"函数之前将其所有字段复制到记忆中。第二个`Cart'实例存储在框框中,其指针存储在执行部分。当调用`pass_pointer'函数时,只有支架的指针在函数调用之前被复制到记忆中。但是,在这两种情况下,即时结构将把其所有数值存储在执行部分:只有从执行部分取的数据才能填充框中。"

#: src/ch11-02-smart-pointers.md:96
msgid "The `Nullable<T>` Type for Dictionaries"
msgstr "用于字典的“ ullball<T} 类型” 字典"

#: src/ch11-02-smart-pointers.md:98
msgid ""
"`Nullable<T>` is another type of smart pointer that can either point to a "
"value or be `null` in the absence of value. It is defined at the Sierra "
"level. This type is mainly used in dictionaries that contain types that "
"don't implement the `zero_default` method of the `Felt252DictValue<T>` trait"
" (i.e., arrays and structs)."
msgstr ""
"`Nullble<T}是另一种智能指针,可以指向一个值,也可以指向没有值的`Null`。在Sierra一级定义了这种指针。这种类型主要用于字典中含有不执行“Felt252DictValue<T”特性(即阵列和阵列)的`0-default'方法的字典。"

#: src/ch11-02-smart-pointers.md:100
msgid ""
"If we try to access an element that does not exist in a dictionary, the code"
" will fail if the `zero_default` method cannot be called."
msgstr "如果我们试图访问字典中不存在的元素,如果无法调用`零-默认'方法,代码将失效。"

#: src/ch11-02-smart-pointers.md:102
msgid ""
"[Chapter 3.2](/ch03-02-dictionaries.md#dictionaries-of-types-not-supported-"
"natively) about dictionaries thoroughly explains how to store a "
"`Span<felt252>` variable inside a dictionary using the `Nullable<T>` type. "
"Please refer to it for further information."
msgstr ""
"[第3.2章](/Ch03-02-词典.md#词典-类型-无支持-"
"本地)关于词典的完整解释如何使用`Nullble<T类型在字典中存储“span<felt252}”变量。请参考该词典了解更多信息。"

#: src/ch11-02-smart-pointers.md:106
msgid "{{#quiz ../quizzes/ch11-02-smart_pointers.toml}}"
msgstr "Quiz./quizzes/ch11-02-mart_pointers.toml"

#: src/ch11-03-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows "
"the redefinition of standard operators, such as addition (`+`), subtraction "
"(`-`), multiplication (`*`), and division (`/`), to work with user-defined "
"types. This can make the syntax of the code more intuitive, by enabling "
"operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr ""
"操作员超载是某些编程语言的一个特点,使得能够重新定义标准操作员,例如添加()、减(`-')、乘()和分(`/'),以便与用户定义的类型合作,这可以使代码的语法更直观,使用户定义类型的操作能够与原始类型的操作以同样的方式表达。"

#: src/ch11-03-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of "
"specific traits. Each operator has an associated trait, and overloading that"
" operator involves providing an implementation of that trait for a custom "
"type. However, it's essential to use operator overloading judiciously. "
"Misuse can lead to confusion, making the code more difficult to maintain, "
"for example when there is no semantic meaning to the operator being "
"overloaded."
msgstr ""
"在开罗,操作员超载是通过实施特定特性来实现的。 每个操作员都有相关特性,而超载操作员的超载则涉及对某种定制类型实施该特性。 "
"但是,必须明智地使用操作员超载。 滥用会导致混乱,使代码更难维持,比如当操作员超载没有语义意义时。"

#: src/ch11-03-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have "
"two data fields, mana and health. Combining two `Potions` should add their "
"respective fields."
msgstr "例如,两个`政策'需要合并。`政策'有两个数据领域,即mana和健康。将两个`政策'合并,应增加各自的领域。"

#: src/ch11-03-operator-overloading.md:26
msgid "// Both potions were combined with the `+` operator.\n"
msgstr "两种药剂均与 操作员结合使用。\n"

#: src/ch11-03-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type."
" The add function takes two arguments: `lhs` and `rhs` (left and right-hand "
"side). The function body returns a new `Potion` instance, its field values "
"being a combination of `lhs` and `rhs`."
msgstr ""
"在以上代码中,我们正在执行`政治'类型的`添加'特性,添加函数需要两个参数:`lhs'和`rhs'(左侧和右侧)。函数体返回一个新的`potion'实例,其字段值是`lhs'和`rhs'的组合。"

#: src/ch11-03-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires "
"specification of the concrete type being overloaded. The overloaded generic "
"trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr ""
"如例子所示,操作员超载要求具体说明超载的具体类型。超载的通用特性是“Add<T”,我们用“Add<Potion”定义了“Potion”类型的具体实施。"

#: src/ch11-03-operator-overloading.md:36
msgid "{{#quiz ../quizzes/ch11-03-operator-overloading.toml}}"
msgstr ""
"Quiz./quizzes/ch11-03-Operator-overloading.toml /quizzes/ch11-03-Operator-"
"loading.toml"

#: src/ch11-04-hash.md:1
msgid "Hashes"
msgstr "头饰"

#: src/ch11-04-hash.md:3
msgid ""
"At its essence, hashing is a process of converting input data (often called "
"a message) of any length into a fixed-size value, typically referred to as a"
" \"hash.\" This transformation is deterministic, meaning that the same input"
" will always produce the same hash value. Hash functions are a fundamental "
"component in various fields, including data storage, cryptography and data "
"integrity verification. They are very often used when developing smart "
"contracts, especially when working with [Merkle "
"trees](https://en.wikipedia.org/wiki/Merkle_tree#Uses)."
msgstr ""
"从本质上说,散列是一种将任何长度的输入数据(通常称为信息)转换成固定规模值的过程,通常被称为“hash”。这种转变具有决定性意义,意味着同样的输入将永远产生相同的散列值。散列函数是各个领域的基本组成部分,包括数据存储、加密和数据完整性核查。它们常常用于制定智能合同,特别是在与[Merkle"
" trees](https://en.wikipedia.org/wiki/Merkle_tree#Universes)合作时。"

#: src/ch11-04-hash.md:5
msgid ""
"In this chapter, we will present the two hash functions implemented natively"
" in the Cairo core library: `Poseidon` and `Pedersen`. We will discuss when "
"and how to use them, and see examples with Cairo programs."
msgstr ""
"在本章中,我们将介绍开罗核心图书馆“Poseidon”和“Pedersen”这两个散列功能。我们将讨论何时和如何使用这两个功能,并见开罗方案的例子。"

#: src/ch11-04-hash.md:9
msgid "Hash Functions in Cairo"
msgstr "开罗的散列函数"

#: src/ch11-04-hash.md:11
msgid ""
"The Cairo core library provides two hash functions: Pedersen and Poseidon."
msgstr "开罗核心图书馆提供两种散列功能:Pedersen和Poseidon。"

#: src/ch11-04-hash.md:13
msgid ""
"Pedersen hash functions are cryptographic algorithms that rely on [elliptic "
"curve cryptography](https://en.wikipedia.org/wiki/Elliptic-"
"curve_cryptography). These functions perform operations on points along an "
"elliptic curve — essentially, doing math with the locations of these points "
"— which are easy to do in one direction and hard to undo. This one-way "
"difficulty is based on the Elliptic Curve Discrete Logarithm Problem "
"(ECDLP), which is a problem so hard to solve that it ensures the security of"
" the hash function. The difficulty of reversing these operations is what "
"makes the Pedersen hash function secure and reliable for cryptographic "
"purposes."
msgstr ""
"Pedersen hash 函数是依赖于[椭圆曲线加密法](https://en.wikipedia.org/wiki/Elliptic-"
"curve_cryptography)的加密算法算法。这些函数在椭圆曲线沿线的点上运行,主要是用这些点的位置进行数学计算,这很容易朝一个方向做,很难解开。这个单向的难题基于“ELliptic"
" Curve Discrete Logarithm 问题 "
"”(ECDLP),这是一个很难解决的问题,因此难以解决,无法确保散列函数的安全。扭转这些操作的困难在于使Pedersen能够安全可靠地进行加密。"

#: src/ch11-04-hash.md:15
msgid ""
"Poseidon is a family of hash functions designed to be very efficient as "
"algebraic circuits. Its design is particularly efficient for Zero-Knowledge "
"proof systems, including STARKs (so, Cairo). Poseidon uses a method called a"
" 'sponge construction,' which soaks up data and transforms it securely using"
" a process known as the Hades permutation. Cairo's version of Poseidon is "
"based on a three-element state permutation with [specific "
"parameters](https://github.com/starkware-"
"industries/poseidon/blob/main/poseidon3.txt)."
msgstr ""
"Poseidon是一个散列函数组,其设计非常高效,作为代数电路,其设计对零知识验证系统(包括STARKs(so,开罗))特别高效。波塞冬使用一种称为“海绵构造”的方法,用一个称为哈迪斯变异的过程将数据浸泡起来并进行安全变换。开罗版本的波塞冬基于三个要素的状态变换,并具有[具体参数](https://github.com/starkware-"
"industry/poseidon/blob/main/poseidon3.txt)。"

#: src/ch11-04-hash.md:20
msgid "When to Use Them?"
msgstr "什么时候用他们?"

#: src/ch11-04-hash.md:22
msgid ""
"Pedersen was the first hash function used on Starknet, and is still used to "
"compute the addresses of variables in storage (for example, `LegacyMap` uses"
" Pedersen to hash the keys of a storage mapping on Starknet). However, as "
"Poseidon is cheaper and faster than Pedersen when working with STARK proofs "
"system, it's now the recommended hash function to use in Cairo programs."
msgstr ""
"Pedersen 是史塔克内特第一个使用的散列函数, 仍然用于计算存储变量的地址( 例如, “ LegacyMap” 使用 Pedersen "
"来收集斯塔克内特存储映射的密钥 ) 。 然而, 由于波塞顿在使用STARK 验证系统时比佩德森更便宜、更快, 因此现在开罗程序建议使用的散列函数 。"

#: src/ch11-04-hash.md:26
msgid ""
"The core library makes it easy to work with hashes. The `Hash` trait is "
"implemented for all types that can be converted to `felt252`, including "
"`felt252` itself. For more complex types like structs, deriving `Hash` "
"allows them to be hashed easily using the hash function of your choice - "
"given that all of the struct's fields are themselves hashable. You cannot "
"derive the `Hash` trait on a struct that contains un-hashable values, such "
"as `Array<T>` or `Felt252Dict<T>`, even if `T` itself is hashable."
msgstr ""
"核心图书馆便于与大麻打交道。 “ Hash” 特性针对所有可以转换为“ felt252” 的种类,包括“ felt252” "
"本身。对于更复杂的种类,如树枝,产生“ "
"Hash”,允许它们容易地使用你选择的散列函数,因为所有树枝的字段本身都是易散的。您无法从含有不可磨损的值,如“Array<T}或“Felt252Dict<T”"
" 的树枝上获取“ Hash” 特性,即使`T'本身也是易散的。"

#: src/ch11-04-hash.md:28
msgid ""
"The `Hash` trait is accompanied by the `HashStateTrait` and "
"`HashStateExTrait` that define the basic methods to work with hashes. They "
"allow you to initialize a hash state that will contain the temporary values "
"of the hash after each application of the hash function, update the hash "
"state and finalize it when the computation is completed. `HashStateTrait` "
"and `HashStateExTrait` are defined as follows:"
msgstr ""
"`Hash'特性附有`Hash StateTrait'和`Hash StateExtrait "
"',这两个特性界定了与hashes合作的基本方法,允许您在每次应用hash函数后初始化一个含有hash临时值的散列状态,更新hash状态,并在计算完成后最终确定。"

#: src/ch11-04-hash.md:31
msgid "/// A trait for hash state accumulators.\n"
msgstr "大麻国家蓄积器的特征\n"

#: src/ch11-04-hash.md:36
msgid "/// Extension trait for hash state accumulators.\n"
msgstr "// 散列状态蓄积器的扩展特性。\n"

#: src/ch11-04-hash.md:39 src/ch11-04-hash.md:45
msgid "/// Updates the hash state with the given value.\n"
msgstr "// 以给定值更新散列状态。\n"

#: src/ch11-04-hash.md:42
msgid "/// A trait for values that can be hashed.\n"
msgstr "/ 一种可以散列的价值特征。\n"

#: src/ch11-04-hash.md:50
msgid ""
"To use hashes in your code, you must first import the relevant traits and "
"functions. In the following example, we will demonstrate how to hash a "
"struct using both the Pedersen and Poseidon hash functions."
msgstr ""
"要在代码中使用hashes, 您必须首先导入相关的特性和函数。 在下面的例子中, 我们将演示如何使用 Pedersen 和 Poseidon hash "
"函数来进行支架 。"

#: src/ch11-04-hash.md:52
msgid ""
"The first step is to initialize the hash with either `PoseidonTrait::new() "
"-> HashState` or `PedersenTrait::new(base: felt252) -> HashState` depending "
"on which hash function we want to work with. Then the hash state can be "
"updated with the `update(self: HashState, value: felt252) -> HashState` or "
"`update_with(self: S, value: T) -> S` functions as many times as required. "
"Then the function `finalize(self: HashState) -> felt252` is called on the "
"hash state and it returns the value of the hash as a `felt252`."
msgstr ""
"第一步是先用`海神:New() - > Hash State'或`PedersenTrait::new(基础: fel252) - > Hash "
"State'启动大麻,这取决于我们想与哪个海神一起工作的大麻功能。然后,海神国家可以更新`更新(本身:海神国家,价值: fel252) - > Hash"
" State` 或`更新_(自己:S,价值:T) - > S` 函数,需要多少次。然后,“最终(自己:海神) > "
"felth252”功能被调用在海神状态上,它返回散神作为`felt252'的价值。"

#: src/ch11-04-hash.md:74
msgid ""
"Pedersen is different from Poseidon, as it starts with a base state. This "
"base state must be of `felt252` type, which forces us to either hash the "
"struct with an arbitrary base state using the `update_with` method, or "
"serialize the struct into an array to loop through all of its fields and "
"hash its elements together."
msgstr ""
"Pedersen不同于Poseidon, 因为它是从一个基点状态开始的。 这个基点状态必须是“ felt252 ” 类型, 迫使我们要么使用“ 更新” "
"方法, 用任意基点状态支架, 要么将支架序列成一个阵列, 以绕过其所有字段, 并集合其元素 。"

#: src/ch11-04-hash.md:76
msgid "Here is a short example of Pedersen hashing:"
msgstr "以下是Pedersenhing的简短例子:"

#: src/ch11-04-hash.md:93
msgid "// hash1 is the result of hashing a struct with a base state of 0\n"
msgstr "/ hash1 是按0的基状态为0的块状散列的结果 / hash1\n"

#: src/ch11-04-hash.md:105
msgid "// hash2 is the result of hashing only the fields of the struct\n"
msgstr "/ hash2 仅仅是草原田间散列的结果\n"

#: src/ch11-04-hash.md:114
msgid "Advanced Hashing: Hashing Arrays with Poseidon"
msgstr "高级散列: 配有波塞冬的散列阵列"

#: src/ch11-04-hash.md:116
msgid ""
"Let us look at an example of hashing a struct that contains a "
"`Span<felt252>`. To hash a `Span<felt252>` or a struct that contains a "
"`Span<felt252>` you can use the built-in function `poseidon_hash_span(mut "
"span: Span<felt252>) -> felt252`. Similarly, you can hash `Array<felt252>` "
"by calling `poseidon_hash_span` on its span."
msgstr ""
"让我们来看看一个散列的示例,其中含有“span<felt252} ” 的支架。 使用“ span<felt252}” "
"或含有“span<felt252}” 的支架, 您可以使用“ plaidon_ hash_ span( 范围: span<felt252> ) - > "
"feelt252 ” 的内置函数。 同样, 您也可以使用“ poseidon_ hash_span” 在其间用 。"

#: src/ch11-04-hash.md:119
msgid "First, let us import the following traits and function:"
msgstr "首先,让我们输入以下特征和功能:"

#: src/ch11-04-hash.md:127
msgid ""
"Now we define the struct. As you might have noticed, we didn't derive the "
"`Hash` trait. If you attempt to derive the `Hash` trait for this struct, it "
"will result in an error because the structure contains a field that is not "
"hashable."
msgstr ""
"现在,我们定义结构。正如你可能注意到的那样,我们没有得出“哈什”特性。如果你试图得出这一结构的“哈什”特性,它将导致错误,因为结构包含一个非易乱的字段。"

#: src/ch11-04-hash.md:138
msgid ""
"In this example, we initialized a `HashState` (`hash`), updated it and then "
"called the function `finalize()` on the `HashState` to get the computed hash"
" `hash_felt252`. We used `poseidon_hash_span` on the `Span` of the "
"`Array<felt252>` to compute its hash."
msgstr ""
"在这个例子中,我们先开始一个`Hash State'(`hash') (`hash') (`hash'),然后更新了它,然后在`Hash "
"State'上称为`Finalize() "
"',以获得计算出的hash`hash_felt252'(`hash_felt252'),我们在`Array<felt252'的`span'`span'(`span')上使用`posidon_hash_span'(`span')来计算其散列。"

#: src/ch11-05-macros.md:3
msgid ""
"The Cairo language has some plugins that allow developers to simplify their "
"code. They are called `inline_macros` and are a way of writing code that "
"generates other code."
msgstr "开罗语言有一些插件可以让开发者简化代码。 它们被称为“ 内线_ macros ”, 是一种生成其他代码的写法。"

#: src/ch11-05-macros.md:5
msgid "`consteval_int!` Macro"
msgstr "`contenteval_int!' 宏"

#: src/ch11-05-macros.md:7
msgid ""
"In some situations, a developer might need to declare a constant that is the"
" result of a computation of integers. To compute a constant expression and "
"use its result at compile time, it is required to use the `consteval_int!` "
"macro."
msgstr ""
"在某些情况下,开发者可能需要声明一个常数,该常数是计算整数的结果。要计算一个常数表达式并在编译时使用其结果,就需要使用`conteval_int!' "
"宏。"

#: src/ch11-05-macros.md:9
msgid "Here is an example of `consteval_int!`:"
msgstr "以下是`conteval_int!'的例子:"

#: src/ch11-05-macros.md:15
msgid "This will be interpreted as `const a: felt252 = 8;` by the compiler."
msgstr "这将被汇编者解释为`a: feel252=8;'。"

#: src/ch11-05-macros.md:17
msgid "`selector!` Macro"
msgstr "`选择者!'宏观"

#: src/ch11-05-macros.md:19
msgid ""
"See [Entry Point Selector](./ch15-02-contract-dispatchers-library-"
"dispatchers-and-system-calls.md#entry-point-selector)."
msgstr "见[输入点选择器](./ch15-02-合同-发送器-图书馆-发送器-发送器-系统呼叫.md#entry-点选择器)。"

#: src/ch11-05-macros.md:21
msgid "`print!` and `println!` Macros"
msgstr "\" 印刷! \" 和 \" 印刷! \" 宏"

#: src/ch11-05-macros.md:23
msgid "Please refer to the [Printing](./ch11-08-printing.md) page."
msgstr "请参见[打印](./ch11-08-printing.md)页面。"

#: src/ch11-05-macros.md:27
msgid "Please refer to the [Arrays](./ch03-01-arrays.md) page."
msgstr "请参见[Arrays] (./ch03-01-arrays.md)页面。"

#: src/ch11-05-macros.md:31
msgid ""
"See [Unrecoverable Errors with panic](./ch09-01-unrecoverable-errors-with-"
"panic.html#panic-macro) page."
msgstr "见[惊慌中无法挽回的错误] (./ch09-01-无法复原-erors- with-panic.html#panic-macro)页面。"

#: src/ch11-05-macros.md:33
msgid "`assert!` and `assert_xx!` Macros"
msgstr "\" 资产! \" 和 \" 资产_xx! \" 宏观"

#: src/ch11-05-macros.md:35
msgid "See [How to Write Tests](./ch10-01-how-to-write-tests.md) page."
msgstr "见[如何写测试](./ch10-01-how-to-write-tests.md)页面。"

#: src/ch11-05-macros.md:37
msgid "`format!` Macro"
msgstr "`format!'宏观"

#: src/ch11-05-macros.md:39
msgid "See [Printing](./ch11-08-printing.html#formatting) page."
msgstr "见[Printing] (./ch11-08-printing.html#formatting)页面。"

#: src/ch11-05-macros.md:41
msgid "`write!` and `writeln!` Macros"
msgstr "\" wwrite! \" 和 \" writeln! \" 宏"

#: src/ch11-05-macros.md:43
msgid ""
"See [Printing](./ch11-08-printing.html#printing-custom-data-types) page."
msgstr "见[Printing] (./ch11-08-printing.html#printing-custom-data-type)页面。"

#: src/ch11-05-macros.md:45
msgid "`get_dep_component!`, `get_dep_component_mut` and `component!` Macros"
msgstr "` Get_ dep_ 构件!'、` get_ dep_ 构件_ mut'和` 构件!'宏"

#: src/ch11-05-macros.md:47
msgid ""
"Please refer to the [Composability and "
"Components](./ch16-02-00-composability-and-components.md) chapter."
msgstr "请参见[可容性和构件](./ch16-02-00-可容性和构件.md)一章。"

#: src/ch11-06-inlining-in-cairo.md:3
msgid ""
"Inlining is a common code optimization technique supported by most "
"compilers. It involves replacing a function call at the call site with the "
"actual code of the called function, eliminating the overhead associated with"
" the function call itself. This can improve performance by reducing the "
"number of instructions executed, but may increase the total size of the "
"program. When you're thinking about whether to inline a function, take into "
"account things like how big it is, what parameters it has, how often it gets"
" called, and how it might affect the size of your compiled code."
msgstr ""
"内衬是一种常见的代码优化技术,得到大多数编译者的支持。 它涉及用调用站点的函数实际代码替换一个调用功能的实际代码, 消除函数调用本身的间接费用。 "
"这可以通过减少执行指令的数量来改进性能, 但可能会增加程序的总规模。 当您在考虑是否插入一个函数时, 要考虑到它有多大、 它有多少参数、 "
"它被调用的次数如何, 以及它会如何影响您编译的代码的大小 。"

#: src/ch11-06-inlining-in-cairo.md:5
msgid "The `inline` Attribute"
msgstr "`内含'属性"

#: src/ch11-06-inlining-in-cairo.md:7
msgid ""
"In Cairo, the `inline` attribute suggests whether or not the Sierra code "
"corresponding to the attributed function should be directly injected in the "
"caller function's context, rather than using a `function_call` libfunc to "
"execute that code."
msgstr ""
"在开罗,`内线'属性表明,与归属函数相对应的Sierra代码是否应该直接注入调用函数的上下文,而不是使用`函数呼叫' libfunc来执行该代码。"

#: src/ch11-06-inlining-in-cairo.md:9
msgid "There are three variants of the `inline` attribute that one can use:"
msgstr "\" 内含 \" 属性有三种变式,人们可以使用:"

#: src/ch11-06-inlining-in-cairo.md:11
msgid "`#[inline]` suggests performing an inline expansion."
msgstr "`[内 `建议进行内线扩展。"

#: src/ch11-06-inlining-in-cairo.md:12
msgid ""
"`#[inline(always)]` suggests that an inline expansion should always be "
"performed."
msgstr "`建议始终应进行内线扩展。"

#: src/ch11-06-inlining-in-cairo.md:13
msgid ""
"`#[inline(never)]` suggests that an inline expansion should never be "
"performed."
msgstr "`[内(内 `建议绝不应进行内线扩展。"

#: src/ch11-06-inlining-in-cairo.md:15
msgid ""
"Note: the `inline` attribute in every form is a hint, with no requirements "
"on the language to place a copy of the attributed function in the caller. "
"This means that the attribute may be ignored by the compiler. In practice, "
"`#[inline(always)]` will cause inlining in all but the most exceptional "
"cases."
msgstr ""
"注: \" 内嵌的 \" 属性在每一种形式中都是提示,不需要语言在调用者中放置指定函数的副本,这意味着该属性可能被编译者忽略。实际上, \" "
"[内嵌(always)] \" 除了最特殊的情况外, \" 将诱导所有内容的内嵌。"

#: src/ch11-06-inlining-in-cairo.md:17
msgid ""
"Many of the Cairo corelib functions are inlined. User-defined functions may "
"also be annotated with the `inline` attribute. Annoting functions with the "
"`#[inline(always)]` attribute reduces the total number of steps required "
"when calling these attributed functions. Indeed, injecting the Sierra code "
"at the caller site avoids the step-cost involved in calling functions and "
"obtaining their arguments."
msgstr ""
"许多开罗核心lib功能是内嵌的,用户定义的功能也可以用“内联”属性附加说明,用“内联(内联)属性”的标记功能减少了调用这些指定功能所需的步骤总数,事实上,在呼叫站点输入Sierra代码可以避免调用功能和获取其论点的分级成本。"

#: src/ch11-06-inlining-in-cairo.md:19
msgid ""
"However, inlining can also lead to increased code size. Whenever a function "
"is inlined, the call site contains a copy of the function's Sierra code, "
"potentially leading to duplication of code across the compiled code."
msgstr "然而,内衬还可能导致代码大小的增加。 当函数被内嵌时, 呼叫网站都包含该函数的Sierra代码副本, 可能导致编译代码中代码的重复 。"

#: src/ch11-06-inlining-in-cairo.md:21
msgid ""
"Therefore, inlining should be applied with caution. Using `#[inline]` or "
"`#[inline(always)]` indiscriminately will lead to increased compile time. It"
" is particularly useful to inline small functions, ideally with many "
"arguments. This is because inlining large functions will increase the code "
"length of the program, and handling many arguments will increase the number "
"of steps to execute these functions."
msgstr ""
"因此,应谨慎地应用内衬。 不分青红皂白地使用“ 内嵌” 或“ 内联(线性) ” 将增加汇编时间。 插入小功能特别有用, 最好加上许多论据。 "
"这是因为内嵌大型功能将增加程序代码长度, 处理许多论据将增加执行这些功能的步骤的数量 。"

#: src/ch11-06-inlining-in-cairo.md:23
msgid ""
"The more frequently a function is called, the more beneficial inlining "
"becomes in terms of performance. By doing so, the number of steps for the "
"execution will be lower, while the code length will not grow that much or "
"might even decrease in terms of total number of instructions."
msgstr "要求一个功能的频率越高,从业绩角度来说,从内衬越有利,执行步骤的数目就越少,而守则的长度不会长得那么大,甚至从指示的总数来看也不会减少。"

#: src/ch11-06-inlining-in-cairo.md:25
msgid ""
"Inlining is often a tradeoff between number of steps and code length. Use "
"the `inline` attribute cautiously where it is appropriate."
msgstr "内衬往往是若干步骤和编码长度之间的权衡,适当时谨慎使用 \" 内线 \" 属性。"

#: src/ch11-06-inlining-in-cairo.md:27
msgid "Inlining Example"
msgstr "内列示例"

#: src/ch11-06-inlining-in-cairo.md:29
msgid ""
"Let's introduce a short example to illustrate the mechanisms of inlining in "
"Cairo. Listing 11-3 shows a basic program allowing comparison between "
"inlined and non-inlined functions."
msgstr "让我们举一个简短的例子来说明开罗的内衬机制。 列出 11-3 显示一个基本程序, 能够比较内嵌功能和非内嵌功能 。"

#: src/ch11-06-inlining-in-cairo.md:47
msgid ""
"<span class=\"caption\">Listing 11-3: A small Cairo program that adds the "
"return value of 2 functions, with one of them being inlined</span>"
msgstr ""
"<span class=\"Caption\" > listing 11-3:一个小开罗程序,增加了2个函数的返回值,其中1个功能被嵌入 </span>"

#: src/ch11-06-inlining-in-cairo.md:49
msgid ""
"Let's take a look at the corresponding Sierra code to see how inlining works"
" under the hood:"
msgstr "让我们看看相应的Sierra代码 看看在引擎盖下面的内衬是如何工作的:"

#: src/ch11-06-inlining-in-cairo.md:52 src/ch11-06-inlining-in-cairo.md:215
msgid "// type declarations\n"
msgstr "/ 类型声明\n"

#: src/ch11-06-inlining-in-cairo.md:54 src/ch11-06-inlining-in-cairo.md:218
msgid "// libfunc declarations\n"
msgstr "//自由声明\n"

#: src/ch11-06-inlining-in-cairo.md:61 src/ch11-06-inlining-in-cairo.md:226
msgid "// statements\n"
msgstr "/ 发言/发言\n"

#: src/ch11-06-inlining-in-cairo.md:75 src/ch11-06-inlining-in-cairo.md:238
msgid "// funcs\n"
msgstr ""
"/ fincs / funcs / funcs / funcs / funcs / funcs / funcs / funcs / funcs / "
"funcs / funcs / funcs / funcs / funcs / funcs / funcs / funcs / funcs / "
"funcs\n"

#: src/ch11-06-inlining-in-cairo.md:82
msgid "The Sierra file is structured in three parts:"
msgstr "Sierra文件分为三部分:"

#: src/ch11-06-inlining-in-cairo.md:84
msgid "Type and libfunc declarations."
msgstr "类型和 libfunc 声明 。"

#: src/ch11-06-inlining-in-cairo.md:85
msgid "Statements that constitute the program."
msgstr "构成方案的说明。"

#: src/ch11-06-inlining-in-cairo.md:86
msgid "Declaration of the functions of the program."
msgstr "宣布方案的职能。"

#: src/ch11-06-inlining-in-cairo.md:88
msgid ""
"The Sierra code statements always match the order of function declarations "
"in the Cairo program. Indeed, the declaration of the functions of the "
"program tells us that:"
msgstr "塞拉码声明总是符合开罗方案中功能声明的顺序。 事实上,该程序功能声明告诉我们:"

#: src/ch11-06-inlining-in-cairo.md:90
msgid "`main` function starts at line 0, and returns a `felt252` on line 5."
msgstr "`主要'功能从第0行开始,返回第5行的`felt252'。"

#: src/ch11-06-inlining-in-cairo.md:91
msgid ""
"`inlined` function starts at line 6, and returns a `felt252` on line 8."
msgstr "`内含'功能从第6行开始,返回第8行的`felt252'。"

#: src/ch11-06-inlining-in-cairo.md:92
msgid ""
"`not_inlined` function starts at line 9, and returns a `felt252` on line 11."
msgstr "“非线性”函数从第9行开始,返回第11行的“felt252”。"

#: src/ch11-06-inlining-in-cairo.md:94
msgid ""
"All statements corresponding to the `main` function are located between "
"lines 0 and 5:"
msgstr "与`主要'功能相应的所有语句位于第0行和第5行之间:"

#: src/ch11-06-inlining-in-cairo.md:105
msgid ""
"The `function_call` libfunc is called on line 0 to execute the `not_inlined`"
" function. This will execute the code from lines 9 to 10 and store the "
"return value in the variable with id `0`."
msgstr "“函数呼叫'libfunc'被调用到第0行,以执行`非线性'函数,这将执行从行9到行10的代码,并将返回值以 id'0'存储在变量中。"

#: src/ch11-06-inlining-in-cairo.md:112
msgid ""
"This code uses a single data type, `felt252`. It uses two library functions "
"- `felt_const<2>`, which returns the constant `felt252` 2, "
"and `store_temp<felt252>`, which pushes a constant value to memory. The "
"first line calls the `felt_const<2>` libfunc to create a variable with "
"id `0`. Then, the second line pushes this variable to memory for later use."
msgstr "此代码使用单一数据类型 `felt252' 。 它使用两个库函数 - `felt_ const < 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/ch11-06-inlining-in-cairo.md:114
msgid ""
"After that, Sierra statements from line 1 to 2 are the actual body of the "
"`inlined` function:"
msgstr "之后,第1行至第2行的Sierra语句是`内含'函数的实际正文:"

#: src/ch11-06-inlining-in-cairo.md:121
msgid ""
"The only difference is that the inlined code will store the `felt252_const` "
"value in a variable with id `1`, because `[0]` refers to a variable "
"previously assigned:"
msgstr "唯一的区别是,内嵌代码将把`felt252_const' 值存储在有id`1'的变量中,因为`[0]是指先前指定的变量:"

#: src/ch11-06-inlining-in-cairo.md:128
msgid ""
"Note: in both cases (inlined or not), the `return` instruction of the "
"function being called is not executed, as this would lead to prematurely end"
" the execution of the `main` function. Instead, return values of `inlined` "
"and `not_inlined` will be added and the result will be returned."
msgstr ""
"注:在两种情况(内含或非内含)中,所呼叫函数的`返回'指示没有执行,因为这将导致`主要'函数的履行过早结束,而是将增加`内含'和`未内含'的返回值,结果将被退回。"

#: src/ch11-06-inlining-in-cairo.md:130
msgid ""
"Lines 3 to 5 contain the Sierra statements that will add the values "
"contained in variables with ids `0` and `1`, store the result in memory and "
"return it:"
msgstr "第3至5行载有塞拉语句,这些语句将添加以 \" 0 \" 和 \" 1 \" 代号为代号的变量中的数值,储存结果并返回内存:"

#: src/ch11-06-inlining-in-cairo.md:138
msgid ""
"Now, let's take a look at the Casm code corresponding to this program to "
"really understand the benefits of inlining."
msgstr "现在,让我们来看看与这个程序相对应的 Casm 代码, 来真正理解内衬的好处。"

#: src/ch11-06-inlining-in-cairo.md:140
msgid "Casm Code Explanations"
msgstr "Casm Casm 代码解释"

#: src/ch11-06-inlining-in-cairo.md:142
msgid "Here is the Casm code for our previous program example:"
msgstr "以下是我们上一个程序示例的 Casm 代码 :"

#: src/ch11-06-inlining-in-cairo.md:158
msgid ""
"Don't hesitate to use [cairovm.codes](https://cairovm.codes/) playground to "
"follow along and see all the execution trace."
msgstr "(https://cairovm.codes/)游乐场,"

#: src/ch11-06-inlining-in-cairo.md:160
msgid ""
"Each instruction and each argument for any instruction increment the Program"
" Counter (known as PC) by 1. This means that `ret` on line 2 is actually the"
" instruction at `PC = 3`, as the argument `3` corresponds to `PC = 2`."
msgstr ""
"方案柜台(称为PC)的任何指示加注的每项指示和每一论点,以1计,这意味着第2行的`停止'实际上是`PC=3'的指令,因为`3'的论据相当于`PC=2'。"

#: src/ch11-06-inlining-in-cairo.md:162
msgid ""
"The `call` and `ret` instructions allow implementation of a function stack:"
msgstr "`调用'和`调用'指示允许执行功能堆叠:"

#: src/ch11-06-inlining-in-cairo.md:164
msgid ""
"`call` instruction acts like a jump instruction, updating the PC to a given "
"value, whether relatively to the current value using `rel` or absolutely "
"using `abs`."
msgstr "`调用'指令如同跳跃指令,将个人电脑更新到给定值,无论是相对于使用`rel'或绝对使用`abs'的当前值。"

#: src/ch11-06-inlining-in-cairo.md:165
msgid ""
"`ret` instruction jumps back right after the `call` instruction and "
"continues the execution of the code."
msgstr "\" 调用 \" 指令在 \" 调用 \" 指令后立即跳回 \" 指令,并继续执行该代码。"

#: src/ch11-06-inlining-in-cairo.md:167
msgid ""
"We can now decompose how these instructions are executed to understand what "
"this code does:"
msgstr "我们现在可以分解这些指令是如何执行的 来理解这个代码会做什么:"

#: src/ch11-06-inlining-in-cairo.md:169
msgid ""
"`call rel 3`: this instruction increments the PC by 3 and executes the "
"instruction at this location, which is `call rel 9` at `PC = 4`."
msgstr "`召回 regl 3':本指令将个人电脑加增为3,并在此处执行指令,即`PC=4'的`call regl 9'。"

#: src/ch11-06-inlining-in-cairo.md:170
msgid ""
"`call rel 9` increments the PC by 9 and executes the instruction at `PC = "
"13`, which is actually line 9."
msgstr "`召回regl 9'将个人电脑加到9,并在`PC=13'执行指示,其实是第9行。"

#: src/ch11-06-inlining-in-cairo.md:171
msgid ""
"`[ap + 0] = 2, ap++`: `ap` stands for Allocation Pointer, which points to "
"the first memory cell that has not been used by the program so far. This "
"means we store the value `2` in the next free memory cell indicated by the "
"current value of `ap`, after which we increment `ap` by 1. Then, we go to "
"the next line which is `ret`."
msgstr ""
"`[ap+0]=2, "
"ap:`ap'表示分配指针,指第一个内存单元格,但迄今为止程序尚未使用,这意味着我们将`ap'表示的`2'值储存在下一个免费内存单元格中,以`ap'的当前值表示,之后我们增加`ap"
" ',1。 然后,我们进入下一行,即`ret'。"

#: src/ch11-06-inlining-in-cairo.md:172
msgid "`ret`: jumps back to the line after `call rel 9`, so we go to line 4."
msgstr "`雷特':在`召回第9号'后回到线上,所以我们转到第4行。"

#: src/ch11-06-inlining-in-cairo.md:173
msgid ""
"`[ap + 0] = 1, ap++` : we store the value `1` in `[ap]` and we apply `ap++` "
"so that `[ap - 1] = 1`. This means we now have `[ap-1] = 1, [ap-2] = 2` and "
"we go to the next line."
msgstr ""
"`[ap + 0 = 1, ap = 1:我们在`ap'中储存`1'值,我们应用`ap ',以便`[ap - 1]=1 ',这意味着我们现在有`[ap "
"- 1]=1,[ap-2]=2 ',我们走下一行。"

#: src/ch11-06-inlining-in-cairo.md:174
msgid ""
"`[ap + 0] = [ap + -1] + [ap + -2], ap++`: we sum the values `1` and `2` and "
"store the result in `[ap]`, and we apply `ap++` so the result is `[ap-1] = "
"3, [ap-2] = 1, [ap-3]=2`."
msgstr ""
"`[ap + 0] = [ap + -1] + [ap + -2], ap:我们对数值“1”和“2”进行总和,并将结果储存在`[ap]中,我们应用`ap"
" =,结果为`[ap-1] = 3,[ap-2]=1,[ap-3]=2。"

#: src/ch11-06-inlining-in-cairo.md:175
msgid "`ret`: jumps back to the line after `call rel 3`, so we go to line 2."
msgstr "`雷特':在`召回瑞特3'后回到线上,所以我们转到第2行。"

#: src/ch11-06-inlining-in-cairo.md:176
msgid ""
"`ret`: last instruction executed as there is no more `call` instruction "
"where to jump right after. This is the actual return instruction of the "
"Cairo `main` function."
msgstr "`ret':由于不再有`调用'指令而执行的最后指令。这是开罗`主要'功能的实际返回指令。"

#: src/ch11-06-inlining-in-cairo.md:178
msgid "To summarize:"
msgstr "总结如下:"

#: src/ch11-06-inlining-in-cairo.md:180
msgid ""
"`call rel 3` corresponds to the `main` function, which is obviously not "
"inlined."
msgstr "`call rel 3'对应的`主要'功能,显然没有内嵌。"

#: src/ch11-06-inlining-in-cairo.md:181
msgid ""
"`call rel 9` triggers the call the `not_inlined` function, which returns `2`"
" and stores it at the final location `[ap-3]`."
msgstr "`召回 recall rel 9'触发呼叫`not_inlined'函数,该函数返回`2 ',储存在最后地点`[ap-3]'。"

#: src/ch11-06-inlining-in-cairo.md:182
msgid ""
"The line 4 is the inlined code of the `inlined` function, which returns `1` "
"and stores it at the final location `[ap-2]`. We clearly see that there is "
"no `call` instruction in this case, because the body of the function is "
"inserted and directly executed."
msgstr ""
"第4行是`内嵌'函数的内嵌代码,返回`1 ',储存在最后地点`[ap-2] "
"',我们清楚地看到,在本案中没有`调用'指令,因为函数的体是插入并直接执行的。"

#: src/ch11-06-inlining-in-cairo.md:183
msgid ""
"After that, the sum is computed and we ultimately go back to the line 2 "
"which contains the final `ret` instruction that returns the sum, "
"corresponding to the return value of the `main` function."
msgstr "在此之后,计算总和,我们最终回到第2行,该行载有最后的`ret'指示,该指示返回总和,与`主要'函数的返回值相对应。"

#: src/ch11-06-inlining-in-cairo.md:185
msgid ""
"It is interesting to note that in both Sierra code and Casm code, the "
"`not_inlined` function will be called and executed before the body of the "
"`inlined` function, even though the Cairo program executes `inlined() + "
"not_inlined()`."
msgstr ""
"值得注意的是,在Sierra代码和Casm代码中,在`Inlined'函数正文之前,将调用和履行`not_inlined'函数,尽管开罗方案执行`inlined()+not_inlined()'。"

#: src/ch11-06-inlining-in-cairo.md:187
msgid ""
"The Casm code of our program clearly shows that there is a function call for"
" the `not_inlined` function, while the `inlined` function is correctly "
"inlined."
msgstr "我们程序的 Casm 代码清楚地显示,有一个函数需要“非内嵌”函数,而“内嵌”函数的内嵌正确。"

#: src/ch11-06-inlining-in-cairo.md:189
msgid "Additional Optimizations"
msgstr "额外优化"

#: src/ch11-06-inlining-in-cairo.md:191
msgid ""
"Let's study another program that shows other benefits that inlining may "
"sometimes provide. Listing 11-4 shows a Cairo program that calls 2 functions"
" and doesn't return anything:"
msgstr "让我们研究另一个显示内衬有时可能提供的其他好处的方案。 列出 11 - 4 显示一个开罗方案, 它需要 2 功能, 没有任何回报 :"

#: src/ch11-06-inlining-in-cairo.md:210
msgid ""
"<span class=\"caption\">Listing 11-4: A small Cairo program that calls "
"`inlined` and `not_inlined` and doesn't return any value.</span>"
msgstr ""
"<span类=“caption” > listing 11-4:一个称为“Inlined”和“not_inlined”且不返回任何值的小型开罗方案。 "
"</span>"

#: src/ch11-06-inlining-in-cairo.md:212
msgid "Here is the corresponding Sierra code:"
msgstr "以下是相应的Sierra代码:"

#: src/ch11-06-inlining-in-cairo.md:245
msgid ""
"In this specific case, we can observe that the compiler has applied "
"additional optimizations to the `main` function of our code : the code of "
"the `inlined` function, which is annotated with the `#[inline(always)]` "
"attribute, is actually not copied in the `main` function. Instead, the "
"`main` function starts with the `function_call` libfunc to call the "
"`not_inlined` function, entirely omitting the code of the `inlined` "
"function."
msgstr ""
"在此具体情况下,我们可以观察到,汇编者对我们代码的`主要'功能应用了额外的优化:`内含'函数的代码,加上`内含(线性)'属性的注释,实际上没有在`内含(线性)'函数中复制,而`主要'函数从`职能'呼唤`libfunc调用`非线性'函数开始,完全省略了`内含(线性)'函数的代码。"

#: src/ch11-06-inlining-in-cairo.md:247
msgid ""
"Because `inlined` return value is never used, the compiler optimizes the "
"`main` function by skipping the `inlined` function code. This will actually "
"reduce the code length while reducing the number of steps required to "
"execute `main`."
msgstr "由于“内含”返回值从未使用,汇编者通过跳过“内含”函数代码优化了“主要”功能,这将实际上缩短代码长度,同时减少执行“主要”所需步骤的数量。"

#: src/ch11-06-inlining-in-cairo.md:249
msgid ""
"In contrast, line 0 uses the `function_call` libfunc to execute the "
"`not_inlined` function normally. This means that all the code from lines 7 "
"to 8 will be executed:"
msgstr "相比之下,第0行通常使用“函数呼叫” libfunc来执行“非线性”函数。 这意味着从行7到行8的所有代码都将被执行:"

#: src/ch11-06-inlining-in-cairo.md:256
msgid ""
"This value stored in the variable with id `0` is then dropped on line 1, as "
"it is not used in the `main` function:"
msgstr "此值储存在有 id'0'的变量中的变量中,然后在第1行下调,因为该值未用于“主要”函数:"

#: src/ch11-06-inlining-in-cairo.md:262
msgid ""
"Finally, as the `main` function doesn't return any value, a variable of unit"
" type `()` is created and returned:"
msgstr "最后,由于`主要'函数不返回任何价值,因此创建并返回了`()'类型单位的变量:"

#: src/ch11-06-inlining-in-cairo.md:271
msgid ""
"Inlining is a compiler optimization technique that can be very useful in "
"various situations. Inlining a function allows to get rid of the overhead of"
" calling a function with the `function_call` libfunc by injecting the Sierra"
" code directly in the caller function's context, while potentially "
"optimizing the Sierra code executed to reduce the number of steps. If used "
"effectively, inlining can even reduce code length as shown in the previous "
"example."
msgstr ""
"内衬是一种编译优化技术,在不同情况下非常有用。 外衬功能可以将调用功能的“ 函数呼叫’ libfunc” 的间接责任消除, 直接将 Sierra "
"代码插入调用函数的背景中, 同时有可能优化执行的Sierra 代码以减少步骤数量。 如果有效使用, 内衬甚至可以降低前一个示例所示的代码长度 。"

#: src/ch11-06-inlining-in-cairo.md:273
msgid ""
"Nevertheless, applying the `inline` attribute to a function with a lot of "
"code and few parameters might result in an increased code size, especially "
"if the inlined function is used many times in the codebase. Use inlining "
"only where it makes sense, and be aware that the compiler handles inlining "
"by default. Therefore, manually applying inlining is not recommended in most"
" situations, but can help improve and fine-tune your code's behavior."
msgstr ""
"尽管如此,应用“内线属性”到含有大量代码和少数参数的函数,可能会增加代码的大小,特别是如果内线函数在代码库中多次使用,则会增加代码的大小。仅在合理的情况下使用内衬,并注意编译者会处理默认的内衬。因此,大多数情况下不推荐人工应用内衬,但有助于改进和微调您的代码行为。"

#: src/ch11-08-printing.md:3
msgid ""
"When writing a program, it is quite common to print some data to the "
"console, either for the normal process of the program or for debugging "
"purpose. In this chapter, we describe the options you have to print simple "
"and complex data types."
msgstr ""
"写入程序时, 通常会向控制台打印一些数据, 无论是为程序的正常进程, 还是为调试目的。 在本章中, 我们描述您要打印简单复杂的数据类型的选项 。"

#: src/ch11-08-printing.md:5
msgid "Printing Standard Data Types"
msgstr "印刷标准标准数据类型"

#: src/ch11-08-printing.md:7
msgid "Cairo provides two macros to print standard data types:"
msgstr "开罗为打印标准数据类型提供了两个宏:"

#: src/ch11-08-printing.md:9
msgid "`println!` which prints on a new line"
msgstr "印在新线上的指纹"

#: src/ch11-08-printing.md:10
msgid "`print!` with inline printing"
msgstr "\" 印刷! \",内印"

#: src/ch11-08-printing.md:12
msgid ""
"Both take a `ByteArray` string as first parameter (see [Data "
"Types](./ch02-02-data-types.md#byte-array-strings)), which can be a simple "
"string to print a message or a string with placeholders to format the way "
"values are printed."
msgstr ""
"两者均将“ByteArray”字符串作为第一个参数(见 [数据类型] (./ch02-02-d-data-types.md#byte-array-"
"strings)),该字符串可以是打印信件的简单字符串,也可以是带有占位符的字符串,以格式化打印数值的方式。"

#: src/ch11-08-printing.md:14
msgid "There are two ways to use these placeholders and both can be mixed:"
msgstr "使用这些占位符有两种方法,两种方法可以混合:"

#: src/ch11-08-printing.md:16
msgid ""
"empty curly brackets `{}` are replaced by values given as parameters to the "
"`print!` macro, in the same order."
msgstr "空括号  由以“print!” 宏为参数的数值替换,按同一顺序排列。"

#: src/ch11-08-printing.md:17
msgid ""
"curly brackets with variable names are directly replaced by the variable "
"value."
msgstr "带有变量名称的圆括号由变量值直接替换。"

#: src/ch11-08-printing.md:19
msgid "Here are some examples:"
msgstr "以下是一些例子:"

#: src/ch11-08-printing.md:27
msgid "\"Hello world!\""
msgstr "\"你好世界!\""

#: src/ch11-08-printing.md:28
msgid "\"{} {} {}\""
msgstr ""

#: src/ch11-08-printing.md:28
msgid "// 10 20 30\n"
msgstr "/ 10 20 30\n"

#: src/ch11-08-printing.md:29
msgid "\"{c} {a} {}\""
msgstr "\"{c}{a}}\""

#: src/ch11-08-printing.md:29
msgid "// 30 10 20\n"
msgstr "/ 30 10 20\n"

#: src/ch11-08-printing.md:33
msgid ""
"`print!` and `println!` macros use the `Display` trait under the hood, and "
"are therefore used to print the value of types that implement it. This is "
"the case for basic data types, but not for more complex ones. If you try to "
"print complex data type values with these macros, e.g. for debugging "
"purposes, you will get an error. In that case, you can either [manually "
"implement](./ch11-08-printing.md#printing-custom-data-types) the `Display` "
"trait for your type or use the `Debug` trait (see "
"[below](./ch11-08-printing.md#print-debug-traces))."
msgstr ""
"`print!' 和`println!' 宏在引擎盖下使用`display' "
"特性,因此用于打印执行该特性的类型的值。基本数据类型属于这种情况,但对于较复杂的数据类型则不属于这种情况。如果试图用这些宏打印复杂的数据类型值,例如,为调试目的,则会有一个错误。在这种情况下,您可以使用“display”特性(./ch11-08-printing.md#printing-"
"custom-data-"
"type)来打印类型中的“display”特性,或者使用“dobug”特性(见[blow](/ch11-08-printing.md#print-"
"debug-traces)。"

#: src/ch11-08-printing.md:39
msgid "Formatting"
msgstr "格式格式化"

#: src/ch11-08-printing.md:41
msgid ""
"Cairo also provides a useful macro to handle string formatting: `format!`. "
"This macro works like `println!`, but instead of printing the output to the "
"screen, it returns a `ByteArray` with the contents. In the following "
"example, we perform string concatenation using either the `+` operator or "
"the `format!` macro. The version of the code using `format!` is much easier "
"to read, and the code generated by the `format!` macro uses snapshots, so "
"that this call doesn’t take ownership of any of its parameters."
msgstr ""
"开罗也提供了处理字符串格式的有用的宏:`format!'。这个宏的写法像`println!',但是它不向屏幕打印输出,而是返回含有内容的`ByteAray'。在下面的例子中,我们使用“format!”"
" 或“format!” 宏来进行字符串拼凑。使用`format!' 的代码版本更容易阅读,而“format!' "
"宏使用快照生成的代码则容易阅读,这样这个电话就不会拥有它的任何参数。"

#: src/ch11-08-printing.md:46 src/ch11-08-printing.md:52
msgid "\"tic\""
msgstr "\"圆\""

#: src/ch11-08-printing.md:47 src/ch11-08-printing.md:53
msgid "\"tac\""
msgstr "\"Tac\" \"Tac\" (\"Tac\")"

#: src/ch11-08-printing.md:48 src/ch11-08-printing.md:54
msgid "\"toe\""
msgstr "\"脚趾\""

#: src/ch11-08-printing.md:49
msgid "\"-\""
msgstr "\" -\" \" -\" \" -\""

#: src/ch11-08-printing.md:50
msgid "// using + operator consumes the strings, so they can't be used again!\n"
msgstr "/ 使用 + 操作员消耗字符串, 这样它们就不能被再次使用!\n"

#: src/ch11-08-printing.md:55
msgid "\"{s1}-{s2}-{s3}\""
msgstr "\"{s1}-{s2}-{s3}\""

#: src/ch11-08-printing.md:55
msgid ""
"// s1, s2, s3 are not consumed by format!\n"
"    // or\n"
msgstr "/ s1, s2, s3 格式不消耗! // 或\n"

#: src/ch11-08-printing.md:57
msgid "\"{}-{}-{}\""
msgstr ""

#: src/ch11-08-printing.md:63
msgid "Printing Custom Data Types"
msgstr "打印自定义数据类型"

#: src/ch11-08-printing.md:65
msgid ""
"As previously explained, if you try to print the value of a custom data type"
" with `print!` or `println!` macros, you'll get an error telling you that "
"the `Display` trait is not implemented for your custom type:"
msgstr ""
"如前所述,如果试图用“print!” 或“println!” 宏打印自定义数据类型的值,就会有错误地告诉你“display” "
"特性没有为您的自定义类型执行:"

#: src/ch11-08-printing.md:71
msgid ""
"The `println!` macro can do many kinds of formatting, and by default, the "
"curly brackets tell `println!` to use formatting known as `Display` - output"
" intended for direct end user consumption. The primitive types we’ve seen so"
" far implement `Display` by default because there’s only one way you’d want "
"to show a `1` or any other primitive type to a user. But with structs, the "
"way `println!` should format the output is less clear because there are more"
" display possibilities: Do we want commas or not? Do we want to print the "
"curly brackets? Should all the fields be shown? Due to this ambiguity, Cairo"
" doesn’t try to guess what we want, and structs don’t have a provided "
"implementation of `Display` to use with `println!` and the `{}` placeholder."
msgstr ""
"`println!' 宏可以做许多格式化, 默认情况下, 卷括号可以告诉`println!' 使用被称为`display' 的格式化, "
"即直接用户消费的输出。 我们所看到的原始类型之所以使用`display'默认,是因为只有一种方式, 你才想向用户显示`1' 或任何其他原始类型。 "
"但是,用支架, `println!' 的方式, 格式应该不那么清晰, 因为有更大的显示可能性: 我们是否想要逗号? 我们是否想要打印卷轴? "
"是否要打印所有字段? 由于这种模糊性,开罗没有试图猜测我们想要什么, 支架没有提供“ Display” 与`println!'和“ 占位符” 一起使用。"

#: src/ch11-08-printing.md:73
msgid "Here is the `Display` trait to implement:"
msgstr "以下是要执行的`演练'特征:"

#: src/ch11-08-printing.md:81
msgid ""
"The second parameter `f` is of type `Formatter`, which is just a struct "
"containing a `ByteArray`, representing the pending result of formatting:"
msgstr "第二个参数`f'为`Formatter'类型,只是含有`ByteAray'的支架,代表格式化的未决结果:"

#: src/ch11-08-printing.md:86
msgid "/// The pending result of formatting.\n"
msgstr "// 格式化的未决结果。\n"

#: src/ch11-08-printing.md:91
msgid ""
"Knowing this, here is an example of how to implement the `Display` trait for"
" a custom `Point` struct:"
msgstr "了解这一点后,这里的例子说明如何执行“点点”传统结构的`演练'特征:"

#: src/ch11-08-printing.md:104
msgid "\"Point ({}, {})\""
msgstr "\"点(,)\""

#: src/ch11-08-printing.md:112 src/ch11-08-printing.md:156
msgid "// Point: (1, 3)\n"
msgstr "点数:(1,3)\n"

#: src/ch11-08-printing.md:116
msgid ""
"Cairo also provides the `write!` and `writeln!` macros to write formatted "
"strings in a formatter. Here is a short example using `write!` macro to "
"concatenate multiple strings on the same line and then print the result:"
msgstr ""
"开罗还提供“ write!” 和“ writeln!” 宏, 用于将格式化的字符串写入一个要旨。 下面是使用“ write!” 的简短示例, "
"用于将多个字符串合并在同一行, 然后打印结果 :"

#: src/ch11-08-printing.md:126
msgid "\"hello\""
msgstr "\"你好\""

#: src/ch11-08-printing.md:127
msgid "\"world\""
msgstr "\"世界\""

#: src/ch11-08-printing.md:128
msgid "\" {a} {b}\""
msgstr "{a}{b} {a} {b} {a} {b} {a} {b} {b} {a} {a} {b} {b} {a}"

#: src/ch11-08-printing.md:130
msgid "// helloworld 10 20\n"
msgstr "喜好世界 10 20\n"

#: src/ch11-08-printing.md:134
msgid ""
"It is also possible to implement the `Display` trait for the `Point` struct "
"using these macros, as shown here:"
msgstr "如下文所示,利用这些宏执行`点'结构的`碎片'特性也是可能的:"

#: src/ch11-08-printing.md:150
msgid "\"Point ({x}, {y})\""
msgstr "“ 点 ({x}, {y}) ”"

#: src/ch11-08-printing.md:160
msgid ""
"Printing complex data types this way might not be ideal as it requires "
"additional steps to use the `print!` and `println!` macros. If you need to "
"print complex data types, especially when debugging, use the `Debug` trait "
"described below instead."
msgstr ""
"这样打印复杂的数据类型可能不理想,因为它需要额外步骤使用“打印!”和“打印!”宏。如果需要打印复杂的数据类型,特别是在调试时,请使用下文所述的“调试”特性。"

#: src/ch11-08-printing.md:162
msgid "Print Debug Traces"
msgstr "打印调试追踪"

#: src/ch11-08-printing.md:164
msgid ""
"Cairo provides the `Debug` trait, which can be derived to print the value of"
" variables when debugging. Simply add `:?` within the curly brackets `{}` "
"placeholders in a `print!` or `println!` macro string."
msgstr "开罗提供了“调试”特性,可以用来打印调试时的变量值,只需在“打印”或“打印”宏观字符串中括号内添加“?” 。"

#: src/ch11-08-printing.md:166
msgid ""
"This trait is very useful and is implemented by default for basic data "
"types. It can also be simply derived for complex data types using the "
"`#[derive(Debug)]` attribute, as long as all types they contain implement "
"it. This eliminates the need to manually implement extra code to print "
"complex data types."
msgstr ""
"这一特性非常有用,并且默认地用于基本数据类型。它也可以简单地用于使用 "
"{{[derive(Debug)]}`属性的复杂数据类型,只要它们包含的所有类型都加以执行。这就消除了手动执行额外代码以打印复杂数据类型的需要。"

#: src/ch11-08-printing.md:168
msgid ""
"Note that `assert_xx!` macros used in tests require the provided values to "
"implement the `Debug` trait, as they also print the result in case of "
"assertion failure."
msgstr "请注意,在测试中使用的`Assert_xx!'宏要求提供数值,以落实`调试'特性,因为它们还印出在未能证实的情况下的结果。"

#: src/ch11-08-printing.md:170
msgid ""
"For more details about the `Debug` trait and its usage for printing values "
"when debugging, please refer to the [Derivable "
"Traits](./appendix-03-derivable-traits.md#debug-trait-for-printing-and-"
"debugging) appendix."
msgstr ""
"关于“调试”特性及其在调试时用于打印值的更多详情,请参见[可调试]附录(./附录-03-可调试-traits.md#debug-trait- for-"
"printing-和调试)。"

#: src/appendix-00.md
msgid ""
"The following sections contain reference material you may find useful in "
"your Cairo journey."
msgstr "以下各节载有您在开罗之旅中可能认为有用的参考材料。"

#: src/appendix-01-keywords.md:1
msgid "Appendix A - Keywords"
msgstr "附录A - 关键词"

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or future"
" use by the Cairo language."
msgstr "下表所列关键词专供开罗语文当前或今后使用。"

#: src/appendix-01-keywords.md:5
msgid "There are three keyword categories:"
msgstr "关键字有三个类别:"

#: src/appendix-01-keywords.md:7
msgid "strict"
msgstr "严格"

#: src/appendix-01-keywords.md:8
msgid "loose"
msgstr "松散"

#: src/appendix-01-keywords.md:9
msgid "reserved"
msgstr "保留"

#: src/appendix-01-keywords.md:11
msgid ""
"There is a fourth category, which are functions from the core library. While"
" their names are not reserved, they are not recommended to be used as names "
"of any items to follow good practices."
msgstr "第四类是核心图书馆的职能,虽然不保留其名称,但建议不将其作为任何遵循良好做法的项目的名称。"

#: src/appendix-01-keywords.md:16
msgid "Strict keywords"
msgstr "严格关键词"

#: src/appendix-01-keywords.md:18
msgid ""
"These keywords can only be used in their correct contexts. They cannot be "
"used as names of any items."
msgstr "这些关键字只能用于正确的背景。 它们不能用作任何项目的名称。"

#: src/appendix-01-keywords.md:21
msgid "`as` - Rename import"
msgstr "`as'- 重命名导入"

#: src/appendix-01-keywords.md:22
msgid "`break` - Exit a loop immediately"
msgstr "`突破'- 立即退出环环"

#: src/appendix-01-keywords.md:23
msgid "`const` - Define constant items"
msgstr "`保留'- 定义固定项目"

#: src/appendix-01-keywords.md:24
msgid "`continue` - Continue to the next loop iteration"
msgstr "`继续'- 继续下一轮循环迭代"

#: src/appendix-01-keywords.md:25
msgid "`else` - Fallback for `if` and `if let` control flow constructs"
msgstr "`else'-`如果'和`如果'控制流量结构的倒退"

#: src/appendix-01-keywords.md:26
msgid "`enum` - Define an enumeration"
msgstr "`enum'- 界定列举"

#: src/appendix-01-keywords.md:27
msgid ""
"`extern` - Function defined at the compiler level that can be compiled to "
"CASM"
msgstr "`外部'- 在汇编者一级界定的功能,可汇编成化学文摘社"

#: src/appendix-01-keywords.md:28
msgid "`false` - Boolean false literal"
msgstr "`假'- 布尔假字"

#: src/appendix-01-keywords.md:29
msgid "`fn` - Define a function"
msgstr "`fn'- 定义函数"

#: src/appendix-01-keywords.md:30
msgid "`if` - Branch based on the result of a conditional expression"
msgstr "`如果'-基于有条件表达结果的分支"

#: src/appendix-01-keywords.md:31
msgid "`impl` - Implement inherent or trait functionality"
msgstr "`impl'- 实施固有或特性功能"

#: src/appendix-01-keywords.md:32
msgid ""
"`implicits` - Special kind of function parameters that are required to "
"perform certain actions"
msgstr "`隐含'- 执行某些行动所需的特殊种类的功能参数"

#: src/appendix-01-keywords.md:33
msgid "`let` - Bind a variable"
msgstr "`let'- 捆绑变量"

#: src/appendix-01-keywords.md:34
msgid "`loop` - Loop unconditionally"
msgstr "`循环'- 无条件循环"

#: src/appendix-01-keywords.md:35
msgid "`match` - Match a value to patterns"
msgstr "`匹配' - 匹配值到模式"

#: src/appendix-01-keywords.md:36
msgid "`mod` - Define a module"
msgstr "`模式'- 定义模块"

#: src/appendix-01-keywords.md:37
msgid "`mut` - Denote variable mutability"
msgstr "`mut'- 表示可变变化的可变性"

#: src/appendix-01-keywords.md:38
msgid ""
"`nopanic` - Functions marked with this notation mean that the function will "
"never panic."
msgstr "`非西班牙'- 以此符号标示的功能意味着该函数永远不会惊慌。"

#: src/appendix-01-keywords.md:39
msgid "`of` - Implement a trait"
msgstr "``` - 实施一个特性"

#: src/appendix-01-keywords.md:40
msgid ""
"`pub` - Denote public visibility in items, such as struct and struct fields,"
" enums, consts, traits and impl blocks, or modules"
msgstr "`管道'- 指在诸如建筑和建筑田、圆柱、阴柱、特性和断管块或模块等项目的公众能见度"

#: src/appendix-01-keywords.md:41
msgid "`ref` - Parameter passed implicitly returned at the end of a function"
msgstr "`ref'- 参数通过时默认返回函数结束时的参数"

#: src/appendix-01-keywords.md:42
msgid "`return` - Return from function"
msgstr "`返回'- 复职"

#: src/appendix-01-keywords.md:43
msgid "`struct` - Define a structure"
msgstr "`建筑'- 界定一个结构"

#: src/appendix-01-keywords.md:44
msgid "`trait` - Define a trait"
msgstr "`trait'- 界定特性"

#: src/appendix-01-keywords.md:45
msgid "`true` - Boolean true literal"
msgstr "`真正的'- 布尔真实的字面"

#: src/appendix-01-keywords.md:46
msgid "`type` - Define a type alias"
msgstr "`类型'- 定义类型别名"

#: src/appendix-01-keywords.md:47
msgid "`use` - Bring symbols into scope"
msgstr "`使用'- 将符号纳入范围"

#: src/appendix-01-keywords.md:48
msgid "`while` - loop conditionally based on the result of an expression"
msgstr "`同时'- 有条件地根据表达方式的结果循环"

#: src/appendix-01-keywords.md:52
msgid "Loose Keywords"
msgstr "松放关键字"

#: src/appendix-01-keywords.md:54
msgid ""
"These keywords are associated with a specific behaviour, but can also be "
"used to define items."
msgstr "这些关键词与具体行为相关联,但可用于界定项目。"

#: src/appendix-01-keywords.md:56
msgid "`self` - Method subject"
msgstr "`自我'- 方法问题"

#: src/appendix-01-keywords.md:57
msgid "`super` - Parent module of the current module"
msgstr "`超级' - 当前模块的父模块"

#: src/appendix-01-keywords.md:61
msgid "Reserved Keywords"
msgstr "关键词"

#: src/appendix-01-keywords.md:63
msgid ""
"These keywords aren't used yet, but they are reserved for future use. For "
"now, it is possible to use them to define items, although it is highly "
"recommended not to do so. The reasoning behind this recommendation is to "
"make current programs forward compatible with future versions of Cairo by "
"forbidding them to use these keywords."
msgstr ""
"这些关键字尚未使用, 但保留给未来使用 。 目前, 可以使用这些关键字来定义项目, 虽然强烈建议不要这样做 。 这项建议的理由是, "
"禁止当前程序使用这些关键字, 使当前程序与开罗的未来版本兼容 。"

#: src/appendix-01-keywords.md:68
msgid "`Self`"
msgstr "`自 '"

#: src/appendix-01-keywords.md:69
msgid "`do`"
msgstr "`做'"

#: src/appendix-01-keywords.md:70
msgid "`dyn`"
msgstr "`dyn'"

#: src/appendix-01-keywords.md:71
msgid "`for`"
msgstr "`为`"

#: src/appendix-01-keywords.md:72
msgid "`hint`"
msgstr "`东西'"

#: src/appendix-01-keywords.md:73
msgid "`in`"
msgstr "`in '"

#: src/appendix-01-keywords.md:74
msgid "`macro`"
msgstr "`马克罗 '"

#: src/appendix-01-keywords.md:75
msgid "`move`"
msgstr "`移动 '"

#: src/appendix-01-keywords.md:76
msgid "`static_assert`"
msgstr "`静态资产 '"

#: src/appendix-01-keywords.md:77
msgid "`static`"
msgstr "`静 '"

#: src/appendix-01-keywords.md:78
msgid "`try`"
msgstr "`Try'"

#: src/appendix-01-keywords.md:79
msgid "`typeof`"
msgstr "`类型'"

#: src/appendix-01-keywords.md:80
msgid "`unsafe`"
msgstr "`不安全'"

#: src/appendix-01-keywords.md:81
msgid "`where`"
msgstr "`此处 '"

#: src/appendix-01-keywords.md:82
msgid "`with`"
msgstr "`与`"

#: src/appendix-01-keywords.md:83
msgid "`yield`"
msgstr "`爱'"

#: src/appendix-01-keywords.md:87
msgid "Built-in Functions"
msgstr "内置功能"

#: src/appendix-01-keywords.md:89
msgid ""
"The Cairo programming language provides several specific functions that "
"serve a special purpose. We will not cover all of them in this book, but "
"using the names of these functions as names of other items is not "
"recommended."
msgstr "开罗节目制作语言提供若干具体功能,用于特殊目的,我们在本书中不涵盖所有功能,但建议不使用这些功能的名称作为其他项目的名称。"

#: src/appendix-01-keywords.md:91
msgid ""
"`assert` - This function checks a boolean expression, and if it evaluates to"
" false, it triggers the panic function."
msgstr "`资产'- 此函数检查布林表达式, 如果评估为假, 则触发恐慌功能 。"

#: src/appendix-01-keywords.md:92
msgid ""
"`panic` - This function acknowledges the occurrence of an error and "
"terminates the program."
msgstr "`西班牙' - 此函数确认发生错误并终止程序。"

#: src/appendix-02-operators-and-symbols.md:1
msgid "Appendix B - Operators and Symbols"
msgstr "附录B -- -- 操作员和符号"

#: src/appendix-02-operators-and-symbols.md:3
msgid ""
"This appendix contains a glossary of Cairo's syntax, including operators and"
" other symbols that appear by themselves or in the context of paths, "
"generics, macros, attributes, comments, tuples, and brackets."
msgstr "本附录载有开罗语法词汇表,包括操作员和其他符号本身或路径、非专利、宏观、属性、评论、图普尔和括号上出现的其他符号。"

#: src/appendix-02-operators-and-symbols.md:5
msgid "Operators"
msgstr "运算符"

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr ""
"表B-1载有开罗的操作员,一个操作员如何在上下文中出现的例子,一个简短的解释,以及操作员是否超载。 如果操作员超载,则列出该操作员超载的相关特性。"

#: src/appendix-02-operators-and-symbols.md:9
msgid "Operator"
msgstr "运算器操作员"

#: src/appendix-02-operators-and-symbols.md:9
#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:66
#: src/appendix-02-operators-and-symbols.md:76
#: src/appendix-02-operators-and-symbols.md:89
#: src/appendix-02-operators-and-symbols.md:120
#: src/appendix-02-operators-and-symbols.md:146
#: src/appendix-02-operators-and-symbols.md:154
#: src/appendix-02-operators-and-symbols.md:168
msgid "Explanation"
msgstr "解释解释解释 解释解释"

#: src/appendix-02-operators-and-symbols.md:9
msgid "Overloadable?"
msgstr "超载?"

#: src/appendix-02-operators-and-symbols.md:11
msgid "`!`"
msgstr "`!'`"

#: src/appendix-02-operators-and-symbols.md:11
msgid "`!expr`"
msgstr "`[!! Exdr '"

#: src/appendix-02-operators-and-symbols.md:11
msgid "Logical complement"
msgstr "逻辑补充"

#: src/appendix-02-operators-and-symbols.md:11
msgid "`Not`"
msgstr "`不是'"

#: src/appendix-02-operators-and-symbols.md:12
msgid "`~`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:12
msgid "`~expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:12
msgid "Bitwise NOT"
msgstr "位元不顺位"

#: src/appendix-02-operators-and-symbols.md:12
msgid "`BitNot`"
msgstr "`不`"

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!=`"
msgstr ""
"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"

#: src/appendix-02-operators-and-symbols.md:13
msgid "`expr != expr`"
msgstr "\" Exter! \" = expr`"

#: src/appendix-02-operators-and-symbols.md:13
msgid "Non-equality comparison"
msgstr "不平等比较"

#: src/appendix-02-operators-and-symbols.md:13
#: src/appendix-02-operators-and-symbols.md:38
msgid "`PartialEq`"
msgstr "`partialEq '"

#: src/appendix-02-operators-and-symbols.md:14
msgid "`%`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:14
msgid "`expr % expr`"
msgstr "`Exmer % exprer '"

#: src/appendix-02-operators-and-symbols.md:14
msgid "Arithmetic remainder"
msgstr "论论余余"

#: src/appendix-02-operators-and-symbols.md:14
msgid "`Rem`"
msgstr "`Rem '"

#: src/appendix-02-operators-and-symbols.md:15
msgid "`%=`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:15
msgid "`var %= expr`"
msgstr "`var {____\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/appendix-02-operators-and-symbols.md:15
msgid "Arithmetic remainder and assignment"
msgstr "相对余量和派任"

#: src/appendix-02-operators-and-symbols.md:15
msgid "`RemEq`"
msgstr "`RemEq '"

#: src/appendix-02-operators-and-symbols.md:16
msgid "`&`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:16
msgid "`expr & expr`"
msgstr "`Exter & expr '"

#: src/appendix-02-operators-and-symbols.md:16
msgid "Bitwise AND"
msgstr "按比位和"

#: src/appendix-02-operators-and-symbols.md:16
msgid "`BitAnd`"
msgstr "`比尔和'"

#: src/appendix-02-operators-and-symbols.md:17
msgid "`&&`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:17
msgid "`expr && expr`"
msgstr ""
"`Expr'Expr { { expr` { expr } { expr { { expr { } { expr { } { expr { { { "
"expr } { { expr { { { { { { } { expr { { { {"

#: src/appendix-02-operators-and-symbols.md:17
msgid "Short-circuiting logical AND"
msgstr "短路路逻辑和"

#: src/appendix-02-operators-and-symbols.md:18
#: src/appendix-02-operators-and-symbols.md:21
msgid "`*`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:18
msgid "`expr * expr`"
msgstr "`Exder * depr '"

#: src/appendix-02-operators-and-symbols.md:18
msgid "Arithmetic multiplication"
msgstr "A. 物理乘数"

#: src/appendix-02-operators-and-symbols.md:18
msgid "`Mul`"
msgstr "`穆勒 '"

#: src/appendix-02-operators-and-symbols.md:19
msgid "`*=`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:19
msgid "`var *= expr`"
msgstr "`var {____\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/appendix-02-operators-and-symbols.md:19
msgid "Arithmetic multiplication and assignment"
msgstr "A. 相对性乘数和任务"

#: src/appendix-02-operators-and-symbols.md:19
msgid "`MulEq`"
msgstr "`穆勒埃克 '"

#: src/appendix-02-operators-and-symbols.md:20
msgid "`@`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:20
msgid "`@var`"
msgstr ""
"#var`_#########################################################################################################################################################################################################################################################################################################"

#: src/appendix-02-operators-and-symbols.md:20
msgid "Snapshot"
msgstr "抓图"

#: src/appendix-02-operators-and-symbols.md:21
msgid "`*var`"
msgstr ""
"#var`_#########################################################################################################################################################################################################################################################################################################"

#: src/appendix-02-operators-and-symbols.md:21
msgid "Desnap"
msgstr "后发"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`+`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`expr + expr`"
msgstr "`Exder + expr '"

#: src/appendix-02-operators-and-symbols.md:22
msgid "Arithmetic addition"
msgstr "修 修 修 修 修 修 修 修 修 修 修 修 修 修 修 修 修"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`Add`"
msgstr "`Add'号"

#: src/appendix-02-operators-and-symbols.md:23
msgid "`+=`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:23
msgid "`var += expr`"
msgstr "`var {____\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/appendix-02-operators-and-symbols.md:23
msgid "Arithmetic addition and assignment"
msgstr "修配和派任"

#: src/appendix-02-operators-and-symbols.md:23
msgid "`AddEq`"
msgstr "`AddEq`"

#: src/appendix-02-operators-and-symbols.md:24
msgid "`,`"
msgstr "`,`,`"

#: src/appendix-02-operators-and-symbols.md:24
msgid "`expr, expr`"
msgstr "`Exter, depr '"

#: src/appendix-02-operators-and-symbols.md:24
msgid "Argument and element separator"
msgstr "参数和元素分隔符"

#: src/appendix-02-operators-and-symbols.md:25
#: src/appendix-02-operators-and-symbols.md:26
msgid "`-`"
msgstr "`-``"

#: src/appendix-02-operators-and-symbols.md:25
msgid "`-expr`"
msgstr "` - 发光 '"

#: src/appendix-02-operators-and-symbols.md:25
msgid "Arithmetic negation"
msgstr "理论否定"

#: src/appendix-02-operators-and-symbols.md:25
msgid "`Neg`"
msgstr "`Neg '"

#: src/appendix-02-operators-and-symbols.md:26
msgid "`expr - expr`"
msgstr "`Exprer - expr`"

#: src/appendix-02-operators-and-symbols.md:26
msgid "Arithmetic subtraction"
msgstr "亚性减法"

#: src/appendix-02-operators-and-symbols.md:26
msgid "`Sub`"
msgstr "```````"

#: src/appendix-02-operators-and-symbols.md:27
msgid "`-=`"
msgstr ""
"`-_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:27
msgid "`var -= expr`"
msgstr "`var -= expr`"

#: src/appendix-02-operators-and-symbols.md:27
msgid "Arithmetic subtraction and assignment"
msgstr "A. 相对减法和任务"

#: src/appendix-02-operators-and-symbols.md:27
msgid "`SubEq`"
msgstr ""
"`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````"

#: src/appendix-02-operators-and-symbols.md:28
msgid "`->`"
msgstr ""
"`-_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:28
msgid "`fn(...) -> type`, <code>\\|...\\| -> type</code>"
msgstr "`fn(...) - > 类型 ', < code_...\\\\\\ > > 类型 </code>"

#: src/appendix-02-operators-and-symbols.md:28
msgid "Function and closure return type"
msgstr "函数和关闭返回类型"

#: src/appendix-02-operators-and-symbols.md:29
msgid "`.`"
msgstr "`.``"

#: src/appendix-02-operators-and-symbols.md:29
msgid "`expr.ident`"
msgstr "`非常身份 '"

#: src/appendix-02-operators-and-symbols.md:29
msgid "Member access"
msgstr "成员访问"

#: src/appendix-02-operators-and-symbols.md:30
msgid "`/`"
msgstr "`/``"

#: src/appendix-02-operators-and-symbols.md:30
msgid "`expr / expr`"
msgstr "`Exter / depr '"

#: src/appendix-02-operators-and-symbols.md:30
msgid "Arithmetic division"
msgstr "亚学分"

#: src/appendix-02-operators-and-symbols.md:30
msgid "`Div`"
msgstr "`第`第``"

#: src/appendix-02-operators-and-symbols.md:31
msgid "`/=`"
msgstr ""
"`/_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:31
msgid "`var /= expr`"
msgstr "`var /= expr`"

#: src/appendix-02-operators-and-symbols.md:31
msgid "Arithmetic division and assignment"
msgstr "相对分解和任务"

#: src/appendix-02-operators-and-symbols.md:31
msgid "`DivEq`"
msgstr "`DivEq '"

#: src/appendix-02-operators-and-symbols.md:32
#: src/appendix-02-operators-and-symbols.md:33
msgid "`:`"
msgstr "`:`"

#: src/appendix-02-operators-and-symbols.md:32
msgid "`pat: type`, `ident: type`"
msgstr "`空间:类型 ',`身份:类型 '"

#: src/appendix-02-operators-and-symbols.md:32
msgid "Constraints"
msgstr "制约因素"

#: src/appendix-02-operators-and-symbols.md:33
msgid "`ident: expr`"
msgstr "`日期:日期`"

#: src/appendix-02-operators-and-symbols.md:33
msgid "Struct field initializer"
msgstr "Struct 字段初始化器"

#: src/appendix-02-operators-and-symbols.md:34
msgid "`;`"
msgstr "`;`;`"

#: src/appendix-02-operators-and-symbols.md:34
msgid "`expr;`"
msgstr "`Exter; '"

#: src/appendix-02-operators-and-symbols.md:34
msgid "Statement and item terminator"
msgstr "报表和项目"

#: src/appendix-02-operators-and-symbols.md:35
msgid "`<`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:35
msgid "`expr < expr`"
msgstr "`Exder < depr '"

#: src/appendix-02-operators-and-symbols.md:35
msgid "Less than comparison"
msgstr "低于比较"

#: src/appendix-02-operators-and-symbols.md:35
#: src/appendix-02-operators-and-symbols.md:36
#: src/appendix-02-operators-and-symbols.md:40
#: src/appendix-02-operators-and-symbols.md:41
msgid "`PartialOrd`"
msgstr "`部分命令 '"

#: src/appendix-02-operators-and-symbols.md:36
msgid "`<=`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:36
msgid "`expr <= expr`"
msgstr ""
"`Expr'Expr { { expr` { expr } { expr { { expr { } { expr { } { expr { { { "
"expr } { { expr { { { { { { } { expr { { { {"

#: src/appendix-02-operators-and-symbols.md:36
msgid "Less than or equal to comparison"
msgstr "小于或等于比较"

#: src/appendix-02-operators-and-symbols.md:37
msgid "`=`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:37
msgid "`var = expr`"
msgstr "`var = expr`"

#: src/appendix-02-operators-and-symbols.md:37
msgid "Assignment"
msgstr "派 派 派"

#: src/appendix-02-operators-and-symbols.md:38
msgid "`==`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:38
msgid "`expr == expr`"
msgstr ""
"`Exer = expr = = Expr = = = = = = = = = = = = = = = = = = = = = = = = = = = "
"= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = "
"= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = "
"= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = "
"= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="

#: src/appendix-02-operators-and-symbols.md:38
msgid "Equality comparison"
msgstr "平等比较"

#: src/appendix-02-operators-and-symbols.md:39
msgid "`=>`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:39
msgid "`pat => expr`"
msgstr "`pat  expr`"

#: src/appendix-02-operators-and-symbols.md:39
msgid "Part of match arm syntax"
msgstr "匹配的 arm 语法部分"

#: src/appendix-02-operators-and-symbols.md:40
msgid "`>`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:40
msgid "`expr > expr`"
msgstr "`Exder > Expr '"

#: src/appendix-02-operators-and-symbols.md:40
msgid "Greater than comparison"
msgstr "大于比较"

#: src/appendix-02-operators-and-symbols.md:41
msgid "`>=`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:41
msgid "`expr >= expr`"
msgstr ""
"`Expr'Expr { { expr` { expr } { expr { { expr { } { expr { } { expr { { { "
"expr } { { expr { { { { { { } { expr { { { {"

#: src/appendix-02-operators-and-symbols.md:41
msgid "Greater than or equal to comparison"
msgstr "大于或等于比较"

#: src/appendix-02-operators-and-symbols.md:42
msgid "`^`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:42
msgid "`expr ^ expr`"
msgstr "`Exter = expr`"

#: src/appendix-02-operators-and-symbols.md:42
msgid "Bitwise exclusive OR"
msgstr "按位元算的独家 OR"

#: src/appendix-02-operators-and-symbols.md:42
msgid "`BitXor`"
msgstr "`BitXor '"

#: src/appendix-02-operators-and-symbols.md:43
msgid "<code>\\|</code>"
msgstr "<code/code>"

#: src/appendix-02-operators-and-symbols.md:43
msgid "<code>expr \\| expr</code>"
msgstr "<code>expr {} expr </code> 。 <code> > expr < expr </code>"

#: src/appendix-02-operators-and-symbols.md:43
msgid "Bitwise OR"
msgstr "按位数 OR"

#: src/appendix-02-operators-and-symbols.md:43
msgid "`BitOr`"
msgstr "`比尔'"

#: src/appendix-02-operators-and-symbols.md:44
msgid "<code>\\|\\|</code>"
msgstr "<code/code>"

#: src/appendix-02-operators-and-symbols.md:44
msgid "<code>expr \\|\\| expr</code>"
msgstr "<code>expr {} expr </code> 。 <code> > expr < expr </code>"

#: src/appendix-02-operators-and-symbols.md:44
msgid "Short-circuiting logical OR"
msgstr "短路逻辑"

#: src/appendix-02-operators-and-symbols.md:45
msgid "`?`"
msgstr "`?'`? '"

#: src/appendix-02-operators-and-symbols.md:45
msgid "expr?"
msgstr "发件人?"

#: src/appendix-02-operators-and-symbols.md:45
msgid "Error propagation"
msgstr "错误传播"

#: src/appendix-02-operators-and-symbols.md:47
msgid "<span class=\"caption\">Table B-1: Operators</span>"
msgstr "<span类=“Caption” >表B-1:运算符 </span>"

#: src/appendix-02-operators-and-symbols.md:49
msgid "Non Operator Symbols"
msgstr ""
"编号 编号 编号 号 号 编号 号 号 编号 号 号 编号 号 号 号 号号无号号 "
"号号无号号号只有号和无号号号号只有只有只有只有只有号号只有只有只有只有号号号。"

#: src/appendix-02-operators-and-symbols.md:51
msgid ""
"The following list contains all symbols that are not used as operators; that"
" is, they do not have the same behavior as a function or method call."
msgstr "以下列表包含所有未用作操作员的符号;也就是说,它们的行为与函数或方法调用没有相同。"

#: src/appendix-02-operators-and-symbols.md:53
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr "表B-2显示自发出现并在各种地点有效的符号。"

#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:66
#: src/appendix-02-operators-and-symbols.md:76
#: src/appendix-02-operators-and-symbols.md:89
#: src/appendix-02-operators-and-symbols.md:120
#: src/appendix-02-operators-and-symbols.md:146
#: src/appendix-02-operators-and-symbols.md:154
msgid "Symbol"
msgstr "符号符号符号"

#: src/appendix-02-operators-and-symbols.md:57
msgid "`..._u8`, `..._usize`, `..._bool`, etc."
msgstr "``.u8',`._usize`,`._bool`,等等。"

#: src/appendix-02-operators-and-symbols.md:57
msgid "Numeric literal of specific type"
msgstr "特定类型数值字数"

#: src/appendix-02-operators-and-symbols.md:58
msgid "`\"...\"`"
msgstr ""
"````````````......`......`......`......`......`......`......`......`......`......`......`......`......``......``......``......```......````......```````......```````......``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````"

#: src/appendix-02-operators-and-symbols.md:58
msgid "String literal"
msgstr "字符字符字符串字数"

#: src/appendix-02-operators-and-symbols.md:59
msgid "`'...'`"
msgstr ""
"``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````[``````````````````````````````````````````````````````[`````````````````````````````````````````````````[````````````````````````````[`````````````````````````````````````````````````````````````````````````````[``````````````````````````````````````````````````````"

#: src/appendix-02-operators-and-symbols.md:59
msgid "Short string, 31 ASCII characters maximum"
msgstr "短字符串, 31 ASCII 最大字符数"

#: src/appendix-02-operators-and-symbols.md:60
msgid "`_`"
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:60
msgid "“Ignored” pattern binding"
msgstr "“未承认”有约束力模式"

#: src/appendix-02-operators-and-symbols.md:62
msgid "<span class=\"caption\">Table B-2: Stand-Alone Syntax</span>"
msgstr "<span类=“caption” >表B-2:单方语法 </span>"

#: src/appendix-02-operators-and-symbols.md:64
msgid ""
"Table B-3 shows symbols that are used within the context of a module "
"hierarchy path to access an item."
msgstr "表B-3显示模块结构路径中用于访问某个项目的符号。"

#: src/appendix-02-operators-and-symbols.md:68
msgid "`ident::ident`"
msgstr "`身份:身份:身份`"

#: src/appendix-02-operators-and-symbols.md:68
msgid "Namespace path"
msgstr "命名空间路径"

#: src/appendix-02-operators-and-symbols.md:69
msgid "`super::path`"
msgstr "`超级:病道'"

#: src/appendix-02-operators-and-symbols.md:69
msgid "Path relative to the parent of the current module"
msgstr "相对于当前模块父的当前模块的路径"

#: src/appendix-02-operators-and-symbols.md:70
msgid "`trait::method(...)`"
msgstr "`trait::方法(...) '"

#: src/appendix-02-operators-and-symbols.md:70
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr "通过命名界定该功能的特性来使一种方法调用不同"

#: src/appendix-02-operators-and-symbols.md:72
msgid "<span class=\"caption\">Table B-3: Path-Related Syntax</span>"
msgstr "<span类=“caption” >表B-3:与路径相关的语法 </span>"

#: src/appendix-02-operators-and-symbols.md:74
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr "表B-4显示使用通用类型参数时出现的符号。"

#: src/appendix-02-operators-and-symbols.md:78
msgid "`path<...>`"
msgstr ""
"路由... "
"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"

#: src/appendix-02-operators-and-symbols.md:78
msgid "Specifies parameters to generic type in a type (e.g., `Array<u8>`)"
msgstr "指定类型中通用类型的参数(例如,`Array<u8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\可以\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/appendix-02-operators-and-symbols.md:79
msgid "`path::<...>`, `method::<...>`"
msgstr ""
"病历: < "
"_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________"
" "
"方法:<_____________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:79
msgid ""
"Specifies parameters to a generic type, function, or method in an "
"expression; often referred to as turbofish"
msgstr "指定表达式中通用类型、函数或方法的参数;通常称为涡轮鱼"

#: src/appendix-02-operators-and-symbols.md:80
msgid "`fn ident<...> ...`"
msgstr "\" 身份 \" <. >.`"

#: src/appendix-02-operators-and-symbols.md:80
msgid "Define generic function"
msgstr "定义通用功能"

#: src/appendix-02-operators-and-symbols.md:81
msgid "`struct ident<...> ...`"
msgstr "\" 站点身份 \" <. >.`"

#: src/appendix-02-operators-and-symbols.md:81
msgid "Define generic structure"
msgstr "界定通用结构"

#: src/appendix-02-operators-and-symbols.md:82
msgid "`enum ident<...> ...`"
msgstr ""
"\".号 \" 号号号 \" 号号 \" 号 \" 号号 \" 号号 \" 号号 \" 号号 \" 号号 \" 号号 \" 号号号 \" 号号 \" "
"号号号 \" 号号号 \" 号号号 \" 号号号号 \" 号号号 \" 号号号 \" 号号 \" 号号号 \" 号号号 \" 号号号 \" 号号号 \""
" 号号号 \" 号号号 \" 号号号 \" 号号 \" 号号号 \" 号号号号 \" 号号号 \" 号号 \" 号号号 \" 号号 \" 号号 \" "
"号号号 \" 号号 \" 号号号 \" 号号 \" 号号号号号号 \" 号号号号号 \" 号号号 \" 号号 \" 号号号号号 \" 号号号号号 \" "
"号号号号号号号 \" 号号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \""
" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" "
"号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号"
" \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 "
"\" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 "
"\" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号 "
"\" 号 \" 号 \" 号 \" 号 \" 号 \" 号 \" 号"

#: src/appendix-02-operators-and-symbols.md:82
msgid "Define generic enumeration"
msgstr "界定一般查点"

#: src/appendix-02-operators-and-symbols.md:83
msgid "`impl<...> ...`"
msgstr "`impl <... > `"

#: src/appendix-02-operators-and-symbols.md:83
msgid "Define generic implementation"
msgstr "界定一般实施"

#: src/appendix-02-operators-and-symbols.md:85
msgid "<span class=\"caption\">Table B-4: Generics</span>"
msgstr "<span类=“Caption” >表B-4:通用 </span>"

#: src/appendix-02-operators-and-symbols.md:87
msgid ""
"Table B-5 shows symbols that appear in the context of specifying attributes "
"on an item."
msgstr "表B-5显示在指定项目属性时出现的符号。"

#: src/appendix-02-operators-and-symbols.md:91
msgid "`#[derive(...)]`"
msgstr "*[代(...)]`"

#: src/appendix-02-operators-and-symbols.md:91
msgid "Automatically implements a trait for a type"
msgstr "自动执行类型特性"

#: src/appendix-02-operators-and-symbols.md:92
msgid "`#[inline]`"
msgstr "[内 `"

#: src/appendix-02-operators-and-symbols.md:92
msgid "Hint to the compiler to allow inlining of annotated function"
msgstr "向汇编者提示,以便插入附加说明的功能"

#: src/appendix-02-operators-and-symbols.md:93
msgid "`#[inline(always)]`"
msgstr "``[内线(始终 `"

#: src/appendix-02-operators-and-symbols.md:93
msgid "Hint to the compiler to systematically inline annotated function"
msgstr "将附加说明的函数系统嵌入到汇编器中"

#: src/appendix-02-operators-and-symbols.md:94
msgid "`#[inline(never)]`"
msgstr "[内 [永 `"

#: src/appendix-02-operators-and-symbols.md:94
msgid "Hint to the compiler to never inline annotated function"
msgstr "向汇编者提示, 永远不要插入附加说明的函数"

#: src/appendix-02-operators-and-symbols.md:95
msgid "`#[must_use]`"
msgstr "`[必须_用 `"

#: src/appendix-02-operators-and-symbols.md:95
msgid ""
"Hint to the compiler that the return value of a function or a specific "
"returned type must be used"
msgstr "提示编辑器必须使用函数或特定返回类型返回值"

#: src/appendix-02-operators-and-symbols.md:96
msgid "`#[generate_trait]`"
msgstr "[遗传_trait]`"

#: src/appendix-02-operators-and-symbols.md:96
msgid "Automatically generates a trait for an impl"
msgstr "自动生成软管特性"

#: src/appendix-02-operators-and-symbols.md:97
msgid "`#[available_gas(...)]`"
msgstr "*[可用_gas(...)]`"

#: src/appendix-02-operators-and-symbols.md:97
msgid "Set the maximum amount of gas available to execute a function"
msgstr "设定可用于执行函数的最大气体量"

#: src/appendix-02-operators-and-symbols.md:98
msgid "`#[panic_with('...', wrapper_name)]`"
msgstr "* ```[panic_ with('......)',包装_name'`"

#: src/appendix-02-operators-and-symbols.md:98
msgid ""
"Creates a wrapper for the annotated function which will panic if the "
"function returns `None` or `Err`, with the given data as the panic error"
msgstr "为附加说明的函数创建一个包装纸,如果函数返回`无'或`错误 ',如果函数返回`无'或`错误 ',以给定数据为惊慌错误,则会惊慌"

#: src/appendix-02-operators-and-symbols.md:99
msgid "`#[test]`"
msgstr "`[试 `"

#: src/appendix-02-operators-and-symbols.md:99
msgid "Describe a function as a test function"
msgstr "描述函数为测试函数"

#: src/appendix-02-operators-and-symbols.md:100
msgid "`#[cfg(...)]`"
msgstr "`[参考(...)]`"

#: src/appendix-02-operators-and-symbols.md:100
msgid ""
"Configuration attribute, especially used to configure a `tests` module with "
"`#[cfg(test)]`"
msgstr "配置属性, 特别是用于配置“ 测试” 模块的“ 测试” 属性"

#: src/appendix-02-operators-and-symbols.md:101
msgid "`#[should_panic]`"
msgstr "`[应_泛 `"

#: src/appendix-02-operators-and-symbols.md:101
msgid "Specifies that a test function should necessarily panic"
msgstr "指定测试函数必须恐慌"

#: src/appendix-02-operators-and-symbols.md:102
msgid "`#[starknet::contract]`"
msgstr "[星网:合同]`"

#: src/appendix-02-operators-and-symbols.md:102
msgid "Defines a Starknet smart contract"
msgstr "定义斯塔克内特智能合同"

#: src/appendix-02-operators-and-symbols.md:103
msgid "`#[starknet::interface]`"
msgstr "[星网::接口]`"

#: src/appendix-02-operators-and-symbols.md:103
msgid "Defines a Starknet interface"
msgstr "定义 Starknet 界面"

#: src/appendix-02-operators-and-symbols.md:104
msgid "`#[starknet::component]`"
msgstr "[星网::构成部分]`"

#: src/appendix-02-operators-and-symbols.md:104
msgid "Defines a Starknet component"
msgstr "定义 Starknet 组件"

#: src/appendix-02-operators-and-symbols.md:105
msgid "`#[starknet::embeddable]`"
msgstr "``[星网::可腐 `"

#: src/appendix-02-operators-and-symbols.md:105
msgid ""
"Defines an isolated embeddable implementation that can be injected in any "
"smart contract"
msgstr "定义可在任何智能合同中注入的孤立的嵌入式实施"

#: src/appendix-02-operators-and-symbols.md:106
msgid "`#[embeddable_as(...)]`"
msgstr "*[可编 [作为(...)]`"

#: src/appendix-02-operators-and-symbols.md:106
msgid "Defines an embeddable implementation inside a component"
msgstr "定义构成部分内可嵌入的执行内容"

#: src/appendix-02-operators-and-symbols.md:107
msgid "`#[storage]`"
msgstr "`[储存]`"

#: src/appendix-02-operators-and-symbols.md:107
msgid "Defines the storage of a smart contract"
msgstr "定义智能合同的储存"

#: src/appendix-02-operators-and-symbols.md:108
msgid "`#[event]`"
msgstr "`[活动]`"

#: src/appendix-02-operators-and-symbols.md:108
msgid "Defines an event in a smart contract"
msgstr "在智能合同中定义事件"

#: src/appendix-02-operators-and-symbols.md:109
msgid "`#[constructor]`"
msgstr "`[构 `"

#: src/appendix-02-operators-and-symbols.md:109
msgid "Defines the constructor in a smart contract"
msgstr "在一个智能合同中定义构建器"

#: src/appendix-02-operators-and-symbols.md:110
msgid "`#[abi(embed_v0)]`"
msgstr "* [(embed_v0)]`"

#: src/appendix-02-operators-and-symbols.md:110
msgid ""
"Defines an implementation of a trait, exposing the functions of the impl as "
"entrypoints of a contract"
msgstr "定义了特性的实施,将分化功能暴露为合同的切入点"

#: src/appendix-02-operators-and-symbols.md:111
msgid "`#[abi(per_item)]`"
msgstr "[(每个项目)]`"

#: src/appendix-02-operators-and-symbols.md:111
msgid ""
"Allows individual definition of the entrypoint type of functions inside an "
"impl"
msgstr "允许对内插插管函数的切入点类型进行单个定义"

#: src/appendix-02-operators-and-symbols.md:112
msgid "`#[external(v0)]`"
msgstr "[外部(v0)]`"

#: src/appendix-02-operators-and-symbols.md:112
msgid "Defines an external function when `#[abi(per_item)]` is used"
msgstr "使用 {{{{{{{{{{( per_ itp}} ` 时定义外部函数"

#: src/appendix-02-operators-and-symbols.md:113
msgid "`#[flat]`"
msgstr ""
"________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________"

#: src/appendix-02-operators-and-symbols.md:113
msgid ""
"Defines a enum variant of the `Event` enum that is not nested, ignoring the "
"variant name in the serialization process, very useful for composability "
"when using Starknet components"
msgstr "定义“Event” enum的昆虫变体,该变体没有嵌套,在序列化过程中忽略变体名称,在使用 Starknet 组件时对可变性非常有用"

#: src/appendix-02-operators-and-symbols.md:114
msgid "`#[key]`"
msgstr "`[关键]`"

#: src/appendix-02-operators-and-symbols.md:114
msgid ""
"Defines an indexed `Event` enum field, allowing for more efficient queries "
"and filtering of events"
msgstr "定义索引化的“晚上”内容字段,以便更有效地查询和筛选事件"

#: src/appendix-02-operators-and-symbols.md:116
msgid "<span class=\"caption\">Table B-5: Attributes</span>"
msgstr "<span类=“Caption” >表B-5:属性 </span>"

#: src/appendix-02-operators-and-symbols.md:118
msgid ""
"Table B-6 shows symbols that appear in the context of calling or defining "
"macros."
msgstr "表B-6显示在调用或定义宏时出现的符号。"

#: src/appendix-02-operators-and-symbols.md:122
msgid "`print!`"
msgstr "印记!"

#: src/appendix-02-operators-and-symbols.md:122
msgid "Inline printing"
msgstr "内线打印"

#: src/appendix-02-operators-and-symbols.md:123
msgid "`println!`"
msgstr "\" 印记! \""

#: src/appendix-02-operators-and-symbols.md:123
msgid "Print on a new line"
msgstr "在新行打印"

#: src/appendix-02-operators-and-symbols.md:124
msgid "`consteval_int!`"
msgstr "\" 常务会议! \""

#: src/appendix-02-operators-and-symbols.md:124
msgid "Declare a constant that is the result of a computation of integers"
msgstr "声明一个常数,该常数是计算整数的结果"

#: src/appendix-02-operators-and-symbols.md:125
msgid "`array!`"
msgstr "\" 列车! \""

#: src/appendix-02-operators-and-symbols.md:125
msgid "Instantiate and fill arrays"
msgstr "证明和填充阵列"

#: src/appendix-02-operators-and-symbols.md:126
msgid "`panic!`"
msgstr "`西班牙人! '"

#: src/appendix-02-operators-and-symbols.md:126
msgid ""
"Calls `panic` function and allows to provide a message error longer than 31 "
"characters"
msgstr "调用 `panic' 函数并允许提供超过 31 个字符的信息错误"

#: src/appendix-02-operators-and-symbols.md:127
msgid "`assert!`"
msgstr "`资产! '"

#: src/appendix-02-operators-and-symbols.md:127
msgid "Evaluates a Boolean and panics if `false`"
msgstr "评估布尔和恐慌,如果`假'"

#: src/appendix-02-operators-and-symbols.md:128
msgid "`assert_eq!`"
msgstr "`Assert_eq! '"

#: src/appendix-02-operators-and-symbols.md:128
msgid "Evaluates an equality, and panics if not equal"
msgstr "评估平等,如果不是平等,也会惊慌失措"

#: src/appendix-02-operators-and-symbols.md:129
msgid "`assert_ne!`"
msgstr "`assrt_ne!'`Assert_ne!'`Assert_ne!'`Assert_ne! '"

#: src/appendix-02-operators-and-symbols.md:129
msgid "Evaluates an equality, and panics if equal"
msgstr "评估平等,如果平等,则评估恐慌"

#: src/appendix-02-operators-and-symbols.md:130
msgid "`assert_lt!`"
msgstr "`资产! '"

#: src/appendix-02-operators-and-symbols.md:130
msgid "Evaluates a comparison, and panics if greater or equal"
msgstr "评估比较,评估恐慌,如果更大或相等"

#: src/appendix-02-operators-and-symbols.md:131
msgid "`assert_le!`"
msgstr "`assrt_le!'阿瑟特! '"

#: src/appendix-02-operators-and-symbols.md:131
msgid "Evaluates a comparison, and panics if greater"
msgstr "评估比较,评估恐慌,如果更大"

#: src/appendix-02-operators-and-symbols.md:132
msgid "`assert_gt!`"
msgstr "`assrt_gt!'(Assert_gt! )"

#: src/appendix-02-operators-and-symbols.md:132
msgid "Evaluates a comparison, and panics if lower or equal"
msgstr "比较评价比较,低或等的惊慌或惊慌"

#: src/appendix-02-operators-and-symbols.md:133
msgid "`assert_ge!`"
msgstr "`Astort_ge! '"

#: src/appendix-02-operators-and-symbols.md:133
msgid "Evaluates a comparison, and panics if lower"
msgstr "评估比较,如果比较低,就会惊慌"

#: src/appendix-02-operators-and-symbols.md:134
msgid "`format!`"
msgstr "`format! '"

#: src/appendix-02-operators-and-symbols.md:134
msgid "Format a string and returns a `ByteArray` with the contents"
msgstr "格式化字符串并返回含有内容的“ Byte 阵列”"

#: src/appendix-02-operators-and-symbols.md:135
msgid "`write!`"
msgstr "\" 写! \""

#: src/appendix-02-operators-and-symbols.md:135
msgid "Write formatted strings in a formatter"
msgstr "将格式格式化字符串写入为要处理的事项"

#: src/appendix-02-operators-and-symbols.md:136
msgid "`writeln!`"
msgstr "\" wwretln! \" (Wwretln! )"

#: src/appendix-02-operators-and-symbols.md:136
msgid "Write formatted strings in a formatter on a new line"
msgstr "将格式化字符串写入新行的要书"

#: src/appendix-02-operators-and-symbols.md:137
msgid "`get_dep_component!`"
msgstr "\" 获取部件! \""

#: src/appendix-02-operators-and-symbols.md:137
msgid ""
"Returns the requested component state from a snapshot of the state inside a "
"component"
msgstr "从部件内状态的快照返回请求的组件状态"

#: src/appendix-02-operators-and-symbols.md:138
msgid "`get_dep_component_mut!`"
msgstr "\" 获取组件!\""

#: src/appendix-02-operators-and-symbols.md:138
msgid ""
"Returns the requested component state from a reference of the state inside a"
" component"
msgstr "从部件内状态的引用返回请求的组件状态"

#: src/appendix-02-operators-and-symbols.md:139
msgid "`component!`"
msgstr "\" 构件! \""

#: src/appendix-02-operators-and-symbols.md:139
msgid ""
"Macro used in Starknet contracts to embed a component inside a contract"
msgstr "Starknet 合同中用于将组成部分嵌入合同的宏"

#: src/appendix-02-operators-and-symbols.md:142
msgid "<span class=\"caption\">Table B-6: Macros</span>"
msgstr "<span类=“Caption” >表B-6:宏 </span>"

#: src/appendix-02-operators-and-symbols.md:144
msgid "Table B-7 shows symbols that create comments."
msgstr "表B-7显示创建注释的符号。"

#: src/appendix-02-operators-and-symbols.md:148
msgid "`//`"
msgstr "`/``"

#: src/appendix-02-operators-and-symbols.md:148
msgid "Line comment"
msgstr "线条注释注释"

#: src/appendix-02-operators-and-symbols.md:150
msgid "<span class=\"caption\">Table B-7: Comments</span>"
msgstr "<span类=“Caption” >表B-7:批注 </span>"

#: src/appendix-02-operators-and-symbols.md:152
msgid "Table B-8 shows symbols that appear in the context of using tuples."
msgstr "表B-8显示了在使用图普尔时出现的符号。"

#: src/appendix-02-operators-and-symbols.md:156
msgid "`()`"
msgstr "`()`"

#: src/appendix-02-operators-and-symbols.md:156
msgid "Empty tuple (aka unit), both literal and type"
msgstr "空图普(aa 单位), 字面和类型"

#: src/appendix-02-operators-and-symbols.md:157
msgid "`(expr)`"
msgstr "`((燃料)`)`"

#: src/appendix-02-operators-and-symbols.md:157
msgid "Parenthesized expression"
msgstr "括号表达式"

#: src/appendix-02-operators-and-symbols.md:158
msgid "`(expr,)`"
msgstr "`((Exter,))`"

#: src/appendix-02-operators-and-symbols.md:158
msgid "Single-element tuple expression"
msgstr "单元素图普表达式"

#: src/appendix-02-operators-and-symbols.md:159
msgid "`(type,)`"
msgstr "`(类型,)`"

#: src/appendix-02-operators-and-symbols.md:159
msgid "Single-element tuple type"
msgstr "单元素图普型"

#: src/appendix-02-operators-and-symbols.md:160
msgid "`(expr, ...)`"
msgstr "`((Exter,...))`"

#: src/appendix-02-operators-and-symbols.md:160
msgid "Tuple expression"
msgstr "图图表达式"

#: src/appendix-02-operators-and-symbols.md:161
msgid "`(type, ...)`"
msgstr "`(类型,.) '"

#: src/appendix-02-operators-and-symbols.md:161
msgid "Tuple type"
msgstr "图示类型类型"

#: src/appendix-02-operators-and-symbols.md:162
msgid "`expr(expr, ...)`"
msgstr "`Exter( Exter,...) '"

#: src/appendix-02-operators-and-symbols.md:162
msgid ""
"Function call expression; also used to initialize tuple `struct`s and tuple "
"`enum` variants"
msgstr "函数调用表达式; 也用于初始化 tuple `struct' 和 tuple `enum' 变量"

#: src/appendix-02-operators-and-symbols.md:164
msgid "<span class=\"caption\">Table B-8: Tuples</span>"
msgstr "<span类=“Caption” >表B-8:图例 </span>"

#: src/appendix-02-operators-and-symbols.md:166
msgid "Table B-9 shows the contexts in which curly braces are used."
msgstr "表B-9显示了使用卷轴牙套的背景。"

#: src/appendix-02-operators-and-symbols.md:168
msgid "Context"
msgstr "背景背景背景背景"

#: src/appendix-02-operators-and-symbols.md:170
msgid "`{...}`"
msgstr "{\\fn华文楷体\\fs16\\1cHE0E0E0}... {\\fn华文楷体\\fs16\\1cHE0E0E0}..."

#: src/appendix-02-operators-and-symbols.md:170
msgid "Block expression"
msgstr "块块表达式"

#: src/appendix-02-operators-and-symbols.md:171
msgid "`Type {...}`"
msgstr "类型 {...} {...} {...}"

#: src/appendix-02-operators-and-symbols.md:171
msgid "`struct` literal"
msgstr "`建筑'字面"

#: src/appendix-02-operators-and-symbols.md:173
msgid "<span class=\"caption\">Table B-9: Curly Braces</span>"
msgstr "<span类=“Caption” >表B-9:圆括号 </span>"

#: src/appendix-03-derivable-traits.md:1
msgid "Appendix C - Derivable Traits"
msgstr "附录C - 可衍生轨迹"

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which"
" you can apply to a struct or enum definition. The `derive` attribute "
"generates code to implement a default trait on the type you’ve annotated "
"with the `derive` syntax."
msgstr ""
"在书中的各个地方,我们讨论了`衍生'属性,你可以将其应用于构造或元素定义,`衍生'属性产生代码,以便在你用`衍生'语法注释的那类词上执行默认特性。"

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the "
"traits in the standard library compatible with the `derive` attribute."
msgstr "在本附录中,我们提供一个全面参考,详细说明标准图书馆中与`衍生'属性相符的所有特征。"

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that "
"can be implemented on your types using `derive`. Other traits defined in the"
" standard library don’t have sensible default behavior, so it’s up to you to"
" implement them in a way that makes sense for what you’re trying to "
"accomplish."
msgstr ""
"此处列出的这些特征是核心图书馆定义的唯一一种特征,它们可以用“衍生”方式在你们类型上实施。 "
"标准图书馆中定义的其他特征没有合理的默认行为,因此,要由你们来实施它们,才能对你们试图实现的目标产生意义。"

#: src/appendix-03-derivable-traits.md:9
msgid "Drop and Destruct"
msgstr "下降和破坏"

#: src/appendix-03-derivable-traits.md:11
msgid ""
"When moving out of scope, variables need to be moved first. This is where "
"the `Drop` trait intervenes. You can find more details about its usage "
"[here](ch04-01-what-is-ownership.md#no-op-destruction-the-drop-trait)."
msgstr ""
"当移出范围时, 变量需要先移动。 这是“ 拖放” 特性介入的地方 。 您可以在此找到更多关于它使用情况的细节 。 (ch04-01- which - "
"is - 拥有. md# no- op- destroy- the drop- trait) 。"

#: src/appendix-03-derivable-traits.md:13
msgid ""
"Moreover, Dictionaries need to be squashed before going out of scope. "
"Calling the `squash` method on each of them manually can quickly become "
"redundant. `Destruct` trait allows Dictionaries to be automatically squashed"
" when they get out of scope. You can also find more information about "
"`Destruct` [here](ch04-01-what-is-ownership.md#destruction-with-a-side-"
"effect-the-destruct-trait)."
msgstr ""
"此外,在超出范围之前,词典需要被压碎。 将每个词典上“ quash” 的方法人工调用会很快变得多余。 “ 破坏” 特性允许词典在超出范围时自动被压碎。 "
"您还可以找到更多关于“ 破坏” (这里) (ch04-01-what- what- is- own. md# deview - with - "
"deside - effect- the- used-trait) 的信息 。"

#: src/appendix-03-derivable-traits.md:15
msgid "`Clone` and `Copy` for Duplicating Values"
msgstr "\" Clone \" 和 \" Copy \" 用于复制价值"

#: src/appendix-03-derivable-traits.md:17
msgid ""
"The `Clone` trait provides the functionality to explicitly create a deep "
"copy of a value."
msgstr "`Clone'特性提供了明确创建深重价值副本的功能。"

#: src/appendix-03-derivable-traits.md:19
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone "
"on each of the type's components. This means all the fields or values in the"
" type must also implement `Clone` to derive `Clone`."
msgstr "产生“单”的方法是“单”方法,而“单”方法又将克隆称为“单”方法,这意味着该类型的所有字段或数值也必须执行“单”以得出“单”。"

#: src/appendix-03-derivable-traits.md:21
msgid "Here is a simple example:"
msgstr "以下是一个简单的例子:"

#: src/appendix-03-derivable-traits.md:32
#: src/appendix-03-derivable-traits.md:50
msgid "\"Not equal\""
msgstr "\"不平等\""

#: src/appendix-03-derivable-traits.md:36
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy`"
" on any type whose parts all implement `Copy`."
msgstr "`复制'特性允许重复价值,任何部件都执行`复制'的种类,都可以获得`复制'特性。"

#: src/appendix-03-derivable-traits.md:49
msgid "// Copy Trait prevents first_struct from moving into second_struct\n"
msgstr "/ 复制 trat 防止第一个_ struct 移动到第二个_ struct\n"

#: src/appendix-03-derivable-traits.md:51
msgid "\"Not Equal\""
msgstr "\"不平等\""

#: src/appendix-03-derivable-traits.md:55
msgid "`Debug` for Printing and Debugging"
msgstr "打印和调试“调试”的“调试”"

#: src/appendix-03-derivable-traits.md:57
msgid ""
"The `Debug` trait enables debug formatting in format strings, which you "
"indicate by adding `:?` within `{}` placeholders."
msgstr "在“占位符”内添加“?”表示`调试'特性能够以格式字符串格式进行调试格式。"

#: src/appendix-03-derivable-traits.md:59
msgid ""
"It allows you to print instances of a type for debugging purposes, so you "
"and other programmers using this type can inspect an instance at a "
"particular point in a program’s execution."
msgstr "它允许您为调试目的打印一种类型的实例, 这样您和其他使用这种类型的程序员就可以在程序执行的特定点检查一个实例 。"

#: src/appendix-03-derivable-traits.md:61
msgid ""
"For example, if you want to print the value of a variable of type `Point`, "
"you can do it as follows:"
msgstr "例如,如果想要打印类型“点”的变量的值,可以按以下方式进行:"

#: src/appendix-03-derivable-traits.md:72
msgid "\"{:?}\""
msgstr "\"{:?}\" \"{:?}\""

#: src/appendix-03-derivable-traits.md:81
msgid ""
"The `Debug` trait is required, for example, when using the `assert_xx!` "
"macros in tests. Theses macros print the values of instances given as "
"arguments if the equality or comparison assertion fails so programmers can "
"see why the two instances weren’t equal."
msgstr ""
"例如,在测试中使用`Assert_xx!' "
"宏时,需要“调试”特性。如果平等或比较主张失败,程序员可以理解为什么这两个例子不相等,则这些宏打印了作为论据的事例的数值。"

#: src/appendix-03-derivable-traits.md:83
msgid "`Default` for Default Values"
msgstr "默认值“ Default” 的“ 默认值”"

#: src/appendix-03-derivable-traits.md:85
msgid ""
"The `Default` trait allows creation of a default value of a type. The most "
"common default value is zero. All primitive types in the standard library "
"implement `Default`."
msgstr "`默认'特性允许创建一种类型的默认值。最常见的默认值为零。标准库中的所有原始类型都执行`默认'。"

#: src/appendix-03-derivable-traits.md:87
msgid ""
"If you want to derive `Default` on a composite type, each of its elements "
"must already implement `Default`. If you have an [`enum`](ch06-01-enums.md) "
"type, you must declare its default value by using the `#[default]` attribute"
" on one of its variants."
msgstr ""
"如果您想要在复合类型上得出`违约', 其每个元素必须已经执行`违约' 。 如果您有[`enum' (ch06-01-enums.md) 类型, "
"您必须使用`[ 默认] 属性来声明其默认值 。"

#: src/appendix-03-derivable-traits.md:89
msgid "An example:"
msgstr "例如:"

#: src/appendix-03-derivable-traits.md:108
msgid "\"item1 mismatch\""
msgstr "“项目1不匹配”"

#: src/appendix-03-derivable-traits.md:109
msgid "\"item2 mismatch\""
msgstr "“项目2不匹配”"

#: src/appendix-03-derivable-traits.md:112
msgid "\"case mismatch\""
msgstr "\"情况不匹配\""

#: src/appendix-03-derivable-traits.md:116
msgid "`PartialEq` for Equality Comparisons"
msgstr "平等比较的`Part PartialEq'"

#: src/appendix-03-derivable-traits.md:118
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for "
"equality, thereby enabling the `==` and `!=` operators."
msgstr "`partialEq'特性使得可以比较一种平等的情况,从而使该类人和该类经营者能够进行比较。"

#: src/appendix-03-derivable-traits.md:120
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all "
"their fields are equal; they are not equal if any field is different. When "
"derived for enums, each variant is equal to itself and not equal to the "
"other variants."
msgstr ""
"当`partialEq'来源于建筑时,只有其所有领域都平等时,两例是平等的;如果任何领域不同,则两例是平等的;如果任何领域不同,则两例是平等的。当对树脂产生时,每种变式都与其本身相同,而不是与其他变式相同。"

#: src/appendix-03-derivable-traits.md:122
msgid ""
"You can write your own implementation of the `PartialEq` trait for your "
"type, if you can't derive it or if you want to implement your custom rules. "
"In the following example, we write an implementation for `PartialEq` in "
"which we consider that two rectangles are equal if they have the same area:"
msgstr ""
"您可以自己写出类型“PartialEq”特性的“PartialEq”特性,如果无法从中得出,或者如果你想执行自己的习惯规则,您可以自己写出。在下面的例子中,我们为“partialEq”"
" 编写一个“PartialEq” 执行文件,其中我们认为,如果两个矩形具有相同的区域,这两个矩形是相等的:"

#: src/appendix-03-derivable-traits.md:145
msgid "\"Are rect1 and rect2 equal? {}\""
msgstr "直肠1和直肠2相等吗?"

#: src/appendix-03-derivable-traits.md:149
msgid ""
"The `PartialEq` trait is required when using the `assert_eq!` macro in "
"tests, which needs to be able to compare two instances of a type for "
"equality."
msgstr "在测试中使用`Assert_eq!'宏时需要`partialEq'特性,这需要能够比较一种平等类型的两种情况。"

#: src/appendix-03-derivable-traits.md:162
msgid "\"Structs are different\""
msgstr "\"真相不同\""

#: src/appendix-03-derivable-traits.md:166
msgid "Serializing with `Serde`"
msgstr "与`Serde'序列"

#: src/appendix-03-derivable-traits.md:168
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` "
"functions for data structures defined in your crate. It allows you to "
"transform your structure into an array (or the opposite)."
msgstr "`Serde'为您箱内定义的数据结构提供`序列化'和`序列化'功能的特性执行,使您能够将您的结构转换成一个阵列(或相反的阵列)。"

#: src/appendix-03-derivable-traits.md:170
msgid ""
"**[Serialization](https://en.wikipedia.org/wiki/Serialization)** is a "
"process of transforming data structures into a format that can be easily "
"stored or transmitted. Let's say you are running a program and would like to"
" persist its state to be able to resume it later. To do this, you could take"
" each of the objects your program is using and save their information, for "
"example in a file. This is a simplified version of serialization. Now if you"
" want to resume your program with this saved state, you would perform "
"**deserialization**, which means loading the state of the objects from the "
"saved source."
msgstr ""
"** [序列化] (https://en.wikipedia.org/wiki/sirization)** "
"是一个将数据结构转换成易于存储或传输的格式的过程。让我们假设您正在运行一个程序,并希望坚持其状态以便稍后能够恢复它。 "
"为此,您可以将您程序正在使用的各个对象都带走并保存它们的信息, 例如在文件中。 这是一个简化的序列化版本。 如果您想要在此保存状态下恢复您的程序, "
"您将会执行 ** desericalization**, 这意味着从保存的来源装入对象的状态 。"

#: src/appendix-03-derivable-traits.md:172
msgid "For example:"
msgstr "例如:"

#: src/appendix-03-derivable-traits.md:190
msgid "If you run the `main` function, the output will be:"
msgstr "如果您运行“主要”函数,输出将是:"

#: src/appendix-03-derivable-traits.md:196
msgid ""
"We can see here that our struct `A` has been serialized into the output "
"array. Note that the `serialize` function takes as argument a snapshot of "
"the type you want to convert into an array. This is why deriving `Drop` for "
"`A` is required here, as the `main` function keeps ownership of the "
"`first_struct` struct."
msgstr ""
"我们在这里可以看到,我们的“A”结构已被序列化为输出矩阵。请注意,“序列化”函数将您想要转换成阵列的类型的快照作为参数。这就是为什么这里需要为`A'得出`Drop',因为`主要'功能保留了`第一支`struct'结构的所有权。"

#: src/appendix-03-derivable-traits.md:198
msgid ""
"Also, we can use the `deserialize` function to convert the serialized array "
"back into our `A` struct."
msgstr "此外,我们还可以利用`无战略化'功能,将序列式阵列转换回我们的`A'支架。"

#: src/appendix-03-derivable-traits.md:218
msgid ""
"Here we are converting a serialized array span back to the struct `A`. "
"`deserialize` returns an `Option` so we need to unwrap it. When using "
"`deserialize` we also need to specify the type we want to deserialize into."
msgstr ""
"在这里,我们正在将一个序列数组转换为“A”。`序列化'返回`选项',所以我们需要解开它。在使用`序列化'时,我们还需要具体说明我们想要淡化的型号。"

#: src/appendix-03-derivable-traits.md:220
msgid "Hashing with `Hash`"
msgstr "使用`Hash'混杂"

#: src/appendix-03-derivable-traits.md:222
msgid ""
"It is possible to derive the `Hash` trait on structs and enums. This allows "
"them to be hashed easily using any available hash function. For a struct or "
"an enum to derive the `Hash` attribute, all fields or variants need to be "
"hashable themselves."
msgstr ""
"可以在支架和支架上得出`Hash'特性,这样就可以很容易地使用任何可用的散列函数进行散列。要让支架或支架产生`Hash'属性,所有字段或变体本身都必须是可仓促的。"

#: src/appendix-03-derivable-traits.md:224
msgid ""
"You can refer to the [Hashes section](ch11-04-hash.md) to get more "
"information about how to hash complex data types."
msgstr "您可以查询 [Hashes 区域] (ch11-04-hash.md),以获得更多关于如何散列复杂数据类型的信息。"

#: src/appendix-03-derivable-traits.md:226
msgid "Starknet Storage with `starknet::Store`"
msgstr "Starknet 以“史塔克网:斯托雷”储存"

#: src/appendix-03-derivable-traits.md:228
msgid ""
"The `starknet::Store` trait is relevant only when building on "
"[Starknet](ch13-00-introduction-to-starknet-smart-contracts.md). It allows "
"for a type to be used in smart contract storage by automatically "
"implementing the necessary read and write functions."
msgstr ""
"`Starknet::Store'特性只有在建立[Starknet](ch13-00- intoto-starknet-smart-"
"contracts.md)的基础上才具有相关性。 它允许通过自动执行必要的读写功能,在智能合同储存中使用某种类型。"

#: src/appendix-03-derivable-traits.md:230
msgid ""
"You can find detailed information about the inner workings of Starknet "
"storage in the [Contract storage section](ch14-01-contract-storage.md)."
msgstr "您可以在[合同存储区](ch14-01-合同存储区.md)找到关于斯塔克内储存的内部工作的详细信息。"

#: src/appendix-04-cairo-prelude.md:1
msgid "Appendix D - The Cairo Prelude"
msgstr "附录D - 开罗序言"

#: src/appendix-04-cairo-prelude.md:3
msgid "Prelude"
msgstr "预 酸"

#: src/appendix-04-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data "
"types, and traits that are automatically brought into scope of every module "
"in a Cairo crate without needing explicit import statements. Cairo's prelude"
" provides the basic building blocks developers need to start Cairo programs "
"and writing smart contracts."
msgstr ""
"开罗前奏集集了通用模块、功能、数据类型和特性,这些模块自动纳入开罗箱中每个模块的范畴,而不需要明确的进口说明。 "
"开罗的前奏提供了基本构件开发者启动开罗程序并签订智能合同所需要的基本构件。"

#: src/appendix-04-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the "
"_[lib.cairo](https://github.com/starkware-"
"libs/cairo/blob/main/corelib/src/lib.cairo)_ file of the corelib crate and "
"contains Cairo's primitive data types, traits, operators, and utility "
"functions. This includes:"
msgstr ""
"核心图书馆前奏的定义见核心图书馆箱的档案_[lib.cairo] (https://github.com/starkware-"
"libs/cairo/blob/main/corelib/src/lib.cairo),其中载有开罗原始数据类型、特性、操作员和实用功能。"

#: src/appendix-04-cairo-prelude.md:15
msgid "Data types: integers, bools, arrays, dicts, etc."
msgstr "数据类型:整数、布尔、数组、编辑等。"

#: src/appendix-04-cairo-prelude.md:16
msgid ""
"Traits: behaviors for arithmetic, comparison, and serialization operations"
msgstr "轨迹:计算、比较和序列化操作的行为"

#: src/appendix-04-cairo-prelude.md:17
msgid "Operators: arithmetic, logical, bitwise"
msgstr "运算符:算术、逻辑、比特"

#: src/appendix-04-cairo-prelude.md:18
msgid "Utility functions - helpers for arrays, maps, boxing, etc."
msgstr "工具功能 - 阵列、地图、拳击等的助手。"

#: src/appendix-04-cairo-prelude.md:20
msgid ""
"The core library prelude delivers the fundamental programming constructs and"
" operations needed for basic Cairo programs, without requiring the explicit "
"import of elements. Since the core library prelude is automatically "
"imported, its contents are available for use in any Cairo crate without "
"explicit imports. This prevents repetition and provides a better devX. This "
"is what allows you to use `ArrayTrait::append()` or the `Default` trait "
"without bringing them explicitly into scope."
msgstr ""
"核心图书馆前端提供开罗基本程序所需的基本编程结构和操作,而无需明确输入元素。由于核心图书馆前端是自动进口的,因此其内容可在任何开罗箱中使用,无需明确输入。这防止了重复,提供了更好的devX。这就是您可以使用`ArrayTrait:附录()'或`Default'"
" 特性,而没有将其明确纳入范围。"

#: src/appendix-04-cairo-prelude.md:28
msgid ""
"You can choose which prelude to use. For example, adding `edition = "
"\"2023_11\"` in the _Scarb.toml_ configuration file will load the prelude "
"from November 2023. Note that when you create a new project using `scarb "
"new` command, the _Scarb.toml_ file will automatically include `edition = "
"\"2023_11\"`."
msgstr ""
"您可以选择要使用的前缀 。 例如, 在 _Scarb.toml_配置文件中添加“ edtion = “ 2023_ 11 ”, 从 2023 年 11 "
"月 2023 日起将装入前缀 。 请注意, 当您使用 ` screb new' 命令创建新工程时, _ Scarb.toml_ 文件将自动包含“ "
"edtion = “ 2023_ 11 ” 。"

#: src/appendix-04-cairo-prelude.md:30
msgid "The compiler currently exposes 2 different versions of the prelude:"
msgstr "汇编者目前揭露了前奏的两种不同版本:"

#: src/appendix-04-cairo-prelude.md:32
msgid ""
"A general version, with a lot of traits that are made available, "
"corresponding to `edition = \"2023_01\"`."
msgstr "通用版本,具有许多可用特性,相当于`编辑=`2023_01'`。"

#: src/appendix-04-cairo-prelude.md:33
msgid ""
"A restricted version, including the most essential traits needed for general"
" Cairo programming, corresponding to `edition = 2023_11`."
msgstr "限制性版本,包括开罗总体方案拟订所需的最基本特征,相当于 \" 编辑=2023_11 \" 。"

#: src/appendix-05-common-error-messages.md:1
msgid "Appendix E - Common Error Messages"
msgstr "附录E - 常见错误信息"

#: src/appendix-05-common-error-messages.md:3
msgid ""
"You might encounter error messages when writing Cairo code. Some of them "
"occur very frequently, which is why we will be listing the most common error"
" messages in this appendix to help you resolve common issues."
msgstr ""
"您在写入开罗代码时可能会遇到错误信息。 其中一些非常频繁发生, 这就是为什么我们将在本附录中列出最常见的错误信息, 以帮助您解决常见问题 。"

#: src/appendix-05-common-error-messages.md:5
msgid ""
"`Variable not dropped.`: this error message means that you are trying to "
"make a variable with a type that do not implement the `Drop` trait go out of"
" scope, withtout destroying it. Make sure that variables that need to be "
"dropped at the end of the execution of a function implement the `Drop` trait"
" or the `Destruct` trait. See [Ownership](ch04-01-what-is-"
"ownership.md#destroying-values---example-with-feltdict) section."
msgstr ""
"`可变不可丢弃 。 ` : 此错误信息意味着您正在试图制造一个变量, 其类型不执行 ` 拖放' 特性, 然后再将其销毁。 "
"确保在执行函数的结尾处需要丢弃的变量能够执行 `拖放' 特性 或` 破坏' 特性 。 见 [所有者] (ch04-01-what- is- 拥有. "
"md# destroying- values- example- with- feltdict) 部分。"

#: src/appendix-05-common-error-messages.md:7
msgid ""
"`Variable was previously moved.`: this error message means that you are "
"trying to use a variable whose ownership has already been transferred to "
"another function. When a variable doesn't implement the `Copy` trait, it is "
"passed by value to functions, and ownership of the variable is transferred "
"to the function. Such a variable cannot be used anymore in the current "
"context after its ownership has been transferred. It is often useful to use "
"the `clone` method in this situation."
msgstr ""
"`可变先前已移动 。 ` : 此错误信息意指您正在试图使用一个其所有权已经转移至另一个函数的变量。 当变量不执行“ 复制” "
"特性时,该变量被按价值传递到函数,该变量的所有权被转移到函数。 此变量在所有权转移后无法在当前背景下使用。 在这种情况下,使用“ 克隆” 方法通常有用。"

#: src/appendix-05-common-error-messages.md:9
msgid ""
"`error: Trait has no implementation in context: "
"core::fmt::Display::<package_name::struct_name>`: this error message is "
"encountered if you try to print an instance of a custom data type with `{}` "
"placeholders in a `print!` or `println!` macro. To mitigate this issue, you "
"need to either manually implement the `Display` trait for your type, or use "
"the `Debug` trait by applying `derive(Debug)` to your type, allowing to "
"print your instance by adding `:?` in `{}` placeholders."
msgstr ""
"`error: Trait 在上下文中没有执行: 核心 : fmt : Display: <package_ name: "
"struct_name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"

#: src/appendix-05-common-error-messages.md:11
msgid ""
"`Got an exception while executing a hint: Hint Error: Failed to deserialize "
"param #x.`: this error means that the execution failed because an entrypoint"
" was called without the expected arguments. Make sure that the arguments you"
" provide when calling an entrypoint are correct. There is a classic issue "
"with `u256` variables, which are actually structs of 2 `u128`. Therefore, "
"when calling a function that takes a `u256` as argument, you need to pass 2 "
"values."
msgstr ""
"`在执行提示时有例外 : 提示错误: 解除 palim #x. 失败 : 此错误意味着执行失败, 因为一个输入点被调用时没有预期参数。 "
"请确保您在调用一个输入点时提供的论点是正确的。 ` u256' 变量存在典型问题, 这些变量实际上是 2 ` u128'的支架。 因此, 当调用一个以`"
" u256' 作为参数的函数时, 您需要通过 2 个值 。"

#: src/appendix-05-common-error-messages.md:13
msgid ""
"`Item path::item is not visible in this context.`: this error message lets "
"us know that the path to bring an item into scope is correct, but there is a"
" vibility issue. In cairo, all items are private to parent modules by "
"default. To resolve this issue, make sure that all the modules on the path "
"to items and items themselves are declared with `pub(crate)` or `pub` to "
"have access to them."
msgstr ""
"`项目路径:在此背景下,项目不可见。':这个错误信息让我们知道,将项目带入范围的道路是正确的,但有一个可变问题。在cairo,所有项目默认都是母模块的私有项目。为了解决这个问题,确保项目和项目本身路径上的所有模块都以`pub(crate)'或`pub'进行申报,以便访问它们。"

#: src/appendix-05-common-error-messages.md:15
msgid ""
"`Identifier not found.`: this error message is a bit aspecific but might "
"indicate that:"
msgstr "`未找到身份识别符。':此错误信息有点具体,但可能表明:"

#: src/appendix-05-common-error-messages.md:16
msgid ""
"A variable is being used before it has been declared. Make sure to declare "
"variables with the `let` keyword."
msgstr "在宣布变量之前,正在使用变量。确保用“let”关键字声明变量。"

#: src/appendix-05-common-error-messages.md:17
msgid ""
"The path to bring an item into scope is wrongly defined. Make sure to use "
"valid paths."
msgstr "将项目引入范围的道路定义错误。 请确保使用有效的路径 。"

#: src/appendix-05-common-error-messages.md:19
msgid "Starknet Components Related Error Messages"
msgstr "Starknet 元件相关错误消息"

#: src/appendix-05-common-error-messages.md:21
msgid ""
"You might encounter some errors when trying to implement components. "
"Unfortunately, some of them lack meaningful error messages to help debug. "
"This section aims to provide you with some pointers to help you debug your "
"code."
msgstr ""
"尝试执行组件时可能会遇到一些错误。 不幸的是, 有些缺少有意义的错误信息来帮助调试 。 本节旨在为您提供一些指示符, 帮助您调试您的代码 。"

#: src/appendix-05-common-error-messages.md:25
msgid ""
"`Trait not found. Not a trait.`: this error can occur when you're not "
"importing the component's impl block correctly in your contract. Make sure "
"to respect the following syntax:"
msgstr "`未找到交易, 没有特性.': 未在合同中正确导入组件的分解块时, 可能会发生此错误 。 请务必尊重以下语法 :"

#: src/appendix-05-common-error-messages.md:33
msgid ""
"`Plugin diagnostic: name is not a substorage member in the contract's "
"Storage. Consider adding to Storage: (...)`: the compiler helps you a lot "
"debugging this by giving you recommendation on the action to take. "
"Basically, you forgot to add the component's storage to your contract's "
"storage. Make sure to add the path to the component's storage annotated with"
" the `#[substorage(v0)]` attribute to your contract's storage."
msgstr ""
"`插件诊断: 名称不是合同储存中的子存储成员。 考虑添加到存储中 : (......) `: 编译器通过向您推荐要采取的行动来帮助您调试它。 基本上, "
"您忘记将部件的存储添加到合同的存储中。 请确定将部件的存储路径添加到 {[ 子存储(v0)] 中, 附加“ 合同储存中的属性 ” 。"

#: src/appendix-05-common-error-messages.md:35
msgid ""
"`Plugin diagnostic: name is not a nested event in the contract's Event enum."
" Consider adding to the Event enum:` similar to the previous error, the "
"compiler tells you that you forgot to add the component's events to your "
"contract's events. Make sure to add the path to the component's events to "
"your contract's events."
msgstr ""
"`插件诊断 : 名称不是合同“ 事件” 中的嵌套事件 。 考虑在“ 事件” 中添加 : “ 类似于先前的错误, "
"编译者告诉您您忘记将部件的事件添加到合同的事件中 。 请确保将部件事件路径添加到合同“ 事件 ” 中 。"

#: src/appendix-06-useful-development-tools.md:1
msgid "Appendix F - Useful Development Tools"
msgstr "附录F - 有用的发展工具"

#: src/appendix-06-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo"
" project provides. We’ll look at automatic formatting, quick ways to apply "
"warning fixes, a linter, and integrating with IDEs."
msgstr "在本附录中,我们谈论了开罗项目提供的一些有用的发展工具。 我们将研究自动格式化、快速应用警告修补、隔热和与IDES整合的方法。"

#: src/appendix-06-useful-development-tools.md:7
msgid "Automatic Formatting with `scarb fmt`"
msgstr "“scarb fmt” 自动格式化"

#: src/appendix-06-useful-development-tools.md:9
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command. If you're "
"using the Cairo binaries directly, you can run `cairo-format` instead. Many "
"collaborative projects use `scarb fmt` to prevent arguments about which "
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""
"疤痕项目可以使用“ scarb fmt” 命令格式化。 如果您直接使用开罗二进制文件, 您可以运行“ cairo-format ” 。 "
"许多合作项目使用“ scarb Fmt ” 来防止在撰写开罗文件时使用哪种样式的争论: 每个人都使用工具格式化代码 。"

#: src/appendix-06-useful-development-tools.md:14
msgid ""
"To format any Cairo project, enter the following inside the project "
"directory:"
msgstr "要格式化开罗工程,请在项目目录内输入以下内容:"

#: src/appendix-06-useful-development-tools.md:20
msgid "IDE Integration Using `cairo-language-server`"
msgstr "IDE 利用“开罗语言服务器”实现一体化"

#: src/appendix-06-useful-development-tools.md:22
msgid ""
"To help IDE integration, the Cairo community recommends using the [`cairo-language-server`](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-language-server)<!-- ignore -->. This tool is a set of compiler-centric utilities that speaks the [Language Server Protocol](http://langserver.org/)<!--\n"
"ignore -->, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use `cairo-language-server`, such as [the Cairo extension for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)."
msgstr ""
"为了帮助IDE的一体化,开罗社区建议使用[`cairo-langue-server'] (https://github.com/starkware-"
"libs/cairo/tree/main/crates/cairo-lang-lanng-lange-server) <! -- 忽略 > "
"。这个工具是一套能够使用[Language "
"Server协议](http://langserver.org/)的编译者中心公用设施(http://langserver.org/) <!- 忽略 "
"-- >,这是IDEs和编程语言相互交流的规格。不同的客户可以使用“cairo-lango-server”,例如[视觉工作室代码开罗扩展] "
"(https://markedplace.visualstudiostudio.com/items?itemsNames=starkware.cairo1]。"

#: src/appendix-06-useful-development-tools.md:32
msgid ""
"Visit the `vscode-cairo` "
"[page](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)<!--"
" ignore --> to install it on VSCode. You will get abilities such as "
"autocompletion, jump to definition, and inline errors."
msgstr ""
"访问“ vscode-cairo” [page] (https://markedplace. "
"visualstudio.com/items?itemName=starkware.cairo1) <!- 忽略 -- -- 将其安装在 VSCode "
"上。 您将获得自动补全、 跳转到定义和内嵌错误等能力 。"

#: src/appendix-06-useful-development-tools.md:38
msgid ""
"Note: If you have Scarb installed, it should work out of the box with the "
"Cairo VSCode extension, without a manual installation of the language "
"server."
msgstr "注:如果您安装了刀疤,应使用开罗VSCode扩展名在盒子外工作,无需人工安装语言服务器。"

#: src/appendix-07-cairo-binaries.md:1
msgid "Appendix G - Installing the Cairo Binaries"
msgstr "附录G -- -- 建立《开罗财年》"

#: src/appendix-07-cairo-binaries.md:3
msgid ""
"If you want to have access to the Cairo binaries, for anything that you "
"could not achieve by purely using Scarb you can install them by following "
"the instructions below."
msgstr "如果您想要进入开罗二进制书,对于任何纯粹使用刀疤无法达到的目标,都可以按照以下指示安装。"

#: src/appendix-07-cairo-binaries.md:5
msgid "Prerequisites"
msgstr "先决条件"

#: src/appendix-07-cairo-binaries.md:7
msgid ""
"You will need to have [Rust](https://www.rust-lang.org) and "
"[Git](https://git-scm.com/) installed."
msgstr ""
"(https://www.rust-lang.org)和[Git] (https://git-"
"scm.com/)需要安装[鲁斯特](https://www.rust-lang.org)和[Git]。"

#: src/appendix-07-cairo-binaries.md:9
msgid ""
"To install Rust, you first need the [`rustup`](https://www.rust-"
"lang.org/tools/install) tool. It allows you to install Rust using the "
"following command:"
msgstr ""
"要安装 Rust, 您首先需要使用 [`rustup'] (https://www.rust- lang. org/tools/安装) 工具。 "
"它允许您使用以下命令安装 Rust :"

#: src/appendix-07-cairo-binaries.md:11
msgid "# Install stable Rust\n"
msgstr "{\\fn方正粗倩简体\\fs12\\an8\\1cHFFFF00\\b0}安放稳定的鲁斯特\n"

#: src/appendix-07-cairo-binaries.md:15
msgid ""
"Follow the link for information on how to install [Git](https://git-"
"scm.com/downloads)."
msgstr "如何安装[ Git] 信息的链接( https:// git- scm.com/ downloads) 。"

#: src/appendix-07-cairo-binaries.md:17
msgid ""
"The next step is to install Cairo. We will download Cairo manually, using "
"Cairo repository or with an installation script. You’ll need an internet "
"connection for the download."
msgstr "下一步是安装开罗。 我们将使用开罗存储库或安装脚本手动下载开罗。 您需要互联网连接才能下载。"

#: src/appendix-07-cairo-binaries.md:19
msgid ""
"Installing Cairo with a Script "
"([Installer](https://github.com/franalgaba/cairo-installer) by "
"[Fran](https://github.com/franalgaba))"
msgstr ""
"由[法 (https://github.com/franalgaba/cairo-"
"安裝者)以脚本安装开罗(https://github.com/franalgaba)"

#: src/appendix-07-cairo-binaries.md:21
msgid "Install"
msgstr "安装安装"

#: src/appendix-07-cairo-binaries.md:23
msgid ""
"If you wish to install a specific release of Cairo rather than the latest "
"head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export "
"CAIRO_GIT_TAG=v2.5.1`)."
msgstr ""
"如果您希望安装一个具体版本的开罗,而不是最新的首页,请设置“CAIRO_GIT_TAG”环境变量(例如,`出口CAIRO_GIT_TAG=v2.5.1')。"

#: src/appendix-07-cairo-binaries.md:29
msgid ""
"After installing, follow [these instructions](#set-up-your-shell-"
"environment-for-cairo) to set up your shell environment."
msgstr "在安装后,按照[这些指示](#设置你的壳壳环境为开罗)来设置你的壳环境。"

#: src/appendix-07-cairo-binaries.md:31
msgid "Update"
msgstr "更新更新更新"

#: src/appendix-07-cairo-binaries.md:33
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | bash\n"
"```"
msgstr "https://github.com/franalgaba/cairo-安贝/raw/main/bin/cairo-安贝 bash"

#: src/appendix-07-cairo-binaries.md:38
msgid "Uninstall"
msgstr "解除安装"

#: src/appendix-07-cairo-binaries.md:40
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, "
"just remove it:"
msgstr "开罗安装在`$CAIRO_ROOT'内(默认值:~/.cairo)。"

#: src/appendix-07-cairo-binaries.md:46
msgid "then remove these three lines from .bashrc:"
msgstr "然后从.bashrc 中删除这三条线 :"

#: src/appendix-07-cairo-binaries.md:49
msgid "\"$HOME/.cairo/target/release:$PATH\""
msgstr "\"$HOME/.cairo/目标/释放:$PATH\""

#: src/appendix-07-cairo-binaries.md:52
msgid "and finally, restart your shell:"
msgstr "最后,重新开始你的贝壳:"

#: src/appendix-07-cairo-binaries.md:58
msgid "Set Up your Shell Environment for Cairo"
msgstr "为开罗设置你的壳壳环境"

#: src/appendix-07-cairo-binaries.md:60
msgid ""
"Define environment variable `CAIRO_ROOT` to point to the path where Cairo "
"will store its data. `$HOME/.cairo` is the default. If you installed Cairo "
"via Git checkout, we recommend to set it to the same location as where you "
"cloned it."
msgstr ""
"定义环境变量“ CAIRO_ROOT” 以指向开罗存储其数据的路径。 $HOME/. cairo 默认为“ $HOME/. cairo ” 。 "
"如果您通过 Git 检出安装开罗, 我们建议将其设置在与您克隆它的位置相同的位置 。"

#: src/appendix-07-cairo-binaries.md:64
msgid "Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr "添加“cairo-  ” 可执行文件到您的“ PATH ” 中, 如果它不是已经存在的话 。"

#: src/appendix-07-cairo-binaries.md:66
msgid ""
"The below setup should work for the vast majority of users for common use "
"cases."
msgstr "以下设置应适用于绝大多数用户的通用案例。"

#: src/appendix-07-cairo-binaries.md:68
msgid "For **bash**:"
msgstr "**bash**:"

#: src/appendix-07-cairo-binaries.md:70
msgid ""
"Stock Bash startup files vary widely between distributions in which of them "
"source which, under what circumstances, in what order and what additional "
"configuration they perform. As such, the most reliable way to get Cairo in "
"all environments is to append Cairo configuration commands to both `.bashrc`"
" (for interactive shells) and the profile file that Bash would use (for "
"login shells)."
msgstr ""
"库存 Bash 启动文件在来源的分布上差异很大,在什么情况下、在什么情况下、在什么顺序上和在什么情况下,在什么额外配置下,它们的工作方式不同。 "
"因此,在所有环境中获得开罗的最可靠方式是将开罗配置命令附加到“.bashrc” (用于交互式贝壳)和Bash将使用的配置文件(用于登录贝壳)上。"

#: src/appendix-07-cairo-binaries.md:76
msgid ""
"First, add the commands to `~/.bashrc` by running the following in your "
"terminal:"
msgstr "首先,通过在终端中运行以下操作,将命令添加到 {{{/.bashrc> 中:"

#: src/appendix-07-cairo-binaries.md:79 src/appendix-07-cairo-binaries.md:89
#: src/appendix-07-cairo-binaries.md:95 src/appendix-07-cairo-binaries.md:102
msgid "'export CAIRO_ROOT=\"$HOME/.cairo\"'"
msgstr "\"出口CAIRO_ROOT=\" $HOME/. cairo\""

#: src/appendix-07-cairo-binaries.md:80 src/appendix-07-cairo-binaries.md:90
#: src/appendix-07-cairo-binaries.md:96 src/appendix-07-cairo-binaries.md:103
msgid ""
"'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"'"
msgstr "“指挥 -v cairo-complile >/dev/null = 出口 PATH=$CAIRO_ROOT/目标/释放:$PATH”"

#: src/appendix-07-cairo-binaries.md:83
msgid ""
"Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add "
"the commands there as well. If you have none of these, add them to "
"`~/.profile`."
msgstr ""
"然后,如果你有/.profile,/bash_profile,/bash_profile, 或/bash_login, 也在那里添加命令。 "
"如果您没有这些命令, 请在/profile中添加这些命令 。"

#: src/appendix-07-cairo-binaries.md:86
msgid "to add to `~/.profile`:"
msgstr "添加到 /. profile :"

#: src/appendix-07-cairo-binaries.md:93
msgid "to add to `~/.bash_profile`:"
msgstr "添加到%/.bash_ profile :"

#: src/appendix-07-cairo-binaries.md:99
msgid "For **Zsh**:"
msgstr "@sh**:"

#: src/appendix-07-cairo-binaries.md:106
msgid ""
"If you wish to get Cairo in non-interactive login shells as well, also add "
"the commands to `~/.zprofile` or `~/.zlogin`."
msgstr "如果您也想在非互动登录贝壳中获取开罗, 请在 {{/ zprofile} 或/ zlogin 中添加命令 。"

#: src/appendix-07-cairo-binaries.md:108
msgid "For **Fish shell**:"
msgstr "对于 ** Fish shell** :"

#: src/appendix-07-cairo-binaries.md:110
msgid "If you have Fish 3.2.0 or newer, execute this interactively:"
msgstr "如果您有鱼3.2.0或新鱼,请交互执行:"

#: src/appendix-07-cairo-binaries.md:117
msgid "Otherwise, execute the snippet below:"
msgstr "否则,执行下面的片段:"

#: src/appendix-07-cairo-binaries.md:124
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which "
"provides alternative shell completions for many command line tools with an "
"IDE-like popup interface in the terminal window. (Note that their "
"completions are independent of Cairo's codebase so they might be slightly "
"out of sync for bleeding-edge interface changes.)"
msgstr ""
"在 MacOS 中, 您可能还要安装 [ fig] (https:// fig. io/), 提供许多命令行工具的替代弹壳补全, 在终端窗口中安装类似 "
"IDE 的弹出界面 。 (注意它们的补全独立于开罗的代码库, 这样它们可能略为不同步, 以适应出血的界面变化 。 )"

#: src/appendix-07-cairo-binaries.md:130
msgid "Restart your Shell"
msgstr "重新开始你的壳牌"

#: src/appendix-07-cairo-binaries.md:132
msgid "for the `PATH` changes to take effect."
msgstr "使`PATH'变化生效。"

#: src/appendix-07-cairo-binaries.md:135
msgid "\"$SHELL\""
msgstr "\"美元地狱\""

#: src/appendix-07-cairo-binaries.md:138
msgid ""
"Installing Cairo Manually ([Guide](https://github.com/auditless/cairo-"
"template) by [Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""
"由[Abdel](https://github.com/abdelhamidbakhta)介绍([指南](https://github.com/abdelhamidbakhta)),手动安装开罗([指南](https://github.com/audelhamidbakhta))(https://github.com/auditless/cairo-"
"template)"

#: src/appendix-07-cairo-binaries.md:140
msgid "Step 1: Install Cairo 1.0"
msgstr "第1步:安装开罗1.0"

#: src/appendix-07-cairo-binaries.md:142
msgid ""
"If you are using an x86 Linux system and can use the release binary, "
"download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""
"如果您正在使用x86 Linux系统,并且可以使用释放二进制,请在此下载开罗:<https://github.com/starkware-"
"libs/cairo/releases>。"

#: src/appendix-07-cairo-binaries.md:144
msgid ""
"For everyone else, we recommend compiling Cairo from source as follows:"
msgstr "对于其他人,我们建议从以下来源将开罗汇编如下:"

#: src/appendix-07-cairo-binaries.md:147
msgid "# Start by defining environment variable CAIRO_ROOT\n"
msgstr "# 从定义环境变量 CAIRO_ROOT 开始\n"

#: src/appendix-07-cairo-binaries.md:148
msgid "\"${HOME}/.cairo\""
msgstr "\"${HOME}/. cairo\" (${HOME}/.cairo)"

#: src/appendix-07-cairo-binaries.md:149
msgid "# Create .cairo folder if it doesn't exist yet\n"
msgstr "创建.cairo文件夹,如果它还没有存在的话\n"

#: src/appendix-07-cairo-binaries.md:152
msgid "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
msgstr "# 以 $CAIRO_ROOT (默认根) 克隆开罗汇编器\n"

#: src/appendix-07-cairo-binaries.md:155
msgid ""
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the compiler\n"
"# Fetch all tags (versions)\n"
msgstr "# OPOPAL/RECOMMEND: 如果您想要安装一个编译器的具体版本 # 获取所有标签( 版本) #\n"

#: src/appendix-07-cairo-binaries.md:158
msgid "# View tags (you can also do this in the Cairo compiler repository)\n"
msgstr "# 查看标签( 您也可以在开罗编译器库中这样做 )\n"

#: src/appendix-07-cairo-binaries.md:160
msgid "# Checkout the version you want\n"
msgstr "# 查看您想要的版本\n"

#: src/appendix-07-cairo-binaries.md:163
msgid "# Generate release binaries\n"
msgstr "生成释放的二进制\n"

#: src/appendix-07-cairo-binaries.md:168
msgid "."
msgstr ".."

#: src/appendix-07-cairo-binaries.md:170
msgid "**NOTE: Keeping Cairo up to date**"
msgstr "** 注:不断更新开罗**"

#: src/appendix-07-cairo-binaries.md:172
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to"
" do is pull the latest changes and rebuild as follows:"
msgstr "您的开罗编译器已经在一个克隆的仓库中, 您需要做的就是拉动最新的修改, 并重建如下 :"

#: src/appendix-07-cairo-binaries.md:179
msgid "Step 2: Add Cairo 1.0 Executables to Your Path"
msgstr "步骤2:在您的路径中添加开罗 1.0 执行文件"

#: src/appendix-07-cairo-binaries.md:182
msgid "\"$CAIRO_ROOT/target/release:$PATH\""
msgstr "“CAIRO_ROOT/目标/释放:$PATH”"

#: src/appendix-07-cairo-binaries.md:185
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path "
"accordingly.**"
msgstr "**注:如果从Linux二进制安装,则相应调整目的地路径。 **"

#: src/appendix-07-cairo-binaries.md:187
msgid "Step 3: Setup Language Server"
msgstr "第3步:建立语言服务器"

#: src/appendix-07-cairo-binaries.md:189
msgid "VS Code Extension"
msgstr "VS 代码扩展"

#: src/appendix-07-cairo-binaries.md:191
msgid ""
"If you have the previous Cairo 0 extension installed, you can "
"disable/uninstall it."
msgstr "如果您安装了上一个开罗 0 扩展名, 您可以禁用/ 卸载它 。"

#: src/appendix-07-cairo-binaries.md:192
msgid ""
"Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation. You can find the link to the extension "
"[here](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false),"
" or just search for \"Cairo 1.0\" in the VS Code marketplace."
msgstr ""
"安装开罗 1 扩展名, 用于正确的语法加亮和代码导航 。 您可以找到此扩展名的链接 。 (https:// smarkedplace. "
"visualstudio.com/ items? itemName=starkware. cairo1&sr=false), 或者在 VS "
"代码市场搜索“ Cairo 1.0 ” 。"

#: src/appendix-07-cairo-binaries.md:193
msgid ""
"The extension will work out of the box once you will have "
"[Scarb](./ch01-03-hello-scarb.md) installed."
msgstr "一旦安装了[Scarb](./ch01-03-hello-scarb.md),扩展件将会从盒子中工作。"

#: src/appendix-07-cairo-binaries.md:195
msgid "Cairo Language Server without Scarb"
msgstr "没有疤痕的开罗语言服务器b"

#: src/appendix-07-cairo-binaries.md:197
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language "
"Server with the compiler binary. From [Step 1](#installing-cairo-with-a-"
"script-installer-by-fran), the `cairo-language-server` binary should be "
"built and executing this command will copy its path into your clipboard."
msgstr ""
"如果您不想依赖刀疤, 您仍然可以用编译器二进制使用开罗语言服务器 。 从 [ step 1] (# 安装- cairo- 手稿- 安装- 安装- by-"
" fran), 应该建立“ cairo- 语言服务器” 二进制, 执行此命令时将把路径复制到您的剪贴板 。"

#: src/appendix-07-cairo-binaries.md:204
msgid ""
"Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting"
" the path."
msgstr "通过粘贴路径,更新开罗1.0扩展版的`cairo1. 语文服务Path'。"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"All through the previous sections, you've mostly written programs with a "
"`main` entrypoint. In the coming sections, you will learn to write and "
"deploy Starknet contracts."
msgstr "在前几节中,您大多用“主要”切入点撰写程序。在下几节中,您将学习写作和部署斯塔克内特合同。"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"One of the key applications of the Cairo language is writing smart contracts"
" for the Starknet network. Starknet is a permissionless decentralized "
"network that leverages zk-STARKs technology for scalability. As a Layer 2 "
"(L2) scalability solution for Ethereum, Starknet aims to provide fast, "
"secure, and low-cost transactions. It operates as a validity rollup, "
"commonly known as a zero-knowledge rollup, and is built on top of the Cairo "
"VM."
msgstr ""
"开罗语言的关键应用之一是为史塔克内特网络签订智能合同。史塔克内特是一个使用兹克-"
"STARKs技术进行可缩放的无权限分散的网络。作为Etheum的2层(L2)缩放解决方案,史塔克内特旨在提供快速、安全和低成本的交易。它作为一个有效性的滚动(通常称为零知识卷动"
" ), 并建在开罗VM 之上。"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Starknet contracts are programs specifically designed to run within the "
"Starknet OS. The Starknet OS is a Cairo program itself, which means that any"
" operation executed by the Starknet OS can be proven and succinctly "
"verified. Smart contracts can access Starknet's persistent state through the"
" OS, enabling them to read or modify variables in Starknet’s state, "
"communicate with other contracts, and interact seamlessly with the "
"underlying Layer 1 (L1) network."
msgstr ""
"斯塔克内特合同是专门设计在斯塔克内特操作系统内部运行的程序。 "
"斯塔克内特操作系统是开罗程序本身,这意味着史塔克内特操作系统实施的任何操作都可以得到证明和简明的核实。 "
"智能合同可以通过操作系统进入史塔克内特的持久性状态,使他们能够读取或修改斯塔克内特状态中的变量,与其他合同进行沟通,并与基础图层1(L1)网络进行无缝互动。"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"If you want to learn more about the Starknet network itself, its "
"architecture and the tooling available, you should read the [Starknet "
"Book](https://book.starknet.io/). In this book, we will only focus on "
"writing smart contracts in Cairo."
msgstr ""
"如果您想更多地了解斯塔克内特网络本身、其架构和可用的工具,您应该阅读[星网书](https://book.starknet.io/)。在这本书中,我们只关注在开罗撰写智能合同。"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Scarb"
msgstr "刀疤"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Scarb facilitates smart contract development for Starknet. To enable this "
"feature, you'll need to make some configurations in your _Scarb.toml_ file "
"(see [Installation](./ch01-01-installation.md) for how to install Scarb)."
msgstr ""
"Scarb 有助于为 Starknet 开发智能合同。 要启用此功能, 您需要在您的 _Scarb.toml_ 文件中做出一些配置( 如何安装 "
"scrab, 请参见 [Installation] (./ ch01-01- adplacementation. md) 。"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"First, add the `starknet` dependency to your _Scarb.toml_ file. Next, enable"
" the Starknet contract compilation of the package by adding a "
"`[[target.starknet-contract]]` section. By default, specifying this target "
"will build a Sierra Contract Class file, which can be deployed on Starknet. "
"If you omit to specify the target, your package will compile but will not "
"produce an output that you can use with Starknet."
msgstr ""
"首先,在您的 _Scarb.toml_文件中添加“starknet”依赖性。接下来,通过添加“[目标.starknet-contract]]”部分,启用"
" Starknet 合同包汇编。默认情况下,指定此目标将构建一个可以部署在 Starknet 上的Sierra "
"合同类文件。如果您忽略指定目标,您的软件包将编集,但不会产生 Starknet 可以使用的输出。"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Below is the minimal _Scarb.toml_ file required to compile a crate "
"containing Starknet contracts:"
msgstr "以下是为编制含有Starknet合同的箱子所需的最起码的_Scarb.toml_文件:"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.6.3\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"toml [包装] 名称 = \"package_name\" 版本 = \"0.1.0\" [依附] tarknet = \"2.6.3\" "
"[[目标.starknet-合 ]"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"To compile contracts defined in your package's dependencies, please refer to"
" the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-"
"target.html#compiling-external-contracts)."
msgstr ""
"为了汇编贵国包件的依附关系所界定的合同,请参看[Scarb文件](https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-"
"target.html#comping-extern-contracts)。"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Starknet Foundry"
msgstr "Starknet 铸造公司"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Starknet Foundry is a tool chain for Starknet smart contract development. It"
" supports many features, including writing and running tests with advanced "
"features, deploying contracts, interacting with the Starknet network, and "
"more."
msgstr ""
"Starknet Foundry是史塔克内特智能合同开发的工具链。 它支持许多功能,包括写作和进行先进功能测试、部署合同、与史塔克内特网络互动等等。"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"We'll describe Starknet Foundry in more detail in [Chapter "
"17](./ch17-02-testing-smart-contracts.md#testing-smart-contracts-with-"
"starknet-foundry) when discussing Starknet smart contract testing and "
"security."
msgstr ""
"我们在讨论斯塔克内特智能合同测试和安全问题时,将在[第17章](./ch17-02-测试智能合同.md#测试智能合同-"
"与斯塔克内特公司)中更详细地描述斯塔克内特铸造厂。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart contracts"
" are, what they are used for, and why blockchain developers would use Cairo "
"and Starknet. If you are already familiar with blockchain programming, feel "
"free to skip this chapter. The last part might still be interesting though."
msgstr ""
"本章将给你们一个高层次的介绍,介绍什么是智能合同,什么是智能合同,它们用于什么,为什么连锁开发商会使用开罗和史塔克内特。 "
"如果你已经熟悉连锁程序,你可以跳过这一章。最后部分可能仍然很有趣。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:6
msgid "Smart Contracts"
msgstr "智能合同"

#: src/ch13-01-general-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth "
"of Ethereum. Smart contracts are essentially programs deployed on a "
"blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that "
"are executed based on specific inputs. They primarily consist of two "
"components: storage and functions. Once deployed, users can interact with "
"smart contracts by initiating blockchain transactions containing execution "
"data (which function to call and with what input). Smart contracts can "
"modify and read the storage of the underlying blockchain. A smart contract "
"has its own address and is considered a blockchain account, meaning it can "
"hold tokens."
msgstr ""
"智能合同越来越受欢迎,随着Etheum的诞生而变得更加普及。智能合同基本上是在一块铁链上部署的程序。 "
"“智能合同”一词有些误导性,因为它们既不是“智能合同”也不是“合同”而是根据具体投入执行的代码和指令。它们主要由两个组成部分组成:存储和功能。一旦部署,用户可以通过包含执行数据的链交易(该功能可以调用和投入)与智能合同互动。智能合同可以修改和读取基本铁链的存储。智能合同有其自己的地址,并且被视为一个铁链账户,这意味着它可以持有标识。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on "
"the blockchain. For example, on Ethereum and the [EVM-compatible "
"ecosystem](https://ethereum.org/en/developers/docs/evm/), the most commonly "
"used language is Solidity, while on Starknet, it is Cairo. The way the code "
"is compiled also differs based on the blockchain. On Ethereum, Solidity is "
"compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then "
"into Cairo Assembly (CASM)."
msgstr ""
"用于撰写智能合同的编程语言因链条而异。例如,在Etherem和[EVM-"
"兼容生态系统](https://etherum.org/en/developmenters/docs/evm/)上,最常用的语言是Solidity,而在Starknet上,则是Casknet,是开罗。代码的编纂方式也因链条而异。在Ethereum上,Solidiity被编成字码。在Starknet上,开罗被编成Sierra,然后被编成开罗大会(CASM)。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are "
"**permissionless**, meaning anyone can deploy a smart contract on the "
"network (within the context of a decentralized blockchain, of course). Smart"
" contracts are also **transparent**; the data stored by the smart contract "
"is accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write "
"smart contracts that use other smart contracts. Smart contracts can only "
"access and interact with data from the blockchain they are deployed on. They"
" require third-party software (called _oracles_) to access external data "
"(the price of a token for instance)."
msgstr ""
"智能合同具有几个独特的特点。 它们具有** 不可允许**, 意思是任何人都可以在网络上部署智能合同(当然是指在分散的链条范围内)。 智能合同也是** "
"透明** ; 智能合同所储存的数据可供任何人查阅。 构成合同的代码也可以是透明的, 使得** 兼容性** 。 "
"这使得开发商能够撰写使用其他智能合同的智能合同。 智能合同只能访问和与所部署的链条的数据互动, 需要第三方软件( 称为 oracless_ ) "
"才能访问外部数据( 例如象征性价格 ) 。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, "
"it is required to know what the other contracts look like. Hence, Ethereum "
"developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to "
"build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs (Non-"
"Fungible Tokens) like `CryptoPunks` or `Everai`."
msgstr ""
"开发商要建立能够相互互动的智能合同,就必须了解其他合同的长相,因此,Etheroum开发商开始为智能合同的开发制定标准,即`ERCxx "
"',最常用和最著名的两个标准是`ERC20 ',用于制造“USCC”、“DAI”或`STARK'等标牌,以及“ERC721”,用于NFTs(非可爆 "
"Tokens),如`CryptoPunks'或`Everai'。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:18
msgid "Use Cases"
msgstr "使用案例"

#: src/ch13-01-general-introduction-to-smart-contracts.md:20
msgid ""
"There are many possible use cases for smart contracts. The only limits are "
"the technical constraints of the blockchain and the creativity of "
"developers."
msgstr "智能合同有许多可能的使用案例,唯一的限制是链条的技术限制和开发商的创造力。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:22
msgid "DeFi"
msgstr "DeFi  DeFi 开发"

#: src/ch13-01-general-introduction-to-smart-contracts.md:24
msgid ""
"For now, the principal use case for smart contracts is similar to that of "
"Ethereum or Bitcoin, which is essentially handling money. In the context of "
"the alternative payment system promised by Bitcoin, smart contracts on "
"Ethereum enable the creation of decentralized financial applications that no"
" longer rely on traditional financial intermediaries. This is what we call "
"DeFi (decentralized finance). DeFi consists of various projects such as "
"lending/borrowing applications, decentralized exchanges (DEX), on-chain "
"derivatives, stablecoins, decentralized hedge funds, insurance, and many "
"more."
msgstr ""
"目前,智能合同的主要用途与Etheum或Bitcoin相似,后者主要处理资金问题,在Bitcoin承诺的替代支付制度下,Eceenum的智能合同使分散的金融应用程序得以创建,不再依赖传统的金融中介机构。"
" 这就是我们所谓的DEFi(分散化金融 ) 。  DeFi(分散化金融 ), 包括各种项目,如贷款/借款应用程序、分散化交易所(DEX ) 、 "
"链上衍生物、 稳定库、 分散化对冲基金、 保险等等。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:26
msgid "Tokenization"
msgstr "当当当化"

#: src/ch13-01-general-introduction-to-smart-contracts.md:28
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such "
"as real estate, art, or precious metals. Tokenization divides an asset into "
"digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and "
"simplify the buying and selling process."
msgstr ""
"智能合同可以促进房地产、艺术品或贵金属等真实世界资产象征性化。 化石化将资产分成数字标牌,在铁链平台上交易和管理容易。 "
"这可以增加流动性,实现分数所有权,并简化买卖过程。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:30
msgid "Voting"
msgstr ""
"表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 "
"表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决 表决表决 表决表决表决表决 表决 "
"表决表决表决表决表决 表决表决表决表决表决 "
"表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决表决"

#: src/ch13-01-general-introduction-to-smart-contracts.md:32
msgid ""
"Smart contracts can be used to create secure and transparent voting systems."
" Votes can be recorded on the blockchain, ensuring immutability and "
"transparency. The smart contract can then automatically tally the votes and "
"declare the results, minimizing the potential for fraud or manipulation."
msgstr ""
"智能合同可以用来创建安全和透明的投票系统。 选票可以记录在块链上,确保不可改变性和透明度。 "
"智能合同可以自动计票并宣布结果,最大限度地降低欺诈或操纵的可能性。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:34
msgid "Royalties"
msgstr "版费"

#: src/ch13-01-general-introduction-to-smart-contracts.md:36
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and "
"other content creators. When a piece of content is consumed or sold, the "
"smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for "
"intermediaries."
msgstr ""
"智能合同可以自动为艺术家、音乐家和其他内容创作者支付使用费。 "
"当某部分内容被消费或出售时,智能合同可以自动计算并向合法所有者分配使用费,确保公平补偿并减少对中介的需求。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:38
msgid "Decentralized Identities DIDs"
msgstr "D. 分散的公有实体"

#: src/ch13-01-general-introduction-to-smart-contracts.md:40
msgid ""
"Smart contracts can be used to create and manage digital identities, "
"allowing individuals to control their personal information and share it with"
" third parties securely. The smart contract could verify the authenticity of"
" a user's identity and automatically grant or revoke access to specific "
"services based on the user's credentials."
msgstr ""
"智能合同可用于创建和管理数字身份,使个人能够控制个人信息并安全地与第三方共享信息,智能合同可以核实用户身份的真实性,并根据用户的资质自动给予或取消获取特定服务的机会。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:46
msgid "The Rise of Starknet and Cairo"
msgstr "斯塔克内特和开罗的崛起"

#: src/ch13-01-general-introduction-to-smart-contracts.md:48
msgid ""
"Ethereum, being the most widely used and resilient smart contract platform, "
"became a victim of its own success. With the rapid adoption of some "
"previously mentioned use cases, mainly DeFi, the cost of performing "
"transactions became extremely high, rendering the network almost unusable. "
"Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue."
msgstr ""
"Etheum是使用最广泛和最具弹性的智能合同平台,成为其自身成功的受害者。 "
"随着上述一些使用案例(主要是DeFi)的迅速采纳,进行交易的成本变得极高,使得网络几乎无法使用。 "
"生态系统的工程师和研究人员开始研究解决这一可扩缩性问题的办法。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:50
msgid ""
"A famous trilemma called The Blockchain Trilemma in the blockchain space "
"states that it is hard to achieve a high level of scalability, "
"decentralization, and security simultaneously; trade-offs must be made. "
"Ethereum is at the intersection of decentralization and security. "
"Eventually, it was decided that Ethereum's purpose would be to serve as a "
"secure settlement layer, while complex computations would be offloaded to "
"other networks built on top of Ethereum. These are called Layer 2s (L2s)."
msgstr ""
"块链空间中名为“三环链”的著名三环称“三环链”称,很难同时实现高度的可扩展性、权力下放和安全;必须作出权衡。Etheum位于权力下放和安全的交汇处。最后,决定Etherem的目的将是充当一个安全的定居层,而复杂的计算将被卸载到Ethereum上方的其他网络上。这些被称为“第二层"
" ” ( L2 ) 。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:52
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. "
"Both approaches involve compressing and batching numerous transactions "
"together, computing the new state, and settling the result on Ethereum (L1)."
" The difference lies in the way the result is settled on L1. For optimistic "
"rollups, the new state is considered valid by default, but there is a 7-day "
"window for nodes to identify malicious transactions."
msgstr ""
"两种主要的L2类型是乐观的卷式和有效性卷式。 这两种方法都涉及压缩和分批大量交易,计算新状态,并解决Etheum(L1)的结果。 "
"区别在于结果在L1上的解决方式。 对于乐观卷式来说,新状态在默认情况下是有效的,但节点有一个7天的窗口来识别恶意交易。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:54
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove "
"that the new state has been correctly computed. This is the purpose of "
"STARKs, this cryptographic technology could permit validity rollups to scale"
" significantly more than optimistic rollups. You can learn more about STARKs"
" from Starkware's Medium [article](https://medium.com/starkware/starks-"
"starkex-and-starknet-9a426680745a), which serves as a good primer."
msgstr ""
"相比之下,诸如斯塔克内特(Starknet)等有效性卷号则使用加密法来证明新状态的计算正确。 这是STARKs的目的, "
"这种加密技术可以让有效性卷号的规模大大超过乐观卷号。 "
"您可以从Starkware的中型[文章](https://medic.com/starkware/starks-starkex-and-"
"starknet-9a4260745a)中(https://medic.com/starkware/starkware/starks-starknet-"
"starkex-and-starknet-9a4260745a)了解更多关于STARKs的信息。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:56
msgid ""
"Starknet's architecture is thoroughly described in the [Starknet "
"Book](https://book.starknet.io/ch03-00-architecture.html), which is a great "
"resource to learn more about the Starknet network."
msgstr ""
"Starknet的建筑在[Starknet "
"book](https://book.starknet.io/ch03-00-architecture.html)中作了全面描述,这是进一步了解Starknet网络的伟大资源。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:58
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work "
"with STARKs and make them general-purpose. With Cairo, we can write "
"**provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another."
msgstr ""
"记得开罗吗?事实上,它是专门为与STARKs合作而开发的一种语言,并使它们成为通用语言。在开罗,我们可以写出**可验证的代码**。在史塔克内特,这可以证明从一个州到另一个州的计算是否正确。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:60
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM"
" (either as-is or adapted) as a base layer, Starknet employs its own VM. "
"This frees developers from the constraints of the EVM, opening up a broader "
"range of possibilities. Coupled with decreased transaction costs, the "
"combination of Starknet and Cairo creates an exciting playground for "
"developers. Native account abstraction enables more complex logic for "
"accounts, that we call \"Smart Accounts\", and transaction flows. Emerging "
"use cases include **transparent AI** and machine learning applications. "
"Finally, **blockchain games** can be developed entirely **on-chain**. "
"Starknet has been specifically designed to maximize the capabilities of "
"STARK proofs for optimal scalability."
msgstr ""
"Starknet的多数(如果不是全部的话)竞争对手选择使用EVM作为基础层, Starknet则雇用自己的VM。 Starknet "
"将开发商从EVM的限制中解脱出来,开辟了更广泛的可能性。 与交易成本的降低、 Starknet 和开罗的结合为开发者创造了一个令人兴奋的游乐场。 "
"本地账户的抽取为账户提供了更复杂的逻辑, 我们称之为“ 智能账户 ”, 以及交易流。 新兴的使用案例包括** 透明AI** 和机器学习应用程序。 最后,"
" ** 链式游戏** 可以完全开发** 连锁** 。 Starknet 专门设计的目的是最大限度地提高STARK 验证的最佳可扩展性。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:62
msgid ""
"Learn more about Account Abstraction in the [Starknet "
"Book](https://book.starknet.io/ch04-00-account-abstraction.html)."
msgstr ""
"在[Starknet book] (https://book.starknet.io/ch04-00-ccount-"
"abstraction.html)中了解更多关于账户摘要的更多信息。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:68
msgid "Cairo Programs and Starknet Contracts: What Is the Difference?"
msgstr "开罗方案和斯塔克内特合同:有什么区别?"

#: src/ch13-01-general-introduction-to-smart-contracts.md:70
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts"
" previously learned in this book are still applicable to write Starknet "
"contracts. As you may have already noticed, a Cairo program must always have"
" a `main` function that serves as the entry point for this program:"
msgstr ""
"Starknet 合同是开罗方案的特殊超级集,因此本书中以前学到的概念仍然适用于写 Starknet 合同。 "
"正如你可能已经注意到的,开罗方案必须始终有一个“主要”功能,作为这个方案的切入点:"

#: src/ch13-01-general-introduction-to-smart-contracts.md:77
msgid ""
"Contracts deployed on the Starknet network are essentially programs that are"
" run by the sequencer, and as such, have access to Starknet's state. "
"Contracts do not have a `main` function but one or multiple functions that "
"can serve as entry points."
msgstr ""
"在斯塔克内特网络上部署的合同基本上是由测序器操作的程序,因此可以进入斯塔克内特的状态,合同没有`主要'功能,而是可以作为切入点的一种或多种功能。"

#: src/ch13-01-general-introduction-to-smart-contracts.md:79
msgid ""
"Starknet contracts are defined within [modules](./ch07-02-defining-modules-"
"to-control-scope.md). For a module to be handled as a contract by the "
"compiler, it must be annotated with the `#[starknet::contract]` attribute."
msgstr ""
"Starknet 合同在[模块](./ch07-02-定义模块-模块到控制范围.md)中界定。对于由汇编者作为合同处理的模块,必须附加“[星网:合同:合"
" ”属性的附加说明。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts using a "
"very simple smart contract as example. You will learn how to write a "
"contract that allows anyone to store a single number on the Starknet "
"blockchain."
msgstr ""
"本章将向您介绍斯塔克内特合同的基本内容, 使用非常简单的智能合同作为例子。 您将学习如何写入合同, 允许任何人在斯塔克内特区链上存储一个数字 。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:5
msgid ""
"Let's consider the following contract for the whole chapter. It might not be"
" easy to understand it all at once, but we will go through it step by step:"
msgstr "我们来考虑一下整个章节的以下合同。也许不易一一理解,但我们将一步一步地通过:"

#: src/ch13-02-anatomy-of-a-simple-contract.md:34
msgid "<span class=\"caption\">Listing 13-1: A simple storage contract</span>"
msgstr "<span类=“caption” > listing 13-1: 简单的储存合同 </span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:36
msgid "What Is this Contract?"
msgstr "这是什么合同?"

#: src/ch13-02-anatomy-of-a-simple-contract.md:38
msgid ""
"Contracts are defined by encapsulating state and logic within a module "
"annotated with the `#[starknet::contract]` attribute."
msgstr "合同的定义是,将状态和逻辑包含在一个配有`[星网:合 属性的单元中。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:40
msgid ""
"The state is defined within the `Storage` struct, and is always initialized "
"empty. Here, our struct contains a single a field called `stored_data` of "
"type `u128` (unsigned integer of 128 bits), indicating that our contract can"
" store any number between 0 and \\\\( {2^{128}} - 1 \\\\)."
msgstr ""
"状态定义在“ 标准” 结构内, 并且总是初始化为空 。 在这里, 我们的结构包含一个名为 u128 类型“ 储存数据” 的字段( 未签名的整数为 128"
" 位), 表明我们的合同可以在 0 到\\\\\\ ( {2\\\\\\\\ 128\\\\ - 1\\\\) 之间存储任何数字 。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:42
msgid ""
"The logic is defined by functions that interact with the state. Here, our "
"contract defines and publicly exposes the functions `set` and `get` that can"
" be used to modify or retrieve the value of the stored variable. You can "
"think of it as a single slot in a database that you can query and modify by "
"calling functions of the code that manages the database."
msgstr ""
"逻辑由与国家互动的函数来定义。 在这里, 我们的合同定义并公开披露“ 设置” 和“ 获取” 功能, 用于修改或检索存储变量的价值。 "
"您可以把它视为数据库中的一个单行位, 您可以调用管理数据库的代码的函数来查询和修改 。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:45
msgid "The Interface: the Contract's Blueprint"
msgstr "接口:合同的蓝图"

#: src/ch13-02-anatomy-of-a-simple-contract.md:55
msgid "<span class=\"caption\">Listing 13-2: A basic contract interface</span>"
msgstr "<span类=“caption” >Listing 13-2:基本合同界面 </span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:58
msgid ""
"Interfaces represent the blueprint of the contract. They define the "
"functions that the contract exposes to the outside world. In Cairo, they're "
"defined by annotating a trait with the `#[starknet::interface]` attribute. "
"All functions of the trait are considered public functions of any contract "
"that implements this trait, and are callable from the outside world."
msgstr ""
"界面代表合同的蓝图。 它们定义了合同对外部世界所暴露的功能。 在开罗, 它们的定义是用“ 星网: 界面” 属性来说明特性。 "
"特性的所有功能都被视为任何执行该特性的合同的公共功能, 并且可以被外部世界所呼唤 。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:60
msgid ""
"All contract interfaces use a generic type for the `self` parameter, "
"representing the contract state. We chose to name this generic parameter "
"`TContractState` in our interface, but this is not enforced and any name can"
" be chosen."
msgstr "所有合同界面都使用通用类型,用于“自我”参数,代表合同状态。我们选择在界面中命名该通用参数“缔约方”,但这不是强制的,可以选择任何名称。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:62
msgid ""
"In our interface, note the generic type `TContractState` of the `self` "
"argument which is passed by reference to the `set` function. Seeing the "
"`self` argument passed in a contract function tells us that this function "
"can access the state of the contract. The `ref` modifier implies that `self`"
" may be modified, meaning that the storage variables of the contract may be "
"modified inside the `set` function."
msgstr ""
"在我们的界面中,请注意“自我”论点的通用类型`合同国',该论点通过提及`赛特'功能而通过。看到合同函数中通过的`自我'论点告诉我们,这一功能可以进入合同状态。`检索`修改者意味着`自我'可以修改,这意味着合同的储存变量可以在`赛特'功能中修改。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:64
msgid ""
"On the other hand, the `get` function takes a snapshot of `TContractState`, "
"which immediately tells us that it does not modify the state (and indeed, "
"the compiler will complain if we try to modify storage inside the `get` "
"function)."
msgstr "另一方面,`获取'功能对`缔约国'进行截图,立即告诉我们,它不会改变状态(事实上,汇编者会抱怨,如果我们试图修改`获取'功能内的储存)。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:66
msgid ""
"By leveraging the [traits & impls](./ch08-02-traits-in-cairo.md) mechanism "
"from Cairo, we can make sure that the actual implementation of the contract "
"matches its interface. In fact, you will get a compilation error if your "
"contract doesn’t conform with the declared interface. For example, Listing "
"13-3 shows a wrong implementation of the `ISimpleStorage` interface, "
"containing a slightly different `set` function that doesn't have the same "
"signature."
msgstr ""
"通过利用开罗的[traits & Impls] (./ch08-02-traits- in-cairo.md) "
"机制,我们可以确保合同的实际执行与其界面相符。 事实上, 如果您的合同与所申报的界面不相符, 您将会收到一个编译错误。 例如, 列出 13-3 显示“ "
"简单标准” 界面的错误执行, 包含略微不同的“ 设置” 功能, 且该功能没有相同的签名 。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:78
msgid ""
"<span class=\"caption\">Listing 13-3: A wrong implementation of the "
"interface of the contract. This does not compile, as the signature of `set` "
"doesn't match the trait's.</span>"
msgstr ""
"<span类=“caption” > listing 13-3: 合同接口执行错误。 由于` set' 的签名与特性不符, 此签名无法编译 。 "
"</span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:80
msgid ""
"Trying to compile a contract using this implementation will result in the "
"following error:"
msgstr "试图使用此项执行来汇编合同将导致以下错误:"

#: src/ch13-02-anatomy-of-a-simple-contract.md:100
msgid "Public Functions Defined in an Implementation Block"
msgstr "执行区块中定义的公共功能"

#: src/ch13-02-anatomy-of-a-simple-contract.md:102
msgid "Before we explore things further down, let's define some terminology."
msgstr "在我们进一步探索之前, 让我们来定义一些术语。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:104
msgid ""
"In the context of Starknet, a _public function_ is a function that is "
"exposed to the outside world. A public function can be called by anyone, "
"either from outside the contract or from within the contract itself. In the "
"example above, `set` and `get` are public functions."
msgstr ""
"在史塔克内特背景下,`公共职能'是一种与外部世界接触的功能,任何人,无论是从合同之外还是从合同本身之内,都可以要求公共职能,在上文的例子中,`set'和`get'是公共职能。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:106
msgid ""
"What we call an _external_ function is a public function that can be "
"directly invoked through a Starknet transaction and that can mutate the "
"state of the contract. `set` is an external function."
msgstr "我们称之为`外部'功能的是一种公共功能,可以通过斯塔克内交易直接援引,并能够改变合同状态。 \" 赛特 \" 是一种外部功能。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:108
msgid ""
"A _view_ function is a public function that is typically read-only and "
"cannot mutate the state of the contract. However, this limitation is only "
"enforced by the compiler, and not by Starknet itself. We will discuss the "
"implications of this in a later section. `get` is a view function."
msgstr ""
"_view_ "
"函数是一种公共功能,通常只读,不能改变合同状态。然而,这一限制只由编译者执行,而不是由Starknet本身执行。我们将在后面的一节中讨论这一点的影响。`get'是一个视图函数。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:123
msgid ""
"<span class=\"caption\">Listing 13-4: `SimpleStorage` implementation</span>"
msgstr "<span类=“caption” > listing 13-4:`简单'执行 </span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:125
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in "
"order to match the interface, the public functions of the contract must be "
"defined in an implementation of this trait — which allows us to make sure "
"that the implementation of the contract matches its interface."
msgstr ""
"由于合同接口被界定为`简单'特性,为了与接口相匹配,合同的公共职能必须在执行这一特性时加以界定——这使我们能够确保合同的执行与其接口相匹配。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:127
msgid ""
"However, simply defining the functions in the implementation block is not "
"enough. The implementation block must be annotated with the "
"`#[abi(embed_v0)]` attribute. This attribute exposes the functions defined "
"in this implementation to the outside world — forget to add it and your "
"functions will not be callable from the outside. All functions defined in a "
"block marked as `#[abi(embed_v0)]` are consequently _public functions_."
msgstr ""
"然而,仅仅界定执行区块中的功能是不够的。 执行区块必须附加“ {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}} "
"属性。此属性使执行区块中界定的功能暴露给外部世界—— 忘记添加它, 您的功能不会从外部调用。 "
"在标为{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}的所有功能因此都是_ 公共功能。}"

#: src/ch13-02-anatomy-of-a-simple-contract.md:129
msgid ""
"Because the `SimpleStorage` contract is defined as a module, we need to "
"access the interface defined in the parent module. We can either bring it to"
" the current scope with the `use` keyword, or refer to it directly using "
"`super`."
msgstr "由于`简单'合同被定义为模块,我们需要访问母模块中定义的界面,我们可以用`使用'关键字将其带入当前范围,或者直接使用`超级'将其提及。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:131
msgid ""
"When writing the implementation of an interface, the `self` parameter in the"
" trait methods **must** be of type `ContractState`. The `ContractState` type"
" is generated by the compiler, and gives access to the storage variables "
"defined in the `Storage` struct. Additionally, `ContractState` gives us the "
"ability to emit events. The name `ContractState` is not surprising, as it’s "
"a representation of the contract’s state, which is what we think of `self` "
"in the contract interface trait. When `self` is a snapshot of "
"`ContractState`, only read access is allowed, and emitting events is not "
"possible."
msgstr ""
"在撰写接口实施时,特性方法中的`自我'参数** "
"必须是`缔约国'类型。`缔约国'类型由汇编者产生,并允许查阅`压力'结构中定义的储存变量。此外,`缔约国'使我们有能力发布事件。`缔约国'的名称并不奇怪,因为它代表了合同状态,而这正是我们在合同界面特征中认为`自我'的形式。当`自我'是`缔约国'的缩影时,只允许阅读访问,而排放事件是不可能的。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:135
msgid "Accessing and Modifying the Contract's State"
msgstr "A. 进入和修改合同国"

#: src/ch13-02-anatomy-of-a-simple-contract.md:137
msgid ""
"Two methods are commonly used to access or modify the state of a contract:"
msgstr "获取或修改合同状况通常使用两种方法:"

#: src/ch13-02-anatomy-of-a-simple-contract.md:138
msgid ""
"`read`, which returns the value of a storage variable. This method is called"
" on the variable itself and does not take any argument."
msgstr "`read', 返回存储变量的价值, 此方法由变量本身调用, 不考虑任何参数 。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:144
msgid ""
"`write`, which allows to write a new value in a storage slot. This method is"
" also called on the variable itself and takes one argument, which is the "
"value to be written. Note that `write` may take more than one argument, "
"depending on the type of the storage variable. For example, writing on a "
"mapping requires 2 arguments: the key and the value to be written."
msgstr ""
"` "
"write',它允许在存储槽中写入新值,这种方法也要求变量本身,并采用一个参数,即要写入的值。请注意,根据存储变量的类型,“write”可能需要一个以上的参数。例如,在绘图上写入需要两个参数:键和要写入的值。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:150
msgid ""
"Reminder: if the contract state is passed as a snapshot with `@` instead of "
"passed by reference with `ref`, attempting to modify the contract state will"
" result in a compilation error."
msgstr "提醒:如果合同状态作为快照以通过,而不是以`ref'通过,试图修改合同状态将导致编译错误。"

#: src/ch13-02-anatomy-of-a-simple-contract.md:152
msgid ""
"This contract does not do much apart from allowing anyone to store a single "
"number that is accessible by anyone in the world. Anyone could call `set` "
"again with a different value and overwrite the current number. Nevertheless,"
" each value stored in the storage of the contract will still be stored in "
"the history of the blockchain. Later in this book, you will see how you can "
"impose access restrictions so that only you can alter the number."
msgstr ""
"除了允许任何人存储世界上任何人都可以进入的单一号码之外,这一合同没有多大作用,任何人都可以以不同的价值再次调用`设置'并覆盖当前号码,然而,合同储存中的每个价值将仍然保存在块链的历史中。在这本书的后面,你会看到如何实施访问限制,以便只有您才能改变号码。"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"In the previous section, we gave an introductory example of a smart contract"
" written in Cairo, describing the basic blocks to build smart contracts on "
"Starknet. In this section, we'll be taking a deeper look at all the "
"components of a smart contract, step by step."
msgstr ""
"在前一节,我们给出了一个在开罗写成的智能合同的介绍性例子,描述了在史塔克内特建立智能合同的基本基石。在本节,我们将更深入地审视智能合同的所有组成部分,一步一步地。"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"When we discussed [_interfaces_](./ch13-02-anatomy-of-a-simple-"
"contract.md#the-interface-the-contracts-blueprint), we specified the "
"difference between the two types of _public functions_, i.e., _external "
"functions_ and _view functions_, and we mentioned how to interact with the "
"_storage_ of a contract."
msgstr ""
"当我们讨论[_interfaces_] (./ch13-02-anatomy- a-simple Contract. md# the-"
"interface-the-contract-blueprint)时,我们具体说明了两种类型的公共功能之间的区别,即_外部功能_和_view "
"函数_,我们提到如何与合同的_storage_ 互动。"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "At this point, you should have multiple questions that come to mind:"
msgstr "此时此刻,你应该想到许多问题:"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How can I store more complex data types?"
msgstr "我怎样才能储存更复杂的数据类型?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How do I define internal/private functions?"
msgstr "如何界定内部/私人职能?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How can I emit events? How can I index them?"
msgstr "我怎样才能发布事件?我怎样能为它们索引?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "Is there a way to reduce the boilerplate?"
msgstr "有没有办法减少锅炉板?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"Luckily, we'll be answering all these questions in this chapter. Let's "
"consider the `NameRegistry` contract in Listing 14-1 that we'll be using "
"throughout this chapter:"
msgstr "幸运的是,我们将在本章中回答所有这些问题。让我们考虑在14-1清单中“注册”合同,我们将在整个本章中使用:"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:62 src/ch14-01-contract-storage.md:184
#: src/ch14-01-contract-storage.md:297 src/ch14-01-contract-storage.md:403
#: src/ch14-01-contract-storage.md:509 src/ch14-01-contract-storage.md:615
#: src/ch14-01-contract-storage.md:727 src/ch14-01-contract-storage.md:833
#: src/ch14-02-contract-functions.md:38
msgid "// Public functions inside an impl block\n"
msgstr "/ 内分块内的公共职能\n"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:79 src/ch14-01-contract-storage.md:201
#: src/ch14-01-contract-storage.md:314 src/ch14-01-contract-storage.md:420
#: src/ch14-01-contract-storage.md:526 src/ch14-01-contract-storage.md:632
#: src/ch14-01-contract-storage.md:744 src/ch14-01-contract-storage.md:850
#: src/ch14-02-contract-functions.md:97
msgid "// Standalone public function\n"
msgstr "/独立公共职能\n"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:85 src/ch14-01-contract-storage.md:207
#: src/ch14-01-contract-storage.md:320 src/ch14-01-contract-storage.md:426
#: src/ch14-01-contract-storage.md:532 src/ch14-01-contract-storage.md:638
#: src/ch14-01-contract-storage.md:750 src/ch14-01-contract-storage.md:856
#: src/ch14-02-contract-functions.md:112
msgid "// Could be a group of functions about a same topic\n"
msgstr "/ 可以是有关同一专题的一组职能\n"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:102 src/ch14-01-contract-storage.md:224
#: src/ch14-01-contract-storage.md:337 src/ch14-01-contract-storage.md:443
#: src/ch14-01-contract-storage.md:549 src/ch14-01-contract-storage.md:655
#: src/ch14-01-contract-storage.md:767 src/ch14-01-contract-storage.md:873
#: src/ch14-02-contract-functions.md:129
msgid "// Free function\n"
msgstr "// 自由功能\n"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"<span class=\"caption\">Listing 14-1: Our reference contract for this "
"chapter</span>"
msgstr "<span类=“caption” > listing 14-1:我们关于本章的参考合同 </span>"

#: src/ch14-01-contract-storage.md:3
msgid ""
"The most common way for interacting with a contract’s storage is through "
"storage variables. As stated previously, storage variables allow you to "
"store data that will be stored in the contract's storage that is itself "
"stored on the blockchain. These data are persistent and can be accessed and "
"potentially modified anytime once the contract is deployed."
msgstr ""
"与合同储存进行互动的最常见方式是通过存储变量。 如前所述,存储变量允许您存储存储在合同储存中的数据,而该储存本身就存储在链条上。 "
"这些数据具有持久性,一旦合同部署,随时都可以访问和修改。"

#: src/ch14-01-contract-storage.md:5
msgid ""
"Storage variables in Starknet contracts are stored in a special struct "
"called `Storage`:"
msgstr "Starknet合同中的储存变数储存在一个称为`储存'的特殊支架中:"

#: src/ch14-01-contract-storage.md:111
msgid ""
"The `Storage` struct is a [struct](./ch05-00-using-structs-to-structure-"
"related-data.md) like any other, except that it **must** be annotated with "
"the `#[storage]` attribute. This annotation tells the compiler to generate "
"the required code to interact with the blockchain state, and allows you to "
"read and write data from and to storage. Moreover, this allows you to define"
" storage mappings using the dedicated `LegacyMap` type."
msgstr ""
"`压力'结构是一个[支架](./ch05-00-using-structs-to-"
"结构相关数据.md),与其他任何系统一样,但****必须附加“[储存]”属性的注解。该注解告诉汇编者生成与链条状态互动所需的代码,并允许您读写数据,从和从和存储数据。此外,这允许您使用专用的“egacyMap”类型定义存储图示。"

#: src/ch14-01-contract-storage.md:113
msgid ""
"Variables declared in the `Storage` struct are not stored contiguously but "
"in different locations in the contract's storage. The storage address of a "
"particular variable is determined by the variable's name, and the eventual "
"keys of the variable if it is a mapping."
msgstr ""
"`Storage` struct' "
"中申报的变量不以毗连方式储存,而是在合同储存的不同地点储存。特定变量的存储地址由变量的名称决定,如果是绘图,则由变量的最终密钥确定。"

#: src/ch14-01-contract-storage.md:117
msgid "Addresses of Storage Variables"
msgstr "存储变量地址"

#: src/ch14-01-contract-storage.md:119
msgid "The address of a storage variable is computed as follows:"
msgstr "存储变量的地址计算如下:"

#: src/ch14-01-contract-storage.md:121
msgid ""
"If the variable is a single value, the address is the `sn_keccak` hash of "
"the ASCII encoding of the variable's name. `sn_keccak` is Starknet's version"
" of the Keccak256 hash function, whose output is truncated to 250 bits."
msgstr ""
"如果变量是一个单一值,地址是变量名称的 ASCII 编码中的“sn_keccak' hash”。 “sn_keccak” 是 Keccak256 "
"hash 函数的 Starknet 版本, 其输出被缩短为 250 比特。"

#: src/ch14-01-contract-storage.md:123
msgid ""
"If the variable is composed of multiple values (i.e., a tuple, a struct or "
"an enum), we also use the `sn_keccak` hash of the ASCII encoding of the "
"variable's name to determine the base address in storage. Then, depending on"
" the type, the storage layout will differ. See the [\"Storing Custom "
"Types\"](./ch14-01-contract-storage.md#storing-custom-types) section."
msgstr ""
"如果变量由多个值组成(如图普尔、支架或昆虫),我们也会使用变量名称的 ASCII 编码中的“sn_keccak' hash” "
"来决定存储中的基地址。然后,根据类型,存储布局会有所不同。请参见 [“Storing 自定义类型”] (./ch14-01-contract-"
"soldage.md#storning-custom-types) 部分。"

#: src/ch14-01-contract-storage.md:125
msgid ""
"If the variable is a [mapping](./ch14-01-contract-storage.html#storage-"
"mappings) with a key `k`, the address of the value at key `k` is "
"`h(sn_keccak(variable_name),k)`, where ℎ is the Pedersen hash and the final "
"value is taken modulo \\\\( {2^{251}} - 256\\\\). If the key is composed of "
"more than one `felt252`, the address of the value will be "
"`h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)`, with `k_1,...,k_n` "
"being all `felt252` that constitute the key. In the case of mappings to "
"complex values (e.g., tuples or structs), then this complex value lies in a "
"continuous segment starting from the address calculated with the previous "
"formula. Note that 256 field elements is the current limitation on the "
"maximal size of a complex storage value."
msgstr ""
"如果变量是 [mapping] (./ch14-01- Contract-storage-storage.html#storage-mappings),"
" 带有密钥`k' 的地址是`h(sn_keccak (可变_name), k), h 是Pedersen hash, 最后的值被取用 "
"modulo\\\\\\ ({2251}- 256\\\\) 。 如果密钥由多个“felt252” 组成, 数值的地址将是'h(h) (h) "
"(sn_keccak(可变数_name), k_1, k_2)..., k_n) 的地址是`k_k_ 1,..., k_n' "
"的地址是所有构成密钥的“felt252 ” 的数值的地址。在绘制复杂值(例如 tuples或structs) 的情况下, "
"复杂的数值将包含从先前公式计算的地址开始的连续一段。 。 注意, 25656 字段元素是目前对复杂存储价值的最大尺寸的限制。"

#: src/ch14-01-contract-storage.md:127
msgid ""
"You can access the address of a storage variable by calling the `address` "
"function on the variable, which returns a `StorageBaseAddress` value."
msgstr "您可以通过在变量上调用“地址”函数访问存储变量的地址,该函数返回“StorageBaseAddress”值。"

#: src/ch14-01-contract-storage.md:236
msgid "Interacting with Storage Variables"
msgstr "与存储变量交互"

#: src/ch14-01-contract-storage.md:238
msgid ""
"Variables stored in the `Storage` struct can be accessed and modified using "
"the `read` and `write` functions, respectively. As previously mentioned, you"
" can get their address in storage using the `address` function. All these "
"functions are automatically generated by the compiler for each storage "
"variable."
msgstr ""
"储存在`Storage'支架中的变量可以分别使用`read'和`write'函数访问和修改,如前所述,您可以使用`地址'函数在存储中获取其地址,所有这些功能都是由每个存储变量的汇编者自动生成的。"

#: src/ch14-01-contract-storage.md:240
msgid ""
"To read the value of the `owner` storage variable, which is a single value, "
"we call the `read` function on the `owner` variable, passing in no "
"parameters."
msgstr "阅读`所有者'储存变量的值,这是一个单一值,我们称之为`所有者'变量上的`阅读'功能,不通过参数。"

#: src/ch14-01-contract-storage.md:346
msgid ""
"To read the value of the storage variable `names`, which is a mapping from "
"`ContractAddress` to `felt252`, we call the `read` function on the `names` "
"variable, passing in the key `address` as a parameter. If the mapping had "
"more than one key, we would pass in the other keys as parameters as well."
msgstr ""
"读取存储变量`名称'的值,即从`合同地址'到`felt252'的映射,我们称之为`名称'变量上的`读'函数,在键`地址'中以参数通过。如果映射有一个以上的键,我们也会通过其他键作为参数。"

#: src/ch14-01-contract-storage.md:452
msgid ""
"To write a new value to the storage slot of a storage variable, we call the "
"`write` function passing in the eventual keys and the value as arguments. As"
" with the `read` function, the number of arguments depends on the storage "
"variable type. Here, we only pass in the value to write to the `owner` "
"variable as it is a simple variable."
msgstr ""
"要给存储变量的存储位置写一个新的值, 我们将“ write” 函数称为“  write” 函数通过最终的密钥和作为参数的值。 至于“ read” 函数,"
" 参数的数量取决于存储变量的类型。 在这里, 我们只需将值通过写入“ 拥有者” 变量, 因为它是一个简单的变量 。"

#: src/ch14-01-contract-storage.md:558
msgid ""
"In this second example, we need to pass `user` and `name` as arguments, "
"because `names` is a mapping, with `user` as key and `name` as value."
msgstr "在第二个例子中,我们需要将`用户'和`名称'作为论据,因为`名称'是一种绘图,`用户'作为关键,`名称'作为价值。"

#: src/ch14-01-contract-storage.md:664
msgid "Storing Custom Types"
msgstr "存储自定义类型"

#: src/ch14-01-contract-storage.md:666
msgid ""
"The `Store` trait, defined in the `starknet::storage_access` module, is used"
" to specify how a type should be stored in storage. In order for a type to "
"be stored in storage, it **must** implement the `Store` trait. Most types "
"from the core library, such as unsigned integers (`u8`, `u128`, `u256`...), "
"`felt252`, `bool`, `ByteArray`, `ContractAddress`, etc. implement the "
"`Store` trait and can thus be stored without further action."
msgstr ""
"`恒星网:储存_存取'模块中定义的`轮胎'特性,用于具体说明一种类型应如何储存在储存中,为了将某种类型储存在储存中,它****必须**执行`轮胎'特性,核心图书馆的大多数类型,如未符号的整数(`u8'、`u128'、`u256')、`felt252'、`bool'、`ByteAray'、`合同通讯'等,实施`轮胎'特性,从而可以储存而不采取进一步行动。"

#: src/ch14-01-contract-storage.md:668
msgid ""
"But what if you wanted to store a type that you defined yourself, such as an"
" enum or a struct? In that case, you have to explicitly tell the compiler "
"how to store this type."
msgstr "但如果你想存储一种你定义自己的类型,比如 enum 或 struct 。 那么, 您必须明确告诉编译者如何存储这种类型 。"

#: src/ch14-01-contract-storage.md:670
msgid ""
"In our example, we want to store a `Person` struct in storage, which is only"
" possible by implementing the `Store` trait for the `Person` type. This can "
"be simply achieved by adding a `#[derive(starknet::Store)]` attribute on top"
" of our struct definition. Note that all the members of the struct need to "
"implement the `Store` trait."
msgstr ""
"例如,我们想在储存中储存`人'结构,只有执行`人'类型`轮胎'特性才有可能,而仅仅通过在我们结构定义之上添加`[疗效网:斯塔雷 "
"属性即可做到这一点,请注意,该结构的所有成员都需要执行`轮胎'特性。"

#: src/ch14-01-contract-storage.md:776
msgid ""
"Similarly, Enums can only be written to storage if they implement the "
"`Store` trait, which can be trivially derived as long as all associated "
"types implement the `Store` trait."
msgstr "同样,只有执行`轮胎'特性,才能将东兽书写到储存处,只要所有相关类型都执行`轮胎'特性,就可以微乎其微地得出`轮胎'特性。"

#: src/ch14-01-contract-storage.md:882
msgid ""
"You might have noticed that we also derived `Drop` and `Serde` on our custom"
" types. Both of them are required for properly serializing arguments passed "
"to entrypoints and deserializing their outputs."
msgstr ""
"你可能已经注意到,我们也从我们的习惯类型中推导出`Drop'和`Serde ',两者都需要对通过进入点的论据进行适当序列整理,使其产出失效。"

#: src/ch14-01-contract-storage.md:884
msgid "Structs Storage Layout"
msgstr "Structs 存储布局"

#: src/ch14-01-contract-storage.md:886
msgid ""
"On Starknet, structs are stored in storage as a sequence of primitive types."
" The elements of the struct are stored in the same order as they are defined"
" in the struct definition. The first element of the struct is stored at the "
"base address of the struct, which is computed as specified in [\"Addresses "
"of Storage Variables\"](./ch14-01-contract-storage.html#addresses-of-"
"storage-variables) section and can be obtained by calling `var.address()`, "
"and subsequent elements are stored at addresses contiguous to the first "
"element. For example, the storage layout for the `owner` variable of type "
"`Person` will result in the following layout:"
msgstr ""
"在Starknet上,支架作为原始类型的序列储存在储存中。支架的各个组成部分的储存顺序与在支架定义中定义的顺序相同。支架的第一个组成部分储存在支架的基座(根据[“存储变量的代号”)(./ch14-01-合同-"
"储存.html#地址-储存-"
"可变性)部分的规定计算,可以通过调用`var.address()'获得,随后的元素储存在与第一个元素毗连的地址。例如,`所有者'类型`人'的储存布局将导致以下布局:"

#: src/ch14-01-contract-storage.md:890
msgid "Fields"
msgstr "外地"

#: src/ch14-01-contract-storage.md:890 src/ch14-01-contract-storage.md:905
#: src/ch14-01-contract-storage.md:912
msgid "Address"
msgstr "地址地址地址地址"

#: src/ch14-01-contract-storage.md:892
msgid "name"
msgstr "名称名称名称名称名称"

#: src/ch14-01-contract-storage.md:892
msgid "owner.address()"
msgstr "拥有者. address ()"

#: src/ch14-01-contract-storage.md:893
msgid "address"
msgstr "地址地址地址地址地址地址"

#: src/ch14-01-contract-storage.md:893
msgid "owner.address() +1"
msgstr "所有者. address () +1"

#: src/ch14-01-contract-storage.md:895
msgid ""
"Note that tuples are similarly stored in contract's storage, with the first "
"element of the tuple being stored at the base address, and subsequent "
"elements stored contiguously."
msgstr "请注意,象牙同样储存在合同的储存中,象牙的第一个部分储存在基址,随后的一些部分以毗连方式储存。"

#: src/ch14-01-contract-storage.md:899
msgid "Enums Storage Layout"
msgstr "Enums 存储布局"

#: src/ch14-01-contract-storage.md:901
msgid ""
"When you store an enum variant, what you're essentially storing is the "
"variant's index and eventual associated values. This index starts at 0 for "
"the first variant of your enum and increments by 1 for each subsequent "
"variant. If your variant has an associated value, this value is stored "
"starting from the address immediately following the address of the index of "
"the variant. For example, suppose we have the `RegistrationType` enum with "
"the `finite` variant that carries an associated limit date, and the "
"`infinite` variant without associated data. The storage layout for the "
"`finite` variant would look like this:"
msgstr ""
"当您存储一个 enum 变量时, 您基本上储存的是 变量的索引和最终关联值。 该索引的起始点是 0, 您的宏的第一个变量的起始点是 0, "
"下一个变量的递增点是 1 。 如果您的变量有一个相关值, 该值则从该变量的索引地址旁边的地址开始存储。 例如, 假设我们拥有“ 注册Type” 组件, "
"配有带有相关限制日期的“ Finite ” 变量, 以及没有相关数据的“ 无限” 变量。 “ Finite ” 变量的存储布局将像这样:"

#: src/ch14-01-contract-storage.md:905 src/ch14-01-contract-storage.md:912
msgid "Element"
msgstr "要素要素"

#: src/ch14-01-contract-storage.md:907
msgid "Variant index (0 for finite)"
msgstr "变式指数(限值为0)"

#: src/ch14-01-contract-storage.md:907 src/ch14-01-contract-storage.md:914
msgid "registration_type.address()"
msgstr "注册_ type. address ()"

#: src/ch14-01-contract-storage.md:908
msgid "Associated limit date"
msgstr "相关截止日期"

#: src/ch14-01-contract-storage.md:908
msgid "registration_type.address() + 1"
msgstr "注册_type.mail () + 1"

#: src/ch14-01-contract-storage.md:910
msgid "while the storage layout for the `infinite` would be as follows:"
msgstr "\" 无限 \" 的储存布局如下:"

#: src/ch14-01-contract-storage.md:914
msgid "Variant index (1 for infinite)"
msgstr "变式指数(1无无限)"

#: src/ch14-01-contract-storage.md:916
msgid "Storage Mappings"
msgstr "储存绘图"

#: src/ch14-01-contract-storage.md:918
msgid ""
"Storage mappings are similar to hash tables in that they allow mapping keys "
"to values. However, unlike a typical hash table, the key data itself is not "
"stored - only its hash is used to look up the associated value in the "
"contract's storage. Mappings do not have a concept of length or whether a "
"key/value pair is set. All values are by default set to 0. The only way to "
"remove an entry from a mapping is to set its value to the default zero "
"value."
msgstr ""
"存储映射与散列表相似, 因为它允许绘制值的密钥。 但是, 与典型的散列表不同, 关键数据本身没有被存储 - 只有散列用于查看合同存储中的关联值 。 "
"映射没有长度概念, 也没有设定密钥/ 价值对。 所有值默认设置为 0。 从映射中删除条目的唯一方法是将其值设定为默认零值 。"

#: src/ch14-01-contract-storage.md:921
msgid ""
"Mappings are only used to compute the location of data in the storage of a "
"contract given certain keys. They are thus **only allowed as storage "
"variables**. They cannot be used as parameters or return parameters of "
"contract functions, and cannot be used as types inside structs."
msgstr ""
"绘图仅用于计算合同存储中数据的位置,给定某些密钥。 因此,这些密钥** "
"仅允许作为存储变量**,不能用作合同功能的参数或返回参数,也不能用作建筑内的类型。"

#: src/ch14-01-contract-storage.md:933
msgid ""
"To declare a mapping, use the `LegacyMap` type enclosed in angle brackets "
"`<>`, specifying the key and value types."
msgstr "要宣布绘图,请使用括号括号中括号内的“LegacyMap”类型,具体说明关键和值类型。"

#: src/ch14-01-contract-storage.md:936
msgid ""
"You can also create more complex mappings with multiple keys. You can find "
"in Listing 14-2 the popular `allowances` storage variable of the ERC20 "
"Standard which maps an `owner` and an allowed `spender` to their `allowance`"
" amount using multiple keys passed inside a tuple:"
msgstr ""
"您也可以用多个密钥创建更复杂的映射图。 您可以在列表 14-2 中找到ESRC20 "
"标准中流行的“允许”存储变量,该变量绘制了“所有者”和允许的“允许”“允许”`允许'到其`允许'的`允许'数量,使用在图普尔内传递的多个密钥:"

#: src/ch14-01-contract-storage.md:945
msgid ""
"<span class=\"caption\">Listing 14-2: Storing a mapping with multiple keys "
"inside a tuple</span>"
msgstr "<span class=\"caption\" > listing 14-2: 在 tiple </span> 内存储带多个密钥的映射"

#: src/ch14-01-contract-storage.md:947
msgid ""
"The address in storage of a variable stored in a mapping is computed "
"according to the description in the [\"Addresses of Storage "
"Variables\"](./ch14-01-contract-storage.html#addresses-of-storage-variables)"
" section."
msgstr "映射中存储变量的存储地址根据[“存储变量的地址”] (./ch14-01-合同-存储.html#地址-存储变量-变量)部分的说明计算。"

#: src/ch14-01-contract-storage.md:949
msgid ""
"If the key of a mapping is a struct, each element of the struct constitutes "
"a key. Moreover, the struct should implement the `Hash` trait, which can be "
"derived with the `#[derive(Hash)]` attribute. For example, if you have a "
"struct with two fields, the address will be "
"`h(h(sn_keccak(variable_name),k_1),k_2)` modulo \\\\( {2^{251}} - 256\\\\), "
"where `k_1` and `k_2` are the values of the two fields of the struct."
msgstr ""
"如果映射的键是一个支流, 则支流的每个元素构成一个键。 此外, 支流应该执行“ Hash” 特性, 可以通过 {{[ derive( Hash)] "
"属性来得出。 例如, 如果您有一个带有两个字段的支流, 地址将是 `h( h) (sn_keccak( 变量_ name), k_ 1, k_ 2) "
"modulo\\\\\\\\( { {2251}} { - 256\\\\}), 其中“ k_ 1 ” 和 k_ 2 ” 是该支管的两个字段的值 。"

#: src/ch14-01-contract-storage.md:951
msgid ""
"Similarly, in the case of a nested mapping using a tuple as key, such as "
"`LegacyMap::<(ContractAddress, ContractAddress), u8>`, the address will be "
"computed in the same way, with each element of the tuple being a key: "
"`h(h(sn_keccak(variable_name),k_1),k_2)`."
msgstr ""
"同样,在使用“LegacyMap:<(合同地址、合同地址),u8”等键作为键的嵌套绘图的情况下,地址也将以同样的方式计算,图的每个元素都是一个键:`h(h)(sn_keccak)(变量_name,k_1,k_2)。"

#: src/ch14-02-contract-functions.md:3
msgid ""
"In this section, we are going to be looking at the different types of "
"functions you could encounter in Starknet smart contracts."
msgstr "在本节中,我们将探讨在斯塔克内特智能合同中你可能遇到的不同类型的职能。"

#: src/ch14-02-contract-functions.md:5
msgid ""
"Functions can access the contract's state easily via `self: ContractState`, "
"which abstracts away the complexity of underlying system calls "
"(`storage_read_syscall` and `storage_write_syscall`). The compiler provides "
"two modifiers: `ref` and `@` to decorate `self`, which intends to "
"distinguish view and external functions."
msgstr ""
"各种功能可以通过`本身:合同国'轻易地进入合同状态,该合同国将系统下调(“存储_read_syscall”和`存储_write_syscall')的复杂程度归纳为摘要,汇编者提供两种修饰:`检索'和装饰`自我',意在区分视图和外部功能。"

#: src/ch14-02-contract-functions.md:7
msgid "1. Constructors"
msgstr "1. 建 构 体"

#: src/ch14-02-contract-functions.md:9
msgid ""
"Constructors are a special type of function that only runs once when "
"deploying a contract, and can be used to initialize the state of a contract."
msgstr "建筑体是一种特殊类型的功能,在部署合同时只能运行一次,可用于启动合同状态。"

#: src/ch14-02-contract-functions.md:20
msgid "Some important rules to note:"
msgstr "需要指出的一些重要规则如下:"

#: src/ch14-02-contract-functions.md:22
msgid "A contract can't have more than one constructor."
msgstr "合同不能有一个以上的建筑师。"

#: src/ch14-02-contract-functions.md:23
msgid ""
"The constructor function must be named `constructor`, and must be annotated "
"with the `#[constructor]` attribute."
msgstr "构建符函数必须命名为`构建符',并附加“[构 属性”注释。"

#: src/ch14-02-contract-functions.md:25
msgid ""
"The `constructor` function might take arguments, which are passed when "
"deploying the contract. In our example, we pass some value corresponding to "
"a `Person` type as argument in order to store the `owner` information "
"(address and name) in the contract."
msgstr ""
"`构件人'功能可能需要在部署合同时通过的论点,例如,我们通过某种与`人'类型相对应的价值作为论证,以便将`所有人'的信息(地址和名称)储存在合同中。"

#: src/ch14-02-contract-functions.md:27
msgid ""
"Note that the `constructor` function **must** take `self` as a first "
"argument, corresponding to the state of the contract, generally passed by "
"reference with the `ref` keyword to be able to modify the contract's state. "
"We will explain `self` and its type shortly."
msgstr ""
"请注意,`构件人'功能** 必须** "
"将`自我'作为与合同状况相对应的第一个论点,通常以`ref'关键词作为参考通过,以便能够修改合同的状态,我们将很快解释`自我'及其类型。"

#: src/ch14-02-contract-functions.md:29
msgid "2. Public Functions"
msgstr "2. 公共职能"

#: src/ch14-02-contract-functions.md:31
msgid ""
"As stated previously, public functions are accessible from outside of the "
"contract. They are usually defined inside an implementation block annotated "
"with the `#[abi(embed_v0)]` attribute, but might also be defined "
"independently under the `#[external(v0)]` attribute."
msgstr ""
"如前所述,公共职能可以从合同之外获得,通常在附加说明的`[iabi(embed_v0)]`属性的执行区块内加以界定,但也可以在`[external(v0)]`属性下独立界定。"

#: src/ch14-02-contract-functions.md:33
msgid ""
"The `#[abi(embed_v0)]` attribute means that all functions embedded inside it"
" are implementations of the Starknet interface of the contract, and "
"therefore potential entry points."
msgstr "`[{abi(emed_v0)]`属性系指其中所含的所有功能都是执行合同的Starknet接口,因此是潜在的切入点。"

#: src/ch14-02-contract-functions.md:35
msgid ""
"Annotating an impl block with the `#[abi(embed_v0)]` attribute only affects "
"the visibility (i.e., public vs private/internal) of the functions it "
"contains, but it doesn't inform us on the ability of these functions to "
"modify the state of the contract."
msgstr ""
"说明内插块的“{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}`属性只影响其所含功能的可见度(即公共相对于私人/内部),但并不告诉我们这些功能修改合同状态的能力。"

#: src/ch14-02-contract-functions.md:56
msgid ""
"Similarly to the `constructor` function, all public functions, either "
"standalone functions annotated with the `#[external(v0)]` or functions "
"within an impl block annotated with the `#[abi(embed_v0)]` attribute, "
"**must** take `self` as a first argument. This is not the case for private "
"functions."
msgstr ""
"与`构件'功能相似的是,所有公共职能,要么单独履行附加“[外部(v0)]”说明的职能,要么在“[基础(embed_v0)]”属性下附加附加“[基础(embed_v0)]”说明的分块内履行,**必须**将`自我'作为第一个理由,私人职能则不适用。"

#: src/ch14-02-contract-functions.md:58
msgid "External Functions"
msgstr "外部职能"

#: src/ch14-02-contract-functions.md:60
msgid ""
"External functions are _public_ functions where the `self: ContractState` "
"argument is passed by reference with the `ref` keyword, which exposes both "
"the `read` and `write` access to storage variables. This allows modifying "
"the state of the contract via `self` directly."
msgstr ""
"外部功能为`公共'功能,其中`本身:合同国'论点以`ref`关键词为参照通过,这暴露了`读'和`写'对储存变量的访问,从而允许直接通过`自己'修改合同状况。"

#: src/ch14-02-contract-functions.md:69
msgid "View Functions"
msgstr "查看函数"

#: src/ch14-02-contract-functions.md:71
msgid ""
"View functions are _public_ functions where the `self: ContractState` "
"argument is passed as snapshot, which only allows the `read` access to "
"storage variables, and restricts writes to storage made via `self` by "
"causing compilation errors. The compiler will mark their `state_mutability` "
"to `view`, preventing any state modification through `self` directly."
msgstr ""
"查看功能是`自我:合同国'论点以快照形式传递,只能允许`阅读'查阅储存变量,并限制写作以`自己'方式通过编译错误进行储存,汇编者将标记其`状态可变性'至`观点"
" ',防止通过`自己'直接进行任何国家修改。"

#: src/ch14-02-contract-functions.md:80
msgid "State Mutability of Public Functions"
msgstr "国家公共职能的可变性"

#: src/ch14-02-contract-functions.md:82
msgid ""
"However, as you may have noticed, passing `self` as a snapshot only "
"restricts the storage write access via `self` at compile time. It does not "
"prevent state modification via direct system calls, nor calling another "
"contract that would modify the state."
msgstr ""
"然而,正如你可能已经注意到的,通过 \" 自己 \" 的快照,只会限制通过 \" 自己 \" "
"汇编时间的储存书写访问,并不妨碍通过直接的系统电话进行国家修改,也不会要求签订另一项合同来修改国家。"

#: src/ch14-02-contract-functions.md:84
msgid ""
"The read-only property of view functions is not enforced on Starknet, and "
"sending a transaction targeting a view function _could_  change the state."
msgstr "Starknet 不强制执行只读查看属性功能, 发送针对查看函数的交易 _可以改变状态 。"

#: src/ch14-02-contract-functions.md:86
msgid ""
"In conclusion, even though external and view functions are distinguished by "
"the Cairo compiler, **all public functions** can be called through an invoke"
" transaction and have the potential to modify states on Starknet. Also, all "
"public functions can be queried via `starknet_call` on Starknet, which will "
"not create a transaction and hence will not change the state."
msgstr ""
"最后,即使开罗汇编者区分了外部和视觉功能, **所有公共功能** 都可以通过援引交易来调用,并有可能改变斯塔克内特上的状态。 "
"此外,所有公共功能都可以通过斯塔克内特的“星网呼叫 ” 查询,这不会产生交易,因此不会改变国家。"

#: src/ch14-02-contract-functions.md:88
msgid ""
"**Warning:** This is different from the EVM where a `staticcall` opcode is "
"provided, which prevents storage modifications in the current context and "
"subcontexts. Hence developers **should not** have the assumption that "
"calling a view function on another contract cannot modify the state."
msgstr ""
"** 警告:** 与提供“静态呼叫”代码的EVM不同,该代码防止在目前的上下文和子文本中修改储存,因此开发商** 不应** "
"假定在另一合同上调用查看功能不能改变状态。"

#: src/ch14-02-contract-functions.md:90
msgid "Standalone Public Functions"
msgstr "独立公共职能"

#: src/ch14-02-contract-functions.md:92
msgid ""
"It is also possible to define public functions outside of an implementation "
"of a trait, using the `#[external(v0)]` attribute. Doing this will "
"automatically generate the corresponding ABI, allowing these standalone "
"public functions to be callable by anyone from the outside. These functions "
"can also be called from within the contract just like any function in "
"Starknet contracts. The first parameter must be `self`."
msgstr ""
"也可以使用“[外部(v0)] "
"”属性,在特性实施之外界定公共职能。这样做将自动产生相应的ABI,使这些独立的公共职能可由外部任何人调用,这些职能也可以像斯塔克内特合同中的任何功能一样,在合同中被调用。第一个参数必须是“自我”。"

#: src/ch14-02-contract-functions.md:94
msgid ""
"Here, we define a standalone `get_contract_name` function outside of an impl"
" block:"
msgstr "在此, 我们定义一个独立“ get_ contract_ name” 函数, 其值不在此列 :"

#: src/ch14-02-contract-functions.md:104
msgid "3. Private Functions"
msgstr "3. 私人职能"

#: src/ch14-02-contract-functions.md:106
msgid ""
"Functions that are not defined with the `#[external(v0)]` attribute or "
"inside a block annotated with the `#[abi(embed_v0)]` attribute are private "
"functions (also called internal functions). They can only be called from "
"within the contract."
msgstr ""
"未以 [extern(v0)] 属性定义的函数或以 [abi(embed_v0)] "
"属性附加注释的区块内的函数为私有函数(也称为内部函数),只能从合同中调用。"

#: src/ch14-02-contract-functions.md:108
msgid ""
"They can be grouped in a dedicated impl block (e.g., in components, to "
"easily import internal functions all at once in the embedding contracts) or "
"just be added as free functions inside the contract module. Note that these "
"2 methods are equivalent. Just choose the one that makes your code more "
"readable and easy to use."
msgstr ""
"它们可以分组在一个专用的内嵌块中(例如,在组件中,在嵌入合同中可以轻松地同时输入全部内部功能),也可以在合同模块中作为自由功能添加。请注意,这2种方法是等效的。只需选择一种方法,使您的代码更容易读取和容易使用。"

#: src/ch14-02-contract-functions.md:135
msgid ""
"Wait, what is this `#[generate_trait]` attribute? Where is the trait "
"definition for this implementation? Well, the `#[generate_trait]` attribute "
"is a special attribute that tells the compiler to generate a trait "
"definition for the implementation block. This allows you to get rid of the "
"boilerplate code of defining a trait with generic parameters and "
"implementing it for the implementation block. With this attribute, we can "
"simply define the implementation block directly, without any generic "
"parameter, and use `self: ContractState` in our functions."
msgstr ""
"等等,这是什么 {{{[generate_trait_trait} 的属性? 此执行的特性定义在哪里?{{{}}}}} "
"属性是一个特殊属性,它告诉汇编者为执行区块生成特性定义。这可以使您摆脱用于定义带有通用参数的特性并用于执行区块的锅炉牌代码。有了这一属性,我们可以直接定义执行区块,不使用任何通用参数,并在我们的职能中使用`自我:合同状态'。"

#: src/ch14-02-contract-functions.md:137
msgid ""
"The `#[generate_trait]` attribute is mostly used to define private impl "
"blocks. It might also be used in addition to `#[abi(per_item)]` to define "
"the various entrypoints of a contract (see [next "
"section](./ch14-02-contract-functions.md#4-abiper_item-attribute))."
msgstr ""
"[generate_trait] "
"属性主要用于定义私人内嵌块,除{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}_{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}>外,还可用于界定合同的各个切入点(见{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}_合同-"
"合同-功能。"

#: src/ch14-02-contract-functions.md:139
msgid ""
"Note: using `#[generate_trait]` in addition to the `#[abi(embed_v0)]` "
"attribute for a public impl block is not recommended, as it will result in a"
" failure to generate the corresponding ABI. Public functions should only be "
"defined in an impl block annotated with `#[generate_trait]` if this block is"
" also annotated with the `#[abi(per_item)]` attribute."
msgstr ""
"注:除{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}’外,使用{{{{{{{}}}}}>`{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}>`[{{{{{{{{{{{}}}}}}}}{{{{{{}}}}}不推荐公有公有功能,因为这将导致未能产生相应的ABI。公共功能只应在附加附加说明的{{{{{{{{{{{{{{{{{}}}}}}}}}}}}`的的的内定义。"

#: src/ch14-02-contract-functions.md:144
msgid "`[abi(per_item)]` Attribute"
msgstr "`[{(每项目_项目)]`属性"

#: src/ch14-02-contract-functions.md:146
msgid ""
"You can also define the entrypoint type of functions individually inside an "
"impl block using the`#[abi(per_item)]` attribute on top of your impl. It is "
"often used with the `#[generate_trait]` attribute, as it allows you to "
"define entrypoints without an explicit interface. In this case, the "
"functions will not be grouped under an impl in the ABI. Note that when using"
" `#[abi(per_item)]` attribute, public functions need to be annotated with "
"the `#[external(v0)]` attribute - otherwise, they will not be exposed and "
"will be considered as private functions."
msgstr ""
"您也可以使用 {{{{{{{{{{{{{{{{{}}}}} "
"属性来定义内管块内个别函数的切入点类型。它通常与{{{{{{{{}}}}}}属性一起使用,因为它允许您在没有明确接口的情况下定义切入点。在这种情况下,这些函数不会在"
" ABI 中归类在分块内。请注意,在使用{{{{{{{{{{{{}}}} "
"属性时,公共函数需要附加说明,加上{{{{[extern(v0)]}}}`属性,否则,它们不会暴露出来,将被视为私人功能。"

#: src/ch14-02-contract-functions.md:148
msgid "Here is a short example:"
msgstr "以下是一个简短的例子:"

#: src/ch14-02-contract-functions.md:160
msgid "// this is a constructor function\n"
msgstr "/ 这是构建符函数\n"

#: src/ch14-02-contract-functions.md:164
msgid "// this is a public function\n"
msgstr "/ 这是公共职能\n"

#: src/ch14-02-contract-functions.md:168
msgid "// this is a l1_handler function\n"
msgstr "/ 这是 I1_ handler 函数\n"

#: src/ch14-02-contract-functions.md:171
msgid "// this is an internal function\n"
msgstr "/这是内部职能\n"

#: src/ch14-02-contract-functions.md:177
msgid ""
"In the case of `#[abi(per_item)]` attribute usage without "
"`#[generate_trait]`, it will only be possible to include `constructor`, "
"`l1-handler` and `internal` functions in the trait implementation. Indeed, "
"`#[abi(per_item)]` only works with a trait that is not defined as a Starknet"
" interface. Hence, it will be mandatory to create another trait defined as "
"interface to implement public functions."
msgstr ""
"如果``{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}>`属性使用}>`,则在特性执行中只能包括`构件>、`l1-"
" handler`和`内部'的功能。{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}`但有非 "
"Starknet接口的特性。因此,为履行公共功能,必须创建另一个被定义为接口的特性。"

#: src/ch14-03-contract-events.md:3
msgid ""
"Events are custom data structures that are emitted by smart contracts during"
" execution. They provide a way for smart contracts to communicate with the "
"external world by logging information about specific occurrences in a "
"contract."
msgstr "事件是在执行期间由智能合同排放的定制数据结构,为智能合同通过记录合同中具体事件的信息与外部世界沟通提供了一种途径。"

#: src/ch14-03-contract-events.md:5
msgid ""
"Events play a crucial role in the integration of smart contracts in real-"
"world applications. Take, for instance, the Non-Fungible Tokens (NFTs) "
"minted on Starknet. An event is emitted each time a token is minted. This "
"event is indexed and stored in some database, allowing applications to "
"display almost instantaneously useful information to users. If the contract "
"doesn't emit an event when minting a new token, it would be less practical, "
"with the need of querying the state of the blockchain to get the data "
"needed."
msgstr ""
"事件在将智能合同融入现实世界应用程序方面发挥着关键作用。 例如, 将不可调试 Tokens (NFTs) 刻录在 Starknet 上。 "
"每次标记被刻录时都会释放事件 。 该事件会被索引并存储在某个数据库中, 使应用程序能够向用户显示几乎即时有用的信息。 如果合同在装配新标记时不发布事件,"
" 则不那么实际, 需要查询块链状态才能获得所需的数据 。"

#: src/ch14-03-contract-events.md:7
msgid "Defining Events"
msgstr "界定事件"

#: src/ch14-03-contract-events.md:9
msgid ""
"All the different events in a contract are defined under the `Event` enum, "
"which must implement the `starknet::Event` trait. This trait is defined in "
"the core library as follows:"
msgstr "合同中的所有不同事件均在`Event'enum下界定,必须执行`sharknet::Event'特性,核心图书馆对这一特性的定义如下:"

#: src/ch14-03-contract-events.md:18
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate "
"an implementation for the above trait, instantiated with the `Event` type, "
"which in our example is the following enum:"
msgstr "{{[衍生(星网:Event }}`属性导致编译者为上述特性产生一个执行过程,该特性与`天'类型同时出现,在我们的例子中,该类型如下:"

#: src/ch14-03-contract-events.md:29
msgid ""
"Each variant of the `Event` enum has to be a struct or an enum, and each "
"variant needs to implement the `starknet::Event` trait itself. Moreover, the"
" members of these variants must implement the `Serde` trait (_c.f._ "
"[Appendix C: Serializing with Serde](./appendix-03-derivable-"
"traits.html#serializing-with-serde)), as keys/data are added to the event "
"using a serialization process."
msgstr ""
"`Event' enum的每一种变式都必须是树根或树根,每一变式都需要执行`starknet::Event' "
"特性本身,此外,这些变式的成员必须执行`serde' 特性(_c.f._[附录C:与Serde进行序列排序](./附录03-03-可发送-"
"traits.html#sergic-serde),因为键/数据是使用序列化程序添加到事件上的。"

#: src/ch14-03-contract-events.md:31
msgid ""
"The auto-implementation of the `starknet::Event` trait will implement the "
"`append_keys_and_data` function for each variant of our `Event` enum. The "
"generated implementation will append a single key based on the variant name "
"(`StoredName`), and then recursively call `append_keys_and_data` in the impl"
" of the `Event` trait for the variant’s type."
msgstr ""
"自动实施“星网 ” : Event'特性将为我们的“ Even'enum ” "
"的每一种变体执行“附录_keys_and_data”功能。生成的落实将附加一个基于变体名称(`storedname')的单一密钥,然后在变体类型`vent'特性的插管中反复调用`append_keys_and_data'。"

#: src/ch14-03-contract-events.md:33
msgid ""
"In our example, the `Event` enum contains only one variant, which is a "
"struct named `StoredName`. We chose to name our variant with the same name "
"as the struct name, but this is not enforced."
msgstr ""
"在我们的例子中,`Event' "
"enum只包含一个变体,即一个名为`Stredname'的支架。我们选择用与支架名称相同的名字命名我们的变体,但并未强制执行。"

#: src/ch14-03-contract-events.md:44
msgid ""
"Whenever an enum that derives the `starknet::Event` trait has an enum "
"variant, this enum is nested by default. Therefore, the list of keys "
"corresponding to the variant’s name will include the `sn_keccak` hash of the"
" variant's name itself. This can be superfluous, typically when using "
"embedded components in contracts. Indeed, in such cases, we might want the "
"events defined in the components to be emitted without any additional data, "
"and it could be useful to annotate the enum variant with the `#[flat]` "
"attribute. By doing so, we allow to opt out of the nested behavior and "
"ignore the variant name in the serialization process. On the other hand, "
"nested events have the benefit of distinguishing between the main contract "
"event and different components events, which might be helpful."
msgstr ""
"产生“ 恒星网” 的元素: : Event'treaty has a enum 变异体时, 这个变异体会默认嵌入。 因此, "
"与变异体名称相对应的密钥列表将包含该变异体名称本身的“ sn_keccak” hash 。 这可能是多余的, 通常在合同中使用嵌入组件时是如此。 "
"事实上, 在这样的情况下, 我们可能希望在没有附加任何数据的情况下释放组件中界定的事件, 并且用“ [ 缩放] 属性来说明该变异体。 这样, "
"我们就可以选择退出嵌入的行为, 在序列化过程中忽略变异名称 。 另一方面, 嵌入事件的好处是区分主要合同事件和不同构件事件, 这可能是有益的 。"

#: src/ch14-03-contract-events.md:46
msgid ""
"In our contract, we defined an event named `StoredName` that emits the "
"contract address of the caller and the name stored within the contract, "
"where the `user` field is serialized as a key and the `name` field is "
"serialized as data."
msgstr ""
"在我们的合同中,我们界定了一个名为`注册名称'的事件,该事件透露了打电话者的合同地址和合同中储存的名称,其中`用户'栏目被按序记为钥匙,`名称'栏目被按序记为数据。"

#: src/ch14-03-contract-events.md:48
msgid ""
"Indexing events fields allows for more efficient queries and filtering of "
"events. To index a field as a key of an event, simply annotate it with the "
"`#[key]` attribute as demonstrated in the example for the `user` key. By "
"doing so, any indexed field will allow queries of events that contain a "
"given value for that field with \\\\( O(log(n)) \\\\) time complexity, while"
" non indexed fields require any query to iterate over all events, providing "
"\\\\( O(n) \\\\) time complexity."
msgstr ""
"索引事件字段允许更有效地查询和筛选事件。要将一个字段作为事件的关键,只需用“用户”键示例中显示的 {{[key] ’ "
"属性来说明它。这样,任何索引字段都允许查询含有该字段给定值的事件\\\\ (O(log(n))\\\\\\) "
"时间复杂性,而非索引字段则要求对所有事件进行切换,提供\\\\\\(O(n)\\\\\\)时间复杂性。"

#: src/ch14-03-contract-events.md:50
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: name "
"})`, a key corresponding to the name ` StoredName`, specifically "
"`sn_keccak(StoredName)`, is appended to the keys list. `user`is serialized "
"as key, thanks to the `#[key]` attribute, while address is serialized as "
"data. After everything is processed, we end up with the following keys and "
"data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [name]`."
msgstr ""
"当用`self.emit(用户名 {用户名:用户名:名称 } ` 发布事件时,关键列表中附有一个与`存储名 "
"',特别是`sn_keccak(用户名)'相对应的密钥。 \" 用户名 \" 由于 {[关键] "
"属性被序列作为密钥,而地址则作为数据序列化。在处理所有事项后,我们最后使用以下密钥和数据:`关键字 = [sn_keccak (“存储名”),用户] "
"和`数据= [名 。"

#: src/ch14-03-contract-events.md:54
msgid "Emitting Events"
msgstr "模拟事件"

#: src/ch14-03-contract-events.md:56
msgid ""
"After defining events, we can emit them using `self.emit`, with the "
"following syntax:"
msgstr "在界定事件后,我们可以使用`self.emit ', 使用以下语法来发布:"

#: src/ch14-03-contract-events.md:62
msgid ""
"The `emit` function is called on `self` and takes a reference to `self`, "
"i.e., state modification capabilities are required. Therefore, it is not "
"possible to emit events in view functions."
msgstr "`移民'功能是用`自己'来称呼的,并提到`自己 ',即需要国家修改能力,因此,不可能在观察功能中发布事件。"

#: src/ch15-00-starknet-cross-contract-interactions.md
msgid ""
"Interactions between smart contracts are an important feature when creating "
"complex decentralized applications, as it allows for composability and "
"separation of concerns. This chapter sheds light on how to make contracts "
"interact with each other."
msgstr "智能合同之间的相互作用是建立复杂的分散应用程序的一个重要特征,因为它可以使各种关切能够兼容和分离,本章阐明了如何使合同相互配合。"

#: src/ch15-00-starknet-cross-contract-interactions.md
msgid ""
"Specifically, you'll learn about ABIs, contract interfaces, the contract and"
" library dispatchers and their low-level system call equivalents!"
msgstr "具体地说,你会了解ABIs,合同界面, 合同和图书馆调度员 以及他们的低级系统呼叫等同!"

#: src/ch15-01-abis-and-contract-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a "
"common practice which enables us to build flexible contracts that can speak "
"with each other."
msgstr "链条上智能合同之间的相互合同互动是一种常见做法,使我们能够建立能够相互交谈的灵活合同。"

#: src/ch15-01-abis-and-contract-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr "在史塔克网上实现这一点 需要我们称之为接口的东西"

#: src/ch15-01-abis-and-contract-interfaces.md:7
msgid "ABI - Application Binary Interface"
msgstr "ABI - 应用程序二进制界面"

#: src/ch15-01-abis-and-contract-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the "
"contract's functions and structures, giving anyone (or any other contract) "
"the ability to form encoded calls to it. It is a blueprint that instructs "
"how functions should be called, what input parameters they expect, and in "
"what format."
msgstr ""
"在斯塔克内特,合同的ABI是JSON对合同功能和结构的表述,使任何人(或其他任何合同)能够组成编码电话。 "
"这是一个指导如何称呼功能、他们期望哪些输入参数以及以何种格式的蓝图。"

#: src/ch15-01-abis-and-contract-interfaces.md:11
msgid ""
"While we write our smart contract logics in high-level Cairo, they are "
"stored on the VM as executable bytecodes which are in binary formats. Since "
"this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods "
"which can be called to a smart contract for execution. Without an ABI, it "
"becomes practically impossible for external actors to understand how to "
"interact with a contract."
msgstr ""
"当我们在高层次开罗撰写智能合同逻辑时,它们作为可执行的字节代码存储在VM上,以二元格式保存。由于该字节代码不是人类可读的,因此需要理解解释。 "
"这就是ABIs发挥作用的地方,它界定了可以称为智能合同的具体执行方法。没有ABI,外部行为者实际上不可能理解如何与合同互动。"

#: src/ch15-01-abis-and-contract-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data "
"correctly, making it understandable by the smart contract and vice versa. "
"When you interact with a smart contract through a block explorer like "
"[Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), "
"they use the contract's ABI to format the data you send to the contract and "
"the data it returns."
msgstr ""
"ABIs通常用于 dApps 前端, 允许它正确格式化数据, 让智能合同能够理解数据, 反之亦然。 当您通过像 [Voyager] ( "
"https://voyager. online/) 或 [ Starkkscan] (https:// starkscan.co/) "
"这样的块式探险家与智能合同互动时, 它们使用合同的 ABI 来格式化您发送到合同的数据及其返回的数据 。"

#: src/ch15-01-abis-and-contract-interfaces.md:15
#: src/ch16-05-02-randomness.md:25
msgid "Interface"
msgstr "界面界面"

#: src/ch15-01-abis-and-contract-interfaces.md:17
msgid ""
"The interface of a contract is a list of the functions it exposes publicly. "
"It specifies the function signatures (name, parameters, visibility and "
"return value) contained in a smart contract without including the function "
"body."
msgstr "合同的接口是一份它公开披露的功能清单。 它指定智能合同中包含的功能签名( 名称、 参数、 可见度 和 返回值 ), 但不包括功能体 。"

#: src/ch15-01-abis-and-contract-interfaces.md:20
msgid ""
"Contract interfaces in Cairo are traits annotated with the "
"`#[starknet::interface]` attribute. If you are new to traits, check out the "
"dedicated chapter on [traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"开罗的合同界面是附加说明的属性。 如果您是新特性, 请查看关于[ traits] (./ch08-02- traits- in- cairo. md) "
"的专章 。"

#: src/ch15-01-abis-and-contract-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the "
"`TContractState` type. This is required for functions to access the "
"contract's storage, so that they can read and write to it."
msgstr "一个重要的具体要求是,这种特性必须通用于`缔约国'类型,这是获取合同储存功能所必需的,以便它们能够读和写。"

#: src/ch15-01-abis-and-contract-interfaces.md:24
msgid ""
"Note: The contract constructor is not part of the interface. Nor are "
"internal functions part of the interface."
msgstr "注:合同建造者不是接口的一部分,内部职能也不是接口的一部分。"

#: src/ch15-01-abis-and-contract-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's "
"a generic trait over the `TContractState` type. `view` functions have a self"
" parameter of type `@TContractState`, while `external` functions have a self"
" parameter of type passed by reference `ref self: TContractState`."
msgstr ""
"这是ESC20象征性合同的样本界面。如你所见,这是“缔约国”类型上的通用特征。`观察'功能具有“缔约国”类型的自参数,而`外部'功能具有以`缔约国'为参照的`缔约国'通过类型的自定义参数。"

#: src/ch15-01-abis-and-contract-interfaces.md:55
msgid "<span class=\"caption\">Listing 15-1: A simple ERC20 Interface.</span>"
msgstr "<span类=“ caption” > listing 15-1: 一个简单的 ERC20 接口。 </span>"

#: src/ch15-01-abis-and-contract-interfaces.md:57
msgid ""
"In the next chapter, we will see how we can call contracts from other smart "
"contracts using _dispatchers_ and _syscalls_ ."
msgstr "在下一章,我们将看到如何使用_dispatchers_和_syscalls_将其他智能合同的合同称为合同。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:3
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically"
" created and exported by the compiler. Let's consider an interface that we "
"named IERC20, these would be:"
msgstr "每次确定合同界面, 编辑器自动创建和导出两个调度器。 让我们考虑一个我们命名为 IERC20 的界面, 它们是:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:5
msgid "The Contract Dispatcher `IERC20Dispatcher`"
msgstr "`IERC20Dispatcher'合同调度员"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:6
msgid "The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr "图书馆调度员`IECRC20Library Dispatcher'"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:8
msgid ""
"The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to "
"call the functions defined in the interface on the dispatcher struct."
msgstr "编译器还产生一个特质“IERC20DispatcherTrait”,使我们能够调用调度器支架上的界面中所定义的功能。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:10
msgid ""
"In this chapter, we are going to discuss what these are, how they work and "
"how to use them."
msgstr "在本章中,我们将讨论它们是什么,它们如何运作以及如何使用它们。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:12
msgid ""
"To effectively break down the concepts in this chapter, we are going to be "
"using the IERC20 interface from the previous chapter (refer to Listing "
"15-1)."
msgstr "为了有效地分解本章中的概念,我们将使用上一章中的IERC20接口(参见清单15-1)。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:14
msgid "Contract Dispatcher"
msgstr "合同调度员"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` "
"attribute automatically generate a dispatcher and a trait on compilation. "
"Our `IERC20` interface is expanded into something like this:"
msgstr "如前所述,带有“[星网:界面]”属性附加说明的特性自动生成一个调度器和汇编上的特性。我们的“IER20”接口扩展为类似内容:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:19
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to"
" keep this chapter concise and straight to the point, we focused on one view"
" function `name`, and one external function `transfer`."
msgstr ""
"** 注:** 我们的IERC20接口的扩大代号要长得多,但为了保持本章的简明和直截了当,我们把重点放在一个视图函数`名称'和一个外部函数`转让'上。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:37
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:41
msgid "// starknet::call_contract_syscall is called in here\n"
msgstr "/ 尖尖: 呼叫 - 合同 - 声音呼叫在这里\n"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:46
msgid ""
"<span class=\"caption\">Listing 15-2: An expanded form of the "
"IERC20Dispatcher trait.</span>"
msgstr "<span class=\"caption\" > listing 15-2:IERC20 Dispatcher 特性的扩大形式。 </span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a "
"contract address and implements the `DispatcherTrait` generated by the "
"compiler, allowing us to call functions from another contract. This means "
"that we can instantiate a struct with the address of the contract we want to"
" call, and then simply call the functions defined in the interface on the "
"dispatcher struct as if they were methods of that type."
msgstr ""
"如你所见, “ 古典” 调度器只是包裹合同地址和执行编译器产生的“ DispattercherTrait” 的支架, 允许我们从另一个合同中调用函数。 "
"这意味着我们可以用我们所要调用的合同地址即时调用一个支架, 然后简单地调用调度器支架上接口中定义的功能, 仿佛它们是这种类型的方法。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:50
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes "
"thanks to the power of Cairo plugins."
msgstr "由于开罗插件的力量, 这些都是在幕后抽象的。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:52
msgid "Calling Contracts using the Contract Dispatcher"
msgstr "使用合同调度员的通话合同"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:54
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to "
"call functions defined on an ERC-20 token. Calling `transfer_token` will "
"modify the state of the contract deployed at `contract_address`."
msgstr ""
"这是名为`TokenWrapper'的合同的一个实例,它利用调度员调用ECR-20牌上界定的功能,调用`移交'将改变在`合同地址'上部署的合同状况。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:94
msgid "//**** Specify interface here ****//\n"
msgstr "/**** 指定在此的接口*******//\n"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:125
msgid ""
"<span class=\"caption\">Listing 15-3: A sample contract which uses the "
"Contract Dispatcher.</span>"
msgstr "<span类=“Caption” > listing 15-3:使用合同调度员的样本合同。 </span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:127
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` generated by the compiler, which allows us to make calls "
"to the methods implemented for the `IERC20Dispatcher` struct (`name`, "
"`transfer`, etc), passing in the `contract_address` of the contract we want "
"to call in the `IERC20Dispatcher` struct."
msgstr ""
"如你所见,我们首先必须进口汇编者制作的`IERC20DispatcherTrait'和`IERC20Dispatcher "
"',这使我们能够呼吁为`IERC20Dispatcher'建筑(`名称'、`转让'等)采用的方法,通过我们希望在`IERC20Dispatcher'建筑中使用的合同的`合同'地址。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:129
msgid "Library Dispatcher"
msgstr "图书馆调度器"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library "
"dispatcher lies in the execution context of the logic defined in the class. "
"While regular dispatchers are used to call functions from **contracts** "
"(with an associated state), library dispatchers are used to call **classes**"
" (stateless)."
msgstr ""
"合同调度员和图书馆调度员之间的关键区别在于该类中界定的逻辑的执行背景。 "
"虽然通常的调度员用来调用**合同**(与相关国家)的功能,但图书馆调度员却用来调用**类**(无)的功能。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr "让我们考虑两份合同A和B"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the "
"execution context of the logic defined in B is that of B. This means that "
"the value returned by `get_caller_address()` in B will return the address of"
" A, and updating a storage variable in B will update the storage of B."
msgstr ""
"当A使用“IB Dispatcher”从** Contract** B调用函数时,B中定义的逻辑的执行背景是B。 "
"这意味着B中`get_caller_address()'返回的数值将返回A的地址,而更新B中的存储变量将更新B的存储。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B,"
" the execution context of the logic defined in B's class is that of A. This "
"means that the value returned by `get_caller_address()` variable in B will "
"return the address of the caller of A, and updating a storage variable in "
"B's class will update the storage of A (remember that the **class** of B is "
"stateless; there is no state that can be updated!)"
msgstr ""
"当“IBLIbrary Dispatcher”使用“IBLIbrary Dispatcher”从** B类** ** "
"调来函数时,B类中定义的逻辑执行背景是 A。 这意味着 B类中“get_caller_地址() ” "
"变量返回的数值将返回A调用者的地址,而更新B类中的存储变量将更新A类的存储内容(记住 B类** 是无国籍的; 没有状态可以更新! )"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:139
msgid ""
"The expanded form of the struct and trait generated by the compiler look "
"like:"
msgstr "编译者所生成的构造和特性的扩大形式看起来像:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:157
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:161
msgid "// starknet::syscalls::library_call_syscall  is called in here\n"
msgstr "/ 尖尖: : 侧写: : 图书馆 - 呼叫 - 侧写:\n"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:166
msgid ""
"<span class=\"caption\">Listing 15-4: An expanded form of the IERC20 "
"trait.</span>"
msgstr "<span class=\"caption\" > listing 15-4:IERC20 特性的扩大形式。 </span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:168
msgid ""
"Notice that the main difference between the regular contract dispatcher and "
"the library dispatcher is that the former uses `call_contract_syscall` while"
" the latter uses `library_call_syscall`."
msgstr ""
"请注意,正常合同发件人和图书馆发件人之间的主要区别是前者使用`调用'合同_syscall ',而后者使用`图书馆_call_syscall'。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:170
msgid "Calling Contracts using the Library Dispatcher"
msgstr "使用图书馆调度员的致电合同"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:172
msgid ""
"Below's a sample code for calling contracts using the Library Dispatcher."
msgstr "下面是使用图书馆调度员 调用合同的样本代码"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:208
msgid ""
"<span class=\"caption\">Listing 15-5: A sample contract using the Library "
"Dispatcher.</span>"
msgstr "<span class=\"caption\" > listing 15-5:使用图书馆调度器的样本合同。 </span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:210
msgid ""
"As you can see, we had to first import in our contract the "
"`IContractADispatcherTrait` and `IContractALibraryDispatcher` which were "
"generated from our interface by the compiler. Then, we can create an "
"instance of `IContractALibraryDispatcher` passing in the `class_hash` of the"
" class we want to make library calls to. From there, we can call the "
"functions defined in that class, executing its logic in the context of our "
"contract. When we call `set_value` on ContractA, it will make a library call"
" to the `set_value` function in IContractA, updating the value of the "
"storage variable `value` in ContractA."
msgstr ""
"正如你可以看到的那样,我们首先必须在我们的合同中输入“IcontractA DispatcherTrait”和“Icontralibrary "
"Dispatcher”这两个由编译者从我们的接口中产生的“Icontractalibrary "
"Dispatcher”,然后,我们可以建立一个“Icontractalibrary "
"Dispatcher”通过我们想拨打图书馆电话的`类'的例子。我们可以从那里调用该类中界定的功能,在我们的合同中执行逻辑。当我们在合同中称为`set_value'时,它将在图书馆中呼叫Itractracta的`seet_value'功能,更新合同中储存变量`value'的价值。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:212
msgid "Using low-level syscalls"
msgstr "使用低级别音频调"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:214
msgid ""
"Another way to call other contracts and classes is to use the "
"`starknet::call_contract_syscall`and `starknet::library_call_syscall` system"
" calls. The dispatchers we described in the previous sections are high-level"
" syntaxes for these low-level system calls."
msgstr ""
"调用其他合同和班级的另一种方法是使用“星网:Call_contract_syscall”和“星网:library_call_syscall”系统。我们在前几节中描述的调度员是这些低级别系统电话的高级语法。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:216
msgid ""
"Using these syscalls can be handy for customized error handling or to get "
"more control over the serialization/deserialization of the call data and the"
" returned data. Here's an example demonstrating how to use a "
"`call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr "使用这些系统可方便地处理定制的错误,或对调用数据和返回的数据的序列化/脱序化获得更大的控制权。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:254
msgid "\"transferFrom\""
msgstr "\"从\""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:265
msgid ""
"<span class=\"caption\">Listing 15-6: A sample contract using "
"syscalls.</span>"
msgstr "<span类=“caption” > listing 15-6: 使用 Syscalls 的样本合同。 </span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:267
msgid ""
"To use this syscall, we passed in the contract address, the selector of the "
"function we want to call (see next section), and the call arguments."
msgstr "为了使用这个轮廓,我们在合同地址、我们想要调用函数的选择人(见下一节)和调用参数中通过了。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:269
msgid ""
"The call arguments must be provided as an array of `felt252`. To build this "
"array, we serialize the expected function parameters into an "
"`Array<felt252>` using the `Serde` trait, and then pass this array as "
"calldata. At the end, we are returned a serialized value which we'll need to"
" deserialize ourselves!"
msgstr ""
"调用参数必须作为“ felt252” 的阵列来提供。 要构建此阵列, 我们使用 ` serde' 特性将预期的函数参数序列化为 ` Array< "
"felt252 ', 然后将此阵列作为调用数据传递。 最后, 我们被还回一个序列化值, 以便自我淡化!"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:271
msgid "Entry Point Selector"
msgstr "切入点选择器"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:273
msgid ""
"In the context of a smart contract, a selector is a unique identifier for a "
"specific entrypoint of a contract. When a transaction is sent to a contract,"
" it includes the selector in the calldata to specify which function should "
"be executed."
msgstr "在智能合同中,选择人是一个合同具体切入点的独特识别符。在将交易发送给合同时,在调用数据中包括选择人,以具体说明应履行哪些职能。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:275
msgid ""
"On Starknet, the selector is computed by applying the `sn_keccak` hash "
"function to the string representation of the function name. If the function "
"name is `transfer`, the selector can be computed with "
"`selector!(\"transfer\")`"
msgstr ""
"在 Starknet 上,选择器的计算方法是将`sn_keccak' "
"散列函数应用到函数名称的字符串表示中。如果函数名称是`传输',选择器可以用`选择器! (')'来计算。"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:277
msgid ""
"Note that in `starknet::call_contract_syscall`, we didn't specify the "
"function name as a string, but rather used the `selector!` macro, which "
"computes the `sn_keccak` hash of the provided function signature."
msgstr ""
"请注意,在“星网:Call_contract_syscall”中,我们没有指定函数名称为字符串,而是使用了`选择者!' "
"宏,该宏计算了所提供的函数签名的`sn_keccak' hash。"

#: src/ch16-01-optimizing-storage-costs.md:3
msgid ""
"Bit-packing is a simple concept: use as few bits as possible to store a "
"piece of data. When done well, it can significantly reduce the size of the "
"data you need to store. This is especially important in smart contracts, "
"where storage is expensive."
msgstr ""
"比特包是一个简单的概念: 尽可能少使用比特来存储一个数据。 如果做得好, 它会大大缩小您需要存储的数据的大小 。 这在智能合同中特别重要, "
"智能合同中存储费用昂贵 。"

#: src/ch16-01-optimizing-storage-costs.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage "
"usage to reduce gas costs. Indeed, most of the cost associated with a "
"transaction is related to storage updates; and each storage slot costs gas "
"to write to. This means that by packing multiple values into fewer slots, "
"you can decrease the gas cost incurred by the users of your smart contract."
msgstr ""
"当签订开罗智能合同时,必须优化存储使用以降低天然气成本。 事实上,与交易相关的大部分成本都与存储更新相关;而每个存储槽的成本都与需要写入的天然气相关。 "
"这意味着通过将多个价值包装到更少的空位中,您可以降低您智能合同用户的天然气成本。"

#: src/ch16-01-optimizing-storage-costs.md:8
msgid "Integer Structure and Bitwise Operators"
msgstr "整数结构和位元运算符"

#: src/ch16-01-optimizing-storage-costs.md:10
msgid ""
"An integer is coded on a certain number of bits, depending on its size (For "
"example, a `u8` integer is coded on 8 bits)."
msgstr "整数根据其大小根据一定数位数编码(例如,“u8”整数按8位数编码)。"

#: src/ch16-01-optimizing-storage-costs.md:19
msgid ""
"Intuitively, several integers can be combined into a single integer if the "
"size of this single integer is greater than or equal to the sum of the sizes"
" of the integers (For example, two `u8` and one `u16` in one `u32`)."
msgstr "直观地说,如果单整数的大小大于或等于整数的大小之和(例如,一个`u32'中有两个`u8'和一个`u16'),几个整数可以合并成一个单整数。"

#: src/ch16-01-optimizing-storage-costs.md:21
msgid "But, to do that, we need some bitwise operators:"
msgstr "但是,为了做到这一点,我们需要一些略微明智的操作员:"

#: src/ch16-01-optimizing-storage-costs.md:23
msgid ""
"multiplying or dividing an integer by a power of 2 shifts the integer value "
"to the left or to the right respectively"
msgstr "以 2 的功率乘或除以整数,将整数分别向左或向右移动"

#: src/ch16-01-optimizing-storage-costs.md:32
msgid ""
"applying a mask (`AND` operator) on an integer value isolates some bits of "
"this integer"
msgstr "在整数值上应用掩码 (`AND' 运算符) 来分离此整数的某些位数"

#: src/ch16-01-optimizing-storage-costs.md:41
msgid ""
"adding (`OR` operator) two integers will combine both values into a single "
"one."
msgstr "添加两个整数,将两个数值合并成一个数值。"

#: src/ch16-01-optimizing-storage-costs.md:50
msgid ""
"With these bitwise operators, let's see how to combine two `u8` integers "
"into a single `u16` integer (called `packing`) and reversely (called "
"`unpacking`) in the following example:"
msgstr "使用这些比位运算符,让我们看看如何将两个`u8'整数合并成一个`u16'整数(称为`包装'),并在以下示例中反向(称为`包装'):"

#: src/ch16-01-optimizing-storage-costs.md:59
msgid "Bit-packing in Cairo"
msgstr "开罗的比特包装"

#: src/ch16-01-optimizing-storage-costs.md:61
msgid ""
"The storage of a Starknet smart contract is a map with 2<sup>251</sup> "
"slots, where each slot is a `felt252` which is initialized to 0."
msgstr "Starknet智能合同的存储是一张2<sup>251 </sup> 槽的地图,其中每个槽为“felt252”,初始化为0。"

#: src/ch16-01-optimizing-storage-costs.md:63
msgid ""
"As we saw earlier, to reduce gas costs due to storage updates, we have to "
"use as few bits as possible, so we have to organize stored variables by "
"packing them."
msgstr "正如我们早些时候所看到的那样,为了减少储存更新导致的气体成本,我们必须尽可能少地使用比特,所以我们必须通过包装来组织储存的变量。"

#: src/ch16-01-optimizing-storage-costs.md:65
msgid ""
"For example, consider the following `Sizes` struct with 3 fields of "
"different types: one `u8`, one `u32` and one `u64`. The total size is 8 + 32"
" + 64 = 104 bits. This is less than a slot size (i.e 251 bits) so we can "
"pack them together to be stored into a single slot."
msgstr ""
"例如,考虑以下`Sizes'结构有3个不同类型字段:1个`u8'、1个`u32'和1个`u64 "
"',总尺寸为8+32+64=104位,小于一个空位大小(即251位),这样我们就可以把它们放在一个空格中储存。"

#: src/ch16-01-optimizing-storage-costs.md:67
msgid ""
"Note that, as it also fits in a `u128`, it's a good practice to use the "
"smallest type to pack all your variables, so here a `u128` should be used."
msgstr "请注意,由于它也适合`u128',因此使用最小类型来打包所有变量是一种良好做法,因此此处应使用`u128'。"

#: src/ch16-01-optimizing-storage-costs.md:77
msgid ""
"To pack these 3 variables into a `u128` we have to successively shift them "
"to the left, and finally sum them."
msgstr "要将这三个变数包装成一个`u128 ',我们就必须相继把它们移到左边,最后把它们相加。"

#: src/ch16-01-optimizing-storage-costs.md:86
msgid ""
"To unpack these 3 variables from a `u128` we have to successively shift them"
" to the right and use a mask to isolate them."
msgstr "要将这3个变量从`u128'中解开,我们必须相继将它们转移到右边,并用面具孤立它们。"

#: src/ch16-01-optimizing-storage-costs.md:95
msgid "The `StorePacking` Trait"
msgstr "`托盘包装'托盘"

#: src/ch16-01-optimizing-storage-costs.md:97
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into"
" fewer storage slots. `StorePacking<T, PackedT>` is a generic trait taking "
"the type you want to pack (`T`) and the destination type (`PackedT`) as "
"parameters. It provides two functions to implement: `pack` and `unpack`."
msgstr ""
"开罗提供了`打包'特性,使打包场能够进入较少的储存槽。 "
"“打包<T,包装T是一种通用特性,以你想打包的类型(`T')和目的地类型(`打包T')作为参数,它提供了两个功能,可以执行:`pack'和`unpack'。"

#: src/ch16-01-optimizing-storage-costs.md:99
msgid "Here is the implementation of the example of the previous chapter:"
msgstr "以下是前一章实例的执行情况:"

#: src/ch16-01-optimizing-storage-costs.md:138
msgid "//don't forget to import it!\n"
msgstr "别忘了进口!\n"

#: src/ch16-01-optimizing-storage-costs.md:147
msgid ""
"// This will automatically pack the\n"
"        // struct into a single u128\n"
msgstr "/ 这将自动将 // 支架打包成单 u128\n"

#: src/ch16-01-optimizing-storage-costs.md:155
msgid ""
"// this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
msgstr "/ 这将自动将 / / 包装的表示解包到 大小 支架中\n"

#: src/ch16-01-optimizing-storage-costs.md:166
msgid "In this code snippet, you see that:"
msgstr "在这个代码片段,你可以看到:"

#: src/ch16-01-optimizing-storage-costs.md:168
msgid ""
"`TWO_POW_8` and `TWO_POW_40` are used to shift left in the `pack` function "
"and shift right in the `unpack`function,"
msgstr "\" TWO_POW_8 \" 和 \" TWO_POW_40 \" 用于在`包装'函数中左移和在`无包装'功能中右移,"

#: src/ch16-01-optimizing-storage-costs.md:169
msgid ""
"`MASK_8` and `MASK_32` are used to isolate a variable in the `unpack` "
"function,"
msgstr "`MASK_8'和`MASK_32'用于分离`unpack'函数中的变量,"

#: src/ch16-01-optimizing-storage-costs.md:170
msgid ""
"all the variables from the storage are converted to `u128` to be able to use"
" bitwise operators."
msgstr "存储中的所有变量都转换为“u128”以便使用比特运算符。"

#: src/ch16-01-optimizing-storage-costs.md:172
msgid ""
"This technique can be used for any group of fields that fit within the bit "
"size of the packed storage type. For example, if you have a struct with "
"multiple fields whose bit sizes add up to 256 bits, you can pack them into a"
" single `u256` variable. If the bit sizes add up to 512 bits, you can pack "
"them into a single `u512` variable, and so on. You can define your own "
"structs and logic to pack and unpack them."
msgstr ""
"此技术可用于任何一组适合已包装存储类型比特大小的字段。 例如, 如果您有一个多字段的支流, 其比特大小加256比特, 您可以把它们包装成一个单一的“ "
"u256” 变量。 如果比特大小加512比特, 您可以把它们包装成一个单一的“ u512” 变量, 等等。 您可以定义自己的支流和逻辑来包装和拆包它们。"

#: src/ch16-01-optimizing-storage-costs.md:174
msgid ""
"The rest of the work is done magically by the compiler - if a type "
"implements the `StorePacking` trait, then the compiler will know it can use "
"the `StoreUsingPacking` implementation of the `Store` trait in order to pack"
" before writing and unpack after reading from storage. One important detail,"
" however, is that the type that `StorePacking::pack` spits out also has to "
"implement `Store` for `StoreUsingPacking` to work. Most of the time, we will"
" want to pack into a felt252 or u256 - but if you want to pack into a type "
"of your own, make sure that this one implements the `Store` trait."
msgstr ""
"其余的工作由汇编者神奇地完成 -- -- "
"如果一种类型执行`托盘打包'特性,那么汇编者就会知道它可以使用`托盘打包'执行`托盘打包'特性,以便在书写前打包,在从存储处阅读后打包。然而,一个重要的细节是,`托盘打包::包装`吐口也须执行`托盘"
" ',以便`托盘打包'工作。在多数情况下,我们想打包到感知252或U256中,但是,如果你想打包到自己的一种类型,请确保这一类型执行`托盘'特性。"

#: src/ch16-02-00-composability-and-components.md:1
msgid "Components: Lego-Like Building Blocks for Smart Contracts"
msgstr "构件: 智能合同的乐高型类似建筑块"

#: src/ch16-02-00-composability-and-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and "
"bug-prone, as this logic can hardly be reused and needs to be reimplemented "
"in each contract. But what if there was a way to snap in just the extra "
"functionality you need inside your contract, separating the core logic of "
"your contract from the rest?"
msgstr ""
"制定共享共同逻辑和储存的合同可能会令人痛苦和容易产生错误,因为这一逻辑很难被重新利用,并且需要在每个合同中重新执行。 "
"但如果有办法在合同中打破你所需要的额外功能,将你合同的核心逻辑与其他功能区分开来呢?"

#: src/ch16-02-00-composability-and-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating "
"reusable logic, storage, and events that can be incorporated into multiple "
"contracts. They can be used to extend a contract's functionality, without "
"having to reimplement the same logic over and over again."
msgstr ""
"这些组件正是如此。 它们都是模块化的附加组件,包含可重复使用的逻辑、储存和可以纳入多个合同的事件。 "
"它们可以用来延长合同的功能,而不必一次又一次地执行相同的逻辑。"

#: src/ch16-02-00-composability-and-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts "
"by plugging in a module that you or someone else wrote. This module can be a"
" simple one, like an ownership component, or more complex like a full-"
"fledged ERC20 token."
msgstr ""
"将组件想象成 Lego 区块 。 它们允许您通过插入您或其他人所写的模块来丰富您的合同 。 这个模块可以是一个简单的模块, 像所有制组件一样, "
"或者像完整的 ERC20 符号一样复杂 。"

#: src/ch16-02-00-composability-and-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and "
"functions. Unlike a contract, a component cannot be declared or deployed. "
"Its logic will eventually be part of the contract’s bytecode it has been "
"embedded in."
msgstr "一个组件是一个可以包含存储、事件和功能的单独模块。 与合同不同,一个组件无法申报或部署。 其逻辑最终将成为合同字元编码的一部分。"

#: src/ch16-02-00-composability-and-components.md:24
msgid "What's in a Component?"
msgstr "组件里有什么?"

#: src/ch16-02-00-composability-and-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr "构成部分与合同非常相似,可包含:"

#: src/ch16-02-00-composability-and-components.md:28
msgid "Storage variables"
msgstr "储存变变数"

#: src/ch16-02-00-composability-and-components.md:29
msgid "Events"
msgstr "事件事件事件事件"

#: src/ch16-02-00-composability-and-components.md:30
msgid "External and internal functions"
msgstr "外部和内部职能"

#: src/ch16-02-00-composability-and-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The "
"component's code becomes part of the contract it's embedded to."
msgstr "与合同不同,部件不能自行部署。 部件的代码成为其嵌入的合同的一部分 。"

#: src/ch16-02-00-composability-and-components.md:35
msgid "Creating Components"
msgstr "创建部件"

#: src/ch16-02-00-composability-and-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a "
"`#[starknet::component]` attribute. Within this module, you can declare a ` "
"Storage` struct and `Event` enum, as usually done in "
"[contracts](./ch13-02-anatomy-of-a-simple-contract.md)."
msgstr ""
"要创建组件,请先在自己配有“[星网:构件]”属性的模块中定义该组件,在此模块中,您可以按[合同](./ch13-02-剖析-"
"简单合同.md)中通常的做法,申报“存储”构件和“静脉” 元件。"

#: src/ch16-02-00-composability-and-components.md:41
msgid ""
"The next step is to define the component interface, containing the "
"signatures of the functions that will allow external access to the "
"component's logic. You can define the interface of the component by "
"declaring a trait with the `#[starknet::interface]` attribute, just as you "
"would with contracts. This interface will be used to enable external access "
"to the component's functions using the [dispatcher](./ch15-02-contract-"
"dispatchers-library-dispatchers-and-system-calls.md) pattern."
msgstr ""
"下一步是定义组件界面, 包含允许外部访问组件逻辑的功能的签名。 您可以与合同一样, 声明与 {[ Starknet:: interface] "
"属性的特性, 以此定义组件的界面。 此界面将用于使用 [ dispatcher] (./ch15-02- contract- dispachers-"
"library- dispatterchers- and- system-calls. md) 模式, 使外部能够访问组件的功能 。"

#: src/ch16-02-00-composability-and-components.md:48
msgid ""
"The actual implementation of the component's external logic is done in an "
"`impl` block marked as `#[embeddable_as(name)]`. Usually, this `impl` block "
"will be an implementation of the trait defining the interface of the "
"component."
msgstr ""
"组成部分的外部逻辑的实际实施是在标记为`{{[embedable_as_as(name)]>`的`impl' "
"区块中完成的。通常,`impl'区块将是执行界定组成部分接口的特性。"

#: src/ch16-02-00-composability-and-components.md:52
msgid ""
"Note: `name` is the name that we’ll be using in the contract to refer to the"
" component. It is different than the name of your impl."
msgstr "注:`姓名'是指我们在合同中将用来指该部件的名称,与你的插管的名称不同。"

#: src/ch16-02-00-composability-and-components.md:55
msgid ""
"You can also define internal functions that will not be accessible "
"externally, by simply omitting the `#[embeddable_as(name)]` attribute above "
"the internal `impl` block. You will be able to use these internal functions "
"inside the contract you embed the component in, but not interact with it "
"from outside, as they're not a part of the abi of the contract."
msgstr ""
"您也可以定义无法从外部访问的内部功能, 简单地略去内部“ impl” 区块之上的“ [embedable_ as( name)] ” 属性。 "
"您可以在合同内使用这些内部功能, 将组件嵌入合同内, 但不能从外部与它互动, 因为这些功能不是合同附件的一部分 。"

#: src/ch16-02-00-composability-and-components.md:61
msgid ""
"Functions within these `impl` block expect arguments like `ref self: "
"ComponentState<TContractState>` (for state-modifying functions) or `self: "
"@ComponentState<TContractState>` (for view functions). This makes the impl "
"generic over `TContractState`, allowing us to use this component in any "
"contract."
msgstr ""
"这些`简单'区块预期参数中的功能,如`自我:国家元件 < 合同国}}(用于国家调整功能)或`本身:@concononentstate < "
"合同国'{(用于观察功能),这使“合同国”的内插成为通用的,使我们能够在任何合同中使用这一组成部分。"

#: src/ch16-02-00-composability-and-components.md:70
msgid "Example: an Ownable Component"
msgstr "示例:一个自有组成部分"

#: src/ch16-02-00-composability-and-components.md:72
msgid ""
"⚠️ The example shown below has not been audited and is not intended for "
"production use. The authors are not responsible for any damages caused by "
"the use of this code."
msgstr "以下的例子未经审计,也不打算用于生产,提交人对使用这一代码造成的任何损害不负责。"

#: src/ch16-02-00-composability-and-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available "
"externally to manage ownership of a contract, would look like this:"
msgstr "自有部分的接口,界定了外部管理合同所有权的现有方法,看起来是这样:"

#: src/ch16-02-00-composability-and-components.md:88
msgid "The component itself is defined as:"
msgstr "构成部分本身的定义是:"

#: src/ch16-02-00-composability-and-components.md:166
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The "
"only differences relate to the `#[embeddable_as]` attribute above the impl "
"and the genericity of the impl block that we will dissect in details."
msgstr ""
"这个语法实际上与合同所使用的语法非常相似,唯一的差别在于“{[emiddable_as]’’ ” 属性高于Unl和Unl块的通用性,我们将在细节中解析。"

#: src/ch16-02-00-composability-and-components.md:170
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to "
"the implementation of the interface trait, and one containing methods that "
"should not be exposed externally and are only meant for internal use. "
"Exposing the `assert_only_owner` as part of the interface wouldn't make "
"sense, as it's only meant to be used internally by a contract embedding the "
"component."
msgstr ""
"如你所见,我们的组成部分有两个`内含'区块:一个与接口特性的实施相对应,一个含有不应对外暴露并仅用于内部使用的方法。 "
"将`资产所有者'作为接口的一部分暴露是没有道理的,因为它只是被嵌入组成部分的合同内部使用。"

#: src/ch16-02-00-composability-and-components.md:176
msgid "A Closer Look at the `impl` Block"
msgstr "更仔细地看一看`impl'区块"

#: src/ch16-02-00-composability-and-components.md:185
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable "
"inside a contract. It allows us to specify the name of the impl that will be"
" used in the contract to refer to this component. In this case, the "
"component will be referred to as `Ownable` in contracts embedding it."
msgstr ""
"`{[emeddable_as]’ "
"属性用于标记内嵌在合同中的内嵌,让我们能够指定合同中将使用的内嵌名称来指这个组成部分,在这种情况下,在嵌入该组成部分的合同中,该组成部分将被称为`Ownable'。"

#: src/ch16-02-00-composability-and-components.md:190
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, "
"with the added restriction that `TContractState` must implement the "
"`HasComponent<T>` trait. This allows us to use the component in any "
"contract, as long as the contract implements the `HasComponent` trait. "
"Understanding this mechanism in details is not required to use components, "
"but if you're curious about the inner workings, you can read more in the "
"[\"Components Under the Hood\"](./ch16-02-01-under-the-hood.md) section."
msgstr ""
"实施本身是通用的,而不是“Compent State <Ttract State> ”, 附加的限制是“缔约国”必须执行`Has Conponent "
"<T}特性,这使我们能够在任何合同中使用该组成部分,只要合同执行`Has "
"Conponent'特性。在使用部件时不需要详细了解这一机制,但是,如果你对内部运作感到好奇,可以在[“Hood下的构件”](./ch16-02-01-under-"
"the bethy.md)一节中读更多。"

#: src/ch16-02-00-composability-and-components.md:197
msgid ""
"One of the major differences from a regular smart contract is that access to"
" storage and events is done via the generic `ComponentState<TContractState>`"
" type and not `ContractState`. Note that while the type is different, "
"accessing storage or emitting events is done similarly via "
"`self.storage_var_name.read()` or `self.emit(...).`"
msgstr ""
"与正常的智能合同的主要区别之一是,获取储存和事件是通过通用的 \" Commonent State <Ttract State'类型 \" 而不是 \""
" Parties State \" "
"类型进行的,请注意,虽然这种类型不同,但获取储存或排放事件也同样通过`self.storage_var_name.read()'或`self.emit(.)'进行。"

#: src/ch16-02-00-composability-and-components.md:203
msgid ""
"Note: To avoid the confusion between the embeddable name and the impl name, "
"we recommend keeping the suffix `Impl` in the impl name."
msgstr "注意:为了避免混淆嵌入式名称和内嵌式名称,我们建议把后缀`Impl'保留在内嵌式名称中。"

#: src/ch16-02-00-composability-and-components.md:208
msgid "Migrating a Contract to a Component"
msgstr "将合同移至一个构成部分"

#: src/ch16-02-00-composability-and-components.md:210
msgid ""
"Since both contracts and components share a lot of similarities, it's "
"actually very easy to migrate from a contract to a component. The only "
"changes required are:"
msgstr "由于合同和部件有许多相似之处,实际上很容易从合同转换成部件。"

#: src/ch16-02-00-composability-and-components.md:214
msgid "Adding the `#[starknet::component]` attribute to the module."
msgstr "向模块添加 {[ Starkknet:: 元件] 属性 。"

#: src/ch16-02-00-composability-and-components.md:215
msgid ""
"Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will "
"be embedded in another contract."
msgstr "将“{[embedable_as_as(name)]”属性添加到将嵌入另一合同的`impl'块。"

#: src/ch16-02-00-composability-and-components.md:217
msgid "Adding generic parameters to the `impl` block:"
msgstr "在“impl”区块中添加通用参数:"

#: src/ch16-02-00-composability-and-components.md:218
msgid "Adding `TContractState` as a generic parameter."
msgstr "添加`缔约国'作为通用参数。"

#: src/ch16-02-00-composability-and-components.md:219
msgid "Adding `+HasComponent<TContractState>` as an impl restriction."
msgstr "添加“Has Concomonent <Ttract State>”作为不设限制。"

#: src/ch16-02-00-composability-and-components.md:220
msgid ""
"Changing the type of the `self` argument in the functions inside the `impl` "
"block to `ComponentState<TContractState>` instead of `ContractState`."
msgstr "将`内设'区块内的功能中的`自我'论点类型改为`Compent State <Ttract State ',而不是`缔约国'。"

#: src/ch16-02-00-composability-and-components.md:223
msgid ""
"For traits that do not have an explicit definition and are generated using "
"`#[generate_trait]`, the logic is the same - but the trait is generic over "
"`TContractState` instead of `ComponentState<TContractState>`, as "
"demonstrated in the example with the `InternalTrait`."
msgstr ""
"对于没有明确定义、使用``[遗传_trait]产生的特性,逻辑是相同的,但这种特性一般高于`缔约国 ',而不是`进口国<缔约国 "
"',如`内部Trait'的例子所示。"

#: src/ch16-02-00-composability-and-components.md:228
msgid "Using Components Inside a Contract"
msgstr "合同内使用部件"

#: src/ch16-02-00-composability-and-components.md:230
msgid ""
"The major strength of components is how it allows reusing already built "
"primitives inside your contracts with a restricted amount of boilerplate. To"
" integrate a component into your contract, you need to:"
msgstr "组件的主要强度在于它允许您在合同中用数量有限的锅炉板重新使用已经建成的原始材料。 要将组件纳入合同,您需要:"

#: src/ch16-02-00-composability-and-components.md:234
msgid "Declare it with the `component!()` macro, specifying"
msgstr "以`构件!()`宏观,具体说明"

#: src/ch16-02-00-composability-and-components.md:236
msgid "The path to the component `path::to::component`."
msgstr "`路径:路径:到:部件'。"

#: src/ch16-02-00-composability-and-components.md:237
msgid ""
"The name of the variable in your contract's storage referring to this "
"component's storage (e.g. `ownable`)."
msgstr "您合同储存中提及该部件储存的变量的名称(例如`拥有')。"

#: src/ch16-02-00-composability-and-components.md:239
msgid ""
"The name of the variant in your contract's event enum referring to this "
"component's events (e.g. `OwnableEvent`)."
msgstr "合同中提及本组成部分的事件(例如`不可撤销的Event')时,合同中事件编号中的变式名称。"

#: src/ch16-02-00-composability-and-components.md:242
msgid ""
"Add the path to the component's storage and events to the contract's "
"`Storage` and `Event`. They must match the names provided in step 1 (e.g. "
"`ownable: ownable_component::Storage` and `OwnableEvent: "
"ownable_component::Event`)."
msgstr ""
"在合同的“标准”和“晚上”中加入部件储存和事件的途径,它们必须与第1步中提供的名称相符(例如,`可拥有的:可拥有的'部件::稳定'和`可拥有的Event:可拥有的_组件:Event')。"

#: src/ch16-02-00-composability-and-components.md:247
msgid ""
"The storage variable **MUST** be annotated with the `#[substorage(v0)]` "
"attribute."
msgstr "**** 存储变量** 附加“{[次存储(v0)]`属性”的附加说明。"

#: src/ch16-02-00-composability-and-components.md:250
msgid ""
"Embed the component's logic defined inside your contract, by instantiating "
"the component's generic impl with a concrete `ContractState` using an impl "
"alias. This alias must be annotated with `#[abi(embed_v0)]` to externally "
"expose the component's functions."
msgstr ""
"将部件的逻辑纳入合同中,即用一个混凝土的`缔约国'用隐形别名将部件的通用内插与混凝土`缔约国'连结起来,这一别名必须加上“[babi(embed_v0)]”加注,以外部暴露部件的功能。"

#: src/ch16-02-00-composability-and-components.md:255
msgid ""
"As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`. "
"Indeed, we don't want to expose externally the functions defined in this "
"impl. However, we might still want to access them internally."
msgstr ""
"如你所见,《内部问题》没有标记为`事实上,我们不想对外披露此规定所定义的功能。然而,我们可能仍想在内部查阅这些功能。"

#: src/ch16-02-00-composability-and-components.md:259
msgid ""
"For example, to embed the `Ownable` component defined above, we would do the"
" following:"
msgstr "例如,为了嵌入上文界定的`不可撤销'部分,我们将采取以下行动:"

#: src/ch16-02-00-composability-and-components.md:297
msgid ""
"The component's logic is now seamlessly part of the contract! We can "
"interact with the components functions externally by calling them using the "
"`IOwnableDispatcher` instantiated with the contract's address."
msgstr "部件的逻辑现在是合同的无缝部分! 我们可以使用“IOwnable Dispatcher ” 的地址与部件的外部功能进行互动。"

#: src/ch16-02-00-composability-and-components.md:310
msgid "Stacking Components for Maximum Composability"
msgstr "最大复合性堆叠元件"

#: src/ch16-02-00-composability-and-components.md:312
msgid ""
"The composability of components really shines when combining multiple of "
"them together. Each adds its features onto the contract. You can rely on "
"[Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) "
"implementation of components to quickly plug-in all the common "
"functionalities you need a contract to have."
msgstr ""
"组合多个组件时,部件的可配置性会真正闪亮。 每个组件都会在合同中添加其特性。 您可以依赖[ Openzeppelin's] "
"(https://github.com/ OpenZeppelin/cairo-contracts) 实施组件, 以快速插入所有您需要的通用功能 。"

#: src/ch16-02-00-composability-and-components.md:318
msgid ""
"Developers can focus on their core contract logic while relying on battle-"
"tested and audited components for everything else."
msgstr "开发者可以专注于其核心合同逻辑,同时依靠经过战斗试验和审计的部件来完成其他所有工作。"

#: src/ch16-02-00-composability-and-components.md:321
msgid ""
"Components can even [depend](./ch16-02-02-component-dependencies.md) on "
"other components by restricting the `TContractstate` they're generic on to "
"implement the trait of another component. Before we dive into this "
"mechanism, let's first look at [how components work under the "
"hood](./ch16-02-01-under-the-hood.md)."
msgstr ""
"部件甚至可以(./ch16-02-02- "
"构件依赖性.md)对其他部件进行限制,限制`合同国'的通用性,以实施其他部件的特性。在我们潜入这个机制之前,让我们首先研究[在引擎盖下如何使用部件](./ch16-02-01-under-"
"hood.md)。"

#: src/ch16-02-01-under-the-hood.md:1
msgid "Components: Under the Hood"
msgstr "组成部分:在兜帽下"

#: src/ch16-02-01-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to Starknet contracts. But how does "
"this magic actually happen behind the scenes?"
msgstr "部件为斯塔克内特合同提供了强大的模块性。 但是这个魔法是如何在幕后发生的呢?"

#: src/ch16-02-01-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the "
"mechanisms that enable component composability."
msgstr "本章将深入汇编器的内部,以解释能够使组件可混集的机制。"

#: src/ch16-02-01-under-the-hood.md:9
msgid "A Primer on Embeddable Impls"
msgstr "内嵌的内嵌的内嵌的隐隐性器的开源器"

#: src/ch16-02-01-under-the-hood.md:11
msgid ""
"Before digging into components, we need to understand _embeddable impls_."
msgstr "在挖掘部件之前,我们需要了解 易腐性无能。"

#: src/ch16-02-01-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`)"
" can be made embeddable. Embeddable impls can be injected into any contract,"
" adding new entry points and modifying the ABI of the contract."
msgstr ""
"Starknet 界面特性( 标记为 @ [ starknet:: interface :') 可以嵌入 。 任何合同中都可以注入嵌入的内脏, "
"添加新的切入点, 并修改合同的ABI 。"

#: src/ch16-02-01-under-the-hood.md:17
msgid "Let's look at an example to see this in action:"
msgstr "让我们举个例子,"

#: src/ch16-02-01-under-the-hood.md:42
msgid ""
"By embedding `SimpleImpl`, we externally expose `ret4` in the contract's "
"ABI."
msgstr "通过嵌入“SempImpl”号,我们外部暴露了合同ABI中的“rest4”号。"

#: src/ch16-02-01-under-the-hood.md:44
msgid ""
"Now that we’re more familiar with the embedding mechanism, we can now see "
"how components build on this."
msgstr "现在我们更熟悉嵌入机制, 现在可以看到组件是如何以此为基础的。"

#: src/ch16-02-01-under-the-hood.md:47
msgid "Inside Components: Generic Impls"
msgstr "内装部件:通用Imps"

#: src/ch16-02-01-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr "回想在组件中使用的 unpl 区块语法 :"

#: src/ch16-02-01-under-the-hood.md:58
msgid "The key points:"
msgstr "关键要点:"

#: src/ch16-02-01-under-the-hood.md:60
msgid ""
"`OwnableImpl` requires the implementation of the "
"`HasComponent<TContractState>` trait by the underlying contract, which is "
"automatically generated with the `component!()` macro when using a component"
" inside a contract."
msgstr "`不可承受性影响'要求根据基本合同执行`是否具有`缔约地国'的特性,在使用合同内某一组成部分时,该特性自动由`组成部分!'()`宏'产生。"

#: src/ch16-02-01-under-the-hood.md:65
msgid ""
"The compiler will generate an impl that wraps any function in `OwnableImpl`,"
" replacing the `self: ComponentState<TContractState>` argument with `self: "
"TContractState`, where access to the component state is made via the "
"`get_component` function in the `HasComponent<TContractState>` trait."
msgstr ""
"汇编者将生成一个密钥,将任何函数以`不可逆的Impl'封装,用`自我:缔约方'来取代`自我:构成国家'的争论,即通过`哈斯Component < "
"缔约国家'中的`get_构件'功能进入组成部分状态。"

#: src/ch16-02-01-under-the-hood.md:70
msgid ""
"For each component, the compiler generates a `HasComponent` trait. This "
"trait defines the interface to bridge between the actual `TContractState` of"
" a generic contract, and `ComponentState<TContractState>`."
msgstr "对于每个组成部分,汇编者产生一个`哈斯康本特'特性,这一特性界定了通用合同实际`缔约国'与`综合国家`缔约国'之间的连接点。"

#: src/ch16-02-01-under-the-hood.md:75
msgid "// generated per component\n"
msgstr "/ 每一组成部分产生的\n"

#: src/ch16-02-01-under-the-hood.md:85
msgid ""
"In our context `ComponentState<TContractState>` is a type specific to the "
"ownable component, i.e. it has members based on the storage variables "
"defined in `ownable_component::Storage`. Moving from the generic "
"`TContractState` to `ComponentState<TContractState>` will allow us to embed "
"`Ownable` in any contract that wants to use it. The opposite direction "
"(`ComponentState<TContractState>` to `ContractState`) is useful for "
"dependencies (see the `Upgradeable` component depending on an `IOwnable` "
"implementation example in the [Components dependencies "
"](./ch16-02-02-component-dependencies.md) section)."
msgstr ""
"就我们而言,`Compentate <Ttract State'`Compentate <Ttract State'`Confentate "


#: src/ch16-02-01-under-the-hood.md:94
msgid ""
"To put it briefly, one should think of an implementation of the above "
"`HasComponent<T>` as saying: **“Contract whose state T has the upgradeable "
"component”.**"
msgstr "简而言之,人们应该将上述`Has Concononent <T'的执行情况看作是说:** \" 其状态T具有可升级组成部分的合同 \" 。 **"

#: src/ch16-02-01-under-the-hood.md:98
msgid "`Ownable` is annotated with the `embeddable_as(<name>)` attribute:"
msgstr "`Ownable'带有`embedable_as( <name>)'属性的附加说明:"

#: src/ch16-02-01-under-the-hood.md:100
msgid ""
"`embeddable_as` is similar to `embeddable`; it only applies to impls of "
"`starknet::interface` traits and allows embedding this impl in a contract "
"module. That said, `embeddable_as(<name>)` has another role in the context "
"of components. Eventually, when embedding `OwnableImpl` in some contract, we"
" expect to get an impl with the following functions:"
msgstr ""
"`emeddable_as'与`embedable'类似;它只适用于`tarknet::Interface'特性,允许在合同模块中嵌入这种隐蔽,也就是说,`emeddable_as("
" <name>)'在组件方面还有另一个作用。"

#: src/ch16-02-01-under-the-hood.md:112
msgid ""
"Note that while starting with a function receiving the generic type "
"`ComponentState<TContractState>`, we want to end up with a function "
"receiving `ContractState`. This is where `embeddable_as(<name>)` comes in. "
"To see the full picture, we need to see what is the impl generated by the "
"compiler due to the `embeddable_as(Ownable)` annotation:"
msgstr ""
"请注意,在开始接收通用类型`Component State <Ttract "
"State'的函数时,我们希望最终拥有接收`缔约国'的函数。这是`emeddable_as "
"(<name>)'进入该函数的地方。要看到全景,我们需要看到由于`emeddable_as(Ownable)'a注解而由编译者生成的内线是什么:"

#: src/ch16-02-01-under-the-hood.md:140
msgid ""
"Note that thanks to having an impl of `HasComponent<TContractState>`, the "
"compiler was able to wrap our functions in a new impl that doesn’t directly "
"know about the `ComponentState` type. `Ownable`, whose name we chose when "
"writing `embeddable_as(Ownable)`, is the impl that we will embed in a "
"contract that wants ownership."
msgstr ""
"请注意,由于`HasComponent <Ttract State'``HasComponent <Ttractstate'' "
"`HasComponent <Ttracture'`Taccess "
"State'`Twonable'的暗号,编译者得以把我们的功能包装成一个新的暗号,它并不直接了解`Compent State'的类型。 `Ownable"
" ',我们在写`embeddobable_as(Ownnable)'时选择的名称,是我们希望所有权的合同中的暗号。"

#: src/ch16-02-01-under-the-hood.md:146
msgid "Contract Integration"
msgstr "合同一体化"

#: src/ch16-02-01-under-the-hood.md:148
msgid ""
"We've seen how generic impls enable component reusability. Next let's see "
"how a contract integrates a component."
msgstr "我们已看到通用内分解是如何使组件可再使用。接下来让我们看看合同如何结合组件。"

#: src/ch16-02-01-under-the-hood.md:151
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic "
"impl with the concrete `ContractState` of the contract."
msgstr "合同使用“简略别名**”来将部件与合同的混凝土`缔约国'的通用分解立即化。"

#: src/ch16-02-01-under-the-hood.md:161
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl "
"alias syntax. We’re instantiating the generic `OwnableImpl<TContractState>` "
"with the concrete type `ContractState`. Recall that "
"`OwnableImpl<TContractState>` has the `HasComponent<TContractState>` generic"
" impl parameter. An implementation of this trait is generated by the "
"`component!` macro."
msgstr ""
"上述线条使用开罗隐性嵌入机制与隐性别名词语法并用。我们正在将通用的“Ownable Impl <tract State ” 与具体类型的“Part "
"State ” 同步,回顾“Ownable Impl <Ttract State ” 拥有“Has Concomonent <Ttract State "
"” 通用隐性参数。这种特性的实施是由“组成部分!” 宏产生的。"

#: src/ch16-02-01-under-the-hood.md:167
msgid ""
"Note that only the using contract could have implemented this trait since "
"only it knows about both the contract state and the component state."
msgstr "请注意,只有使用合同才能实施这一特性,因为只有使用合同方既了解合同状况,又了解合同的构成状态。"

#: src/ch16-02-01-under-the-hood.md:171
msgid ""
"This glues everything together to inject the component logic into the "
"contract."
msgstr "这把所有东西粘在一起 将部件逻辑输入到合同中"

#: src/ch16-02-01-under-the-hood.md:173
msgid "Key Takeaways"
msgstr "密钥外出"

#: src/ch16-02-01-under-the-hood.md:175
msgid ""
"Embeddable impls allow injecting components logic into contracts by adding "
"entry points and modifying the contract ABI."
msgstr "可嵌入的不规则通过增加切入点和修改ABI合同,使合同中包含的成分具有逻辑性。"

#: src/ch16-02-01-under-the-hood.md:177
msgid ""
"The compiler automatically generates a `HasComponent` trait implementation "
"when a component is used in a contract. This creates a bridge between the "
"contract's state and the component's state, enabling interaction between the"
" two."
msgstr "汇编器自动生成“在合同中使用某一部件时,是否具有特性的履行”,从而在合同的状况和组成部分的状况之间架起桥梁,使两者之间能够相互作用。"

#: src/ch16-02-01-under-the-hood.md:181
msgid ""
"Components encapsulate reusable logic in a generic, contract-agnostic way. "
"Contracts integrate components through impl aliases and access them via the "
"generated `HasComponent` trait."
msgstr ""
"合同以通用的、合同不可知的方式将部件整合为可重复使用的逻辑,合同通过插管别名将部件整合为一体,并通过生成的 \" 是否具有 \" 特性获取这些部件。"

#: src/ch16-02-01-under-the-hood.md:184
msgid ""
"Components build on embeddable impls by defining generic component logic "
"that can be integrated into any contract wanting to use that component. Impl"
" aliases instantiate these generic impls with the contract's concrete "
"storage types."
msgstr ""
"部件以嵌入的内分泌内分泌为基础,界定通用部件逻辑,可以纳入任何希望使用该部件的合同。 隐含化别名,将这些通用内分泌与合同的混凝土储存类型同步。"

#: src/ch16-02-02-component-dependencies.md:3
msgid ""
"Working with components becomes more complex when we try to use one "
"component inside another. As mentioned earlier, a component can only be "
"embedded within a contract, meaning that it's not possible to embed a "
"component within another component. However, this doesn't mean that we can't"
" use one component inside another. In this section, we will see how to use a"
" component as a dependency of another component."
msgstr ""
"当我们试图在另一个组件中使用一个组件时,与组件一起工作会变得更加复杂。如前所述,一个组件只能嵌入合同中,这意味着无法在另一个组件中嵌入一个组件。然而,这并不意味着我们不能在另一个组件中使用一个组件。在本节中,我们将看到如何使用一个组件作为另一个组件的依赖性。"

#: src/ch16-02-02-component-dependencies.md:5
msgid ""
"Consider a component called `OwnableCounter` whose purpose is to create a "
"counter that can only be incremented by its owner. This component can be "
"embedded in any contract, so that any contract that uses it will have a "
"counter that can only be incremented by its owner."
msgstr ""
"考虑一个称为`不可撤销 "
"Coounter'的部件,其目的是建立一个只能由所有人加注的柜台,这一部件可以嵌入任何合同,这样,任何使用它的合同都有一个只能由所有人加注的柜台。"

#: src/ch16-02-02-component-dependencies.md:7
msgid ""
"The first way to implement this is to create a single component that "
"contains both counter and ownership features from within a single component."
" However, this approach is not recommended: our goal is to minimize the "
"amount of code duplication and take advantage of component reusability. "
"Instead, we can create a new component that _depends_ on the `Ownable` "
"component for the ownership features, and internally defines the logic for "
"the counter."
msgstr ""
"实现这一目的的第一个办法是从一个组成部分内建立一个单一组成部分,既包含反面特征,也包含所有权特征,然而,没有建议采用这一办法:我们的目标是尽量减少代码重复,利用组件可再使用性;相反,我们可以创建一个新的组成部分,在所有权特征的`可操作性'组成部分上,并内部界定柜台的逻辑。"

#: src/ch16-02-02-component-dependencies.md:9
msgid ""
"Listing 16-1 shows the complete implementation, which we'll break down right"
" after:"
msgstr "清单16-1显示了完全的落实情况,我们将在以下各段之后予以分解:"

#: src/ch16-02-02-component-dependencies.md:58
msgid "<span class=\"caption\">Listing 16-1: An OwnableCounter Component</span>"
msgstr "<span class=\"Caption\" > listing 16-1: 自有可操作 Counter 组件 </span>"

#: src/ch16-02-02-component-dependencies.md:60
msgid "Specificities"
msgstr "具体特性"

#: src/ch16-02-02-component-dependencies.md:62
msgid "Specifying Dependencies on Another Component"
msgstr "指定对另一个构成部分的依赖"

#: src/ch16-02-02-component-dependencies.md:73
msgid ""
"In [chapter 8](./ch08-02-traits-in-cairo.md), we introduced trait bounds, "
"which are used to specify that a generic type must implement a certain "
"trait. In the same way, we can specify that a component depends on another "
"component by restricting the `impl` block to be available only for contracts"
" that contain the required component. In our case, this is done by adding a "
"restriction `impl Owner: ownable_component::HasComponent<TContractState>`, "
"which indicates that this `impl` block is only available for contracts that "
"contain an implementation of the `ownable_component::HasComponent` trait. "
"This essentially means that the \\`TContractState' type has access to the "
"ownable component. See [Components under the hood](ch16-02-01-under-the-"
"hood.md#inside-components-generic-impls) for more information."
msgstr ""
"在[第8章] (./ch08-02-traits- in-"
"cairo.md)中,我们引入了特质界限,这些界限用于具体说明通用类型必须执行某种特性,同样,我们可以具体指明,某一组成部分取决于另一组成部分,方法是限制“只有包含所需组成部分的合同才有`不便'块。就我们而言,这样做的方法是增加一项限制,即`不完全所有人:拥有的构成部分:Hasconconcontent"
" <Ttratic-state "
"',这表明,这一`不便'区块仅适用于含有`可拥有的构成部分:Hascompent`特性的合同,这基本上意味着“缔约国”类型可以使用可自行具备的构成部分。"

#: src/ch16-02-02-component-dependencies.md:76
msgid ""
"Although most of the trait bounds were defined using \\[anonymous "
"parameters\\]\\[anonymous generic impl operator\\], the dependency on the "
"`Ownable` component is defined using a named parameter (here, `Owner`). We "
"will need to use this explicit name when accessing the `Ownable`component "
"within the`impl` block."
msgstr ""
"虽然大多数特质界限是用\\[匿名参数\\]\\[匿名通用杂质运算符]来界定的,但依赖`不可腐蚀'组件的定义是使用一个命名参数(此处为`所有者'),我们需要在使用`不易'块内的`不可腐蚀'组件时使用这一明确名称。"

#: src/ch16-02-02-component-dependencies.md:78
msgid ""
"While this mechanism is verbose and may not be easy to approach at first, it"
" is a powerful leverage of the trait system in Cairo. The inner workings of "
"this mechanism are abstracted away from the user, and all you need to know "
"is that when you embed a component in a contract, all other components in "
"the same contract can access it."
msgstr ""
"虽然这一机制是多变的,一开始可能不容易接近,但它是开罗特质系统的强大杠杆。 "
"这一机制的内部运作被从用户中抽取出来,你需要知道的是,当你在合同中嵌入一个组成部分时,同一合同中所有其他组成部分都可以使用它。"

#: src/ch16-02-02-component-dependencies.md:82
msgid ""
"\\[anonymous generic impl operator\\]: ./ch08-01-generic-data-types "
"md#anonymous-generic-implementation-parameter--operator"
msgstr ""
"\\[匿名通用通用内插操作员\\]:./ch08-01-generic-d-d-type-d-md#anonomous-generic-"
"production-parater-operator"

#: src/ch16-02-02-component-dependencies.md:84
msgid "Using the Dependency"
msgstr "使用依赖关系"

#: src/ch16-02-02-component-dependencies.md:86
msgid ""
"Now that we have made our `impl` depend on the `Ownable` component, we can "
"access its functions, storage, and events within the implementation block. "
"To bring the `Ownable` component into scope, we have two choices, depending "
"on whether we intend to mutate the state of the `Ownable` component or not. "
"If we want to access the state of the `Ownable` component without mutating "
"it, we use the `get_dep_component!` macro. If we want to mutate the state of"
" the `Ownable` component (for example, change the current owner), we use the"
" `get_dep_component_mut!` macro. Both macros take two arguments: the first "
"is `self`, either as a snapshot or by reference depending on mutability, "
"representing the state of the component using the dependency, and the second"
" is the component to access."
msgstr ""
"现在,我们已经将“不易”部分作为“不易”部分的“不易”部分,我们可以进入其功能、储存和事件,为了将“不易”部分纳入范围,我们有两个选择,这取决于我们是否打算改变“不易”部分的状态。如果我们想在不进行突变的情况下进入“不易”部分的状态,我们就使用“get_dep_conduction!”宏。如果我们想改变“不易”部分的状态(例如,改变当前所有者),我们就使用“get_dep_deproduction_mut!”宏。两种宏都有两个论点:第一是`self',要么是作为快照,要么是参考根据易变,代表使用依赖的部件的状态;第二是获取的组成部分。"

#: src/ch16-02-02-component-dependencies.md:98
msgid ""
"In this function, we want to make sure that only the owner can call the "
"`increment` function. We need to use the `assert_only_owner` function from "
"the `Ownable` component. We'll use the `get_dep_component!` macro which will"
" return a snapshot of the requested component state, and call "
"`assert_only_owner` on it, as a method of that component."
msgstr ""
"在此函数中, 我们希望确保只有所有者才能使用“ 加速” 功能, 我们需要使用“ 无效” 组件中的“ 资产独有” 所有人” 功能。 我们将使用“ get_"
" dep_ party! ” 宏, 该宏将返回所请求组件状态的快照, 并使用“ 资产独有” 所有人, 作为该组件的一种方法。"

#: src/ch16-02-02-component-dependencies.md:101
msgid ""
"For the `transfer_ownership` function, we want to mutate that state to "
"change the current owner. We need to use the `get_dep_component_mut!` macro,"
" which will return the requested component state as a mutable reference, and"
" call `transfer_ownership` on it."
msgstr ""
"对于`转让_所有权'功能,我们要改变该状态以改变当前所有者。 我们需要使用`get_dep_ controduction_mut!' 宏, "
"该宏将把请求的构成部分状态恢复为可变的参考, 并称之为`转让_ 所有权'。"

#: src/ch16-02-02-component-dependencies.md:112
msgid ""
"It works exactly the same as `get_dep_component!` except that we need to "
"pass the state as a `ref` so we can mutate it to transfer the ownership."
msgstr "它与`get_dep_ particip!'完全相同,但我们需要通过国家作为`ref',以便我们可以改变国家,转让所有权。"

#: src/ch16-02-03-testing-components.md:3
msgid ""
"Testing components is a bit different than testing contracts. Contracts need"
" to be tested against a specific state, which can be achieved by either "
"deploying the contract in a test, or by simply getting the `ContractState` "
"object and modifying it in the context of your tests."
msgstr "测试组件与测试合同略有不同,合同需要根据特定状态进行测试,具体做法可以是将合同部署在测试中,或者只是获取`缔约国'标的并在测试中加以修改。"

#: src/ch16-02-03-testing-components.md:6
msgid ""
"Components are a generic construct, meant to be integrated in contracts, "
"that can't be deployed on their own and don't have a `ContractState` object "
"that we could use. So how do we test them?"
msgstr "部件是一种通用结构,意在纳入合同,不能自行部署,没有我们可以使用的`合同国'物体。我们如何测试它们?"

#: src/ch16-02-03-testing-components.md:8
msgid ""
"Let's consider that we want to test a very simple component called "
"\"Counter\", that will allow each contract to have a counter that can be "
"incremented. The component is defined in Listing 16-2:"
msgstr "让我们考虑一下,我们想测试一个非常简单的部件,叫做“Counter”, 它可以让每份合同都有一个可以增量的柜台。"

#: src/ch16-02-03-testing-components.md:33
msgid "<span class=\"caption\">Listing 16-2: A simple Counter component</span>"
msgstr "<span类=\"Caption\" > listing 16-2:一个简单的对应组件 </span>"

#: src/ch16-02-03-testing-components.md:35
msgid "Testing the Component by Deploying a Mock Contract"
msgstr "通过部署模拟合同测试部件"

#: src/ch16-02-03-testing-components.md:37
msgid ""
"The easiest way to test a component is to integrate it within a mock "
"contract. This mock contract is only used for testing purposes, and only "
"integrates the component you want to test. This allows you to test the "
"component in the context of a contract, and to use a Dispatcher to call the "
"component's entry points."
msgstr ""
"测试部件的最简单方式是将其整合到模拟合同中。 此模拟合同仅用于测试目的, 并且只整合您想要测试的部件。 这样您就可以在合同中测试部件, "
"并使用调度器调用组件的切入点 。"

#: src/ch16-02-03-testing-components.md:39
msgid "We can define such a mock contract as follows:"
msgstr "我们可以将这种模拟合同定义如下:"

#: src/ch16-02-03-testing-components.md:65
msgid ""
"This contract is entirely dedicated to testing the `Counter` component. It "
"embeds the component with the `component!` macro, exposes the component's "
"entry points by annotating the impl aliases with `#[abi(embed_v0)]`."
msgstr "本合同完全用于测试`计算'部件,将部件嵌入`构件!`宏观,通过用`{{ib(embed_v0)]'注解别名,暴露部件的切入点。"

#: src/ch16-02-03-testing-components.md:67
msgid ""
"We also need to define an interface that will be required to interact "
"externally with this mock contract."
msgstr "我们还需要确定一个接口,以便外部与这一模拟合同进行互动。"

#: src/ch16-02-03-testing-components.md:77
msgid ""
"We can now write tests for the component by deploying this mock contract and"
" calling its entry points, as we would with a typical contract."
msgstr "我们现在可以通过部署这一模拟合同,并按典型合同要求其入境点,对组成部分进行测试。"

#: src/ch16-02-03-testing-components.md:107
msgid "Testing Components Without Deploying a Contract"
msgstr "未部署合同的测试部件"

#: src/ch16-02-03-testing-components.md:109
msgid ""
"In [Components under the hood](./ch16-02-01-under-the-hood.md), we saw that "
"components leveraged genericity to define storage and logic that could be "
"embedded in multiple contracts. If a contract embeds a component, a "
"`HasComponent` trait is created in this contract, and the component methods "
"are made available."
msgstr ""
"在[头罩以下的构件](./ch16-02-01-under-"
"world.md)中,我们看到这些构件利用通用性来界定储存和可嵌入多个合同的逻辑,如果合同包含一个构件,则在本合同中设定了`Hasconcompent'特性,并提供了构件方法。"

#: src/ch16-02-03-testing-components.md:111
msgid ""
"This informs us that if we can provide a concrete `TContractState` that "
"implements the `HasComponent` trait to the `ComponentState` struct, should "
"be able to directly invoke the methods of the component using this concrete "
"`ComponentState` object, without having to deploy a mock."
msgstr ""
"这告诉我们,如果我们能够提供具体的`缔约国 "
"',以落实`进口国'结构`存在'特性,就应能直接援引组成部分的方法,使用这一具体的`含水层国'物体,而不必部署假象。"

#: src/ch16-02-03-testing-components.md:113
msgid ""
"Let's see how we can do that by using type aliases. We still need to define "
"a mock contract - let's use the same as above - but this time, we won't need"
" to deploy it."
msgstr "让我们看看我们如何通过使用别名来做到这一点。我们仍然需要定义一个模拟合同,让我们使用与上面相同的方法,但这次,我们不需要部署它。"

#: src/ch16-02-03-testing-components.md:115
msgid ""
"First, we need to define a concrete implementation of the generic "
"`ComponentState` type using a type alias. We will use the "
"`MockContract::ContractState` type to do so."
msgstr "首先,我们需要用别名界定具体实施通用的`实体国'类型,我们将使用`协议:缔约国'类型这样做。"

#: src/ch16-02-03-testing-components.md:123
#: src/ch16-02-03-testing-components.md:167
msgid "// You can derive even `Default` on this type alias\n"
msgstr "/ 你可以在这种别名上甚至得出 \" 违约 \" 。\n"

#: src/ch16-02-03-testing-components.md:144
msgid ""
"We defined the `TestingState` type as an alias of the "
"`CounterComponent::ComponentState<MockContract::ContractState>` type. By "
"passing the `MockContract::ContractState` type as a concrete type for "
"`ComponentState`, we aliased a concrete implementation of the "
"`ComponentState` struct to `TestingState`."
msgstr ""
"我们把`试验国'类型界定为`管制国:Commonent State <Mock Contract:Contront:Controntate_Mock "
"Contract:Parties_BAR__BAR__BAR__BAR__BAR_Controntry_BAR__BAR__BAR__BAR_Controute:Controntate_Mock"
" "
"Contract:Control_BAR__BAR__BAR_BAR__BAR__BAR_BAR__BAR_BAR__BAR__BAR_BAR__BAR_BAR__BAR_BAR__BAR__BAR_BAR__BAR__BAR__BAR__BAR__BAR__BAR__BAR__BAR__BAR_C_Contate:Contractate_Contractate:Contractal:Contractal:Ct_Part:Ctate_Parttate_Parttate_Ctate_Contate_Contate_Contate_Contate_Contate_Cornate_Ctate_Cord_Cord_"
" tyate_Cornate_ tynate_ tynate_Contate_BAR_Con_Con_BAR_Contate_Contate_ "
"tynate_ tynate_Contate_Contate_ ty_ ty_ tynation_ ty_ ty_ ty_我们_ tynate_ "
"tynate_thetate_thetrocordate_Ctate_ tynate_ "
"tynate_我们)的别名别名别名别名别名别名,我们)的别名别名的别名别名别名别名别名别名,我们用的别名别名别名,我们用的别名别名名名,我们,我们,我们用的别名名名名名名名名名名名名名名名名名名,我们具体执行`con,我们的别名名,我们"

#: src/ch16-02-03-testing-components.md:146
msgid ""
"Because `MockContract` embeds `CounterComponent`, the methods of "
"`CounterComponent` defined in the `CounterImpl` block can now be used on a "
"`TestingState` object."
msgstr ""
"由于`Mock Contract'嵌入`Counter Concoment ',`Counter Impl'区块界定的`Counter "
"Concoment'方法现在可用于`试验国'物体。"

#: src/ch16-02-03-testing-components.md:148
msgid ""
"Now that we have made these methods available, we need to instantiate an "
"object of type `TestingState`, that we will use to test the component. We "
"can do so by calling the `component_state_for_testing` function, which "
"automatically infers that it should return an object of type `TestingState`."
msgstr ""
"既然我们提供了这些方法,我们需要即时使用一个`试验国'类型的物体,用来测试部件,我们可以称之为`组成部分_state_for_test'功能,自动推断它应该返回一个`试验国'类型的物体。"

#: src/ch16-02-03-testing-components.md:150
msgid ""
"We can even implement this as part of the `Default` trait, which allows us "
"to return an empty `TestingState` with the `Default::default()` syntax."
msgstr "我们甚至可以将此作为`违约'特性的一部分加以实施,这使我们能够用`违约:违约()`语法”归还一个空的`试验国'。"

#: src/ch16-02-03-testing-components.md:152
msgid "Let's summarize what we've done so far:"
msgstr "让我们总结一下我们迄今所做的工作:"

#: src/ch16-02-03-testing-components.md:154
msgid "We defined a mock contract that embeds the component we want to test."
msgstr "我们定义了一个模拟合同 嵌入我们想要测试的部分"

#: src/ch16-02-03-testing-components.md:155
msgid ""
"We defined a concrete implementation of `ComponentState<TContractState>` "
"using a type alias with `MockContract::ContractState`, that we named "
"`TestingState`."
msgstr ""
"我们用一种别名与我们称为`试验国'的`Mock Contract:Cates'界定了`Component State <Tather "
"State'的具体实施。"

#: src/ch16-02-03-testing-components.md:156
msgid ""
"We defined a function that uses `component_state_for_testing` to return a "
"`TestingState` object."
msgstr "我们定义了一种功能,即使用`元件_state_for_test'来返回`试验国'物体。"

#: src/ch16-02-03-testing-components.md:158
msgid ""
"We can now write tests for the component by calling its functions directly, "
"without having to deploy a mock contract. This approach is more lightweight "
"than the previous one, and it allows testing internal functions of the "
"component that are not exposed to the outside world trivially."
msgstr ""
"我们现在可以通过直接调用部件的功能来为部件写测试,而不必部署模拟合同。 这种方法比前一种更轻,它允许测试部件的内部功能,而这些功能与外界无关。"

#: src/ch16-03-upgradeability.md:1
msgid "Upgradeable Contracts"
msgstr "可升级合同"

#: src/ch16-03-upgradeability.md:3
msgid ""
"Starknet separates contracts into classes and instances, making it simple to"
" upgrade a contract's logic without affecting its state."
msgstr "Starknet将合同分为等级和实例,使得在不影响合同状态的情况下提高合同逻辑的提升变得简单易行。"

#: src/ch16-03-upgradeability.md:5
msgid ""
"A contract class is the definition of the semantics of a contract. It "
"includes the entire logic of a contract: the name of the entry points, the "
"addresses of the storage variables, the events that can be emitted, etc. "
"Each class is uniquely identified by its class hash. A class does not have "
"its own storage: it's only a definition of logic."
msgstr ""
"合同类别是合同语义的定义。 它包括合同的整个逻辑: 切入点的名称、 存储变量的地址、 可以排放的事件等等。 每个类别都有其分类散列所独有的特征。 "
"一个类别没有它自己的储存: 它只是逻辑的定义 。"

#: src/ch16-03-upgradeability.md:7
msgid ""
"Classes are typically identified by a [class "
"hash](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-"
"hash). When declaring a class, the network registers it and assigns a unique"
" hash used to identify the class and deploy contract instances from it."
msgstr ""
"课程通常由[类散列 "
"(https://docs.starknet.io/document/architecture_and_concepts/Smart_contracts/leg-"
"hash) 确定,在宣布一个类别时,网络登记并指定一个独特的散列,用于确定类别和从中部署合同实例。"

#: src/ch16-03-upgradeability.md:9
msgid ""
"A contract instance is a deployed contract corresponding to a class, with "
"its own storage."
msgstr "合同实例是相当于某一类的部署合同,有其本身的储存。"

#: src/ch16-03-upgradeability.md:11
msgid ""
"Starknet natively supports upgradeable contracts through the "
"`replace_class_syscall` [system "
"call](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-"
"calls-cairo1/), enabling simple contract upgrades without affecting the "
"contract's state."
msgstr ""
"Starknet本地支持通过“系统呼叫”(https://docs.starknet.io/document/architecture_and_concepts/Smart_contracts/system-"
"calls-cairo1/)更新可升级的合同,使简单的合同升级能够在不影响合同状态的情况下进行。"

#: src/ch16-03-upgradeability.md:16
msgid "Upgrading Contracts"
msgstr "升级合同"

#: src/ch16-03-upgradeability.md:18
msgid ""
"To upgrade a contract, expose an entry point that executes "
"`replace_class_syscall` with the new class hash as an argument:"
msgstr "为了提升合同,将执行`替换'类叙级呼叫'的切入点与新的类散列作为论据:"

#: src/ch16-03-upgradeability.md:31
msgid ""
"<span class=\"caption\">Listing 16-3: Exposing `replace_class_syscall` to "
"update the contract's class</span>"
msgstr "<span类=“Caption” > listing 16-3: 披露`替换_level_syscall'更新合同的等级 </span>"

#: src/ch16-03-upgradeability.md:33
msgid ""
"Note: Thoroughly review changes and potential impacts before upgrading, as "
"it's a delicate procedure with security implications. Don't allow arbitrary "
"addresses to upgrade your contract."
msgstr "注:在升级前彻底审查变化和潜在影响,因为这是一个微妙的程序,涉及安全问题。不允许任意地址升级合同。"

#: src/ch16-03-upgradeability.md:35
msgid "Upgradeable Component"
msgstr "可升级的构成部分"

#: src/ch16-03-upgradeability.md:37
msgid ""
"OpenZeppelin Contracts for Cairo provides the `Upgradeable` component that "
"can be embedded into your contract to make it upgradeable. This component is"
" a simple way to add upgradeability to your contract while relying on an "
"audited library. It can be combined with the `Ownable` component to restrict"
" the upgradeability to a single address, so that the contract owner has the "
"exclusive right to upgrade the contract."
msgstr ""
"开罗OpenZepperin合同提供`升级'部分,可以嵌入合同,使之升级,这是在依赖经审计的图书馆的同时增加合同升级的简单方式,可以与`可更新'部分相结合,将升级限制在单一地址,以便合同所有人有升级合同的专属权利。"

#: src/ch16-03-upgradeability.md:51
msgid "/// Ownable\n"
msgstr "///可拥有\n"

#: src/ch16-03-upgradeability.md:56
msgid "/// Upgradeable\n"
msgstr "//可升级\n"

#: src/ch16-03-upgradeability.md:84
msgid "// This function can only be called by the owner\n"
msgstr "/ 此函数只能由所有人调用。\n"

#: src/ch16-03-upgradeability.md:87
msgid "// Replace the class hash upgrading the contract\n"
msgstr "替换类散列的升级合同\n"

#: src/ch16-03-upgradeability.md:94
msgid ""
"<span class=\"caption\">Listing 16-4 Integrating OpenZeppelin's Upgradeable "
"component in a contract</span>"
msgstr "<span类=“caption” > listing 16-4 将 OpenZepperin 的可升级组件纳入合同 </span>"

#: src/ch16-03-upgradeability.md:96
msgid ""
"For more information, please refer to the [OpenZeppelin docs API "
"reference](https://docs.openzeppelin.com/contracts-"
"cairo/0.9.0/api/upgrades)."
msgstr ""
"详情请查阅[开放Zeppelin docs API参考](https://docs.openzeppelin.com/contracts-"
"cairo/0.9.0/api/upgrations)。"

#: src/ch16-04-L1-L2-messaging.md:1
msgid "L1-L2 Messaging"
msgstr "L1-L2 通信"

#: src/ch16-04-L1-L2-messaging.md:3
msgid ""
"A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr "第2层的一个关键特征是它与第1层相互作用的能力。"

#: src/ch16-04-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` messaging system, which is different from its "
"consensus mechanism and the submission of state updates on L1. Messaging is "
"a way for smart-contracts on L1 to interact with smart-contracts on L2 (or "
"the other way around), allowing us to do \"cross-chain\" transactions. For "
"example, we can do some computations on a chain and use the result of this "
"computation on the other chain."
msgstr ""
"Starknet有自己的“L1-L2”信息系统,与它的协商一致机制不同,提交有关L1的国家最新情况。 "
"通信是L1的智能合同与L2(或其他途径)的智能合同互动的一种方式,使我们能够进行“跨链”交易。例如,我们可以在链条上进行一些计算,并在另一链条上使用计算结果。"

#: src/ch16-04-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to "
"bridge tokens from Ethereum to Starknet. You will simply have to deposit "
"your tokens in the L1 bridge contract, which will automatically trigger the "
"minting of the same token on L2. Another good use case for `L1-L2` messaging"
" would be [DeFi pooling](https://starkware.co/resource/defi-pooling/)."
msgstr ""
"Starknet上的桥梁都使用“L1-L2”信息。让我们假设你想将标志从Etherom连接到Starknet。你只需在L1桥合同中交存您的标志,这将自动触发L2上的相同标志的混合。"
" “L1-L2”信息的另一个有用实例是[DeFi 信息(DeFi 集合)(https://starkware.co/resource/defi-"
"pooling/)。"

#: src/ch16-04-L1-L2-messaging.md:9
msgid ""
"On Starknet, it's important to note that the messaging system is "
"**asynchronous** and **asymmetric**."
msgstr "在史塔克内特,重要的是要指出, 信息系统是**非同步** 和**非对称** 。"

#: src/ch16-04-L1-L2-messaging.md:11
msgid ""
"**Asynchronous**: this means that in your contract code (being Solidity or "
"Cairo), you can't wait the result of the message being sent on the other "
"chain within your contract code execution."
msgstr "** 同步**:这意味着在您的合同代码(即“团结”或“开罗”)中,您不能等待在合同代码执行中发送到另一条链条的信息的结果。"

#: src/ch16-04-L1-L2-messaging.md:12
msgid ""
"**Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is "
"fully automated by the Starknet sequencer, which means that the message is "
"being automatically delivered to the target contract on L2. However, when "
"sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the"
" message is sent on L1 by the Starknet sequencer. You must then consume the "
"message manually via a transaction on L1."
msgstr ""
"** "
"对称**:从Etheum向Starknet(`L1->L2')发送电文,由斯塔克内特测序器完全自动化,这意味着电文正在自动传送到L2的目标合同上,但是,在从Starknet向Etheum(`L2->L1')发送电文时,只有电文的散列由斯塔克内特测序器在L1上发出。然后,您必须通过L1的交易手动使用电文。"

#: src/ch16-04-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr "让我们深入探讨细节。"

#: src/ch16-04-L1-L2-messaging.md:18
msgid "The StarknetMessaging Contract"
msgstr "StarknetMessignMessating 合同"

#: src/ch16-04-L1-L2-messaging.md:20
msgid ""
"The crucial component of the `L1-L2` Messaging system is the "
"[`StarknetCore`](https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4)"
" contract. It is a set of Solidity contracts deployed on Ethereum that "
"allows Starknet to function properly. One of the contracts of `StarknetCore`"
" is called `StarknetMessaging` and it is the contract responsible for "
"passing messages between Starknet and Ethereum. `StarknetMessaging` follows "
"an [interface](https://github.com/starkware-libs/cairo-"
"lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6)"
" with functions allowing to send message to L2, receiving messages on L1 "
"from L2 and canceling messages."
msgstr ""
"`L1-L2'通信系统的关键组成部分是[StarknetCore'合同[https://etherscan.io/adest/0xc662c410C0ECf747543f5bA909660f6ABeBD9C8c4],这是在Etheum上部署的一套固态合同,使Starknet能够正常运作。`StarknetCore'合同之一是`StarknetMessagage'合同之一,它负责Starknet和Eeenum之间传递信息。`StarknetMessageing'遵循[Interface](https://github.com/starkware-"
"libs/cairo-"
"lang/b/42335f45477b158c81c86c2747471c165/src/starkware/starknet/eth/IstarknetMessageing.solL6),其功能允许向L2发送信息,从L2接收L1和取消信息。"

#: src/ch16-04-L1-L2-messaging.md:51
msgid "<span class=\"caption\"> Starknet messaging contract interface</span>"
msgstr "<span类=“caption”>>斯塔克内通信合同界面 </span>"

#: src/ch16-04-L1-L2-messaging.md:53
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly "
"listening to the logs emitted by the `StarknetMessaging` contract on "
"Ethereum. Once a message is detected in a log, the sequencer prepares and "
"executes a `L1HandlerTransaction` to call the function on the target L2 "
"contract. This takes up to 1-2 minutes to be done (few seconds for ethereum "
"block to be mined, and then the sequencer must build and execute the "
"transaction)."
msgstr ""
"在`L1->L2'电文的情况下,斯塔克内特测序器不断监听Etheum的`StarknetMessmaging'合同所排放的日志,一旦在日志中检测到信息,测序器就准备并执行一项`L1HandlerTransaction"
" ',以调用目标L2合同上的函数。这需要多达1-2分钟的时间(要开采的乙醚块的秒,然后序列器必须构建和执行交易)。"

#: src/ch16-04-L1-L2-messaging.md:56
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of "
"the block produced. When the sequencer produces a block, it sends the hash "
"of each message prepared by contracts execution to the `StarknetCore` "
"contract on L1, where they can then be consumed once the block they belong "
"to is proven and verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""
"`L2>L1'电文由L2的合同执行书制成,是所生产的区块的一部分,当测序器产生一个区块时,它将执行合同的每条电文的散发件发送给L1的`StarknetCore'合同,一旦Ethereum(目前大约为3-4小时)证明和核实其所属区块,这些电文就可以消耗。"

#: src/ch16-04-L1-L2-messaging.md:62
msgid "Sending Messages from Ethereum to Starknet"
msgstr "从 Etheum 发送信件到 Starknet"

#: src/ch16-04-L1-L2-messaging.md:64
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity "
"contracts must call the `sendMessageToL2` function of the "
"`StarknetMessaging` contract. To receive these messages on Starknet, you "
"will need to annotate functions that can be called from L1 with the "
"`#[l1_handler]` attribute."
msgstr ""
"如果您想要从 Etheum 发送信息到 Starknet, 您的 Solicity 合同必须调用“ SendMessage ToL2” 合同的功能。 "
"要在 Starknet 上接收这些消息, 您需要用 {l1_ handler} 属性给 L1 调用函数加注 。"

#: src/ch16-04-L1-L2-messaging.md:66
msgid ""
"Let's take a simple contract taken from [this "
"tutorial](https://github.com/glihm/starknet-messaging-"
"dev/blob/main/solidity/src/ContractMsg.sol) where we want to send a message "
"to Starknet. The `_snMessaging` is a state variable already initialized with"
" the address of the `StarknetMessaging` contract. You can check all Starknet"
" contract and sequencer addresses "
"[here](https://docs.starknet.io/documentation/tools/important_addresses/)."
msgstr ""
"让我们从[这一教程](https://github.com/glihm/starknet- messsage-"
"dev/blob/main/solicity/src/contractingMsg.sol)取得一个简单的合同,我们想向Starknet发送一个信息。“snMessage”是一个州变量,已经根据StarknetMessmaging合同的地址启动。你可以查看所有"
" "
"Starknet合同和测序器地址[此处](https://docs.starknet.io/documentation/tools/importent_addresses/)。"

#: src/ch16-04-L1-L2-messaging.md:70
msgid "// Sends a message on Starknet with a single felt.\n"
msgstr "在史塔克网上发出一个信息 只有一个感觉\n"

#: src/ch16-04-L1-L2-messaging.md:79
msgid ""
"// We \"serialize\" here the felt into a payload, which is an array of "
"uint256.\n"
msgstr "我们在这里“序列化”到一个有效载荷, 也就是五角形256的阵列。\n"

#: src/ch16-04-L1-L2-messaging.md:83
msgid "// msg.value must always be >= 20_000 wei.\n"
msgstr "msg. 值必须始终是  20_ 000 wei。\n"

#: src/ch16-04-L1-L2-messaging.md:92
msgid ""
"The function sends a message with a single felt value to the "
"`StarknetMessaging` contract. Please note that if you want to send more "
"complex data you can. Just be aware that your Cairo contract will only "
"understand `felt252` data type. So you must ensure that the serialization of"
" your data into the `uint256` array follow the Cairo serialization scheme."
msgstr ""
"此函数向`StarknetMessmaging' 合同发送含有单一感觉值的信息。 请注意, 如果您想要发送更复杂的数据, 您可以发送。 请注意, "
"您的开罗合同只能理解“ felt252” 数据类型 。 因此您必须确保您的数据序列化为“ 昆特256” 数组遵循开罗序列化方案。"

#: src/ch16-04-L1-L2-messaging.md:95
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the "
"minimum value we've to send here is `20k wei`, due to the fact that the "
"`StarknetMessaging` contract will register the hash of our message in the "
"storage of Ethereum."
msgstr ""
"必须指出的是,我们的价值是: msg.valu "
"*。事实上,我们在此必须发送的最低价值是`20kwei',因为`StarknetMessmaging'合同将在Etheyum的储存中登记我们信息的散列。"

#: src/ch16-04-L1-L2-messaging.md:98
msgid ""
"In addition to those `20k wei`, since the `L1HandlerTransaction` executed by"
" the sequencer is not tied to any account (the message originates from L1), "
"you must also ensure that you pay enough fees on L1 for your message to be "
"deserialized and processed on L2."
msgstr ""
"除了这些`20kwei'外,由于定序器执行的`L1Handler "
"Transaction'与任何账户(电文来自L1)没有联系(电文来自L1),你还必须确保支付足够的L1费用,使您的电文在L2上被解密和处理。"

#: src/ch16-04-L1-L2-messaging.md:101
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as "
"it would be done for an `Invoke` transaction. For this, you can profile the "
"gas consumption using `starkli` or `snforge` to estimate the cost of your "
"message execution."
msgstr ""
"`L1Handler "
"Transaction'的费用是按对`Invoke'交易的定期计算,为此,您可以用`sharkli'或`Snforge'来估计信息执行费用,来描述气体消耗情况。"

#: src/ch16-04-L1-L2-messaging.md:104
msgid "The signature of the `sendMessageToL2` is:"
msgstr "`发送邮件至L2'的签名是:"

#: src/ch16-04-L1-L2-messaging.md:114
msgid "The parameters are as follows:"
msgstr "参数如下:"

#: src/ch16-04-L1-L2-messaging.md:116
msgid "`toAddress`: The contract address on L2 that will be called."
msgstr "`联系':将调用L2的合同地址。"

#: src/ch16-04-L1-L2-messaging.md:117
msgid ""
"`selector`: The selector of the function of this contract at `toAddress`. "
"This selector (function) must have the `#[l1_handler]` attribute to be "
"callable."
msgstr "`选择方':本合同在`toAddress'的函数选择方。此选择方( 函数) 必须具有{[l1_ handler] 属性可调用 。"

#: src/ch16-04-L1-L2-messaging.md:118
msgid ""
"`payload`: The payload is always an array of `felt252` (which are "
"represented by `uint256` in Solidity). For this reason we've inserted the "
"input `myFelt` into the array. This is why we need to insert the input data "
"into an array."
msgstr ""
"`有效载荷':有效载荷始终是`felt252'的阵列(由`inut256'在“固体”中表示),因此,我们已将输入的`myFelt'插入阵列,这就是为什么我们需要将输入的数据插入阵列的原因。"

#: src/ch16-04-L1-L2-messaging.md:121
msgid "On the Starknet side, to receive this message, we have:"
msgstr "在史塔克内特那边,为了接收这个信息,我们有:"

#: src/ch16-04-L1-L2-messaging.md:128
msgid ""
"// You can now use the data, automatically deserialized from the message "
"payload.\n"
msgstr "/ 你现在可以使用数据,自动从电文有效载荷中解密。\n"

#: src/ch16-04-L1-L2-messaging.md:133
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers "
"are special functions that can only be executed by a `L1HandlerTransaction`."
" There is nothing particular to do to receive transactions from L1, as the "
"message is relayed by the sequencer automatically. In your `#[l1_handler]` "
"functions, it is important to verify the sender of the L1 message to ensure "
"that our contract can only receive messages from a trusted L1 contract."
msgstr ""
"我们需要在我们函数中添加 {[l1_ handler] 属性 。 L1 处理器是特殊功能,只能通过“ L1Handler Transaction ” "
"执行。 接收 L1 的交易没有什么特别需要做的, 因为信件由序列器自动传递 。 在您的 {l1_ handler 函数中, 验证 L1 "
"信件的发件人非常重要, 以确保我们的合同只能接收信任的 L1 合同中的信息 。"

#: src/ch16-04-L1-L2-messaging.md:138
msgid "Sending Messages from Starknet to Ethereum"
msgstr "将信件从 Starknet 发送到 Etheum"

#: src/ch16-04-L1-L2-messaging.md:140
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the "
"`send_message_to_l1` syscall in your Cairo contracts. This syscall allows "
"you to send messages to the `StarknetMessaging` contract on L1. Unlike "
"`L1->L2` messages, `L2->L1` messages must be consumed manually, which means "
"that you will need your Solidity contract to call the `consumeMessageFromL2`"
" function of the `StarknetMessaging` contract explicitly in order to consume"
" the message."
msgstr ""
"在从 Starknet 发送信件到 Etheum 时, 您必须使用您的开罗合同中的 ` send_ message_ to_ l1' syscall 。"
" 此语句提醒允许您将信息发送到 L1 上的` StarknetMessage'合同 。 与 ` L1 - > L2'电文不同, ` L2 > "
"L1'电文必须手工处理, 这意味着您需要您的可靠合同将` StarknetMessing'合同的` consumesingMessage "
"fromL2'功能明确称为` StarknetMessmaking'合同中的` consessageMessing'功能, 才能使用该电文。"

#: src/ch16-04-L1-L2-messaging.md:142
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr "发送L2到L1的信息 我们在Starknet上会做的是:"

#: src/ch16-04-L1-L2-messaging.md:146
msgid ""
"// Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
msgstr ""

#: src/ch16-04-L1-L2-messaging.md:153
msgid ""
"We simply build the payload and pass it, along with the L1 contract address,"
" to the syscall function."
msgstr "我们只是建造有效载荷,并将它连同L1合同地址一起传送到交响功能。"

#: src/ch16-04-L1-L2-messaging.md:155
msgid ""
"On L1, the important part is to build the same payload sent by the L2. Then "
"you call `consumeMessageFromL2` in you Solidity contract by passing the L2 "
"contract address and the payload. Please be aware that the L2 contract "
"address expected by the `consumeMessageFromL2` is the address of the "
"contract that sends the message on the L2 by calling "
"`send_message_to_l1_syscall`."
msgstr ""
"关于L1, 重要部分是建造L2发送的同一有效载荷, 然后通过L2合同地址和有效载荷,在您的合同中称为`ConsumeMessage FromL2 "
"',通过“Send_Message_to_l1_syscall”, 将“ConsumeMessage FromL2” "
"所预期的L2合同地址作为合同地址,通过“send_Message_to_l1_syscall” 发送L2上的信息。"

#: src/ch16-04-L1-L2-messaging.md:166
msgid "// You can use the message hash if you want here.\n"
msgstr "/ 您可以在这里使用信件散列 。\n"

#: src/ch16-04-L1-L2-messaging.md:168
msgid ""
"// We expect the payload to contain only a felt252 value (which is a uint256"
" in Solidity).\n"
msgstr "我们预计有效载荷只含有一种感觉252值(即五分制256在固体中)。\n"

#: src/ch16-04-L1-L2-messaging.md:169
msgid "\"Invalid payload\""
msgstr "\"无效有效载荷\""

#: src/ch16-04-L1-L2-messaging.md:173
msgid ""
"// From here, you can safely use `my_felt` as the message has been verified "
"by StarknetMessaging.\n"
msgstr "/ 从这里,你可以安全地使用“我的'felt'”,因为电文已经由斯塔克内特通讯公司核实。\n"

#: src/ch16-04-L1-L2-messaging.md:174
msgid "\"Invalid value\""
msgstr "“无效值”"

#: src/ch16-04-L1-L2-messaging.md:178
msgid ""
"As you can see, in this context we don't have to verify which contract from "
"L2 is sending the message (as we do on the L2 to verify which contract from "
"L1 is sending the message). But we are actually using the "
"`consumeMessageFromL2` of the `StarknetCore` contract to validate the inputs"
" (the contract address on L2 and the payload) to ensure we are only "
"consuming valid messages."
msgstr ""
"如你所见,在此情况下,我们不必核实L2的哪些合同发出电文(正如我们在L2上所做的那样,以核实L1的合同发出电文),但我们实际上正在使用`StarknetCore'合同的`Message"
" FromL2'合同的`consumeMessage FromL2'来验证投入(L2和有效载荷的合同地址),以确保我们只使用有效电文。"

#: src/ch16-04-L1-L2-messaging.md:180
msgid ""
"**Note:** The `consumeMessageFromL2` function of the `StarknetCore` contract"
" is expected to be called from a Solidity contract, and not directly on the "
"`StarknetCore` contract. The reason of that is because the `StarknetCore` "
"contract is using `msg.sender` to actually compute the hash of the message. "
"And this `msg.sender` must correspond to the `to_address` field that is "
"given to the function `send_message_to_l1_syscall` that is called on "
"Starknet."
msgstr ""
"** 注:** `StarknetCore'合同的`Message "
"FromL2'功能预计将从“StarknetCore'合同中称为`starknetCore'合同,而不是直接在`StarknetCore'合同中称为`consumeMessage"
" FromL2 "
"',原因是`StarknetCore'合同正在使用`msg.sender'来实际计算电文的散数。而此`msg.sender'必须与调用在Starknet的函数`send_message_to_l1_syscall'的`to_desend_message_to_l1_ssscall'的字段相对应。"

#: src/ch16-04-L1-L2-messaging.md:182
msgid ""
"It is important to remember that on L1 we are sending a payload of "
"`uint256`, but the basic data type on Starknet is `felt252`; however, "
"`felt252` are approximately 4 bits smaller than `uint256`. So we have to pay"
" attention to the values contained in the payload of the messages we are "
"sending. If, on L1, we build a message with values above the maximum "
"`felt252`, the message will be stuck and never consumed on L2."
msgstr ""
"必须记住,在L1上,我们正在发送一个有效载荷`unit256 "
"',但Starknet上的基本数据类型是`felt252';然而,`felt252'大约小于`unit256'4位,因此,我们必须注意我们发送的信息的有效载荷中所含的值。如果在L1上,我们用最大`felt252'的值建立一条信息,信息将卡在L2上,永远不消耗在L2上。"

#: src/ch16-04-L1-L2-messaging.md:184
msgid "Cairo Serde"
msgstr "开罗塞尔德"

#: src/ch16-04-L1-L2-messaging.md:186
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet "
"contracts, written in Cairo, can only understand serialized data. And "
"serialized data is always an array of `felt252`. In Solidity we have "
"`uint256` type, and `felt252` are approximately 4 bits smaller than "
"`uint256`. So we have to pay attention to the values contained in the "
"payload of the messages we are sending. If, on L1, we build a message with "
"values above the maximum `felt252`, the message will be stuck and never "
"consumed on L2."
msgstr ""
"在发送 L1 和 L2 之间的信息之前, 您必须记住, 在开罗写的 Starknet 合同只能理解序列数据。 而序列数据总是一系列的“ felt252 "
"” 。 在“ Soliity” 中, 我们拥有“ unt256 ” 类型, 而“ felt252 ” 大约比 ` unt256 ” 小4位。 "
"所以我们必须注意我们发送的信息的有效载荷中包含的值 。 如果在 L1 上, 我们构建了一个超过最大 ` felt252 '值的信息, 信息将卡在L2 "
"上, 永远不会被消耗在 L2 上 。"

#: src/ch16-04-L1-L2-messaging.md:190
msgid ""
"So for instance, an actual `uint256` value in Cairo is represented by a "
"struct like:"
msgstr "例如,开罗的实际`5int256'价值就表现为:"

#: src/ch16-04-L1-L2-messaging.md:199
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for "
"the `high`. This means that to send only one `u256` to Cairo, you'll need to"
" send a payload from L1 with **TWO** values."
msgstr ""
"其序列编号为**TWO**感觉,“低”为1,“高”为1,这意味着如果只向开罗发送一个`U256',你将需要从L1发送一个带有**TWO**值的有效载荷。"

#: src/ch16-04-L1-L2-messaging.md:202
msgid "// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
msgstr "让我们把价值1 以 u256 在cairo: 低= 1, 高= 0。\n"

#: src/ch16-04-L1-L2-messaging.md:208
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the "
"[Starknet "
"documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-"
"mechanism/)."
msgstr ""
"如果您想更多地了解信息传递机制,请访问[Starknet文件] "
"(https://docs.starknet.io/documentation/architecture_and_concepts/Network_Archarture/Message-"
"mechanism/)。"

#: src/ch16-04-L1-L2-messaging.md:210
msgid ""
"You can also find a [detailed guide here](https://github.com/glihm/starknet-"
"messaging-dev) to test the messaging system locally."
msgstr ""
"您也可在当地(https://github.com/glihm/starknet-message-"
"dev)找到一个[此处详细指南](https://github.com/glihm/starknet-Message-dev)测试发信系统。"

#: src/ch16-05-oracle-interactions.md:3
msgid ""
"This section focuses on the concept of bringing off-chain data to the "
"Starknet blockchain using oracles. Oracles are third-party services that "
"serve as intermediaries, securely transmitting external data, such as asset "
"prices, weather information, or other real-world data, to blockchains and "
"smart contracts. It also provides practical examples and code snippets "
"demonstrating how developers can interact with a specific oracle named "
"Pragma on Starknet network, covering topics like querying and handling price"
" data, and verifiable random function (VRF) to generate random numbers."
msgstr ""
"本节重点阐述利用神器将离链数据带入史塔克内区块链的概念,甲骨文是第三方服务,作为中间人,安全地将资产价格、天气信息或其他真实世界数据等外部数据传送到链条和智能合同,并提供实际例子和代码片,说明开发商如何与斯塔克内区网络上名为Praggma的具体神器进行互动,涵盖诸如查询和处理价格数据以及可核实随机功能以生成随机数字等专题。"

#: src/ch16-05-01-price-feeds.md:3
msgid ""
"Price feeds enabled by an oracle serve as a bridge between real-world data "
"feed and the blockchain. They provide real time pricing data that is "
"aggregated from multiple trusted external sources ( e.g. crypto exchanges, "
"financial data providers, etc. ) to the blockchain network."
msgstr ""
"由甲骨文促成的价格供料是真实世界数据反馈与链链之间的桥梁,提供实时定价数据,这些数据从多个可信赖的外部来源(例如密码交换、金融数据提供者等)到链链网络汇总。"

#: src/ch16-05-01-price-feeds.md:5
msgid ""
"For the example in this book section, we will use Pragma Oracle to read the "
"price feed for `ETH/USD` asset pair and also showcase a mini application "
"that utilizes this feed."
msgstr "例如,在本书节中,我们将使用Pragma Oracle阅读`ETH/USD'资产配对的价格饲料,并展示利用这种饲料的微型应用。"

#: src/ch16-05-01-price-feeds.md:7
msgid ""
"[Pragma Oracle](https://www.pragma.build/) is a leading zero knowledge "
"oracle that provides access to off-chain data on Starknet blockchain in a "
"verifiable way."
msgstr ""
"[Pragma Oracle] "
"(https://www.pragma.building/)是一个领先的零知识神器,它以可核查的方式提供获取斯塔克内特块链上离链数据的途径。"

#: src/ch16-05-01-price-feeds.md:9
msgid "Add Pragma as a Project Dependency"
msgstr "将棱镜添加为项目依赖性"

#: src/ch16-05-01-price-feeds.md:11
msgid ""
"To get started with integrating Pragma on your Cairo smart contract for "
"price feed data, edit your project's `Scarb.toml` file to include the path "
"to use Pragma."
msgstr ""
"要开始将Pragma纳入您的开罗智能价格反馈数据合同, 请编辑您的项目 `Scarb.toml' 文件, 以包括使用 Pragma 路径 。"

#: src/ch16-05-01-price-feeds.md:13 src/ch16-05-02-randomness.md:20
msgid ""
"```toml\n"
"[dependencies]\n"
"pragma_lib = { git = \"https://github.com/astraly-labs/pragma-lib\" }\n"
"```"
msgstr ""
"{git = \"https://github.com/astraly-labs/pragma-"
"lib\"}}}}{grama_lib=\"https://gitub.com/astraly-labs/pragma-"
"lib\"}}}}{grama_lib={git=\"https://gitub.com/astraly-labs/pragma-lib\"}}}}}{"

#: src/ch16-05-01-price-feeds.md:18
msgid "Creating a Price Feed Contract"
msgstr "订立价格饲料合同"

#: src/ch16-05-01-price-feeds.md:20
msgid ""
"After adding the required dependencies for your project, you'll need to "
"define a contract interface that includes the required pragma price feed "
"entry point."
msgstr "在为您的项目添加所需的依赖关系之后, 您将需要定义一个合同界面, 包括所需的实用价格馈送切入点 。"

#: src/ch16-05-01-price-feeds.md:22
msgid "Contract Interface"
msgstr "合同接口"

#: src/ch16-05-01-price-feeds.md:32
msgid ""
"Of the two public functions exposed in the `IPriceFeedExample`, the one "
"necessary to interact with the pragma price feed oracle is the "
"`get_asset_price` function, a view function that takes in the `asset_id` "
"argument and returns a `u128` value."
msgstr ""
"在`IPriceFeedExample'中暴露的两种公共职能中,与软体价格饲料或质谱互动所必需的一种是`get_asset_price'功能,一种在`asset_id'参数中取而代之的视图功能,并返回`u128'值。"

#: src/ch16-05-01-price-feeds.md:34
msgid "Pragma Dependency Import to Contract"
msgstr "合同的进口"

#: src/ch16-05-01-price-feeds.md:41
msgid ""
"The snippet above shows the necessary imports you need to add to your "
"contract module in order to interact with the Pragma oracle."
msgstr "上面的片段显示您需要添加到合同模块中的必要导入, 以便与 Praggma 甲骨文互动 。"

#: src/ch16-05-01-price-feeds.md:43
msgid "Required Price Feed Function Impl in Contract"
msgstr "合同中必需的价格进餐功能"

#: src/ch16-05-01-price-feeds.md:47 src/ch16-05-01-price-feeds.md:117
msgid "// Retrieve the oracle dispatcher\n"
msgstr "/ 检索信器调度器\n"

#: src/ch16-05-01-price-feeds.md:52 src/ch16-05-01-price-feeds.md:122
msgid "// Call the Oracle contract, for a spot entry\n"
msgstr "呼叫甲骨文合同, 抽空进入\n"

#: src/ch16-05-01-price-feeds.md:60
msgid ""
"The `get_asset_price` function is responsible for retrieving the price of "
"the asset specified by the `asset_id` argument from Pragma Oracle. The "
"`get_data_median` method is called from the `IPragmaDispatcher` instance by "
"passing the `DataType::SpotEntry(asset_id)` as an argument and its output is"
" assigned to a variable named `output` of type `PragmaPricesResponse`. "
"Finally, the function returns the price of the requested asset as a `u128`."
msgstr ""
"`get_asset_price' 函数负责从Pragma "
"Oracle`asset_id'参数中收回`asset_id'参数中指明的资产价格,`get_data_medient'方法从`Itragma "
"Dispatcher'实例中称为`get_dataType::SpotEntry(asset_id)'参数,其输出被指定给名为`PragmaPriccesResponse'类型“Exput”的变量。最后,该函数将请求资产的价格作为`u128'返回。"

#: src/ch16-05-01-price-feeds.md:62
msgid "Example Application Using Pragma Price Feed"
msgstr "使用 Pragma 价格饲料的示例应用"

#: src/ch16-05-01-price-feeds.md:96
msgid "// Calculate the amount of ETH needed\n"
msgstr "计算需要的埃塞俄比亚(ETH)数量\n"

#: src/ch16-05-01-price-feeds.md:102 src/ch16-05-02-randomness.md:228
msgid "// ETH Contract Address\n"
msgstr "ETET 合同地址\n"

#: src/ch16-05-01-price-feeds.md:105
msgid "// Transfer the ETH to the caller\n"
msgstr "将ETH转至呼叫者\n"

#: src/ch16-05-01-price-feeds.md:132
msgid ""
"Note: Pragma returns the value of different token pairs using the decimal "
"factor of 6 or 8. You can convert the value to the required decimal factor "
"by dividing the value by \\\\( {10^{n}} \\\\), where `n` is the decimal "
"factor."
msgstr ""
"注意: Praggma 使用小数点为 6 或 8 的十进制系数返回不同象征性配对的值。您可以通过将数值除以\\\\ ({ "
"10\\\\\\\\\\\\\\\\) 来将数值转换为所需的小数系数,“n” 是小数点。"

#: src/ch16-05-01-price-feeds.md:134
msgid ""
"The code above is an example implementation of an applications consuming a "
"price feed from the Pragma oracle. The contract imports necessary modules "
"and interfaces, including the `IPragmaABIDispatcher` for interacting with "
"the Pragma oracle contract and the `ERC20ABIDispatcher` for interacting with"
" the ETH ERC20 token contract."
msgstr ""
"上面的代码是使用Praggma oracle的价格饲料的应用程序的一个实例,合同进口必要的模块和接口,包括用于与Praggma "
"oracle合同互动的`IPragmaABIDispatcher'和用于与ETH ERRC20象征性合同互动的`ERC20ABIDispatcher'。"

#: src/ch16-05-01-price-feeds.md:136
msgid ""
"The contract has a `const` that stores the token pair ID of `ETH/USD`, and a"
" `Storage` struct that holds two fields `pragma_contract` and "
"`product_price_in_usd`. The constructor function initializes the "
"`pragma_contract` address and sets the `product_price_in_usd` to 100."
msgstr ""
"合同有一个`契约 "
"',储存`ETH/USD'的标牌对牌号,以及一个`标准'支架,该支架拥有两个字段`pragma_contract'和`product_price_in_usd'。构建符功能初始化了`pragma_contract'地址,并将`product_press_in_usd'设置为`product_press_in_usd'至100。"

#: src/ch16-05-01-price-feeds.md:138
msgid ""
"The `buy_item` function is the main entry point for a user to purchase an "
"item. It retrieves the caller's address. It calls the `get_asset_price` "
"function to get the current price of ETH in USD using the `ETH_USD` asset "
"ID. It calculates the amount of ETH needed to buy the product based on the "
"product price in USD at the corresponding ETH price. It then checks if the "
"caller has enough ETH by calling the `balance_of` method on the ERC20 ETH "
"contract. If the caller has enough ETH, it calls the `transfer_from` method "
"of the `eth_dispatcher` instance to transfer the required amount of ETH from"
" the caller to another contract address."
msgstr ""
"`buy_item' 函数是用户购买物品的主要切入点,它检索了来电者的地址,它称为`get_asset_price'函数,用`ETH_USD' "
"资产代号以美元取得ETH的现价,它根据以美元计算的产品价格,以相应的ETH价格计算购买产品所需的ETH数量,然后通过在ERC20 ETH "
"合同中将`平衡'方法称为`平衡'方法,检查来电者是否有足够的ETH。如果来电者有足够的ETH,它称为`ETH_dispatcher'的`转让方法 "
"',它称为`ETH_dispatcher'实例,将所要求的ETH数量从打电话者转到另一个合同地址。"

#: src/ch16-05-01-price-feeds.md:140
msgid ""
"The `get_asset_price` function is the entry point to interact with the "
"Pragma oracle and has been explained in the section above."
msgstr "`get_asset_price' 函数是与Praggma oracle互动的切入点,已在上一节作了解释。"

#: src/ch16-05-01-price-feeds.md:142
msgid ""
"You can get a detailed guide on consuming data using Pragma price feeds "
"[here](https://docs.pragma.build/Resources/Cairo%201/data-feeds/consuming-"
"data)."
msgstr ""
"您可以从Praggma价格反馈(https://docs.pragma.building/Resources/Cairo%201/data-"
"feeds/pent-data)获得详细的消费数据指南。"

#: src/ch16-05-02-randomness.md:3
msgid ""
"Since all blockchains are fundamentally deterministic and most are public "
"ledgers, generating truly unpredictatable randomness on-chain presents a "
"challenge. This randomness is crucial for fair outcomes in gaming, "
"lotteries, and unique generation of NFTs. To address this, verifiable random"
" functions (VRFs) provided by oracles offer a solution. VRFs guarantee that "
"the randomness can't be predicted or tampered with, ensuring trust and "
"transparency in these applications."
msgstr ""
"由于所有链条基本上都是决定性的,而且大部分是公共分类账,因此在链条上造成真正无法预测的随机性是一个挑战。 "
"这种随机性对于游戏、彩票和独特型NFT的公平结果至关重要。 要解决这个问题,由甲骨文提供的可核查随机功能(VRFs)提供了一种解决方案。 "
"VRFs保证随机性不会被预测或篡改,确保这些应用程序的信任和透明度。"

#: src/ch16-05-02-randomness.md:5
msgid "Overview on VRFs"
msgstr "风险成果框架概览"

#: src/ch16-05-02-randomness.md:7
msgid ""
"Pseudo-random but secure: VRFs use a secret key and a nonce (a unique input)"
" to generate an output that appears random. While technically 'pseudo-"
"random', it's practically impossible for another party to predict the "
"outcome without knowing the secret key."
msgstr ""
"假冒- 随机性但安全性: VRFs使用秘密密钥和非密钥( 一种独特的输入) 生成随机输出。 虽然技术上“ 假冒- 随机性 ”, "
"但另一方几乎不可能在不知道秘密密钥的情况下预测结果 。"

#: src/ch16-05-02-randomness.md:9
msgid ""
"Verifiable output: VRFs produce not only the random number but also a proof "
"that anyone can use to independently verify that the result was generated "
"correctly according to the function's parameters."
msgstr "可核实产出: VRF不仅提供随机数字,而且还提供证据,证明任何人都可以用来独立核实结果是否根据函数参数正确产生。"

#: src/ch16-05-02-randomness.md:11
msgid "Generating Randomness with Pragma"
msgstr "与 Pragma 生成随机"

#: src/ch16-05-02-randomness.md:13
msgid ""
"[Pragma](https://www.pragma.build/), an oracle on Starknet provides a "
"solution for generating random numbers using VRFs. Let's dive into how to "
"use Pragma VRF to generate a random number in a simple dice game contract."
msgstr ""
"[Pragma] (https://www.pragma.building/), Starknet 上的甲骨文提供了使用 VRF "
"生成随机数字的解决方案。让我们跳入如何使用 Pragma VRF 在简单的骰子游戏合同中生成随机数字 。"

#: src/ch16-05-02-randomness.md:16
msgid "Add Pragma as a Dependency"
msgstr "将棱镜添加成依赖性"

#: src/ch16-05-02-randomness.md:18
msgid ""
"Edit your cairo project's `Scarb.toml` file to include the path to use "
"Pragma."
msgstr "编辑您的 cairo 工程的 `Scarb.toml' 文件, 以包含使用 Pragma 的路径 。"

#: src/ch16-05-02-randomness.md:61
msgid ""
"<span class=\"caption\">Listing 16-5 shows a contract interfaces for Pragma "
"VRF and a simple dice game.</span>"
msgstr "<span类=“caption” >Listing 16-5 显示Pragma VRF的合同界面和一个简单的骰子游戏。 </span>"

#: src/ch16-05-02-randomness.md:63
msgid "Description of Key IPragmaVRF Entrypoints and Their Inputs"
msgstr "说明主要IPRAGmaVRF切入点及其投入"

#: src/ch16-05-02-randomness.md:65
msgid ""
"The function `request_randomness_from_pragma` initiates a request for "
"verifiable randomness from the Pragma oracle. It does this by emitting an "
"event that triggers the following actions off-chain:"
msgstr ""
"函数 `request_randomity_from_pragma' 启动从 Praggma 甲骨文中提出可核查随机性请求。 "
"这样做的方式是发布一个触发以下非链外动作的事件:"

#: src/ch16-05-02-randomness.md:67
msgid ""
"Randomness generation: The oracle generates random values and a "
"corresponding proof."
msgstr "随机生成: 甲骨文生成随机值和相应的证明 。"

#: src/ch16-05-02-randomness.md:68
msgid ""
"On-chain submission: The oracle submits the generated randomness and proof "
"back to the blockchain via the `receive_random_words` callback function."
msgstr "链式提交文件:神器通过回馈功能,将生成的随机性和证据通过`收到_random_words'回馈功能送回到链式链条。"

#: src/ch16-05-02-randomness.md:70
msgid "`request_randomness_from_pragma` Inputs"
msgstr "`请求-随机性_来自_pragma'输入"

#: src/ch16-05-02-randomness.md:72
msgid ""
"`seed`: A value used to initialize the randomness generation process. This "
"should be unique to ensure unpredictable results."
msgstr "`种子':用于初始化随机生成过程的值,应具有独特性,以确保不可预测的结果。"

#: src/ch16-05-02-randomness.md:73
msgid ""
"`callback_address`: The contract address where the `receive_random_words` "
"function will be called to deliver the generated randomness. It is typically"
" the address of your deployed contract implementing Pragma VRF."
msgstr "`回召'地址:`收到_随机_words'功能将被调用以提供产生的随机性的合同地址,通常是你部署的落实Praggma VRF合同的地址。"

#: src/ch16-05-02-randomness.md:74
msgid ""
"`callback_fee_limit`: The maximum amount of gas you're willing to spend on "
"executing the `receive_random_words` callback function."
msgstr "`召回_fee_limit':您愿意用于执行`接收_random_words'回调功能的最大气体量。"

#: src/ch16-05-02-randomness.md:75
msgid ""
"`publish_delay`: The minimum delay (in blocks) between requesting randomness"
" and the oracle fulfilling the request."
msgstr "`出版迟延':请求随机性与满足请求的神器之间的最小延迟(区块内)。"

#: src/ch16-05-02-randomness.md:76
msgid ""
"`num_words`: The number of random values (each represented as a `felt252`) "
"you want to receive in a single callback."
msgstr "`numm_words': 随机值数(每个值以`felt252'表示), 您想要在一次回调中收到 。"

#: src/ch16-05-02-randomness.md:77
msgid ""
"`calldata`: Additional data you want to pass to the `receive_random_words` "
"callback function."
msgstr "`呼叫数据':您要将更多数据传送到`收到_random_words'回调功能。"

#: src/ch16-05-02-randomness.md:79
msgid "`receive_randomn_words` Inputs"
msgstr "`收到_randomn_words'输入"

#: src/ch16-05-02-randomness.md:81
msgid ""
"`requester_address`: The contract address that initiated the randomness "
"request."
msgstr "`请购人地址':启动随机性请求的合同地址。"

#: src/ch16-05-02-randomness.md:82
msgid "`request_id`: A unique identifier assigned to the randomness request."
msgstr "`request_id':随机性请求中指定的独特标识符。"

#: src/ch16-05-02-randomness.md:83
msgid ""
"`random_words`:  An array (span) of the generated random values (represented"
" as `felt252`)."
msgstr "`随机字':生成随机值的数组(span)(表示为`felt252')。"

#: src/ch16-05-02-randomness.md:84
msgid ""
"`calldata`:  Additional data passed along with the initial randomness "
"request."
msgstr "`呼叫数据':与最初随机性请求同时传送的额外数据。"

#: src/ch16-05-02-randomness.md:86
msgid "Dice Game Contract"
msgstr "骰子游戏合同"

#: src/ch16-05-02-randomness.md:88
msgid ""
"This dice game contract allows players to guess a number between 1 & 6 "
"during an active game window. The contract owner then has the ability to "
"toggle the game window to disable new guesses from players. To determine the"
" winning number, the contract owner calls the "
"`request_randomness_from_pragma` function to request a random number from "
"the Pragma VRF oracle. Once the random number is received through the "
"`receive_random_words` callback function, it is stored in the "
"`last_random_number` storage variable. Each player has to call "
"`process_game_winners` function to determine if they have won or lost. The "
"`last_random_number` generated is then reduced to a number between 1 & 6, "
"and compared to the guesses of the players stored in the `user_guesses` "
"mapping, which leads to the emission of an event `GameWinner` or `GameLost`."
msgstr ""
"此 dice 游戏合同允许玩家在活动游戏窗口中猜测 1 和 6 之间的数字。 合同所有人然后能够切换游戏窗口以禁用玩家的新猜想。 要确定胜数, "
"合同所有人将“ 请求_ randomnes_ from_ pragma” 函数调用“ pragma VRF 或acle” 随机数。 一旦随机数通过“ "
"接收_ random_ words” 回调功能接收, 它就会被存储在“ 最后_ random_ number ” 存储变量中。 每个玩家必须调用“ "
"进程_ game_ winner ” 函数来确定他们是否赢了或输了。 生成的“ 最后一个_ random_ number” 后被减为1 和 6 "
"之间的数字, 与存储在“ 用户- guesses ” 映射中的玩家的猜测数相比, 随机数导致事件“ GameWinner ” 或“ GameLost” "
"的排放。"

#: src/ch16-05-02-randomness.md:223
msgid ""
"// Approve the randomness contract to transfer the callback fee\n"
"            // You would need to send some ETH to this contract first to cover the fees\n"
msgstr "批准随机合同 转回回扣费 您需要先把一些ETH送到合同\n"

#: src/ch16-05-02-randomness.md:236
msgid "// Request the randomness\n"
msgstr "/ 要求随机性\n"

#: src/ch16-05-02-randomness.md:253
msgid ""
"// Have to make sure that the caller is the Pragma Randomness Oracle "
"contract\n"
msgstr "必须确保打电话者是 普拉格马随机性甲骨文合同\n"

#: src/ch16-05-02-randomness.md:259
msgid ""
"// and that the current block is within publish_delay of the request block\n"
msgstr "/ 并且当前区块在请求区块的发布_延迟之内\n"

#: src/ch16-05-02-randomness.md:273
msgid "// ETH Contract Address            \n"
msgstr "ETET 合同地址\n"

#: src/ch16-05-02-randomness.md:282
msgid ""
"<span class=\"caption\">Listing 16-6: Simple Dice Game Contract using Pragma"
" VRF.</span>"
msgstr "<span class=\"Caption\" > listing 16-6: 使用 Pragma VRF 的简单骰子游戏合同。 </span>"

#: src/ch16-05-02-randomness.md:284
msgid "NB: Fund Your Contract After Deployment to Utilize Pragma VRF"
msgstr "NB:在部署使用Pragma VRF后,为您的合同供资"

#: src/ch16-05-02-randomness.md:286
msgid ""
"After deploying your contract that includes Pragma VRF functionalities, "
"ensure it holds sufficient ETH to cover the expenses related to requesting "
"random values. Pragma VRF requires payment for both generating the random "
"numbers and executing the callback function defined in your contract."
msgstr ""
"在部署包含Pragma VRF功能的合同后,确保有足够的ETH支付与要求随机值有关的费用。 Pragma "
"VRF要求支付生成随机数和执行合同中规定的回馈功能的费用。"

#: src/ch16-05-02-randomness.md:288
msgid ""
"For more information, please refer to the "
"[Pragma](https://docs.pragma.build/Resources/Cairo%201/randomness/randomness)"
" docs."
msgstr ""
"详情请查阅[Pragma](https://docs.pragma.building/Resources/Cairo%201/randomness/randomness)文件。"

#: src/ch16-06-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, "
"utilizing various features of the Cairo programming language. Your "
"contributions are welcome and encouraged, as we aim to gather as many "
"diverse examples as possible."
msgstr "本节载有斯塔克内特智能合同的其他例子,利用开罗方案语言的各种特点,欢迎和鼓励你的贡献,因为我们的目标是收集尽可能多的不同的例子。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:1
msgid "Deploying and Interacting with a Voting contract"
msgstr "与表决合同的部署和互动"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the"
" contract's constructor. Three voters are initialized at this stage, and "
"their addresses are passed to an internal function **`_register_voters`**. "
"This function adds the voters to the contract's state, marking them as "
"registered and eligible to vote."
msgstr ""
"斯塔克内特的“Vote”合同从通过合同的构建者对选民进行登记开始,在这个阶段,有3名选民被初始化,他们的地址被传给内部功能“register_voters”。这一功能使选民加入到合同的状态中,他们被标记为已登记并有资格投票。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to "
"represent the voting options (1 and 0, respectively). These constants "
"facilitate the voting process by standardizing the input values."
msgstr "在合同中,常数 \" YES \" 和 \" NO \" 被定义为代表投票选项(分别为1和0)。这些常数通过使输入值标准化来便利投票过程。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** "
"function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting,"
" the state of the contract is updated, recording the vote and marking the "
"voter as having voted. This ensures that the voter is not able to cast a "
"vote again within the same proposal. The casting of a vote triggers the "
"**`VoteCast`** event, logging the action."
msgstr ""
"一旦登记,选民就可以使用“vote”功能投票,选择1(YES)或0(NO)作为他们的选票。在投票时,合同状况将更新,记录投票情况,并将选民标记为投票者。这确保选民无法在同一提案中再次投票。投票引发了“VoteCast”事件,记录了投票情况。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized "
"action is detected, such as a non-registered user attempting to vote or a "
"user trying to vote again, the **`UnauthorizedAttempt`** event is emitted."
msgstr "如果发现未经授权的行动,如未注册的用户试图投票或未注册的用户试图再次投票,则释放“未经授权的企图”事件。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured"
" voting system, managing the lifecycle of a vote from registration to "
"casting, event logging, and result retrieval within the Starknet "
"environment. Constants like **`YES`** and **`NO`** help streamline the "
"voting process, while events play a vital role in ensuring transparency and "
"traceability."
msgstr ""
"这些功能、州、州、常数和活动合在一起创造了一个结构化的投票系统,管理从登记到投票、事件记录和史塔克内特环境内结果检索的投票周期。 诸如“YES ” "
"和“NO”等常数有助于简化投票过程,而活动在确保透明度和可追踪性方面发挥着至关重要的作用。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:13
msgid "Listing 16-7 shows the `Vote` contract in detail:"
msgstr "第16-7号清单详细列出了“Vote”合同:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:16
msgid ""
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
msgstr ""
"///@dev Core library Exports for the Treats unter the Starknet contract. "
"合同外的塔克内特核心图书馆进口 /// @dev Core library Exports for the trackits for the "
"Starknet contract\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:18
msgid ""
"/// @dev Trait defining the functions that can be implemented or called by "
"the Starknet Contract\n"
msgstr "///@dev Trait 界定斯塔克内特合同可以履行或要求履行的职能\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:22
msgid "/// @dev Function that returns the current vote status\n"
msgstr "// @dev 函数返回当前投票状态\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:24
msgid ""
"/// @dev Function that checks if the user at the specified address is "
"allowed to vote\n"
msgstr "// @dev 函数检查指定地址用户是否允许投票\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:26
msgid ""
"/// @dev Function that checks if the specified address is registered as a "
"voter\n"
msgstr "// @dev 函数检查指定地址是否登记为选民\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:28
msgid "/// @dev Function that allows a user to vote\n"
msgstr "// @dev 功能允许用户投票\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:31
msgid ""
"/// @dev Starknet Contract allowing three registered voters to vote on a "
"proposal\n"
msgstr "///@dev Starknet 合同允许三名登记选民投票表决一项提案\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:41
msgid "/// @dev Structure that stores vote counts and voter states\n"
msgstr "///@dev 储存计票和选民状态的结构\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:50
msgid ""
"/// @dev Contract constructor initializing the contract with a list of "
"registered voters and 0 vote count\n"
msgstr "///@dev@dev 合同建造商以登记选民名单和0票计票开始合同\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:58
msgid "// Register all voters by calling the _register_voters function\n"
msgstr "/ 通过调用 _register_voters 功能登记所有选民\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:61
msgid "// Initialize the vote count to 0\n"
msgstr "/ 开始投票数为0\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:66
msgid "/// @dev Event that gets emitted when a vote is cast\n"
msgstr "///@dev 事件,当投票时会发布\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:74
msgid "/// @dev Represents a vote that was cast\n"
msgstr "//@dev 代表投票结果\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:81
msgid "/// @dev Represents an unauthorized attempt to vote\n"
msgstr "//@@dev 代表未经授权的投票企图\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:87
msgid "/// @dev Implementation of VoteTrait for ContractState\n"
msgstr "///@dev 实施合同国的投票程序\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:90
msgid "/// @dev Returns the voting results\n"
msgstr "// @dev 返回投票结果\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:97
msgid "/// @dev Check whether a voter is allowed to vote\n"
msgstr "///@dev 检查是否允许选民投票\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:102
msgid "/// @dev Check whether an address is registered as a voter\n"
msgstr "///@dev 检查一个地址是否登记为选民\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:107
msgid "/// @dev Submit a vote\n"
msgstr "// @dev 提交投票\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:109
msgid "\"VOTE_0_OR_1\""
msgstr "\"VOTE_0_OR_1\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:125
msgid "/// @dev Internal Functions implementation for the Vote contract\n"
msgstr "///@dev 实施投票合同的内部功能\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:128
msgid ""
"/// @dev Registers the voters and initializes their voting status to true "
"(can vote)\n"
msgstr "//@dev 登记选民,\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:146
msgid "/// @dev Asserts implementation for the Vote contract\n"
msgstr "///@dev Asserts 实施投票合同\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:149
msgid "// @dev Internal function that checks if an address is allowed to vote\n"
msgstr "/ @dev@dev 内部功能,可以检查是否允许投票地址\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:158
msgid "\"USER_NOT_REGISTERED\""
msgstr "(美国核反应堆)"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:159
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:440
msgid "\"USER_ALREADY_VOTED\""
msgstr ""
"(AAAAREADAVED) (USERAAREAADEVETED) (AUSERAAREAADADED) (AUSERAREAREADANDATED)"
" (AUSERAREAREADANDATED) (AUSERERAREAREADANDATED)"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:163
msgid "/// @dev Implement the VotingResultTrait for the Vote contract\n"
msgstr "/// @dev 执行投票结果 投票合同\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:166
msgid ""
"// @dev Internal function to get the voting results (yes and no vote "
"counts)\n"
msgstr "/ @dev 内部功能以获得投票结果(是和不计票)\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:174
msgid ""
"// @dev Internal function to calculate the voting results in percentage\n"
msgstr "/ / @dev 内部函数以百分比计算投票结果\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:192
msgid "<span class=\"caption\">Listing 16-7: A voting smart contract</span>"
msgstr "<span类=“caption” > listing 16-7: 投票智能合同 </span>"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:194
msgid "Deploying, Calling and Invoking the Voting Contract"
msgstr "部署、调用和援引投票合同"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:196
msgid ""
"Part of the Starknet experience is deploying and interacting with smart "
"contracts."
msgstr "斯塔克内特的部分经验是部署和与智能合同互动。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:198
msgid ""
"Once the contract is deployed, we can interact with it by calling and "
"invoking its functions:"
msgstr "一旦合同部署完毕,我们可以通过调用和援引其职能与合同互动:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:200
msgid ""
"Calling contracts: Interacting with external functions that only read from "
"the state. These functions do not alter the state of the network, so they "
"don't require fees or signing."
msgstr "连接合同: 与只从国家读取的外部功能互动。 这些功能不会改变网络状态, 因此不需要收费或签名 。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:201
msgid ""
"Invoking contracts: Interacting with external functions that can write to "
"the state. These functions do alter the state of the network and require "
"fees and signing."
msgstr "援引合同:与可以向国家写信的外部职能进行互动,这些职能确实改变了网络的状况,需要收费和签名。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:203
msgid ""
"We will setup a local development node using `katana` to deploy the voting "
"contract. Then, we'll interact with the contract by calling and invoking its"
" functions. You can also use the Goerli Testnet instead of `katana`. "
"However, we recommend using `katana` for local development and testing. You "
"can find the complete tutorial for `katana` in the [\"Katana: A Local "
"Node\"](https://book.starknet.io/ch02-04-katana.html) chapter of the "
"Starknet Book."
msgstr ""
"我们将用`katana'来设置地方发展节点,以部署投票合同,然后,我们将通过调用和援引合同功能与合同互动,您也可以使用Goerli "
"Testnet而不是`katana',然而,我们建议使用`katana'来进行地方发展和测试。您可以在斯塔克内特书(https://book.starknet.io/ch02-04-katana.html)一章中找到`katana'的完整辅导。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:207
msgid "The `katana` Local Starknet Node"
msgstr "`katana'地方史塔克网节点"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:209
msgid ""
"`katana` is designed to support local development by the [Dojo "
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana). It will "
"allow you to do everything you need to do with Starknet, but locally. It is "
"a great tool for development and testing."
msgstr ""
"`katana'由[Dojo小组](https://github.com/dojoengine/dojo/blob/main/crates/katana)设计,目的是支持地方发展,使你能够对Starknet尽你所能,但可以在当地进行,这是发展和测试的伟大工具。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:211
msgid ""
"To install `katana` from the source code, please refer to the [\"Basic "
"Installation\"](https://book.starknet.io/ch02-01-basic-"
"installation.html#katana-node-installation) chapter of the Starknet Book."
msgstr ""
"要从源代码中安装`katana',请参见斯塔克内特书中的[“基本安装”]一章(https://book.starknet.io/ch02-01-import-"
"安裝.html#katana-node-安裝)。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:213
msgid ""
"Note: Please verify that the version of `katana` match the specified version"
" provided below."
msgstr "注:请核实`katana'的版本与下文规定的版本相符。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:220
msgid ""
"To upgrade `katana` version, refer to the [\"Basic "
"Installation\"](https://book.starknet.io/ch02-01-basic-"
"installation.html#katana-node-installation) chapter of the Starknet Book."
msgstr ""
"为了升级“katana”版本,请参考斯塔克内特书中的[“基本安装”]一章(https://book.starknet.io/ch02-01-import-"
"安裝.html#katana-node-安裝)。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:222
msgid ""
"Once you have `katana` installed, you can start the local Starknet node "
"with:"
msgstr "安装“katana”后,您可以用下列方式启动本地的 Starknet 节点:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:228
msgid ""
"This command will start a local Starknet node with 3 deployed accounts. We "
"will use these accounts to deploy and interact with the voting contract:"
msgstr "此命令将启动一个本地的 Starknet 节点, 包含 3 个已部署的账户 。 我们将使用这些账户来部署和与投票合同互动 :"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:233
msgid "================="
msgstr ""
"_____________________________________________________________________________________________________________________________________________________________________________________________"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:249
msgid ""
"Before we can interact with the voting contract, we need to prepare the "
"voter and admin accounts on Starknet. Each voter account must be registered "
"and sufficiently funded for voting. For a more detailed understanding of how"
" accounts operate with Account Abstraction, refer to the [\"Account "
"Abstraction\"](https://book.starknet.io/ch04-00-account-abstraction.html) "
"chapter of the Starknet Book."
msgstr ""
"在与投票合同互动之前,我们需要准备斯塔克内特的选民帐户和行政帐户。每个选民帐户必须登记,并有足够的投票资金。为了更详细地了解账户与“账户摘要”如何运作,请参见史塔克内特书中的“账户摘要”一章(https://book.starknet.io/ch04-00-count-"
"abstraction.html)。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:255
msgid "Smart Wallets for Voting"
msgstr "用于投票的智能票花板"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:257
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a "
"command line tool that allows you to interact with Starknet. You can find "
"the installation instructions in the \\[\"Basic Installation\"\\]\\[starkli "
"installation\\] chapter of the Starknet Book."
msgstr ""
"除了疤痕之外, 您还需要安装斯塔克利。 Starkli 是一个命令行工具, 允许您与 Starknet 互动。 您可以在 Starknet 书的 \\ "
"[ “ 基本安装”\\]\\ [ starkkli 安装] 章节中找到安装指令 。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:259
msgid ""
"Note: Please verify that the version of `starkli` match the specified "
"version provided below."
msgstr "注:请核实`starkli'的版本是否与下文规定的版本相符。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:266
msgid ""
"To upgrade `starkli` to `0.2.9`, use the `starkliup -v 0.2.9` command, or "
"simply `starkliup` which installed the latest stable version."
msgstr ""
"将`Starkli'升级为`0.2.9',使用`Starkliup-v0.2.9'命令,或简单地使用安装最新稳定版本的`Starkliup'命令。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:268
msgid ""
"For each smart wallet we'll use, we must create a Signer within the "
"encrypted keystore and an Account Descriptor. This process is also detailed "
"in the \\[\"Testnet Deployment\"\\]\\[signer creation\\] chapter of the "
"Starknet Book."
msgstr ""
"对于我们将要使用的每一个智能钱包, 我们必须在加密的密钥库和账户描述符中创建一个签名人。 这个过程在史塔克内书的\\[“ 测试网部署”\\]\\[ "
"符号创建] 章节中也有详细描述 。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:270
msgid ""
"We can create Signers and Account Descriptors for the accounts we want to "
"use for voting. Let's create a smart wallet for voting in our smart "
"contract."
msgstr "我们可以为我们要用于投票的账户创建签名人和账户描述符。 让我们创建一个智能钱包, 用于在智能合同中投票 。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:272
msgid "Firstly, we create a signer from a private key:"
msgstr "首先,我们用私人密钥创建签名人:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:278
msgid ""
"Then, we create the Account Descriptor by fetching the katana account we "
"want to use:"
msgstr "然后,我们通过获取我们想要使用的katana账户创建账户描述符:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:284
msgid ""
"This command will create a new `account0_account.json` file containing the "
"following details:"
msgstr "此命令将创建一个新的“ account0_ account.json” 文件, 包含以下细节 :"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:288
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:291
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:401
msgid "\"version\""
msgstr "\"转换\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:289
msgid "\"variant\""
msgstr "\"变异\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:290
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:407
msgid "\"type\""
msgstr "\"类型\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:290
msgid "\"open_zeppelin\""
msgstr "\"开放 - 飞艇\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:292
msgid "\"public_key\""
msgstr "\"公用钥匙\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:292
msgid "\"<SMART_WALLET_PUBLIC_KEY>\""
msgstr "(<SMART_WALLET_PUBLIC_KEY>)"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:294
msgid "\"deployment\""
msgstr "\"部署\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:295
msgid "\"status\""
msgstr "\"状态\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:295
msgid "\"deployed\""
msgstr "\"已部署\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:296
msgid "\"class_hash\""
msgstr "\"类- 类- 类- 类- 类- 类- 类- 类- 类- 类- 类- 类- 类- 类- 类- 类- 类- 类"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:296
msgid "\"<SMART_WALLET_CLASS_HASH>\""
msgstr "(<SMART_WALLET_CLASS_HASH>) (<SMART_WALLET_CLASS_HASH>)"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:297
msgid "\"address\""
msgstr "\"地址\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:297
msgid "\"<SMART_WALLET_ADDRESS>\""
msgstr "(<SMART_WALLET_地址>)"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:302
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all "
"your smart wallets) with the following command. Notice the use of the "
"`--rpc` flag and the RPC endpoint provided by `katana`:"
msgstr ""
"您可以使用以下命令获取智能钱包类散列( 智能钱包类散列将相同) 。 请注意 ` katana'提供的 `- rpc'旗帜和 RPC 端点的使用 :"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:304
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"Starkli 类-hash-at <SMART_WALLET_ADIDESS>-rpc <http://0.0. 0.0: 5050\\ \\ \\ "
"\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ "
"\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:308
msgid ""
"For the public key, you can use the `starkli signer keystore inspect` "
"command with the directory of the keystore json file:"
msgstr "对于公用钥匙,您可以使用“starkli signer keytore 检查”命令,并使用键盘 Json 文件目录:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:314
msgid ""
"This process is identical for `account_1` and `account_2` in case you want "
"to have a second and a third voter."
msgstr "如果您想要第二和第三选民,这个过程与`账号_1'和`账号_2'相同。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:316
msgid ""
"\\[starkli installation\\]: https://book.starknet.io/ch02-01-basic-"
"installation.html#starkli-installation) \\[signer creation\\]: "
"https://book.starknet.io/ch02-05-testnet-"
"deployment.html?highlight=signer#creating-a-signer"
msgstr ""
"https://book.starknet.io/ch02-01-import-安裝.html#starkli-安裝)\\[發號人創 "
"https://book.starknet.io/ch02-05-stestnet-"
"importation.html?highlight=signer#reating-a-signer"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:319
msgid "Contract Deployment"
msgstr "合同部署"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:321
msgid ""
"Before deploying, we need to declare the contract. We can do this with the "
"`starkli declare` command:"
msgstr "在部署之前,我们需要宣布合同。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:327
msgid ""
"If the compiler version you're using is older than the one used by Starkli "
"and you encounter a `compiler-version` error while using the command above, "
"you can specify a compiler version to use in the command by adding the "
"`--compiler-version x.y.z` flag."
msgstr ""
"如果您正在使用的编译器版本比 Starkli 所使用的版本旧,而您在使用上述命令时遇到“ 编译器版本” 错误,您可以通过添加“-- compiler- "
"version x.y.z” 标志指定一个编译器版本,用于命令中。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:329
msgid ""
"If you're still encountering issues with the compiler version, try upgrading"
" Starkli using the command: `starkliup` to make sure you're using the latest"
" version of starkli."
msgstr ""
"如果您仍遇到编译器版本的问题, 请尝试使用命令“ Starkliup ” 来升级 Starkli, 以确保您使用最新版本的 Starkli 。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:331
msgid ""
"The class hash of the contract is: "
"`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You "
"can declare this contract on Sepolia testnet and see that the class hash "
"will correspond."
msgstr ""
"合同的等级是:`0x06976777a079b7edfadcd70aa4d12aac02263a4cda379009fca125e0ab1a9ba52',你可以在Sepolia测试网上申报这一合同,并看该类散列是否对应。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:333
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by "
"`katana`). The `--account` flag specifies the account to use for signing the"
" transaction. The account we use here is the one we created in the previous "
"step. The `--keystore` flag specifies the keystore file to use for signing "
"the transaction."
msgstr ""
"`-rpc'旗帜指定了RPC使用的端点(由`katana'提供的端点);`-account'旗帜指定了用于签署交易的账户;我们在此使用的账户是我们在前一个步骤中创建的账户;`-keystore'旗帜指定了用于签署交易的钥匙文件。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:335
msgid ""
"Since we are using a local node, the transaction will achieve finality "
"immediately. If you are using the Goerli Testnet, you will need to wait for "
"the transaction to be final, which usually takes a few seconds."
msgstr "由于我们正在使用本地节点, 交易将立即实现终结性 。 如果您正在使用 Goerli 测试网, 您需要等待交易最终完成, 通常需要几秒钟 。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:337
msgid ""
"The following command deploys the voting contract and registers voter_0, "
"voter_1, and voter_2 as eligible voters. These are the constructor "
"arguments, so add a voter account that you can later vote with."
msgstr "以下指挥部部署投票合同并登记选民:0人、选民:1人、选民2人为合格选民。这些是施工者的论点,因此加上一个选民账户,你以后可以投票。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:343
msgid "An example command:"
msgstr "示例命令 :"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:349
msgid ""
"In this case, the contract has been deployed at an specific address: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This "
"address will be different for you. We will use this address to interact with"
" the contract."
msgstr ""
"在这种情况下,合同部署在一个具体地址:`0x05ea3a690be71c7c7cd83945517f82e8861a97d42fca8ec9c468631d11f33349',这个地址对你们不同,我们将使用这个地址与合同互动。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:351
msgid "Voter Eligibility Verification"
msgstr "选民资格核查"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:353
msgid ""
"In our voting contract, we have two functions to validate voter eligibility,"
" `voter_can_vote` and `is_voter_registered`. These are external read "
"functions, which mean they don't alter the state of the contract but only "
"read the current state."
msgstr ""
"在我们的投票合同中,我们有两个职能来验证选民资格,即`voter_can_vote'和`is_voter_登记',这些是外部阅读功能,这意味着它们不会改变合同的状况,而只是读取目前的状况。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:355
msgid ""
"The `is_voter_registered` function checks whether a particular address is "
"registered as an eligible voter in the contract. The `voter_can_vote` "
"function, on the other hand, checks whether the voter at a specific address "
"is currently eligible to vote, i.e., they are registered and haven't voted "
"already."
msgstr ""
"`ototer_注册'功能检查某一地址是否登记为合同中的合格选民;`voter_can_vote'功能检查某一地址的选民目前是否有资格投票,即他们已经登记,尚未投票。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:357
msgid ""
"You can call these functions using the `starkli call` command. Note that the"
" `call` command is used for read functions, while the `invoke` command is "
"used for functions that can also write to storage. The `call` command does "
"not require signing, while the `invoke` command does."
msgstr ""
"您可以使用“Starkli "
"call”命令调用这些函数。请注意,“调用”命令用于读函数,而“调用”命令用于也可以写入存储的函数。“调用”命令不需要签名,而“调用”命令则需要签名。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:359
msgid ""
"```bash+\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"Bash+ Starkli 呼叫 "
"0x05ea3a690be71c7fd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 "
"选民_can_vote "
"0x03ee9e18edc71a6df30ac3aca2e0b02a1998fcce197480a63a0d71cd76652e0 -rpc "
"http://0.00.0.0:50"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:363
msgid ""
"First we added the address of the contract, then the function we want to "
"call, and finally the input for the function. In this case, we are checking "
"whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can "
"vote."
msgstr ""
"首先我们添加了合同的地址, 然后我们想要调用的函数, 最后是该函数的输入。 在这种情况下, 我们正在检查“ "
"0x03ee9e18edc716df30ac3ca2e02a198fce197480a63a0d71cd76652e0” 的选民是否可以投票。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:365
msgid ""
"Since we provided a registered voter address as an input, the result is 1 "
"(boolean true), indicating the voter is eligible to vote."
msgstr "由于我们提供了登记选民的地址作为投入,结果为1(绝对真实),表明选民有资格投票。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:367
msgid ""
"Next, let's call the `is_voter_registered` function using an unregistered "
"account address to observe the output:"
msgstr "接下来,让我们使用一个未注册的账户地址,将“is_voter_注册”功能称为“is_votter_注册”功能,以观察产出:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:373
msgid ""
"With an unregistered account address, the terminal output is 0 (i.e., "
"false), confirming that the account is not eligible to vote."
msgstr "有未注册的账户地址,终端输出为0(即虚假),确认账户没有资格投票。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:375
msgid "Casting a Vote"
msgstr "投 票 投 票"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:377
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! "
"To vote, we interact with the `vote` function, which is flagged as external,"
" necessitating the use of the `starknet invoke` command."
msgstr "现在,我们已经确定了如何核查选民资格,我们可以投票了!为了投票,我们与“投票”功能互动,该功能被标为外部功能,需要使用“星网援引”命令。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:379
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we"
" submit either `1` (for Yes) or `0` (for No) as our input. When we invoke "
"the `vote` function, we are charged a fee, and the transaction must be "
"signed by the voter; we are writing to the contract's storage."
msgstr ""
"`voke' "
"命令语法类似于`呼叫'命令,但在投票时,我们要么将`1'(是),要么将`0'(否)作为我们的投入,当我们援引`投票'功能时,我们收取费用,交易必须由选民签字;我们正在写到合同的储存处。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:389
msgid ""
"You will be prompted to enter the password for the signer. Once you enter "
"the password, the transaction will be signed and submitted to the Starknet "
"network. You will receive the transaction hash as output. With the starkli "
"transaction command, you can get more details about the transaction:"
msgstr ""
"您将被提示输入签名者的密码。 一旦您输入了密码, 交易将被签名并提交给 Starknet 网络。 您将接收作为输出的交易散列。 使用 strarkli "
"交易命令, 您可以得到关于交易的更多细节 :"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:395
msgid "This returns:"
msgstr "此返回 :"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:399
msgid "\"transaction_hash\""
msgstr "\"交易 -hash\" \"交易 -hash\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:399
msgid "\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""
msgstr "“05604a9792b6811060e70ed0b40959ea9e20ee726220b526ec690de8923907fd”"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:400
msgid "\"max_fee\""
msgstr "\"麻牛'''''''\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:400
msgid "\"0x430e81\""
msgstr "\"0x430e81\" \"0x430e81\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:401
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:410
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:414
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:415
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:416
msgid "\"0x1\""
msgstr "“ 0x11”"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:402
msgid "\"signature\""
msgstr "\"签名\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:403
msgid "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\""
msgstr "\"0x75e548e4880d7a8301b35ff4a1ed1e3d72fffefa64b6c306c334496e6e402d57\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:404
msgid "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""
msgstr "“0xbb6c459b395b35ddd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51”"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:406
msgid "\"nonce\""
msgstr "\"单\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:406
msgid "\"0x3\""
msgstr "\"0x3\" (0x3)"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:407
msgid "\"INVOKE\""
msgstr "\"在电影中\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:408
msgid "\"sender_address\""
msgstr "\"发件人地址\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:408
msgid "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""
msgstr "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fce19b7480a63a0d71cd76652e0\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:409
msgid "\"calldata\""
msgstr "\"呼叫数据\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:411
msgid "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""
msgstr "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2468331d11f3349\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:412
msgid "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""
msgstr ""
"“0.132bdf85fc8aa10aa10ac3c22f022317f8f53d4b4f52235e1eabb3a4cbb08b5c41”"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:413
msgid "\"0x0\""
msgstr "\"0x0\" (0x0)"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:421
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr "如果您试图用同一个签名人两次投票, 将会有错误 :"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:424
msgid "\"Contract error\""
msgstr "“合同错误”"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:427
msgid ""
"The error is not very informative, but you can get more details when looking"
" at the output in the terminal where you started `katana` (our local "
"Starknet node):"
msgstr "错误信息不甚丰富, 但是在您开始“ 卡塔纳” (我们本地的 Starknet 节点) 的终端中查看输出时, 您可以获得更多的细节 :"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:431
msgid ""
"\"Error in the called contract (0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
msgstr ""
"“在所谓的合同中错误(0x03ee9e18edc71a6df30ac3ca2e0b02a1998fcce19b7480a63a0d71cd76652e0):"
" pc=0.81:在执行提示时有一个例外: 自定义提示错误: 执行失败。 失败原因 :\\ \"USER_ ALREADY_ "
"VOTED\\\"...\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:437
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr "错误的密钥是`USER_ALREADY_VOTED'。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:443
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the "
"accounts we want to use for voting. Remember that each Signer must be "
"created from a private key, and each Account Descriptor must be created from"
" a public key, a smart wallet address, and the smart wallet class hash "
"(which is the same for each voter)."
msgstr ""
"我们可以重复为我们要用于投票的账户创建签名人和账户描述符的程序 。 "
"记住每个签名人必须用私人密钥创建,每个账户描述符必须用公共密钥、智能钱包地址和智能钱包类散列(每个选民都一样 ) 创建。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:451
msgid "Visualizing Vote Outcomes"
msgstr "将投票结果可视化"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:453
msgid ""
"To examine the voting results, we invoke the `get_vote_status` function, "
"another view function, through the `starknet call` command."
msgstr "为了审查投票结果,我们通过“星网呼叫”命令,援引“获得选票”的功能,即另一种视图功能。"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:459
msgid ""
"The output reveals the tally of \"Yes\" and \"No\" votes along with their "
"relative percentages."
msgstr "产出显示了“是”和“否”的票数及其相对百分比。"

#: src/ch17-01-general-recommendations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually "
"straightforward. However, preventing unintended usage and vulnerabilities "
"can be more challenging."
msgstr "在开发软件时,确保软件按预期运行通常是直截了当的,但防止意外使用和脆弱性可能更具挑战性。"

#: src/ch17-01-general-recommendations.md:5
msgid ""
"In smart contract development, security is very important. A single error "
"can result in the loss of valuable assets or the improper functioning of "
"certain features."
msgstr "在智能合同开发中,担保非常重要,单一错误可能导致有价值的资产损失或某些特征的不当运作。"

#: src/ch17-01-general-recommendations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can "
"examine the code and interact with it. Any errors or vulnerabilities in the "
"code can be exploited by malicious actors."
msgstr "智能合同在公众环境中执行,任何人都可以检查代码并与代码互动,守则中的任何错误或弱点都可以被恶意行为者利用。"

#: src/ch17-01-general-recommendations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart "
"contracts. By incorporating these concepts during development, you can "
"create robust and reliable smart contracts. This reduces the chance of "
"unexpected behavior or vulnerabilities."
msgstr ""
"本章提出起草安全智能合同的一般性建议,通过在开发过程中纳入这些概念,您可以创建强有力和可靠的智能合同,从而减少出现意外行为或脆弱性的可能性。"

#: src/ch17-01-general-recommendations.md:11
msgid "Disclaimer"
msgstr "免责声明者"

#: src/ch17-01-general-recommendations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security "
"issues, and it does not guarantee that your contracts will be completely "
"secure."
msgstr "本章没有详尽无遗地列出所有可能的安全问题,也不保证你们的合同将完全安全。"

#: src/ch17-01-general-recommendations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly "
"recommended to conduct external audits performed by security experts."
msgstr "如果您正在制订智能生产使用合同,强烈建议由安保专家进行外部审计。"

#: src/ch17-01-general-recommendations.md:17
msgid "Mindset"
msgstr "心心集"

#: src/ch17-01-general-recommendations.md:19
msgid ""
"Cairo is a highly safe language inspired by Rust. It is designed in a way "
"that forces you to cover all possible cases. Security issues on Starknet "
"mostly arise from the way smart contract flows are designed, not much from "
"the language itself."
msgstr ""
"开罗是受鲁斯特启发的高度安全的语言。 其设计方式迫使你覆盖所有可能的案例。 史塔克内特的安全问题主要来自智能合同流动的设计方式,而不是语言本身。"

#: src/ch17-01-general-recommendations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart "
"contracts. Try to always consider all possible scenarios when writing code."
msgstr "采用安全心态是写好安全智能合同的第一步。 尽量在写代码时总是考虑到所有可能的情况。"

#: src/ch17-01-general-recommendations.md:23
msgid "Viewing Smart Contracts as Finite State Machines"
msgstr "将智能合同视为有限国家机器"

#: src/ch17-01-general-recommendations.md:25
msgid ""
"Transactions in smart contracts are atomic, meaning they either succeed or "
"fail without making any changes."
msgstr "智能合同中的交易是原子交易,意味着它们要么成功,要么失败,不作任何改变。"

#: src/ch17-01-general-recommendations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial "
"states defined by the constructor constraints, and external functions "
"represent a set of possible state transitions. A transaction is nothing more"
" than a state transition."
msgstr "将智能合同视为国家机器:它们拥有一套由建筑师限制定义的初始状态,外部功能代表一系列可能的状态转型。 交易只不过是国家转型。"

#: src/ch17-01-general-recommendations.md:29
msgid ""
"The `assert!` or `panic!` macros can be used to validate conditions before "
"performing specific actions. You can learn more about these on the "
"[Unrecoverable Errors with panic](./ch09-01-unrecoverable-errors-with-"
"panic.md) page."
msgstr ""
"`assirt!'或`panic!' 宏可用于在采取具体行动之前验证条件。您可以在[惊慌中无法弥补的错误](./ch09-01-无法恢复的-erors-"
" with-panic.md)页面上了解更多关于这些条件的信息。"

#: src/ch17-01-general-recommendations.md:31
msgid "These validations can include:"
msgstr "这些验证可包括:"

#: src/ch17-01-general-recommendations.md:33
msgid "Inputs provided by the caller"
msgstr "打电话者提供的投入"

#: src/ch17-01-general-recommendations.md:34
msgid "Execution requirements"
msgstr "执行要求"

#: src/ch17-01-general-recommendations.md:35
msgid "Invariants (conditions that must always be true)"
msgstr "变化(条件必须始终是真实的)"

#: src/ch17-01-general-recommendations.md:36
msgid "Return values from other function calls"
msgstr "从其他函数调用返回值"

#: src/ch17-01-general-recommendations.md:38
msgid ""
"For example, you could use the `assert!` macro to validate that a user has "
"enough funds to perform a withdraw transaction. If the condition is not met,"
" the transaction will fail and the state of the contract will not change."
msgstr "例如,您可以使用`assirt!'宏来验证用户是否有足够资金进行撤回交易。如果不符合条件,交易就会失败,合同状况也不会改变。"

#: src/ch17-01-general-recommendations.md:45
msgid "\"Insufficient funds\""
msgstr "“资金不足资金”"

#: src/ch17-01-general-recommendations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly"
" define the boundaries of possible state transitions for each function in "
"your smart contract. These checks ensure that the behavior of the contract "
"stays within the expected limits."
msgstr "使用这些功能来检查条件会增加一些限制,有助于明确界定您智能合同中每项功能可能发生国家过渡的界限。 这些检查确保了合同行为保持在预期限度内。"

#: src/ch17-01-general-recommendations.md:53
msgid "Recommendations"
msgstr "建议建议建议建议建议建议建议"

#: src/ch17-01-general-recommendations.md:55
msgid "Checks Effects Interactions Pattern"
msgstr "检查效果互动模式"

#: src/ch17-01-general-recommendations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to "
"prevent reentrancy attacks on Ethereum. While reentrancy is harder to "
"achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""
"检查效果相互作用模式是一种常见的设计模式,用来防止Etheum再次受到攻击。虽然在斯塔克内特很难实现再现,但仍建议在你的智能合同中使用这种模式。"

#: src/ch17-01-general-recommendations.md:61
msgid ""
"The pattern consists of following a specific order of operations in your "
"functions:"
msgstr "该模式包括按您职务中具体操作顺序排列的操作模式:"

#: src/ch17-01-general-recommendations.md:63
msgid ""
"**Checks**: Validate all conditions and inputs before performing any state "
"changes."
msgstr "** 检查**:在进行任何状态变化之前,验证所有条件和投入。"

#: src/ch17-01-general-recommendations.md:64
msgid "**Effects**: Perform all state changes."
msgstr "** 效果**:进行所有状态变化。"

#: src/ch17-01-general-recommendations.md:65
msgid ""
"**Interactions**: All external calls to other contracts should be made at "
"the end of the function."
msgstr "** 互动**:所有向其他合同发出的外部电话都应在职能结束时发出。"

#: src/ch17-01-general-recommendations.md:67
msgid "Access Control"
msgstr "出入控制"

#: src/ch17-01-general-recommendations.md:69
msgid ""
"Access control is the process of restricting access to certain features or "
"resources. It is a common security mechanism used to prevent unauthorized "
"access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""
"出入控制是限制获取某些特征或资源的过程,是用来防止未经授权获取敏感信息或行动的一个共同安全机制,在智能合同中,某些职能往往仅限于特定的用户或角色。"

#: src/ch17-01-general-recommendations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. "
"This pattern consists of defining a set of roles and assigning them to "
"specific users. Each function can then be restricted to specific roles."
msgstr "您可以使用访问控制模式来方便地管理权限。这个模式包括定义一组角色并将其分配给特定的用户。然后,每个功能可以局限于特定的角色。"

#: src/ch17-01-general-recommendations.md:92
msgid "// Role 'owner': only one address\n"
msgstr "角色“所有人”:只有一个地址\n"

#: src/ch17-01-general-recommendations.md:94
msgid "// Role 'role_a': a set of addresses\n"
msgstr "角色“作用_a”:一套地址\n"

#: src/ch17-01-general-recommendations.md:103
msgid "// Guard functions to check roles\n"
msgstr "/ 警卫职能检查角色\n"

#: src/ch17-01-general-recommendations.md:118
msgid "\"Not owner\""
msgstr "\"不是所有者\""

#: src/ch17-01-general-recommendations.md:123
msgid "\"Not role A\""
msgstr "\"不是角色A\""

#: src/ch17-01-general-recommendations.md:126
msgid "// You can easily combine guards to perform complex checks\n"
msgstr "你可以很容易地把警卫合在一起 来进行复杂的检查\n"

#: src/ch17-01-general-recommendations.md:128
msgid "\"Not allowed\""
msgstr "\"不允许\""

#: src/ch17-01-general-recommendations.md:131
msgid "// Functions to manage roles\n"
msgstr "/ 管理作用的职能\n"

#: src/ch17-01-general-recommendations.md:138
msgid ""
"// You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
msgstr "现在您可以关注您的合同的商业逻辑 并且通过使用警卫功能 降低您的代码的复杂性\n"

#: src/ch17-02-testing-smart-contracts.md:3
msgid ""
"Testing smart contracts is a critical part of the development process. It is"
" important to ensure that smart contracts behave as expected and that they "
"are secure."
msgstr "测试智能合同是发展进程的一个关键部分,必须确保智能合同按预期行事,并确保其安全。"

#: src/ch17-02-testing-smart-contracts.md:5
msgid ""
"In a previous section of the Cairo Book, we learned how to write and "
"structure our tests for Cairo programs. We demonstrated how these tests "
"could be run using the `scarb` command-line tool. While this approach is "
"useful for testing standalone Cairo programs and functions, it lacks "
"functionality for testing smart contracts that require control over the "
"contract state and execution context. Therefore, in this section, we will "
"introduce how to use Starknet Foundry, a smart contract development "
"toolchain for Starknet, to test your Cairo contracts."
msgstr ""
"在《开罗书》前一节,我们学会了如何写作和构建开罗程序测试。我们展示了这些测试如何使用“切割”指令线工具进行。这种方法虽然有助于测试独立的开罗程序和功能,但缺乏测试需要控制合同状态和执行背景的智能合同的功能。因此,在本节中,我们将介绍如何使用斯塔克内特·菲茨里(Starknet"
" Foundry)这个为斯塔克内特设计的智能合同开发工具链来测试您的开罗合同。"

#: src/ch17-02-testing-smart-contracts.md:8
msgid ""
"Throughout this chapter, we will be using as an example the `PizzaFactory` "
"contract in Listing 17-1 to demonstrate how to write tests with Starknet "
"Foundry."
msgstr "在整个本章中,我们将以17-1清单中的`Pizza Factory'合同为例,示范如何与Starknet Foundry进行测试。"

#: src/ch17-02-testing-smart-contracts.md:59
#: src/ch17-02-testing-smart-contracts.md:64
msgid "\"Amount cannot be 0\""
msgstr "\"数量不能为 0\""

#: src/ch17-02-testing-smart-contracts.md:69
msgid "\"Not enough pepperoni\""
msgstr "\"香肠不够\""

#: src/ch17-02-testing-smart-contracts.md:70
msgid "\"Not enough pineapple\""
msgstr "\"菠萝不够\""

#: src/ch17-02-testing-smart-contracts.md:75
#: src/ch17-02-testing-smart-contracts.md:210
#: src/ch17-02-testing-smart-contracts.md:326
#: src/ch17-02-testing-smart-contracts.md:438
#: src/ch17-02-testing-smart-contracts.md:550
#: src/ch17-02-testing-smart-contracts.md:664
msgid "\"Only the owner can make pizza\""
msgstr "\"只有店主才能做披萨\""

#: src/ch17-02-testing-smart-contracts.md:101
#: src/ch17-02-testing-smart-contracts.md:200
#: src/ch17-02-testing-smart-contracts.md:316
#: src/ch17-02-testing-smart-contracts.md:428
#: src/ch17-02-testing-smart-contracts.md:540
#: src/ch17-02-testing-smart-contracts.md:654
msgid "\"Only the owner can set ownership\""
msgstr "\"只有所有者才能确定所有权\""

#: src/ch17-02-testing-smart-contracts.md:109
msgid ""
"<span class=\"caption\">Listing 17-1: A pizza factory that needs to be "
"tested</span>"
msgstr "<span class=\"caption\" > listing 17-1:需要测试的披萨工厂 </span>"

#: src/ch17-02-testing-smart-contracts.md:111
msgid "Configuring your Scarb project with Starknet Foundry"
msgstr "与 Starknet 铸造公司一起配置您的刀疤项目"

#: src/ch17-02-testing-smart-contracts.md:113
msgid ""
"The settings of your Scarb project can be configured in the `Scarb.toml` "
"file. To use Starknet Foundry as your testing tool, you will need to add it "
"as a dev dependency in your `Scarb.toml` file. At the time of writing, the "
"latest version of Starknet Foundry is `v0.22.0` - but you should use the "
"latest version."
msgstr ""
"您的刀疤工程的设置可以配置在 `Scarb.toml' 文件中。 要使用 Starknet Foundry 作为测试工具, 您需要在您的“ Scarb."
" toml” 文件中添加此设置作为 dev 依赖性。 在撰写本文件时, Starknet Foundry 的最新版本是`v0. 22.0' - "
"但你应该使用最新版本 。"

#: src/ch17-02-testing-smart-contracts.md:115
msgid ""
"```toml,noplayground\n"
"[dev-dependencies]\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"v0.22.0\" }\n"
"\n"
"[scripts]\n"
"test = \"snforge test\"\n"
"```"
msgstr ""
"@toml, noplayfloor [dev-dependies] snforge_std = {git = "
"\"https://gitub.com/foundry-rs/foundry-rs/starknet-foundry.git\",标签= "
"\"v0.22.0\" }[脚本] 测试= \" snforge test\" = screts"

#: src/ch17-02-testing-smart-contracts.md:123
msgid ""
"The `scarb test` command is configured to execute `scarb cairo-test` by "
"default. In our settings, we have configured it to execute `snforge test` "
"instead. This will allow us to run our tests using Starknet Foundry when we "
"run the `scarb test` command."
msgstr ""
"`碳试验' "
"命令被配置为默认地执行`碳试验'。在我们设置中,我们已经配置了它来执行`鼻孔试验',这将使我们能够在运行`碎片试验'命令时使用Starknet "
"Foundry进行测试。"

#: src/ch17-02-testing-smart-contracts.md:125
msgid ""
"Once your project is configured, you will need to install Starknet Foundry "
"by following the installation guide from the [Starknet Foundry "
"Documentation](https://foundry-rs.github.io/starknet-foundry/getting-"
"started/installation.html). As usual, we recommend to use `asdf` to manage "
"versions of your development tools."
msgstr ""
"一旦您的工程配置完毕, 您将需要安装 Starknet Foundry, 并遵循[ Starknet Foundry Documents] "
"(https://foundry- rs.github.io/starknet- foundry/getting- "
"started/stallation. html) 的安装指南。 和往常一样, 我们建议使用“ asdf” 来管理您的开发工具的版本 。"

#: src/ch17-02-testing-smart-contracts.md:127
msgid "Testing Smart Contracts with Starknet Foundry"
msgstr "与斯塔克内特铸造公司测试智能合同"

#: src/ch17-02-testing-smart-contracts.md:129
msgid ""
"The usual command to run your tests using Starknet Foundry is `snforge "
"test`. However, when we configured our projects, we defined that the `scarb "
"test` command will run the `snforge test` command. Therefore, during the "
"rest of this chapter, consider that the `scarb test` command will be using "
"`snforge test` under the hood."
msgstr ""
"使用 Starknet Foundry 进行测试的通常命令是`鼻孔试验 "
"',然而,当我们配置项目时,我们确定`刀疤试验'命令将运行`鼻孔试验'命令,因此,在本章其余部分,考虑`刀疤试验'命令将使用头罩下的`鼻孔试验'。"

#: src/ch17-02-testing-smart-contracts.md:131
msgid "The usual testing flow of a contract is as follows:"
msgstr "合同通常的测试流程如下:"

#: src/ch17-02-testing-smart-contracts.md:133
msgid "Declare the class of the contract to test, identified by its name"
msgstr "宣布以其名称标明的检验合同类别"

#: src/ch17-02-testing-smart-contracts.md:134
msgid "Serialize the constructor calldata into an array"
msgstr "将构建器调用数据序列化为数组"

#: src/ch17-02-testing-smart-contracts.md:135
msgid "Deploy the contract and retrieve its address"
msgstr "部署合同并检索其地址"

#: src/ch17-02-testing-smart-contracts.md:136
msgid "Interact with the contract's entrypoint to test various scenarios"
msgstr "与合同的切入点进行互动,以测试各种设想情况"

#: src/ch17-02-testing-smart-contracts.md:138
msgid "Deploying the Contract to Test"
msgstr "部署测试合同"

#: src/ch17-02-testing-smart-contracts.md:140
msgid ""
"In Listing 17-2, we wrote a function that deploys the `PizzaFactory` "
"contract and sets up the dispatcher for interactions."
msgstr "在名单17-2中,我们写了一个功能,即部署`Pizza Factory'合同,并设立互动调度员。"

#: src/ch17-02-testing-smart-contracts.md:162
#: src/ch17-02-testing-smart-contracts.md:278
#: src/ch17-02-testing-smart-contracts.md:390
#: src/ch17-02-testing-smart-contracts.md:502
#: src/ch17-02-testing-smart-contracts.md:616
msgid "\"PizzaFactory\""
msgstr "\"披萨脚步\""

#: src/ch17-02-testing-smart-contracts.md:178
#: src/ch17-02-testing-smart-contracts.md:294
#: src/ch17-02-testing-smart-contracts.md:406
#: src/ch17-02-testing-smart-contracts.md:518
#: src/ch17-02-testing-smart-contracts.md:632
msgid "\"pepperoni\""
msgstr "\"帕波罗尼\""

#: src/ch17-02-testing-smart-contracts.md:179
#: src/ch17-02-testing-smart-contracts.md:295
#: src/ch17-02-testing-smart-contracts.md:407
#: src/ch17-02-testing-smart-contracts.md:519
#: src/ch17-02-testing-smart-contracts.md:633
msgid "\"pineapple\""
msgstr "\"菠萝\""

#: src/ch17-02-testing-smart-contracts.md:221
#: src/ch17-02-testing-smart-contracts.md:337
#: src/ch17-02-testing-smart-contracts.md:449
#: src/ch17-02-testing-smart-contracts.md:561
#: src/ch17-02-testing-smart-contracts.md:675
msgid "// Setup\n"
msgstr "/ 设置\n"

#: src/ch17-02-testing-smart-contracts.md:226
#: src/ch17-02-testing-smart-contracts.md:342
#: src/ch17-02-testing-smart-contracts.md:454
#: src/ch17-02-testing-smart-contracts.md:566
#: src/ch17-02-testing-smart-contracts.md:680
msgid "// When\n"
msgstr "/ 何时\n"

#: src/ch17-02-testing-smart-contracts.md:229
#: src/ch17-02-testing-smart-contracts.md:345
#: src/ch17-02-testing-smart-contracts.md:457
#: src/ch17-02-testing-smart-contracts.md:569
#: src/ch17-02-testing-smart-contracts.md:683
msgid "// Then\n"
msgstr "礛\n"

#: src/ch17-02-testing-smart-contracts.md:246
msgid "<span class=\"caption\">Listing 17-2 Deploying the contract to test</span>"
msgstr "<span类=“caption” > listing 17-2 部署合同以测试 </span>"

#: src/ch17-02-testing-smart-contracts.md:248
msgid "Testing our Contract"
msgstr "测试我们的合同"

#: src/ch17-02-testing-smart-contracts.md:250
msgid ""
"Determining the behavior that your contract should respect is the first step"
" in writing tests. In the `PizzaFactory` contract, we determined that the "
"contract should have the following behavior:"
msgstr "在`Pizza Factory'合同中,我们确定合同应具有以下行为:"

#: src/ch17-02-testing-smart-contracts.md:252
msgid ""
"Upon deployment, the contract owner should be set to the address provided in"
" the constructor, and the factory should have 10 units of pepperoni and "
"pineapple, and no pizzas created."
msgstr "在部署时,合同所有人应定在建筑商提供的地址,工厂应拥有10个单位的辣椒和菠萝,不得制造披萨。"

#: src/ch17-02-testing-smart-contracts.md:253
msgid ""
"If someone tries to make a pizza and they are not the owner, the operation "
"should fail. Otherwise, the pizza count should be incremented, and an event "
"should be emitted."
msgstr "如果有人试图做披萨,而他们不是披萨的主人,手术就应该失败。 否则,披萨的计数应该增加,事件应该被排放出来。"

#: src/ch17-02-testing-smart-contracts.md:254
msgid ""
"If someone tries to take ownership of the contract and they are not the "
"owner, the operation should fail. Otherwise, the owner should be updated."
msgstr "如果有人试图取得合同的所有权,而他们不是合同的所有人,经营就应该失败,否则,所有者应当更新。"

#: src/ch17-02-testing-smart-contracts.md:256
msgid "Accessing Storage Variables with `load`"
msgstr "使用带有“装载”的存储变量"

#: src/ch17-02-testing-smart-contracts.md:362
msgid ""
"<span class=\"caption\">Listing 17-3: Testing the initial state by loading "
"storage variables </span>"
msgstr "<span类=“caption” >Listing 17-3:通过装入存储变量 </span>测试初始状态"

#: src/ch17-02-testing-smart-contracts.md:364
msgid ""
"Once our contract is deployed, we want to assert that the initial values are"
" set as expected. If our contract has an entrypoint that returns the value "
"of a storage variable, we can call this entrypoint. Otherwise, we can use "
"the `load` function from `snforge` to load the value of a storage variable "
"inside our contract, even if not exposed by an entrypoint."
msgstr ""
"一旦我们的合同部署完毕,我们想断言初始价值是按预期确定的,如果我们的合同有一个返回存储变量价值的切入点,我们可以调用这个切入点,否则,我们可以使用`鼻孔'中的`装载'功能来装载我们合同中的存储变量价值,即使未通过一个切入点暴露。"

#: src/ch17-02-testing-smart-contracts.md:366
msgid "Mocking the Caller Address with `start_cheat_caller_address`"
msgstr "以“ start_chead_caller_address” 模拟调用器地址"

#: src/ch17-02-testing-smart-contracts.md:368
msgid ""
"The security of our factory relies on the owner being the only one able to "
"make pizzas and transfer ownership. To test this, we can use the "
"`start_cheat_caller_address` function to mock the caller address and assert "
"that the contract behaves as expected."
msgstr ""
"我们工厂的安全依赖于所有者是唯一能够做披萨和转让所有权的人,为了测试这一点,我们可以使用`开机机'功能来嘲笑电话地址,并声称合同行为符合预期。"

#: src/ch17-02-testing-smart-contracts.md:474
msgid ""
"<span class=\"caption\">Listing 17-4: Testing ownership of the contract by "
"mocking the caller address </span>"
msgstr "<span类=“Caption” >Listing 17-4:模拟调用地址 </span>测试合同所有权"

#: src/ch17-02-testing-smart-contracts.md:476
msgid ""
"Using `start_cheat_caller_address`, we call the `change_owner` function "
"first as the owner, and then as a different address. We assert that the "
"operation fails when the caller is not the owner, and that the owner is "
"updated when the caller is the owner."
msgstr ""
"使用“start_chead_caller_address”,我们首先将“change_所有者”的功能称为拥有者,然后将它称为不同的地址。我们声称,如果调用者不是拥有者,操作就会失败,如果调用者是拥有者,则会更新所有者。"

#: src/ch17-02-testing-smart-contracts.md:478
msgid "Capturing Events with `spy_events`"
msgstr "以`spy_events' 拍摄事件"

#: src/ch17-02-testing-smart-contracts.md:480
msgid ""
"When a pizza is created, the contract emits an event. To test this, we can "
"use the `spy_events` function to capture the emitted events and assert that "
"the event was emitted with the expected parameters. Naturally, we can also "
"assert that the pizza count was incremented, and that only the owner can "
"make a pizza."
msgstr ""
"创建比萨饼时, 合同会发出事件。 为了测试这一点, 我们可以使用“ spy_ events” 功能来捕捉排放的事件, 并声明事件是用预期参数排放的。 "
"当然, 我们还可以断言比萨饼的计数是增加的, 只有拥有者才能做比萨饼 。"

#: src/ch17-02-testing-smart-contracts.md:586
msgid ""
"<span class=\"caption\">Listing 17-5: Testing the events emitted when a "
"pizza is created</span>"
msgstr "<span class=\"caption\" > listing 17-5: 测试披萨创建时所排放的事件 </span>"

#: src/ch17-02-testing-smart-contracts.md:588
msgid "Accessing Internal Functions with `contract_state_for_testing`"
msgstr "使用`contract_state_ for_测试' 访问内部函数"

#: src/ch17-02-testing-smart-contracts.md:590
msgid ""
"All the tests we have seen so far have been using a workflow that involves "
"deploying the contract and interacting with the contract's entrypoints. "
"However, sometimes we may want to test the internals of the contract "
"directly, without deploying the contract. How could this be done, if we were"
" reasoning in purely Cairo terms?"
msgstr ""
"迄今为止,我们所看到的所有测试都使用了一个工作流程,涉及部署合同和与合同的切入点互动。 但是,有时我们可能想直接测试合同的内部,而不必部署合同。 "
"如果我们纯粹是开罗条款的推理,我们如何做到这一点呢?"

#: src/ch17-02-testing-smart-contracts.md:592
msgid ""
"Recall the struct `ContractState`, which is used as a parameter to all the "
"entrypoints of a contract. To make it short, this struct contains zero-sized"
" fields, corresponding to the storage variables of the contract. The only "
"purpose of these fields is to allow the Cairo compiler to generate the "
"correct code for accessing the storage variables. If we could create an "
"instance of this struct, we could access these storage variables directly, "
"without deploying the contract..."
msgstr ""
"回顾作为合同所有切入点参数的“合同国”结构。为了缩短这一结构,它包含与合同储存变量相对应的零尺寸字段。这些区域的唯一目的是让开罗编译器生成正确的代码来访问存储变量。如果我们能够创建这种结构实例,我们可以直接访问这些存储变量,而不必部署合同..."

#: src/ch17-02-testing-smart-contracts.md:594
msgid ""
"...and this is exactly what the `contract_state_for_testing` function does! "
"It creates an instance of the `ContractState` struct, allowing us to call "
"any function that takes as parameter a `ContractState` struct, without "
"deploying the contract. To interact with the storage variables properly, we "
"need to manually import the traits that define access to the storage "
"variables."
msgstr ""
"......这正是` Contract_state_for_test' "
"函数的作用!它创造了一个`缔约国'结构的例子,允许我们在不部署合同的情况下,将任何功能称为`缔约国'结构的参数,为了与储存变量进行适当互动,我们需要手动输入确定存贮变量访问权限的特性。"

#: src/ch17-02-testing-smart-contracts.md:700
msgid ""
"<span class=\"caption\">Listing 17-6: Unit testing our contract without "
"deployment</span>"
msgstr "<span class=\"caption\" > listing 17-6:在不部署情况下测试我们合同的单位 </span>"

#: src/ch17-02-testing-smart-contracts.md:702
msgid ""
"These imports give us access to our internal functions (notably, "
"`set_owner`), as well as the read/write access to the `owner` storage "
"variable. Once we have these, we can interact with the contract directly, "
"changing the address of the owner by calling the `set_owner` method, "
"accessible through `InternalTrait`, and reading the `owner` storage "
"variable."
msgstr ""
"这些进口使我们有机会使用我们的内部功能(特别是`set_所有人'),以及读/写查阅`所有者'储存变量,一旦有了这些变量,我们可以直接与合同互动,改变所有者地址,称为`set_所有人'方法,可通过`InternalTrait'进入,并阅读`所有者'储存变量。"

#: src/ch17-02-testing-smart-contracts.md:707
msgid ""
"Note: Both approaches cannot be used at the same time. If you decide to "
"deploy the contract, you interact with it using the dispatcher. If you "
"decide to test the internal functions, you interact with the `ContractState`"
" object directly."
msgstr "注:两种方法不能同时使用。如果决定部署合同,使用调度员与合同互动。如果决定测试内部功能,直接与`缔约国'对象互动。"

#: src/ch17-02-testing-smart-contracts.md:728
msgid ""
"The output of the tests shows that all the tests passed successfully, along "
"with an estimation of the gas consumed by each test."
msgstr "测试结果显示,所有测试都成功通过,同时对每次测试所消耗的气体进行了估计。"

#: src/ch17-02-testing-smart-contracts.md:732
msgid ""
"In this chapter, we learned how to test smart contracts using Starknet "
"Foundry. We demonstrated how to deploy a contract and interact with it using"
" the dispatcher. We also showed how to test the contract's behavior by "
"mocking the caller address and capturing events. Finally, we demonstrated "
"how to test the internal functions of the contract directly, without "
"deploying the contract."
msgstr ""
"在本章中,我们学会了如何使用斯塔克内特基金会测试智能合同。我们演示了如何部署合同,并利用调度员与合同互动。我们还演示了如何通过嘲笑电话地址和捕捉事件来测试合同行为。最后,我们演示了如何直接测试合同的内部功能,而没有部署合同。"

#: src/ch17-02-testing-smart-contracts.md:734
msgid ""
"To learn more about Starknet Foundry, refer to the [Starknet Foundry "
"documentation](https://foundry-rs.github.io/starknet-foundry/index.html)."
msgstr ""
"欲了解关于斯塔克内特基金会的更多情况,请查阅[斯塔克内特基金会的文件](https://foundry-rs.github.io/starknet-"
"foundry/index.html)。"

#: src/ch17-03-static-analysis-tools.md:3
msgid ""
"Static analysis refers to the process of examining code without its "
"execution, focusing on its structure, syntax, and properties. It involves "
"analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr "静态分析是指在不执行守则的情况下审查守则的过程,重点是守则的结构、语法和财产,包括分析源代码,以查明潜在的问题、弱点或违反特定规则的情况。"

#: src/ch17-03-static-analysis-tools.md:5
msgid ""
"By defining rules, such as coding conventions or security guidelines, "
"developers can utilize static analysis tools to automatically check the code"
" against these standards."
msgstr "通过界定规则,例如编码公约或安全准则,开发者可以利用静态分析工具,自动对照这些标准检查编码。"

#: src/ch17-03-static-analysis-tools.md:7
msgid "Reference:"
msgstr "参考:"

#: src/ch17-03-static-analysis-tools.md:9
msgid ""
"[Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-"
"supports-cairo-1-0)"
msgstr ""
"[开罗1.0支持标准](http://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0)"

#: src/ch17-03-static-analysis-tools.md:10
msgid ""
"[Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"
msgstr "[Caracal,斯塔克内特静态分析机] (https://github.com/crytic/caracal)"

#: src/appendix-000.md
msgid ""
"The following sections contain reference material you may find useful in "
"your Starknet journey."
msgstr "以下各节载有您在史塔克内特旅途中可能认为有用的参考材料。"

#: src/appendix-08-system-calls.md:1
msgid "Appendix A - System Calls"
msgstr "附录A - 系统呼叫"

#: src/appendix-08-system-calls.md:3
msgid ""
"This chapter is based on the StarkNet documentation available at [StarkNet "
"Docs](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-"
"calls-cairo1/)."
msgstr ""
"本章以可在[StarkNet Docs] "
"(https://docs.starknet.io/documentation/architecture_and_confits/Smart_contracts/system-"
"calls-cairo1)上查阅的斯塔克网络文件为基础。"

#: src/appendix-08-system-calls.md:5
msgid ""
"Writing smart contracts requires various associated operations, such as "
"calling another contract or accessing the contract’s storage, that "
"standalone programs do not require."
msgstr "书写智能合同需要各种相关业务, 如调用另一合同或进入合同储存,"

#: src/appendix-08-system-calls.md:7
msgid ""
"The Starknet contract language supports these operations by using system "
"calls. System calls enable a contract to require services from the Starknet "
"OS. You can use system calls in a function to get information that depends "
"on the broader state of Starknet, which would otherwise be inaccessible, "
"rather than local variables that appear in the function’s scope."
msgstr ""
"Starknet 合同语言使用系统电话支持这些操作。 系统电话使合同能够要求 Starknet OS 服务。 您可以使用系统电话来获取信息, "
"这些信息取决于更广大的 Starknet 状态, 否则无法获取, 而不是功能范围内出现的本地变量 。"

#: src/appendix-08-system-calls.md:9
msgid "Here is a list of the system calls available in Cairo 1.0:"
msgstr "以下是开罗1.0的系统呼叫列表:"

#: src/appendix-08-system-calls.md:11
msgid "[get_block_hash](#get_block_hash)"
msgstr ""
"[get_ block_hash] (# get_ block_hash) (# get_ block_hash) (# get_ "
"block_hash) (# get_ block_hash)"

#: src/appendix-08-system-calls.md:12
msgid "[get_execution_info](#get_execution_info)"
msgstr "[找到_ 执行_ info] (# get_ 执行_ info)"

#: src/appendix-08-system-calls.md:13
msgid "[call_contract](#call_contract)"
msgstr "[电话_合同] (#电话_合同)"

#: src/appendix-08-system-calls.md:14
msgid "[deploy](#deploy)"
msgstr "[部署](#部署)"

#: src/appendix-08-system-calls.md:15
msgid "[emit_event](#emit_event)"
msgstr "[emit_event] (# emit_event) (# emit_event)"

#: src/appendix-08-system-calls.md:16
msgid "[library_call](#library_call)"
msgstr "[library_call] (# library_call) (# library_call) (# library_call)"

#: src/appendix-08-system-calls.md:17
msgid "[send_message_to_L1](#send_message_to_l1)"
msgstr "[send_message_to_L1] (# send_message_to_l1) (# send_message_to_l1)"

#: src/appendix-08-system-calls.md:18
msgid "[replace_class](#replace_class)"
msgstr "[替换_类](#替换_类)"

#: src/appendix-08-system-calls.md:19
msgid "[storage_read](#storage_read)"
msgstr "[存储重 (# 存储重 )"

#: src/appendix-08-system-calls.md:20
msgid "[storage_write](#storage_write)"
msgstr "[存储_ write] (# 存储_ write)"

#: src/appendix-08-system-calls.md:22
msgid "`get_block_hash`"
msgstr ""

#: src/appendix-08-system-calls.md:24 src/appendix-08-system-calls.md:51
#: src/appendix-08-system-calls.md:79 src/appendix-08-system-calls.md:117
#: src/appendix-08-system-calls.md:153 src/appendix-08-system-calls.md:198
#: src/appendix-08-system-calls.md:230 src/appendix-08-system-calls.md:273
#: src/appendix-08-system-calls.md:305 src/appendix-08-system-calls.md:348
msgid "Syntax"
msgstr "语法 语法"

#: src/appendix-08-system-calls.md:32 src/appendix-08-system-calls.md:59
#: src/appendix-08-system-calls.md:87 src/appendix-08-system-calls.md:128
#: src/appendix-08-system-calls.md:161 src/appendix-08-system-calls.md:206
#: src/appendix-08-system-calls.md:238 src/appendix-08-system-calls.md:281
#: src/appendix-08-system-calls.md:313 src/appendix-08-system-calls.md:356
msgid "Description"
msgstr "说明说明"

#: src/appendix-08-system-calls.md:34
msgid ""
"Gets the hash of a specific StarkNet block within the range of "
"`[first_v0_12_0_block, current_block - 10]`."
msgstr "在`[第一个_v0_12_0_0区块、当前_区块 - 10] 的范围内获取特定的 StarkNet 区块的散列。"

#: src/appendix-08-system-calls.md:36 src/appendix-08-system-calls.md:69
#: src/appendix-08-system-calls.md:103 src/appendix-08-system-calls.md:139
#: src/appendix-08-system-calls.md:173 src/appendix-08-system-calls.md:220
#: src/appendix-08-system-calls.md:252 src/appendix-08-system-calls.md:295
#: src/appendix-08-system-calls.md:327 src/appendix-08-system-calls.md:372
msgid "Return Values"
msgstr "回报值"

#: src/appendix-08-system-calls.md:38
msgid "Returns the hash of the given block."
msgstr "返回给定区块的散列。"

#: src/appendix-08-system-calls.md:40
msgid "Error Messages"
msgstr "错误消息"

#: src/appendix-08-system-calls.md:42
msgid ""
"`Block number out of range`: `block_number` is greater than "
"_`current_block`_`- 10`."
msgstr "`超出范围的区号':`区号_数目'大于`流动_区号_-10'。"

#: src/appendix-08-system-calls.md:43
msgid "`0`: `block_number` is less than the first block number of v0.12.0."
msgstr "`0':`区块号'小于v0.12.0的第一个区块号。"

#: src/appendix-08-system-calls.md:45 src/appendix-08-system-calls.md:73
#: src/appendix-08-system-calls.md:107 src/appendix-08-system-calls.md:147
#: src/appendix-08-system-calls.md:192 src/appendix-08-system-calls.md:224
#: src/appendix-08-system-calls.md:267 src/appendix-08-system-calls.md:299
#: src/appendix-08-system-calls.md:342 src/appendix-08-system-calls.md:376
msgid "Common Library"
msgstr "共同图书馆"

#: src/appendix-08-system-calls.md:47
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls.cairo#L37)"
msgstr ""
"[syscalles.cairo] (https://github.com/starkware-"
"libs/cairo/blob/0c882679fdb24a818cad19f2c18decbf665153/corelib/src/starknet/syscalls.cairo#L37)"

#: src/appendix-08-system-calls.md:49
msgid "`get_execution_info`"
msgstr "获取_ 执行_ info"

#: src/appendix-08-system-calls.md:61
msgid "Gets information about the original transaction."
msgstr "获取原始交易的信息 。"

#: src/appendix-08-system-calls.md:63
msgid ""
"In Cairo 1.0, all block/transaction/execution context getters are batched "
"into this single system call."
msgstr "在开罗1.0,所有区块/交易/执行环境抓取器都分批到这个单一的系统呼叫中。"

#: src/appendix-08-system-calls.md:65 src/appendix-08-system-calls.md:97
#: src/appendix-08-system-calls.md:132 src/appendix-08-system-calls.md:167
#: src/appendix-08-system-calls.md:212 src/appendix-08-system-calls.md:246
#: src/appendix-08-system-calls.md:291 src/appendix-08-system-calls.md:321
#: src/appendix-08-system-calls.md:364
msgid "Arguments"
msgstr "参数参数"

#: src/appendix-08-system-calls.md:67 src/appendix-08-system-calls.md:175
#: src/appendix-08-system-calls.md:254 src/appendix-08-system-calls.md:297
#: src/appendix-08-system-calls.md:374
msgid "None."
msgstr "无。"

#: src/appendix-08-system-calls.md:71
msgid ""
"Returns a [struct](https://github.com/starkware-"
"libs/cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8)"
" containing the execution info."
msgstr ""
"返回 a (https://github.com/starkware-libs/cairo/blob/efbf69d4e93a60faa "
"66e1363fd01522b8fcedbb00a/corelib/src/starknet/info.cairo#L8) 含有执行信息。"

#: src/appendix-08-system-calls.md:75
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L35)"
msgstr ""
"[声传 (https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb358797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L35)"

#: src/appendix-08-system-calls.md:77
msgid "`call_contract`"
msgstr "`呼叫_合同 '"

#: src/appendix-08-system-calls.md:89
msgid ""
"Calls a given contract. This system call expects the address of the called "
"contract, a selector for a function within that contract, and call "
"arguments."
msgstr "系统呼叫预期该合同的地址,即该合同内某项职能的选定人,并标注参数。"

#: src/appendix-08-system-calls.md:91 src/appendix-08-system-calls.md:285
msgid "**Note:**"
msgstr "** 注:**"

#: src/appendix-08-system-calls.md:93
msgid ""
"An internal call can’t return Err(\\_) as this is not handled by the "
"sequencer and the Starknet OS."
msgstr "内部呼叫无法返回 Err( ), 因为这不是由定序器和 Starknet OS 处理的 。"

#: src/appendix-08-system-calls.md:95
msgid ""
"If call_contract_syscall fails, this can’t be caught and will therefore "
"result in the entire transaction being reverted."
msgstr "如果调用- contract_syscall 失败, 无法抓住这个机会, 因此会导致整个交易被退回 。"

#: src/appendix-08-system-calls.md:99
msgid "_`address`_: The address of the contract you want to call."
msgstr "地址:您要调用的合同地址 。"

#: src/appendix-08-system-calls.md:100
msgid ""
"_`entry_point_selector`_: A selector for a function within that contract, "
"can be computed with the `selector!` macro."
msgstr "\\\\ entr_ point_ elector } : 合同中函数的选择器, 可以用“ 选择器! ” 宏计算 。"

#: src/appendix-08-system-calls.md:101
msgid "_`calldata`_: The calldata array."
msgstr "呼叫数据:呼叫数据阵列。"

#: src/appendix-08-system-calls.md:105 src/appendix-08-system-calls.md:222
msgid "The call response, of type `SyscallResult<Span<felt252>>`."
msgstr "呼叫响应,类型为“SyscallResult <Span<felt252”。"

#: src/appendix-08-system-calls.md:109
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10)"
msgstr ""
"[声传 (https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb358797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10)"

#: src/appendix-08-system-calls.md:111
msgid ""
"**Note:** This is considered a lower-level syntax for calling contracts. If "
"the interface of the called contract is available, then you can use a more "
"straightforward syntax."
msgstr "** 注:** 这被认为是调用合同的较低级别的语法。如果有所谓的合同的界面,那么您可以使用更直截了当的语法。"

#: src/appendix-08-system-calls.md:115
msgid "`deploy`"
msgstr "`部署 '"

#: src/appendix-08-system-calls.md:130
msgid "Deploys a new instance of a previously declared class."
msgstr "部署一个新例子 之前申报的等级。"

#: src/appendix-08-system-calls.md:134
msgid "_`class_hash`_: The class hash of the contract to be deployed."
msgstr ""

#: src/appendix-08-system-calls.md:135
msgid ""
"_`contract_address_salt`_: The salt, an arbitrary value provided by the "
"sender. It is used in the computation of the contract’s address."
msgstr "合同_地址_salt:盐,发件人提供的任意价值。用于计算合同地址。"

#: src/appendix-08-system-calls.md:136
msgid "_`calldata`_: The constructor’s calldata. An array of felts."
msgstr "@calldata:建筑商的调用数据。"

#: src/appendix-08-system-calls.md:137
msgid ""
"_`deploy_from_zero`_: A flag used for the contract address computation. If "
"not set, the caller address will be used as the new contract’s deployer "
"address, otherwise 0 is used."
msgstr ""
"由_ zero * 调出 : 合同地址计算所使用的旗帜。 如果不设置, 将使用呼叫地址作为新合同的部署地址, 否则使用 0 。 @ info: "
"whatsthis"

#: src/appendix-08-system-calls.md:141
msgid "A tuple wrapped with SyscallResult where:"
msgstr "由SyscallResult包着的图普:"

#: src/appendix-08-system-calls.md:143
msgid ""
"The first element is the address of the deployed contract, of type "
"`ContractAddress`."
msgstr "第一个要素是部署合同的地址,即`合同地址'类型。"

#: src/appendix-08-system-calls.md:145
msgid ""
"The second element is the response array from the contract’s constructor, of"
" type `Span::<felt252>`."
msgstr ""
"第二个要素是合同施工者的反应阵列,即`span:<felt252>"

#: src/appendix-08-system-calls.md:149
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls.cairo#L22)"
msgstr ""
"[缩略语.cairo] (https://github.com/starkware-"
"libs/cairo/blob/4821865770ac9.e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls.cairo#L22)"

#: src/appendix-08-system-calls.md:151
msgid "`emit_event`"
msgstr "`弥撒活动'"

#: src/appendix-08-system-calls.md:163
msgid "Emits an event with a given set of keys and data."
msgstr "以给定的一组密钥和数据为根据进行活动 。"

#: src/appendix-08-system-calls.md:165
msgid ""
"For more information and a higher-level syntax for emitting events, see "
"[Starknet "
"events](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/starknet-"
"events/)."
msgstr ""
"关于排放活动的更多信息和更高层次的语法,见[Starknet事件](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_contracts/starknet-"
"events/)。"

#: src/appendix-08-system-calls.md:169
msgid ""
"_`keys`_: The event’s keys. These are analogous to Ethereum’s event topics, "
"you can use the starknet_getEvents method to filter by these keys."
msgstr "keys: 事件密钥。 这些与 Eceenum 事件主题相似, 您可以使用 Starknet_ get Events 方法过滤这些密钥 。"

#: src/appendix-08-system-calls.md:171
msgid "_`data`_: The event’s data."
msgstr "@data:事件数据。"

#: src/appendix-08-system-calls.md:179
msgid ""
"The following example emits an event with two keys, the strings `status` and"
" `deposit` and three data elements: `1`, `2`, and `3`."
msgstr "以下例子显示了一个有两个关键要素的活动,即`状态'和`交存'的字符串以及三个数据要素:`1'、`2'和`3'。"

#: src/appendix-08-system-calls.md:194
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L30)"
msgstr ""
"[缩略语.cairo] (https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb358797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L30)"

#: src/appendix-08-system-calls.md:196
msgid "`library_call`"
msgstr "`图书馆呼叫 '"

#: src/appendix-08-system-calls.md:208
msgid ""
"Calls the requested function in any previously declared class. The class is "
"only used for its logic."
msgstr "在先前申报的类别中调用请求的函数。 该类别仅用于逻辑 。"

#: src/appendix-08-system-calls.md:210
msgid ""
"This system call replaces the known delegate call functionality from "
"Ethereum, with the important difference that there is only one contract "
"involved."
msgstr "这一系统呼叫取代了Etheum已知的代表呼叫功能,但有重要区别,即只涉及一项合同。"

#: src/appendix-08-system-calls.md:214
msgid "_`class_hash`_: The hash of the class you want to use."
msgstr ""


#: src/appendix-08-system-calls.md:216
msgid ""
"_`function_selector`_: A selector for a function within that class, can be "
"computed with the `selector!` macro."
msgstr "“函数_选择 ” : 该类中函数的选择器可用“ 选择器! ” 宏计算。"

#: src/appendix-08-system-calls.md:218
msgid "_`calldata`_: The calldata."
msgstr "呼叫数据:呼叫数据。"

#: src/appendix-08-system-calls.md:226
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L43)"
msgstr ""
"[声传 (https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb358797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L43)"

#: src/appendix-08-system-calls.md:228
msgid "`send_message_to_L1`"
msgstr "\" send_ message_to_L1 '"

#: src/appendix-08-system-calls.md:240
msgid "Sends a message to L1."
msgstr "向 L1 发送消息 。"

#: src/appendix-08-system-calls.md:242
msgid ""
"This system call includes the message parameters as part of the proof’s "
"output and exposes these parameters to the `StarknetCore` contract on L1 "
"once the state update, including the transaction, is received."
msgstr "这一系统电话包括作为证据输出一部分的信息参数,一旦收到包括交易在内的更新情况,这些参数即暴露于L1号StarknetCore合同中。"

#: src/appendix-08-system-calls.md:244
msgid ""
"For more information, see Starknet’s [messaging "
"mechanism](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-"
"mechanism/)."
msgstr ""
"更多信息见斯塔克内特的[消息机制](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Articture/Message-"
"mechanism/)。"

#: src/appendix-08-system-calls.md:248
msgid "_`to_address`_: The recipient’s L1 address."
msgstr "@to_address:收件人的 L1 地址 。"

#: src/appendix-08-system-calls.md:250
msgid "_`payload`_: The array containing the message payload."
msgstr "payload: 包含信件有效载荷的阵列 。"

#: src/appendix-08-system-calls.md:258
msgid ""
"The following example sends a message whose content is `(1,2)` to the L1 "
"contract whose address is `3423542542364363`."
msgstr "以下示例向地址为`3423542542364363'的L1合同发送内容为`1,2'的电文。"

#: src/appendix-08-system-calls.md:269
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51)"
msgstr ""
"[缩略语.cairo] (https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb358797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51)"

#: src/appendix-08-system-calls.md:271
msgid "`replace_class`"
msgstr "`替换等级 '"

#: src/appendix-08-system-calls.md:283
msgid ""
"Once `replace_class` is called, the class of the calling contract (i.e. the "
"contract whose address is returned by `get_contract_address` at the time the"
" syscall is called) will be replaced by the class whose hash is given by the"
" class_hash argument."
msgstr ""
"一旦将`替换类'称为`替换类 "
"',调用合同的类别(即调用调用时`get_contract_address'返回的地址为`get_contract_address'的合同)将被类中按等级_hash论点提供大麻的类别所取代。"

#: src/appendix-08-system-calls.md:287
msgid ""
"After calling `replace_class`, the code currently executing from the old "
"class will finish running."
msgstr "在调用`替换班'后,从旧班执行的代码将完成运行。"

#: src/appendix-08-system-calls.md:289
msgid ""
"The new class will be used from the next transaction onwards or if the "
"contract is called via the `call_contract` syscall in the same transaction "
"(after the replacement)."
msgstr "新的类别将从下一笔交易开始使用,或从同一笔交易(更换后)中通过`调用合同'调用合同。"

#: src/appendix-08-system-calls.md:293
msgid ""
"_`class_hash`_: The hash of the class you want to use as a replacement."
msgstr ""

#: src/appendix-08-system-calls.md:301
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L77)"
msgstr ""
"[syscalles.cairo] (https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb358797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L77)"

#: src/appendix-08-system-calls.md:303
msgid "`storage_read`"
msgstr "`储存-读 '"

#: src/appendix-08-system-calls.md:315
msgid "Gets the value of a key in the storage of the calling contract."
msgstr "在电话合同的存储中 找到钥匙的价值"

#: src/appendix-08-system-calls.md:317
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.read()`, which enables you to read storage variables that"
" are defined explicitly in the contract."
msgstr "这个系统电话可直接访问储存中的任何可能的钥匙,与`var.read()'不同,后者使你能够阅读合同中明确规定的储存变量。"

#: src/appendix-08-system-calls.md:319 src/appendix-08-system-calls.md:362
msgid ""
"For information on accessing storage by using the storage variables, see "
"[storage "
"variables](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-"
"storage/#storage_variables)."
msgstr ""
"关于使用储存变量获取储存的信息,见[储存变量](https://docs.starknet.io/documentation/architecture_and_confits/Smart_contracts/contract-"
"stories/#storage_可变性])。"

#: src/appendix-08-system-calls.md:323 src/appendix-08-system-calls.md:366
msgid ""
"_`address_domain`_: The domain of the key, used to separate between "
"different data availability modes. This separation is used in Starknet to "
"offer different data availability modes. Currently, only the onchain mode "
"(where all updates go to L1), indicated by domain `0`, is supported. Other "
"address domains which will be introduced in the future will behave "
"differently in terms of publication (in particular, they will not be posted "
"on L1, creating a tradeoff between cost and security)."
msgstr ""
"“地址'dmain ” : 用于区分不同数据可用模式的密钥域。 Starknet 使用此分隔法提供不同的数据可用模式。 目前, 仅支持链路模式( "
"所有更新都使用L1), 按域“ 0 ” 表示 。 未来引入的其他地址域在发布上将表现不同( 尤其是不会在L1上公布, 从而在成本和安全之间实现平衡 ) "
"。"

#: src/appendix-08-system-calls.md:325 src/appendix-08-system-calls.md:368
msgid "_`address`_: The requested storage address."
msgstr "地址:要求的存储地址。"

#: src/appendix-08-system-calls.md:329
msgid "The value of the key, of type `SyscallResult<felt252>`."
msgstr "键的值, 类型“ 系统呼叫Result < felt252 ” 。"

#: src/appendix-08-system-calls.md:344
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60)"
msgstr ""
"[syscalles.cairo] (https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb358797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60)"

#: src/appendix-08-system-calls.md:346
msgid "`storage_write`"
msgstr "`储存_write '"

#: src/appendix-08-system-calls.md:358
msgid "Sets the value of a key in the storage of the calling contract."
msgstr "设定调用合同存储中键值。"

#: src/appendix-08-system-calls.md:360
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.write()`, which enables you to write to storage variables"
" that are defined explicitly in the contract."
msgstr "与`var.write()'相比,这个系统电话可直接进入储存中的任何可能的钥匙,使您能够写到合同中明确规定的储存变量。"

#: src/appendix-08-system-calls.md:370
msgid "_`value`_: The value to write to the key."
msgstr "& value *} : 写到密钥的值 。"

#: src/appendix-08-system-calls.md:378
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L70)"
msgstr ""
"[声传 (https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb358797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L70)"
