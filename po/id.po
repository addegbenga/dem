#
msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: 2024-06-30T10:43:30+01:00\n"
"PO-Revision-Date: 2023-12-11 11:57+0700\n"
"Last-Translator: megumii <contact@megumii.xyz>\n"
"Language-Team: id <id@example.com>\n"
"Language: id\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.1\n"

#: src/SUMMARY.md src/title-page.md
msgid "The Cairo Book"
msgstr "Buku Cairo"

#: src/SUMMARY.md
msgid "The Cairo Book Foreword Introduction"
msgstr "Perkenalan Kata Sandi Buku Cairo"

#: src/SUMMARY.md
msgid "The Cairo Programming Language"
msgstr "Bahasa Pemrograman Cairo"

#: src/SUMMARY.md src/ch01-00-getting-started.md
msgid "Getting Started"
msgstr "Mulai"

#: src/SUMMARY.md src/ch01-01-installation.md:1 src/ch01-01-installation.md:22
msgid "Installation"
msgstr "Instalasi"

#: src/SUMMARY.md
msgid "Hello, World!"
msgstr "Halo, World!"

#: src/SUMMARY.md src/ch02-00-common-programming-concepts.md
msgid "Common Programming Concepts"
msgstr "Konsep Pemrograman Umum"

#: src/SUMMARY.md src/ch02-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr "Variabel dan Mutability"

#: src/SUMMARY.md src/ch02-02-data-types.md:1
msgid "Data Types"
msgstr "Tipe Data"

#: src/SUMMARY.md src/ch02-03-functions.md:1
msgid "Functions"
msgstr "Fungsi"

#: src/SUMMARY.md src/ch02-04-comments.md:1
msgid "Comments"
msgstr "Komentar"

#: src/SUMMARY.md src/ch02-05-control-flow.md:1
msgid "Control Flow"
msgstr "Aliran Kendali"

#: src/SUMMARY.md src/ch03-00-common-collections.md
msgid "Common Collections"
msgstr "Common Collections"

#: src/SUMMARY.md src/ch03-01-arrays.md:1
msgid "Arrays"
msgstr "Array"

#: src/SUMMARY.md src/ch03-02-dictionaries.md:1
msgid "Dictionaries"
msgstr "Kamus"

#: src/SUMMARY.md
msgid "Understanding Ownership"
msgstr "Memahami Kepemilikan"

#: src/SUMMARY.md
msgid "What is Ownership?"
msgstr "Apa Kepemilikan Itu?"

#: src/SUMMARY.md src/ch04-02-references-and-snapshots.md:1
msgid "References and Snapshots"
msgstr "Referensi dan Snapshot"

#: src/SUMMARY.md src/ch05-00-using-structs-to-structure-related-data.md
msgid "Using Structs to Structure Related Data"
msgstr "Menggunakan Struktur untuk Data Struktur Terkait"

#: src/SUMMARY.md src/ch05-01-defining-and-instantiating-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr "Mendefinisikan dan Menginstansi Structs"

#: src/SUMMARY.md src/ch05-02-an-example-program-using-structs.md:1
msgid "An Example Program Using Structs"
msgstr "Contoh Program yang Menggunakan Struktur"

#: src/SUMMARY.md src/ch05-03-method-syntax.md:1
msgid "Method Syntax"
msgstr "Metoda Sintaksis"

#: src/SUMMARY.md src/ch06-00-enums-and-pattern-matching.md
msgid "Enums and Pattern Matching"
msgstr "Enum dan Pola yang Cocok"

#: src/SUMMARY.md src/ch06-01-enums.md:1 src/ch08-01-generic-data-types.md:181
msgid "Enums"
msgstr "Enums"

#: src/SUMMARY.md src/ch06-02-the-match-control-flow-construct.md:1
msgid "The Match Control Flow Construct"
msgstr "Konstruksi Aliran Kendali yang Cocok"

#: src/SUMMARY.md
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:1
msgid "Concise Control Flow with `if let` and `while let`"
msgstr "Pusat kendali akan mengalir jika kita biarkan saja dan biarkan saja."

#: src/SUMMARY.md
#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr "Mengelola Proyek Cairo dengan Paket, Crates dan Modul"

#: src/SUMMARY.md src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr "Paket dan Crates"

#: src/SUMMARY.md src/ch07-02-defining-modules-to-control-scope.md:1
msgid "Defining Modules to Control Scope"
msgstr "Mendefinisikan Modul ke Cakupan Kontrol"

#: src/SUMMARY.md
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr "Path untuk merujuk ke Butir dalam Pohon Modul"

#: src/SUMMARY.md
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr "Membawa Jalur ke Cakupan dengan Kata Kunci Use"

#: src/SUMMARY.md src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr "Memisahkan Modul ke Berkas Berbeda"

#: src/SUMMARY.md src/ch08-01-generic-data-types.md:1
msgid "Generic Data Types"
msgstr "Tipe Data Generik"

#: src/SUMMARY.md src/ch08-00-generic-types-and-traits.md
msgid "Generic Types and Traits"
msgstr "Jenis Generik dan Sifat"

#: src/SUMMARY.md src/ch08-02-traits-in-cairo.md:1
msgid "Traits in Cairo"
msgstr "Sifat - Sifat di Cairo"

#: src/SUMMARY.md
msgid "Error Handling"
msgstr "Kesalahan Menangani"

#: src/SUMMARY.md
msgid "Unrecoverable Errors with panic"
msgstr "Galat Tak Terpulihkan dengan kepanikan"

#: src/SUMMARY.md
msgid "Recoverable Errors with Result"
msgstr "Kesalahan Yang Dapat Dipulihkan dengan Hasil"

#: src/SUMMARY.md src/ch10-00-testing-cairo-programs.md
#, fuzzy
msgid "Testing Cairo Programs"
msgstr "Menguji Program Cairo"

#: src/SUMMARY.md src/ch10-01-how-to-write-tests.md:1
msgid "How To Write Tests"
msgstr "Cara Menulis Ujian"

#: src/SUMMARY.md src/ch10-02-test-organization.md:1
msgid "Testing Organization"
msgstr "Organisasi Uji"

#: src/SUMMARY.md
msgid "Advanced Cairo Features"
msgstr "Fitur Advanced Cairo"

#: src/SUMMARY.md src/ch11-01-custom-data-structures.md:1
msgid "Custom Data Structures"
msgstr "Struktur Data Gubahan"

#: src/SUMMARY.md src/ch11-02-smart-pointers.md:1
msgid "Smart Pointers"
msgstr "Smart Pointers"

#: src/SUMMARY.md src/ch11-03-operator-overloading.md:1
msgid "Operator Overloading"
msgstr "Operator Overloading"

#: src/SUMMARY.md src/ch11-04-hash.md:24
msgid "Working with Hashes"
msgstr "Bekerja dengan Hashes"

#: src/SUMMARY.md src/ch11-05-macros.md:1
msgid "Macros"
msgstr "Makro"

#: src/SUMMARY.md src/ch11-06-inlining-in-cairo.md:1
msgid "Inlining in Cairo"
msgstr "Menyusuri di Cairo"

#: src/SUMMARY.md src/ch11-08-printing.md:1
msgid "Printing"
msgstr "Mencetak"

#: src/SUMMARY.md
msgid "Appendix (Cairo)"
msgstr "Lampiran (Cairo)"

#: src/SUMMARY.md
msgid "A - Keywords"
msgstr "Kata Kunci"

#: src/SUMMARY.md
msgid "B - Operators and Symbols"
msgstr "B - Operator dan Simbol"

#: src/SUMMARY.md
msgid "C - Derivable Traits"
msgstr "C - Sifat yang Dapat Diturunkan"

#: src/SUMMARY.md
msgid "D - The Cairo Prelude"
msgstr "D - Prelude Cairo"

#: src/SUMMARY.md
msgid "E - Common Error Messages"
msgstr "Pesan Kesalahan E - Common"

#: src/SUMMARY.md
msgid "F - Useful Development Tools"
msgstr "Alat Pembangunan yang Berguna F"

#: src/SUMMARY.md
msgid "G - Installing Cairo binaries"
msgstr "Penginstalan G - Cairo binaries"

#: src/SUMMARY.md
msgid "Smart Contracts in Cairo"
msgstr "Kontrak Cerdas di Cairo"

#: src/SUMMARY.md src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Introduction to Starknet Smart Contracts"
msgstr "Perkenalan Kontrak Cerdas Starknet"

#: src/SUMMARY.md src/ch13-01-general-introduction-to-smart-contracts.md:1
msgid "General Introduction to Smart Contracts"
msgstr "Perkenalan Umum Kontrak Cerdas"

#: src/SUMMARY.md src/ch13-02-anatomy-of-a-simple-contract.md:1
msgid "Anatomy of a Simple Contract"
msgstr "Anatomi Kontrak Sederhana"

#: src/SUMMARY.md src/ch14-00-building-starknet-smart-contracts.md
msgid "Building Starknet Smart Contracts"
msgstr "Membangun Kontrak Cerdas Starknet"

#: src/SUMMARY.md src/ch14-01-contract-storage.md:1
msgid "Contract Storage"
msgstr "Penyimpanan Kontrak"

#: src/SUMMARY.md src/ch14-02-contract-functions.md:1
msgid "Contract Functions"
msgstr "Fungsi Kontrak"

#: src/SUMMARY.md src/ch14-03-contract-events.md:1
msgid "Contract Events"
msgstr "Rangkaian Kontrak"

#: src/SUMMARY.md src/ch15-00-starknet-cross-contract-interactions.md
msgid "Starknet Cross-Contract Interactions"
msgstr "Starknet Cross-Contract Interaksi"

#: src/SUMMARY.md src/ch15-01-abis-and-contract-interfaces.md:1
msgid "ABIs and Contract Interfaces"
msgstr "ABI dan Antarmuka Kontrak"

#: src/SUMMARY.md
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:1
msgid "Contract Dispatchers, Library Dispatchers and System Calls"
msgstr "Dispatcher Kontrak, Pengirim Perpustakaan dan Sistem Panggilan"

#: src/SUMMARY.md src/ch16-00-building-advanced-starknet-smart-contracts.md
msgid "Building Advanced Starknet Smart Contracts"
msgstr "Membangun Advanced Starknet Smart Contracts"

#: src/SUMMARY.md src/ch16-01-optimizing-storage-costs.md:1
msgid "Optimizing Storage Costs"
msgstr "Optimasi Biaya Penyimpanan"

#: src/SUMMARY.md
msgid "Composability and Components"
msgstr "Komposabilitas dan Komponen"

#: src/SUMMARY.md
msgid "Under the Hood"
msgstr "Under the Hood"

#: src/SUMMARY.md src/ch16-02-02-component-dependencies.md:1
msgid "Component Dependencies"
msgstr "Ketergantungan Komponen"

#: src/SUMMARY.md src/ch16-02-03-testing-components.md:1
msgid "Testing Components"
msgstr "Komponen Uji"

#: src/SUMMARY.md
msgid "Upgradeability"
msgstr "Peningkatan"

#: src/SUMMARY.md
msgid "L1 \\<\\> L2 Messaging"
msgstr "L1 \\\\> Pesan L2"

#: src/SUMMARY.md src/ch16-05-oracle-interactions.md:1
msgid "Oracle Interactions"
msgstr "Perselisihan Oracle"

#: src/SUMMARY.md src/ch16-05-01-price-feeds.md:1
msgid "Price Feeds"
msgstr "Asupan Harga"

#: src/SUMMARY.md src/ch16-05-02-randomness.md:1
msgid "Randomness"
msgstr "Keacakan"

#: src/SUMMARY.md src/ch16-06-00-other-examples.md:1
msgid "Other Examples"
msgstr "Contoh - Contoh Lain"

#: src/SUMMARY.md
msgid "Deploying and Interacting with a Voting Contract"
msgstr "Menyebarkan dan Interacting dengan Kontrak Voting"

#: src/SUMMARY.md src/ch17-00-starknet-smart-contracts-security.md
msgid "Starknet Smart Contracts Security"
msgstr "Starknet Smart Contracts Security"

#: src/SUMMARY.md src/ch17-01-general-recommendations.md:1
msgid "General Recommendations"
msgstr "Rekomendasi Umum"

#: src/SUMMARY.md src/ch17-02-testing-smart-contracts.md:1
msgid "Testing Smart Contracts"
msgstr "Menguji Kontrak Cerdas"

#: src/SUMMARY.md src/ch17-03-static-analysis-tools.md:1
msgid "Static Analysis Tools"
msgstr "Perkakas Analisis Statik"

#: src/SUMMARY.md
msgid "Formal Verification"
msgstr "Verifikasi Formal"

#: src/SUMMARY.md src/appendix-00.md src/appendix-000.md
msgid "Appendix"
msgstr "Lampiran"

#: src/SUMMARY.md
msgid "Appendix (Starknet)"
msgstr "Lampiran (Starknet)"

#: src/SUMMARY.md
msgid "A - System Calls"
msgstr "Panggilan Sistem"

#: src/SUMMARY.md
msgid "Cairo VM"
msgstr "Cairo VM"

#: src/SUMMARY.md src/ch00-00-introduction.md src/ch200-introduction.md
msgid "Introduction"
msgstr "Perkenalan"

#: src/SUMMARY.md
msgid "Architecture"
msgstr "Arsitektur"

#: src/SUMMARY.md
msgid "Memory"
msgstr "Memori"

#: src/SUMMARY.md
msgid "Non-Deterministic Read-only Memory"
msgstr "Bukan-Deterministik Memori Baca-saja"

#: src/SUMMARY.md
msgid "Segments"
msgstr "Segmen"

#: src/SUMMARY.md
msgid "Segment Value"
msgstr "Nilai segmen"

#: src/SUMMARY.md
msgid "Relocation"
msgstr "Relokasi"

#: src/SUMMARY.md
msgid "Layout"
msgstr "Tata letak"

#: src/SUMMARY.md
msgid "Execution Model"
msgstr "Model Eksekusi"

#: src/SUMMARY.md
msgid "Registers"
msgstr "Register"

#: src/SUMMARY.md
msgid "Instructions"
msgstr "Instruksi"

#: src/SUMMARY.md
msgid "Cairo Assembly (CASM)"
msgstr "Kebaktian Cairo (CASM)"

#: src/SUMMARY.md
msgid "State transition"
msgstr "Pergeseran keadaan"

#: src/SUMMARY.md
msgid "Builtins"
msgstr "Bawaan"

#: src/SUMMARY.md
msgid "Memory Communication"
msgstr "Komunikasi Memori"

#: src/SUMMARY.md
msgid "List of builtins"
msgstr "Daftar builtin"

#: src/SUMMARY.md
msgid "Hints"
msgstr "Petunjuk"

#: src/SUMMARY.md
msgid "Structure"
msgstr "Struktur"

#: src/SUMMARY.md
msgid "Hint runner"
msgstr "Pelari Petunjuk"

#: src/SUMMARY.md
msgid "List of hints"
msgstr "Daftar petunjuk"

#: src/SUMMARY.md
msgid "Runner"
msgstr "Runner"

#: src/SUMMARY.md
msgid "Program"
msgstr "Program"

#: src/SUMMARY.md
msgid "Program Artifacts"
msgstr "Artefak Program"

#: src/SUMMARY.md
msgid "Program Parsing"
msgstr "Parsing Program"

#: src/SUMMARY.md
msgid "Runner Mode"
msgstr "Mode Runner"

#: src/SUMMARY.md
msgid "Execution Mode"
msgstr "Moda Eksekusi"

#: src/SUMMARY.md
msgid "Proof Mode"
msgstr "Mode Bukti"

#: src/SUMMARY.md
msgid "Output"
msgstr "Keluaran"

#: src/SUMMARY.md
msgid "Cairo PIE"
msgstr "Cairo PIE"

#: src/SUMMARY.md
msgid "Memory File"
msgstr "Berkas Memori"

#: src/SUMMARY.md
msgid "Trace file"
msgstr "Telusuri berkas"

#: src/SUMMARY.md
msgid "AIR public input"
msgstr "Masukan publik AIR"

#: src/SUMMARY.md
msgid "AIR private input"
msgstr "Masukan pribadi AIR"

#: src/SUMMARY.md
msgid "Tracer"
msgstr "Pelacak"

#: src/SUMMARY.md
msgid "Implementations"
msgstr "Implementasi"

#: src/SUMMARY.md
msgid "Resources"
msgstr "Sumberdaya"

#: src/title-page.md
msgid ""
"By the Cairo Community and its [contributors](https://github.com/cairo-"
"book/cairo-book.github.io). Special thanks to "
"[StarkWare](https://starkware.co/) through "
"[OnlyDust](https://www.onlydust.xyz/), and "
"[Voyager](https://voyager.online/) for supporting the creation of this book."
msgstr ""
"Oleh Cairo Community and its [contributors][contps://gitub.com/cairo-"
"book/cairo-book.github.io). Khusus berkat "
"[StarkWare][Nolhttps://starkware.co/) melalui [One-satunyaDust] "
"1964htt://www.onlydust.xyz/), dan [Voyager-https://voyager.online/) untuk "
"mendukung pembuatan buku ini."

#: src/title-page.md
msgid ""
"This version of the text assumes you’re using the [Cairo "
"Compiler](https://github.com/starkware-libs/cairo) [version "
"2.6.3](https://github.com/starkware-libs/cairo/releases). See the "
"[Installation](ch01-01-installation.md) section of Chapter 1 to install or "
"update Cairo."
msgstr ""
"Versi teks ini berasumsi bahwa anda menggunakan [Cairo "
"Compiler][Nirottps://gitub.com/starkware-libs/cairo) [version "
"2,3]Tidakhttps://gitub.com/starkware-libs/cairo/release). Lihat bagian 1 "
"untuk memasang atau memperbarui Cairo."

#: src/title-page.md
msgid ""
"If you want to play around with Cairo code and see how it compiles into "
"Sierra (Intermediate Representation) and CASM (Cairo Assembly), you can use "
"[cairovm.codes](https://cairovm.codes/) playground."
msgstr ""
"Jika Anda ingin bermain-main dengan kode Cairo dan melihat bagaimana hal itu"
" dikompilasi ke Sierra (Intermediate Representation) dan CASM "
"(AsolusiCairo), Anda dapat menggunakan taman bermain [cairovm.codes] "
"1964https://cairovm/)."

#: src/ch00-01-foreword.md
msgid "Foreword"
msgstr "Kata pengantar"

#: src/ch00-01-foreword.md
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and"
" gradually became more expressive. The learning curve was initially steep, "
"as Cairo 0.x was a low-level language that did not entirely abstract the "
"underlying cryptographic primitives required to build a proof for the "
"execution of a program."
msgstr ""
"Pada 2020, StarkWare merilis Cairo 0, sebuah bahasa pemrograman lengkap yang"
" mendukung komputasi yang dapat diverifikasi. Cairo dimulai sebagai bahasa "
"perakitan dan secara bertahap menjadi lebih ekspresif. kurva pembelajaran "
"awalnya curam, sebagai Cairo 0.x adalah bahasa tingkat rendah yang tidak "
"sepenuhnya abstrak primitif kriptografik yang diperlukan untuk membangun "
"bukti eksekusi sebuah program."

#: src/ch00-01-foreword.md
msgid ""
"With the release of Cairo 1, the developer experience has considerably "
"improved, abstracting away the underlying immutable memory model of the "
"Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has "
"been built to help you create provable programs without specific knowledge "
"of its underlying architecture so that you can focus on the program itself, "
"increasing the overall security of Cairo programs. Powered by a Rust VM, the"
" execution of Cairo programs is now _blazingly_ fast, allowing you to build "
"an extensive test suite without compromising on performance."
msgstr ""
"Dengan rilis Cairo 1, pengalaman pengembang telah jauh lebih baik, abstrak "
"jauh model memori yang tersembunyi dari arsitektur Cairo di mana mungkin. "
"Sangat terinspirasi oleh Rust, Cairo 1 telah dibangun untuk membantu Anda "
"membuat program provable tanpa pengetahuan spesifik arsitekturnya sehingga "
"Anda dapat fokus pada program itu sendiri, meningkatkan keseluruhan keamanan"
" program Cairo. Powered oleh Rust VM, eksekusi program Cairo sekarang "
"_blazingly_ cepat, memungkinkan Anda untuk membangun suite luas tanpa "
"mengorbankan kinerja."

#: src/ch00-01-foreword.md
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the"
" Cairo programming language to code their smart contracts. This allows the "
"Starknet OS to generate execution traces for transactions to be proved by a "
"prover, which is then verified on Ethereum L1 prior to updating the state "
"root of Starknet."
msgstr ""
"Pengembang rantai blok yang ingin menyebarkan kontrak pada Starknet akan "
"menggunakan bahasa pemrograman Cairo untuk mengkode kontrak cerdas mereka. "
"Hal ini memungkinkan Starknet OS untuk menghasilkan jejak eksekusi untuk "
"transaksi yang akan dibuktikan oleh seorang pembukti, yang kemudian "
"diverifikasi pada Etherum L1 sebelum memperbarui akar negara Starknet."

#: src/ch00-01-foreword.md
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit "
"from being proved on one computer and verified on other machines with lower "
"hardware requirements."
msgstr ""
"Namun, Cairo tidak hanya untuk pengembang rantai blok. dapat digunakan untuk"
" setiap komputasi yang akan bermanfaat dengan satu komputer dan diverifikasi"
" pada mesin lain dengan persyaratan perangkat keras yang lebih rendah."

#: src/ch00-01-foreword.md
msgid ""
"This book is designed for developers with a basic understanding of "
"programming concepts. It is a friendly and approachable text intended to "
"help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there "
"is to know about Cairo!"
msgstr ""
"Buku ini dirancang untuk pengembang dengan pemahaman dasar tentang konsep "
"pemrograman adalah teks yang ramah dan mudah didekati untuk membantu Anda "
"meningkatkan pengetahuan Anda tentang Cairo, tetapi juga membantu Anda "
"mengembangkan keterampilan pemrograman Anda secara umum."

#: src/ch00-01-foreword.md
msgid "Acknowledgements"
msgstr "Pengakuan"

#: src/ch00-01-foreword.md
msgid ""
"This book would not have been possible without the help of the Cairo "
"community. We would like to thank every contributor for their contributions "
"to this book!"
msgstr ""
"Buku ini tidak akan mungkin tanpa bantuan komunitas Cairo. kami ingin "
"berterima kasih kepada setiap kontributor mereka untuk buku ini!"

#: src/ch00-01-foreword.md
msgid ""
"We would like to thank the Rust community for the [Rust "
"Book](https://doc.rust-lang.org/book/), which has been a great source of "
"inspiration for this book. Many examples and explanations have been adapted "
"from the Rust Book to fit the Cairo programming language, as the two "
"languages share many similarities."
msgstr ""
"Kami ingin mengucapkan terima kasih kepada komunitas Rust untuk [Buku "
"Rusia][Ruthttps://doc.rust-lang/book/), yang telah menjadi sumber inspirasi "
"yang besar untuk buku ini. banyak contoh dan penjelasan telah disesuaikan "
"dari Rust Book untuk cocok dengan bahasa pemrograman Cairo, sebagai dua "
"bahasa berbagi banyak kesamaan."

#: src/ch00-00-introduction.md
msgid "What is Cairo?"
msgstr "Apa itu Cairo?"

#: src/ch00-00-introduction.md
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name."
" The unique aspect of this processor is that it was not created for the "
"physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. "
"This means that you can perform time consuming operations on a machine you "
"don't trust, and check the result very quickly on a cheaper machine. While "
"Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo "
"1 is a higher level language. It first compiles to Sierra, an intermediate "
"representation of Cairo which will compile later down to a safe subset of "
"CASM. The point of Sierra is to ensure your CASM will always be provable, "
"even when the computation fails."
msgstr ""
"Cairo adalah bahasa pemrograman yang dirancang untuk CPU virtual dengan nama"
" yang sama. Aspek unik dari prosesor ini adalah bahwa hal itu tidak dibuat "
"untuk kendala fisik dunia kita tetapi untuk kriptonik, membuatnya mampu "
"secara efisien membuktikan eksekusi dari program apapun yang berjalan di "
"atasnya. Ini berarti Anda dapat melakukan operasi memakan waktu pada mesin "
"yang tidak Anda percaya, dan memeriksa hasilnya sangat cepat pada mesin yang"
" lebih murah. Sementara Cairo 0 digunakan untuk secara langsung dikompilasi "
"ke CASM, CPU Cairo, Cairo 1 adalah bahasa tingkat yang lebih tinggi. Ini "
"pertama kali dikompilasi ke Sierra, sebuah representasi intermedia Cairo "
"yang akan dikompilasi ke subM."

#: src/ch00-00-introduction.md
msgid "What Can you Do with It?"
msgstr "Apa yang Dapat Anda Lakukan dengan Itu?"

#: src/ch00-00-introduction.md
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One "
"major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a "
"decentralized blockchain platform that enables the creation of decentralized"
" applications where every single interaction between a user and a d-app is "
"verified by all the participants. Starknet is a Layer 2 built on top of "
"Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the "
"programs and generates proofs that the computations were done correctly. "
"These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and "
"reduced transaction costs while preserving Ethereum security."
msgstr ""
"Cairo memungkinkan Anda untuk menghitung nilai-nilai yang dapat dipercaya "
"pada mesin yang tidak dipercaya. Satu interaksi besar adalah Starknet, "
"solusi untuk skala Ethereum. Etherum adalah platform rantai blok "
"terdesentralisasi yang memungkinkan penciptaan aplikasi terdesentralisasi di"
" mana setiap interaksi utama antara pengguna dan d-app diverifikasi oleh "
"semua partisipan. Starknet adalah Layer 2 dibangun di atas Etherum. Daripada"
" memiliki semua partisipan jaringan untuk memverifikasi semua interaksi "
"pengguna, hanya satu node, yang disebut pembukti, jalankan program dan "
"menghasilkan bukti bahwa perhitungan dilakukan dengan benar. Ini bukti yang "
"diverifikasi oleh Eum maka sebuah kontrak yang cerdas, membutuhkan lebih "
"sedikit kemampuan untuk mengeksekusi diri mereka sendiri melalui pendekatan "
"keamanan sementara untuk menghemat biaya keamanan."

#: src/ch00-00-introduction.md
msgid "What Are the Differences with Other Programming Languages?"
msgstr "Apa Perbedaannya dengan Bahasa Pemrograman Lainnya?"

#: src/ch00-00-introduction.md
msgid ""
"Cairo is quite different from traditional programming languages, especially "
"when it comes to overhead costs and its primary advantages. Your program can"
" be executed in two different ways:"
msgstr ""
"Cairo cukup berbeda dari bahasa pemrograman tradisional, terutama ketika "
"datang ke biaya overhead dan keuntungan utama. program Anda dapat dijalankan"
" dalam dua cara yang berbeda:"

#: src/ch00-00-introduction.md
msgid ""
"When executed by the prover, it is similar to any other language. Because "
"Cairo is virtualized, and because the operations were not specifically "
"designed for maximum efficiency, this can lead to some performance overhead "
"but it is not the most relevant part to optimize."
msgstr ""
"Ketika dieksekusi oleh prover, itu mirip dengan bahasa lain. karena Cairo di"
" virtualisasi, dan karena operasi tidak dirancang secara khusus untuk "
"efisiensi maksimum, ini dapat menyebabkan beberapa kinerja overhead tapi itu"
" bukan bagian yang paling relevan untuk mengoptimalkan."

#: src/ch00-00-introduction.md
msgid ""
"When the generated proof is verified by a verifier, it is a bit different. "
"This has to be as cheap as possible since it could potentially be verified "
"on many very small machines. Fortunately verifying is faster than computing "
"and Cairo has some unique advantages to improve it even more. A notable one "
"is non-determinism. This is a topic you will cover in more detail later in "
"this book, but the idea is that you can theoretically use a different "
"algorithm for verifying than for computing. Currently, writing custom non-"
"deterministic code is not supported for the developers, but the standard "
"library leverages non-determinism for improved performance. For example "
"sorting an array in Cairo costs the same price as copying it. Because the "
"verifier doesn't sort the array, it just checks that it is sorted, which is "
"cheaper."
msgstr ""
"Ketika bukti yang dihasilkan diverifikasi oleh sebuah pemverifikasi, hal ini"
" sedikit berbeda. Ini harus semurah mungkin karena bisa diverifikasi pada "
"banyak mesin yang sangat kecil. Untungnya memverifikasi lebih cepat daripada"
" komputasi dan Cairo memiliki beberapa keuntungan unik untuk meningkatkannya"
" lagi. Sebuah hal yang dapat dilihat tidak ditentukan. Ini adalah topik yang"
" akan Anda bahas dalam lebih detail dalam buku ini, tetapi idenya adalah "
"bahwa Anda dapat secara teori menggunakan algoritma yang berbeda untuk "
"memverifikasi. Saat ini, menulis kode custom non-tertentu tidak didukung "
"untuk pengembang, tetapi standar pengadaan tidak ditentukan dalam kinerja "
"yang lebih baik di buku ini. Untuk pengurutan contoh dalam array Cairo "
"seperti harga yang sama."

#: src/ch00-00-introduction.md
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, "
"memory access is immutable, meaning that once a value is written to memory, "
"it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. "
"Therefore, developers must think carefully about how they manage memory and "
"data structures in their programs to optimize performance."
msgstr ""
"Aspek lain yang mengatur bahasanya adalah model memorinya. di Cairo, akses "
"memori tidak dapat berubah, berarti bahwa sekali nilai ditulis untuk memori,"
" tidak dapat diubah. Cairo 1 menyediakan abstraksi yang membantu pengembang "
"bekerja dengan batasan-batasan ini, tetapi tidak sepenuhnya mensimulasikan "
"mutability. Oleh karena itu, pengembang harus memikirkan dengan cermat "
"bagaimana mereka mengelola memori dan struktur data dalam program mereka "
"untuk mengoptimalkan kinerja."

#: src/ch00-00-introduction.md
msgid "References"
msgstr "Referensi"

#: src/ch00-00-introduction.md
msgid "Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>"
msgstr "Arsitektur CPU Cairo: <https://eprint.iacr.org/2021/1063>"

#: src/ch00-00-introduction.md
msgid ""
"Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-"
"of-cairo-1-0-exploring-sierra-7f32808421f5>"
msgstr ""
"Cairo, Sierra dan Casm: <https://medium.com/nethermind-eth/under-the-hood-"
"of-cairo-1-0-exploring-sierra-7f32808421f5>"

#: src/ch00-00-introduction.md
msgid ""
"State of non determinism: "
"<https://twitter.com/PapiniShahar/status/1638203716535713798>"
msgstr ""
"Keadaan determinisme non: "
"<https://twitter.com/PapiniShahar/status/1638203716535713798>"

#: src/ch01-00-getting-started.md
msgid ""
"Let’s start your Cairo journey! There’s a lot to learn, but every journey "
"starts somewhere. In this chapter, we’ll discuss:"
msgstr "Mari kita mulai perjalanan ke Cairo!"

#: src/ch01-00-getting-started.md
msgid ""
"Installing Scarb, which is Cairo's build toolchain and package manager, on "
"Linux, macOS, and Windows."
msgstr ""
"Memasang Scarb, yang merupakan gantungan alat Cairo dan manajer paket, pada "
"Linux, macOS, dan Windows."

#: src/ch01-00-getting-started.md
msgid "Writing a program that prints `Hello, world!`."
msgstr "Menulis program yang dicetak, dunia!"

#: src/ch01-00-getting-started.md
msgid "Using basic Scarb commands to create a project and execute a program."
msgstr ""
"Menggunakan perintah Scarb dasar untuk membuat proyek dan menjalankan "
"program."

#: src/ch01-00-getting-started.md
msgid "Getting Help"
msgstr "Mendapatkan Bantuan"

#: src/ch01-00-getting-started.md
msgid ""
"If you have any questions about Starknet or Cairo, you can ask them in the "
"[Starknet Discord server](https://discord.gg/starknet-community). The "
"community is friendly and always willing to help."
msgstr ""
"Jika Anda memiliki pertanyaan tentang Starknet atau Cairo, Anda dapat "
"bertanya kepada mereka di [Surver Discord Starknet] mereka ramah dan selalu "
"bersedia membantu."

#: src/ch01-00-getting-started.md
msgid "Interacting with the Cairo Chatbot"
msgstr "Berinteraksi dengan Chatbot Cairo"

#: src/ch01-00-getting-started.md
msgid ""
"Cairo has its own chatbot, which can help you with Cairo-related questions. "
"The chatbot is trained on the Cairo book, and uses RAG to efficiently "
"retrieve information to provide help. You can find the chatbot on the "
"[Cairo-Chatbot](https://cairo-chatbot.vercel.app/) website."
msgstr ""
"Cairo memiliki robot chat-nya sendiri, yang dapat membantu Anda dengan "
"pertanyaan-pertanyaan yang berhubungan dengan Cairo. Chatbot dilatih di buku"
" Cairo, dan menggunakan RAG untuk memperoleh informasi secara efisien untuk "
"menyediakan bantuan. Anda dapat menemukan chatbot (Cairo-Chatbot) di website"
" [Cairo-Chatps://cairo-chatbot.vercel.app/)."

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading "
"[Scarb](https://docs.swmansion.com/scarb/docs). Scarb bundles the Cairo "
"compiler and the Cairo language server together in an easy-to-install "
"package so that you can start writing Cairo code right away."
msgstr ""
"Cairo dapat dipasang hanya dengan mengunduh "
"[Scarb][Scarb][Hyttps://docs.swmansion.com/scarb/docs). Scarb mengelompokkan"
" kompiler Cairo dan server bahasa Cairo bersama-sama dalam paket mudah-ke-"
"install sehingga Anda dapat mulai menulis kode Cairo segera."

#: src/ch01-01-installation.md:5
msgid ""
"Scarb is also Cairo's package manager and is heavily inspired by "
"[Cargo](https://doc.rust-lang.org/cargo/), Rust’s build system and package "
"manager."
msgstr ""
"Scarb juga manajer paket Cairo dan sangat terinspirasi oleh "
"[Cargo][Carhttps://doc.rust-lang.org/cargo/), Rustás membangun sistem dan "
"manajer paket."

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either "
"pure Cairo or Starknet contracts), downloading the libraries your code "
"depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""
"Scarb menangani banyak tugas untuk Anda, seperti membangun kode Anda (yang "
"merupakan kontrak Cairo atau Starknet murni), mengunduh perpustakaan yang "
"kode Anda tergantung pada, membangun perpustakaan tersebut, dan menyediakan "
"dukungan LSP untuk ekstensi VSCode Cairo 1."

#: src/ch01-01-installation.md:9
msgid ""
"As you write more complex Cairo programs, you might add dependencies, and if"
" you start a project using Scarb, managing external code and dependencies "
"will be a lot easier to do."
msgstr ""
"Ketika Anda menulis program Cairo yang lebih kompleks, Anda mungkin "
"menambahkan ketergantungan, dan jika Anda memulai sebuah proyek menggunakan "
"Scarb, mengelola kode eksternal dan ketergantungan akan jauh lebih mudah "
"untuk dilakukan."

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr "Mari kita mulai dengan memasang Scarb."

#: src/ch01-01-installation.md:16
msgid "Installing Scarb"
msgstr "Memasang Scarb"

#: src/ch01-01-installation.md:18
msgid "Requirements"
msgstr "Persyaratan"

#: src/ch01-01-installation.md:20
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment "
"variable."
msgstr ""
"Scarb memerlukan sebuah aplikasi Git untuk tersedia dalam variabel "
"lingkungan åPATH Rasulullah."

#: src/ch01-01-installation.md:24
msgid ""
"To install Scarb, please refer to the [installation "
"instructions](https://docs.swmansion.com/scarb/download). We strongly "
"recommend that you install Scarb [via "
"asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf), a "
"CLI tool that can manage multiple language runtime versions on a per-project"
" basis. This will ensure that the version of Scarb you use to work on a "
"project always matches the one defined in the project settings, avoiding "
"problems related to version mismatches."
msgstr ""
"Untuk memasang Scarb, silakan merujuk ke [installation "
"instruksi][instalasi][installs.stps://docs.swmansion.com/scarb/download). "
"Kami sangat merekomendasikan agar Anda memasang Scarb [via asdf] "
"(via].https://docs.swmansion.com/scarb/download.hml#install-asdf), alat yang"
" dapat mengelola berbagai versi bahasa pada dasar per-project. Ini akan "
"memastikan bahwa versi Scarb yang Anda gunakan untuk mengerjakan sebuah "
"proyek yang selalu cocok pada salah satu proyek yang ditentukan untuk "
"menghindari versi yang terkait."

#: src/ch01-01-installation.md:28
msgid ""
"Please refer to the [asdf documentation](https://asdf-vm.com/guide/getting-"
"started.html) to install all prerequisites."
msgstr ""
"Silakan merujuk ke [asdf dokumentasi][https://asdf-"
"vm.com/guide/dimulai.html) untuk memasang semua prasyarat."

#: src/ch01-01-installation.md:30
msgid ""
"Once you have asdf installed locally, you can download Scarb plugin with the"
" following command:"
msgstr ""
"Setelah Anda memasang asdf secara lokal, Anda dapat mengunduh plugin Scarb "
"dengan perintah berikut:"

#: src/ch01-01-installation.md:36
msgid "This will allow you to download specific versions:"
msgstr "Hal ini akan memungkinkan Anda untuk mengunduh versi spesifik:"

#: src/ch01-01-installation.md:42
msgid "and set a global version:"
msgstr "dan atur sebuah versi global:"

#: src/ch01-01-installation.md:48
msgid ""
"Otherwise, you can simply run the following command in your terminal, and "
"follow the onscreen instructions. This will install the latest stable "
"release of Scarb."
msgstr ""
"Jika tidak, Anda dapat menjalankan perintah berikut di terminal Anda, dan "
"mengikuti instruksi onscreen. Ini akan menginstal rilis Scarb terakhir yang "
"stabil."

#: src/ch01-01-installation.md:51
msgid "'=https'"
msgstr "'=https'"

#: src/ch01-01-installation.md:68
msgid "Installing the VSCode Extension"
msgstr "Memasang Ekstensi VSCode"

#: src/ch01-01-installation.md:70
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code "
"completion, and other useful features. You can install it from the [VSCode "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)."
" Once installed, go into the extension settings, and make sure to tick the "
"`Enable Language Server` and `Enable Scarb` options."
msgstr ""
"Cairo memiliki ekstensi VSCode yang menyediakan penandaan sintaks, "
"pelengkapan kode, dan fitur berguna lainnya. Anda dapat memasangnya dari "
"[VSCode "
"Marketplace]bahttps://pplace.visualstudio.com/items?item?item=starkware.cairo1)."
" Setelah dipasang, masuk ke pengaturan ekstensi, dan pastikan untuk "
"mencentang Server Bahasa yang Dapat Di-enkrip dan pilihan Scarb."

#: src/ch01-01-installation.md:75
msgid "{{#quiz ../quizzes/ch01-01-installation.toml}}"
msgstr "{{#quiz../quizzes/ch01-01-installation.toml}}}"

#: src/ch01-02-hello-world.md:1
msgid "Hello, World"
msgstr "Halo, Dunia"

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first"
" Cairo program. It’s traditional when learning a new language to write a "
"little program that prints the text `Hello, world!` to the screen, so we’ll "
"do the same here!"
msgstr ""
"Sekarang Anda telah menginstal Cairo melalui Scarb, itu waktu untuk menulis "
"program pertama Cairo Anda."

#: src/ch01-02-hello-world.md:7
msgid ""
"Note: This book assumes basic familiarity with the command line. Cairo makes"
" no specific demands about your editing or tooling or where your code lives,"
" so if you prefer to use an integrated development environment (IDE) instead"
" of the command line, feel free to use your favorite IDE. The Cairo team has"
" developed a VSCode extension for the Cairo language that you can use to get"
" the features from the language server and code highlighting. See [Appendix "
"F](./appendix-06-useful-development-tools.md) for more details."
msgstr ""
"Catatan: Buku ini mengasumsikan dasar familiaritas dengan baris perintah. "
"Cairo tidak membuat tuntutan spesifik tentang penyuntingan Anda atau tooling"
" atau di mana kode hidup Anda, jadi jika Anda lebih memilih untuk "
"menggunakan lingkungan pengembangan terpadu (IDE) daripada baris perintah, "
"silakan gunakan IDE favorit Anda. Tim Cairo telah mengembangkan sebuah "
"VSCode ekstensi untuk bahasa Cairo yang dapat Anda gunakan untuk mendapatkan"
" fitur dari server bahasa dan penandaan kode. Lihat [Append F]./appix-"
"useend-fuldevelpment-tool.m) untuk rincian lebih lanjut."

#: src/ch01-02-hello-world.md:17
msgid "Creating a Project Directory"
msgstr "Membuat Direktori Projek"

#: src/ch01-02-hello-world.md:19
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t "
"matter to Cairo where your code lives, but for the exercises and projects in"
" this book, we suggest making a _cairo_projects_ directory in your home "
"directory and keeping all your projects there."
msgstr ""
"Anda akan mulai dengan membuat direktori untuk menyimpan kode Cairo Anda. "
"tidak penting bagi Cairo di mana kode hidup Anda, tetapi untuk latihan dan "
"proyek dalam buku ini, kami menyarankan untuk membuat direktori "
"_cairo_projects_ di direktori rumah Anda dan menjaga semua proyek Anda di "
"sana."

#: src/ch01-02-hello-world.md:24
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory."
msgstr ""
"Buka terminal dan masukkan perintah berikut untuk membuat direktori "
"_cairo_projects_."

#: src/ch01-02-hello-world.md:26
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr "Untuk Linux, macOS, dan PowerShell pada Windows, masukkan ini:"

#: src/ch01-02-hello-world.md:33
msgid "For Windows CMD, enter this:"
msgstr "Untuk Windows CMD, masukkan ini:"

#: src/ch01-02-hello-world.md:36 src/ch01-02-hello-world.md:37
msgid "\"%USERPROFILE%\\cairo_projects\""
msgstr "\"%USERPROFILE%\\cairo_projects\""

#: src/ch01-02-hello-world.md:40
msgid ""
"Note: From now on, for each example shown in the book, we assume that you "
"will be working from a Scarb project directory. If you are not using Scarb, "
"and try to run the examples from a different directory, you might need to "
"adjust the commands accordingly or create a Scarb project."
msgstr ""
"Catatan: Mulai sekarang, untuk setiap contoh yang ditunjukkan dalam buku "
"ini, kita berasumsi bahwa Anda akan bekerja dari direktori projek Scarb. "
"Jika Anda tidak menggunakan Scarb, dan mencoba menjalankan contoh dari "
"direktori yang berbeda, Anda mungkin perlu menyesuaikan perintah yang sesuai"
" atau membuat proyek Scarb."

#: src/ch01-02-hello-world.md:43
msgid "Creating a Project with Scarb"
msgstr "Membuat Projek dengan Scarb"

#: src/ch01-02-hello-world.md:45
msgid "Let’s create a new project using Scarb."
msgstr "Mari kita buat proyek baru menggunakan Scarb."

#: src/ch01-02-hello-world.md:47
msgid ""
"Navigate to your _cairo_projects_ directory (or wherever you decided to "
"store your code). Then run the following:"
msgstr ""
"Navigasi ke direktori _cairo_projects_ Anda (atau di mana pun Anda "
"memutuskan untuk menyimpan kode Anda). Lalu jalankan berikut:"

#: src/ch01-02-hello-world.md:53
msgid ""
"It creates a new directory and project called _hello_world_. We’ve named our"
" project _hello_world_, and Scarb creates its files in a directory of the "
"same name."
msgstr "Ini menciptakan direktori dan proyek baru yang disebut _hello_world_."

#: src/ch01-02-hello-world.md:55
msgid ""
"Go into the _hello_world_ directory with the command `cd hello_world`. "
"You’ll see that Scarb has generated two files and one directory for us: a "
"_Scarb.toml_ file and a _src_ directory with a _lib.cairo_ file inside."
msgstr ""
"Pergi ke direktori _hello_world_ dengan perintah thosecd hello_world. Anda "
"akan melihat bahwa Scarb telah menghasilkan dua berkas dan satu direktori "
"untuk kita: berkas _Scarb.toml_ dan direktori _src_ dengan _lib.cairo_ di "
"dalamnya."

#: src/ch01-02-hello-world.md:57
msgid ""
"It has also initialized a new Git repository along with a `.gitignore` file"
msgstr ""
"Ini juga telah diinisialisasi sebuah repositori Git baru bersama dengan "
"sebuah berkas.gitignore)"

#: src/ch01-02-hello-world.md:59
msgid ""
"Note: Git is a common version control system. You can stop using version "
"control system by using the `--no-vcs` flag. Run `scarb new --help` to see "
"the available options."
msgstr ""
"Catatan: Git adalah sistem kendali versi yang umum. Anda dapat berhenti "
"menggunakan sistem kendali versi dengan menggunakan bendera --no-vcsé. "
"Jalankan --helpán untuk melihat pilihan yang tersedia."

#: src/ch01-02-hello-world.md:62
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-1."
msgstr ""
"Buka _Scarb.toml_ dalam pilihan penyunting teks Anda. Ini akan terlihat "
"mirip dengan kode dalam Daftar 1-1."

#: src/ch01-02-hello-world.md:64
msgid "<span class=\"filename\">Filename: Scarb.toml</span>"
msgstr "<nama berkas=\"pan\"> Nama berkas: Scarb.toml</span>"

#: src/ch01-02-hello-world.md:66
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"edition = \"2023_11\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"Diterjemahkan oleh mumetndase. Lihat lebih banyak kunci dan definisi mereka "
"di https://docs.swmansion.com/scarb/docs/referensi/manifest [ketergantungan]"
" # foo = path = \"vendor/foo\"}"

#: src/ch01-02-hello-world.md:78
msgid ""
"<span class=\"caption\">Listing 1-1: Contents of _Scarb.toml_ generated by "
"`scarb new`</span>"
msgstr ""
"<span class=\"caption\">Listing 1-1: Isi dari _Scarb.toml_ dihasilkan oleh "
"</scarb baru"

#: src/ch01-02-hello-world.md:80
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal "
"Language) format, which is Scarb’s configuration format."
msgstr ""
"Berkas ini ada dalam format [TOML]--https://toml.io/) (Tomous, Minmal "
"Language), yang merupakan format konfigurasi Scarb--s."

#: src/ch01-02-hello-world.md:82
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr ""
"Baris pertama, [paket], adalah judul bagian yang menunjukkan bahwa "
"pernyataan-pernyataan berikut sedang mengkonfigurasi sebuah paket."

#: src/ch01-02-hello-world.md:84
msgid ""
"The next three lines set the configuration information Scarb needs to "
"compile your program: the name of the package and the version of Scarb to "
"use, and the edition of the prelude to use. The prelude is the collection of"
" the most commonly used items that are automatically imported into every "
"Cairo program. You can learn more about the prelude in [Appendix "
"D](./appendix-04-cairo-prelude.md)."
msgstr ""
"Tiga baris berikutnya mengatur informasi konfigurasi Scarb perlu menyusun "
"program Anda: nama paket dan versi Scarb untuk digunakan, dan edisi prelude "
"untuk digunakan. Pralude adalah koleksi dari item yang paling umum digunakan"
" yang secara otomatis diimpor ke setiap program Cairo. Anda dapat belajar "
"lebih lanjut tentang prelude [Appendix D]./appendix-04cairo-prelude.m)."

#: src/ch01-02-hello-world.md:86
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Cairo, packages of code are referred "
"to as crates. We won’t need any other crates for this project."
msgstr ""
"Baris terakhir, [ketergantungan] adalah bagian awal bagi Anda untuk daftar "
"salah satu ketergantungan proyek Anda di Cairo, paket-paket kode yang "
"disebut peti."

#: src/ch01-02-hello-world.md:88
msgid ""
"Note: If you're building contracts for Starknet, you will need to add the "
"`starknet` dependency as mentioned in the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-"
"package.html)."
msgstr ""
"Catatan: Jika Anda membangun kontrak untuk Starknet, Anda perlu menambahkan "
"ketergantungan åstarknet seperti yang disebutkan dalam [Scarb "
"dokumentasi].https://docs.swmansion.com/scarb/docs/extensis/starknet/starknet-"
"package.html)."

#: src/ch01-02-hello-world.md:90
msgid ""
"The other file created by Scarb is _src/lib.cairo_, let's delete all the "
"content and put in the following content, we will explain the reason later."
msgstr ""
"Berkas lain yang dibuat oleh Scarb adalah _src/lib.cairo_, mari kita hapus "
"semua isi dan masukkan ke dalam konten berikut, kita akan menjelaskan "
"alasannya nanti."

#: src/ch01-02-hello-world.md:96
msgid ""
"Then create a new file called _src/hello_world.cairo_ and put the following "
"code in it:"
msgstr ""
"Lalu buat berkas baru yang disebut _src/hello_world.cairo_ dan taruh kode "
"berikut di dalamnya:"

#: src/ch01-02-hello-world.md:98
msgid "<span class=\"filename\">Filename: src/hello_world.cairo</span>"
msgstr "<nama berkas=\"pan\"> Nama berkas: src/hello_world.cairo</span>"

#: src/ch01-02-hello-world.md:102 src/ch01-02-hello-world.md:185
msgid "\"Hello, World!\""
msgstr "\"Halo, World!\""

#: src/ch01-02-hello-world.md:106
msgid ""
"We have just created a file called _lib.cairo_, which contains a module "
"declaration referencing another module named `hello_world`, as well as the "
"file _hello_world.cairo_, containing the implementation details of the "
"`hello_world` module."
msgstr ""
"Kami baru saja membuat file yang disebut _lib.cairo_, yang berisi sebuah "
"deklarasi modul modul lain yang bernama ôhello_world, serta file "
"\"hello_world.cairo_, berisi rincian implementasi dari modul-moduliment dari"
" dunia."

#: src/ch01-02-hello-world.md:108
msgid ""
"Scarb requires your source files to be located within the _src_ directory."
msgstr ""
"Scarb membutuhkan berkas sumber Anda untuk ditempatkan dalam direktori _sc_."

#: src/ch01-02-hello-world.md:110
msgid ""
"The top-level project directory is reserved for README files, license "
"information, configuration files, and any other non-code-related content. "
"Scarb ensures a designated location for all project components, maintaining "
"a structured organization."
msgstr ""
"Direktori projek tingkat atas disediakan bagi berkas README, informasi "
"lisensi, berkas konfigurasi, dan konten lainnya yang tidak berhubungan "
"dengan kode. Scarb memastikan lokasi yang ditentukan bagi semua komponen "
"projek, mempertahankan organisasi terstruktur."

#: src/ch01-02-hello-world.md:113
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a "
"project that does use Scarb. Move the project code into the _src_ directory "
"and create an appropriate _Scarb.toml_ file. You can also use `scarb init` "
"command to generate the _src_ folder and the _Scarb.toml_ it contains."
msgstr ""
"Jika Anda memulai sebuah proyek yang tidak menggunakan Scarb, Anda dapat "
"mengubahnya menjadi proyek yang menggunakan Scarb. Pindahkan kode projek ke "
"direktori _src_ dan buat berkas _Scarb.toml_ yang sesuai. Anda juga dapat "
"menggunakan perintah iniit ▪scarb untuk membuat folder _src_ dan "
"_scarb.toml_ yang ada."

#: src/ch01-02-hello-world.md:122
msgid "<span class=\"caption\"> A sample Scarb project structure</span>"
msgstr "<span class=\"caption\"> Sebuah contoh struktur proyek Scarb</span>"

#: src/ch01-02-hello-world.md:128
msgid "Building a Scarb Project"
msgstr "Membangun Proyek Scarb"

#: src/ch01-02-hello-world.md:130
msgid ""
"From your _hello_world_ directory, build your project by entering the "
"following command:"
msgstr ""
"Dari direktori _hello_world_ Anda, bangun projek Anda dengan memasukkan "
"perintah berikut:"

#: src/ch01-02-hello-world.md:138
msgid ""
"This command creates a `sierra` file in _target/dev_, let's ignore the "
"`sierra` file for now."
msgstr ""
"Perintah ini menciptakan file æsierra di _target/dev_, mari kita abaikan "
"berkas æsierra saat ini."

#: src/ch01-02-hello-world.md:140
msgid ""
"If you have installed Cairo correctly, you should be able to run the `main` "
"function of your program with the `scarb cairo-run` command and see the "
"following output:"
msgstr ""
"Jika Anda telah memasang Cairo dengan benar, Anda seharusnya dapat "
"menjalankan fungsi dari program Anda dengan perintah cairo-run dan melihat "
"keluaran berikut:"

#: src/ch01-02-hello-world.md:149
msgid ""
"Regardless of your operating system, the string `Hello, world!` should be "
"printed to the terminal."
msgstr ""
"Terlepas dari sistem operasi Anda, string yang halo, dunia! harus dicetak ke"
" terminal."

#: src/ch01-02-hello-world.md:152
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Cairo program. That makes you a Cairo programmer — welcome!"
msgstr ""
"Kau resmi menulis program Cairo./ Itu membuatmu diterima oleh programmer "
"Cairo!"

#: src/ch01-02-hello-world.md:155
msgid "Anatomy of a Cairo Program"
msgstr "Anatomi Program Cairo"

#: src/ch01-02-hello-world.md:157
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of the puzzle:"
msgstr "Mari kita tinjau kembali program ini secara rinci!"

#: src/ch01-02-hello-world.md:166
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it is always the first code that runs in every executable Cairo program. "
"Here, the first line declares a function named `main` that has no parameters"
" and returns nothing. If there were parameters, they would go inside the "
"parentheses `()`."
msgstr ""
"Garis-garis ini mendefinisikan sebuah fungsi bernama åmain. Fungsinya sangat"
" spesial: selalu merupakan kode pertama yang dijalankan dalam setiap program"
" yang dapat dieksekusi Cairo."

#: src/ch01-02-hello-world.md:171
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around "
"all function bodies. It’s good style to place the opening curly bracket on "
"the same line as the function declaration, adding one space in between."
msgstr ""
"Tubuh fungsi dibungkus dalam {}. Cairo membutuhkan braket keriting di "
"sekitar semua tubuh fungsi. Ini gaya yang baik untuk menempatkan braket "
"keriting membuka pada baris yang sama seperti deklarasi fungsi, menambahkan "
"satu ruang di antaranya."

#: src/ch01-02-hello-world.md:175
msgid ""
"Note: If you want to stick to a standard style across Cairo projects, you "
"can use the automatic formatter tool available with `scarb fmt` to format "
"your code in a particular style (more on `scarb fmt` in [Appendix "
"F](./appendix-06-useful-development-tools.md)). The Cairo team has included "
"this tool with the standard Cairo distribution, as `cairo-run` is, so it "
"should already be installed on your computer!"
msgstr ""
"Catatan: Jika Anda ingin tetap dengan gaya standar di seluruh proyek Cairo, "
"Anda dapat menggunakan alat formateri otomatis yang tersedia dengan fmscarb "
"fmt; untuk memformat kode Anda dengan gaya tertentu (lebih banyak pada "
"thosescarb fmt-- in [Appendix F]./appendix-06-usful-developmenttools.md). "
"Tim Cairo telah menyertakan alat ini dengan distribusi standar Cairo, "
"sebagai Ácairo-run, jadi ini seharusnya sudah dipasang di komputer Anda!"

#: src/ch01-02-hello-world.md:182
msgid "The body of the `main` function holds the following code:"
msgstr "Tubuh fungsi åmain menyimpan kode berikut:"

#: src/ch01-02-hello-world.md:188
msgid ""
"This line does all the work in this little program: it prints text to the "
"screen. There are four important details to notice here."
msgstr ""
"Baris ini melakukan semua pekerjaan dalam program kecil ini: ini mencetak "
"teks ke layar. Ada empat rincian penting untuk pemberitahuan di sini."

#: src/ch01-02-hello-world.md:191
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr ""
"Pertama, gaya Cairo adalah untuk mengindentasi dengan empat spasi, bukan "
"tab."

#: src/ch01-02-hello-world.md:193
msgid ""
"Second, `println!` calls a Cairo macro. If it had called a function instead,"
" it would be entered as `println` (without the `!`). We’ll discuss Cairo "
"macros in more detail in the [\"Macros\"](./ch11-05-macros.md) chapter. For "
"now, you just need to know that using a `!` means that you’re calling a "
"macro instead of a normal function and that macros don’t always follow the "
"same rules as functions."
msgstr ""
"Kedua, jika disebut makro Cairo. jika disebut fungsi sebagai gantinya, itu "
"akan dimasukkan sebagai ▪printlní (tanpa huruf!). kita akan membahas macro "
"Cairo secara lebih detail dalam bab [\"Macros\"]. /ch11-05-macros.md) untuk "
"sekarang, Anda hanya perlu tahu bahwa menggunakan sebuah ltu!) berarti bahwa"
" Anda memanggil makro bukan fungsi normal dan macros tidak selalu mengikuti "
"aturan yang sama seperti fungsi."

#: src/ch01-02-hello-world.md:196
msgid ""
"Third, you see the `\"Hello, world!\"` string. We pass this string as an "
"argument to `println!`, and the string is printed to the screen."
msgstr ""
"Ketiga, Anda melihat \"Halo, dunia!\" Kami melewati string ini sebagai "
"argumen untuk ·println!, dan string dicetak ke layar."

#: src/ch01-02-hello-world.md:198
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this "
"expression is over and the next one is ready to begin. Most lines of Cairo "
"code end with a semicolon."
msgstr ""
"Keempat, kita mengakhiri garis dengan titik koma (Negara), yang menunjukkan "
"bahwa ekspresi ini berakhir dan yang berikutnya siap untuk dimulai. sebagian"
" besar garis kode Cairo berakhir dengan titik koma."

#: src/ch01-02-hello-world.md:205
msgid "{{#quiz ../quizzes/ch01-02-hello-world.toml}}"
msgstr "[{#quiz.. /quizzes/ch01-02-hello-world.toml] ]"

#: src/ch01-02-hello-world.md:207 src/ch02-05-control-flow.md:311
#: src/ch07-05-separating-modules-into-different-files.md:97
#: src/ch09-02-recoverable-errors.md:188
#: src/ch11-01-custom-data-structures.md:345
#: src/ch11-06-inlining-in-cairo.md:269
#: src/ch17-02-testing-smart-contracts.md:730
msgid "Summary"
msgstr "Ringkasan"

#: src/ch01-02-hello-world.md:209
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr ""
"Mari kita ulangi apa yang telah kita pelajari sejauh ini tentang Scarb:"

#: src/ch01-02-hello-world.md:211
msgid ""
"We can install one or multiple Scarb versions, either the latest stable or a"
" specific one, using asdf."
msgstr ""
"Kita dapat menginstal satu atau beberapa versi Scarb, baik stabil terbaru "
"atau yang spesifik, menggunakan asdf."

#: src/ch01-02-hello-world.md:212
msgid "We can create a project using `scarb new`."
msgstr "Kita bisa membuat sebuah proyek menggunakan bahan bakar baru."

#: src/ch01-02-hello-world.md:213
msgid ""
"We can build a project using `scarb build` to generate the compiled Sierra "
"code."
msgstr ""
"Kita dapat membangun sebuah proyek dengan membangun kereta untuk "
"menghasilkan kode Sierra yang dikompilasi."

#: src/ch01-02-hello-world.md:214
msgid "We can execute a Cairo program using the `scarb cairo-run` command."
msgstr "Kita dapat menjalankan program Cairo menggunakan perintah cairo-run."

#: src/ch01-02-hello-world.md:216
msgid ""
"An additional advantage of using Scarb is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no"
" longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""
"Keuntungan tambahan dari menggunakan Scarb adalah bahwa perintah adalah sama"
" tidak peduli sistem operasi mana yang Anda kerjakan. jadi, pada saat ini, "
"kita tidak lagi memberikan instruksi spesifik untuk Linux dan macOS versus "
"Windows."

#: src/ch01-02-hello-world.md:218
msgid ""
"You’re already off to a great start on your Cairo journey! This is a great "
"time to build a more substantial program to get used to reading and writing "
"Cairo code."
msgstr ""
"Ini adalah waktu yang tepat untuk membangun program yang lebih substansial "
"untuk terbiasa membaca dan menulis kode Cairo."

#: src/ch02-00-common-programming-concepts.md
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Cairo. Many programming languages have much in"
" common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain "
"the conventions around using these concepts."
msgstr ""
"Bab ini mencakup konsep-konsep yang muncul hampir di hampir setiap bahasa "
"pemrograman dan bagaimana mereka bekerja di Cairo. banyak bahasa pemrograman"
" memiliki banyak kesamaan pada inti mereka. tidak satupun konsep yang "
"disajikan di bab ini unik untuk Cairo, tapi kita akan mendiskusikannya dalam"
" konteks Cairo dan menjelaskan konvensi di sekitar menggunakan konsep-konsep"
" ini."

#: src/ch02-00-common-programming-concepts.md
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Cairo "
"program, and learning them early will give you a strong core to start from."
msgstr ""
"Secara khusus, Anda akan belajar tentang variabel, tipe dasar, fungsi, "
"komentar, dan kontrol aliran. fondasi ini akan ada di setiap program Cairo, "
"dan mempelajarinya lebih awal akan memberi Anda inti yang kuat untuk memulai"
" dari."

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is "
"written to, it can't be overwritten but only read from. To reflect this "
"immutable memory model, variables in Cairo are immutable by default. "
"However, the language abstracts this model and gives you the option to make "
"your variables mutable. Let’s explore how and why Cairo enforces "
"immutability, and how you can make your variables mutable."
msgstr ""
"Cairo menggunakan model memori immutable, berarti bahwa sekali sebuah sel "
"memori ditulis, itu tidak dapat ditimpa tetapi hanya dibaca dari. Untuk "
"merefleksikan model memori immutable ini, variabel di Cairo tidak dapat "
"berubah secara baku. Namun, bahasa abstrak model ini dan memberikan pilihan "
"untuk membuat variabel Anda dapat bermutasi. Biarkan orang-orang "
"mengeksplorasi bagaimana dan mengapa Cairo mengerahkan kemampuan abadi, dan "
"bagaimana Anda dapat membuat variabel mustabel."

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t "
"change that value. To illustrate this, generate a new project called "
"_variables_ in your _cairo_projects_ directory by using `scarb new "
"variables`."
msgstr ""
"Ketika sebuah variabel tidak dapat diubah, sekali nilai terikat pada sebuah "
"nama, anda tidak dapat mengubah nilai tersebut. Untuk mengilustrasikan ini, "
"hasilkan sebuah proyek baru yang disebut _variables_ dalam direktori "
"_cairo_projects_ anda dengan menggunakan variabel baru."

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace "
"its code with the following code, which won’t compile just yet:"
msgstr ""
"Kemudian, dalam direktori _variabel_ baru Anda, buka _src/lib.cairo_ dan "
"ganti kodenya dengan kode berikut, yang belum mengkompilasinya:"

#: src/ch02-01-variables-and-mutability.md:17
#: src/ch04-01-what-is-ownership.md:265 src/ch04-01-what-is-ownership.md:310
#: src/ch04-02-references-and-snapshots.md:26
#: src/ch04-02-references-and-snapshots.md:118
#: src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:27
#: src/ch05-01-defining-and-instantiating-structs.md:53
#: src/ch05-01-defining-and-instantiating-structs.md:89
#: src/ch05-01-defining-and-instantiating-structs.md:125
#: src/ch05-01-defining-and-instantiating-structs.md:167
#: src/ch05-01-defining-and-instantiating-structs.md:203
#: src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:50
#: src/ch05-02-an-example-program-using-structs.md:75
#: src/ch07-02-defining-modules-to-control-scope.md:80
#: src/ch07-02-defining-modules-to-control-scope.md:137
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:14
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:90
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:116
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:150
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:36
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:81
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:133
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:206
#: src/ch07-05-separating-modules-into-different-files.md:18
#: src/ch09-01-unrecoverable-errors-with-panic.md:9
#: src/ch10-01-how-to-write-tests.md:32 src/ch10-01-how-to-write-tests.md:89
#: src/ch10-01-how-to-write-tests.md:140 src/ch10-01-how-to-write-tests.md:222
#: src/ch10-01-how-to-write-tests.md:334 src/ch10-01-how-to-write-tests.md:558
#: src/ch10-01-how-to-write-tests.md:652 src/ch10-01-how-to-write-tests.md:741
msgid "<span class=\"filename\">Filename: src/lib.cairo</span>"
msgstr "<nama berkas=\"pan\"> Nama berkas: src/lib.cairo</span>"

#: src/ch02-01-variables-and-mutability.md:22
#: src/ch02-01-variables-and-mutability.md:24
#: src/ch02-01-variables-and-mutability.md:89
#: src/ch02-01-variables-and-mutability.md:91
#: src/ch02-01-variables-and-mutability.md:248
#: src/ch02-01-variables-and-mutability.md:250 src/ch02-03-functions.md:71
#: src/ch02-03-functions.md:287 src/ch02-03-functions.md:325
#: src/ch02-03-functions.md:341
msgid "\"The value of x is: {}\""
msgstr "Nilai x adalah: {}\""

#: src/ch02-01-variables-and-mutability.md:29
msgid ""
"Save and run the program using `scarb cairo-run`. You should receive an "
"error message regarding an immutability error, as shown in this output:"
msgstr ""
"Simpan dan jalankan program dengan menggunakan cairo-run. Anda harus "
"menerima pesan kesalahan mengenai kesalahan immutability, seperti yang "
"ditunjukkan pada keluaran ini:"

#: src/ch02-01-variables-and-mutability.md:45
msgid ""
"This example shows how the compiler helps you find errors in your programs. "
"Compiler errors can be frustrating, but they only mean your program isn’t "
"safely doing what you want it to do yet; they do _not_ mean that you’re not "
"a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""
"Contoh ini menunjukkan bagaimana kompiler membantu Anda menemukan kesalahan "
"dalam program Anda. Kesalahan kompiler dapat membuat frustasi, tetapi hanya "
"berarti program Anda tidak aman melakukan apa yang Anda inginkan; mereka "
"melakukan _not_ berarti bahwa Anda bukan programmer yang baik! Caironautes "
"berpengalaman masih mendapatkan kesalahan kompiler."

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"You received the error message `Cannot assign to an immutable variable.` "
"because you tried to assign a second value to the immutable `x` variable."
msgstr ""
"Anda menerima pesan galat yang tidak dapat diberikan ke variabel yang dapat "
"berubah. Karena Anda mencoba untuk menetapkan nilai kedua ke variabel yang "
"dapat berubah."

#: src/ch02-01-variables-and-mutability.md:53
msgid ""
"It’s important that we get compile-time errors when we attempt to change a "
"value that’s designated as immutable because this specific situation can "
"lead to bugs. If one part of our code operates on the assumption that a "
"value will never change and another part of our code changes that value, "
"it’s possible that the first part of the code won’t do what it was designed "
"to do. The cause of this kind of bug can be difficult to track down after "
"the fact, especially when the second piece of code changes the value only "
"_sometimes_."
msgstr ""
"Sangat penting bahwa kita mendapatkan kesalahan kompilasi-waktu ketika kita "
"mencoba untuk mengubah nilai yang ditunjuk sebagai tidak dapat berubah "
"karena situasi spesifik ini dapat menyebabkan bug. jika salah satu bagian "
"dari kode kita bekerja pada asumsi bahwa nilai tidak akan pernah berubah dan"
" bagian lain dari kode kita berubah nilai itu, itu mungkin bahwa bagian "
"pertama dari kode ini akan melakukan apa yang dirancang untuk dilakukan. "
"Penyebab bug semacam ini dapat sulit untuk melacak setelah fakta, terutama "
"ketika sepotong kode mengubah hanya nilai _somes_."

#: src/ch02-01-variables-and-mutability.md:61
msgid ""
"Cairo, unlike most other languages, has immutable memory. This makes a whole"
" class of bugs impossible, because values will never change unexpectedly. "
"This makes code easier to reason about."
msgstr ""
"Cairo, tidak seperti kebanyakan bahasa lain, memiliki memori yang dapat "
"berubah. ini membuat seluruh kelas bug tidak mungkin, karena nilai-nilai "
"tidak akan berubah tiba-tiba. ini membuat kode lebih mudah untuk dipikirkan."

#: src/ch02-01-variables-and-mutability.md:65
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write. Although variables are immutable by default, you can make them "
"mutable by adding `mut` in front of the variable name. Adding `mut` also "
"conveys intent to future readers of the code by indicating that other parts "
"of the code will be changing the value associated to this variable."
msgstr ""
"Tapi perubahan bisa sangat berguna, dan dapat membuat kode lebih mudah "
"ditulis. Meskipun variabel tidak dapat berubah secara baku, Anda dapat "
"membuatnya dapat bermutasi dengan menambahkan nilai yang terkait dengan "
"variabel ini."

#: src/ch02-01-variables-and-mutability.md:73
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable is declared as `mut`, as we previously mentioned that Cairo's "
"memory is immutable. The answer is that the _value_ is immutable, but the "
"_variable_ isn't. The value associated to the variable can be changed. "
"Assigning to a mutable variable in Cairo is essentially equivalent to "
"redeclaring it to refer to another value in another memory cell, but the "
"compiler handles that for you, and the keyword `mut` makes it explicit. Upon"
" examining the low-level Cairo Assembly code, it becomes clear that variable"
" mutation is implemented as syntactic sugar, which translates mutation "
"operations into a series of steps equivalent to variable shadowing. The only"
" difference is that at the Cairo level, the variable is not redeclared so "
"its type cannot change."
msgstr ""
"Namun, Anda mungkin bertanya-tanya pada titik ini apa yang sebenarnya "
"terjadi ketika variabel dinyatakan sebagai åmuté, seperti yang sebelumnya "
"kami sebutkan bahwa memori Cairo tidak dapat berubah. Jawabannya adalah "
"bahwa _value_ tidak dapat berubah, tapi _variable_ isn apos; t. Nilai yang "
"terkait dengan variabel dapat diubah. Sebagaimana kita sebelumnya disebutkan"
" kepada variabel mutable di Cairo pada dasarnya setara dengan "
"mendeklarasikan kembali ke dalam sel memori lain, tetapi menangani compiler "
"yang untuk Anda, dan kata kunci yang membuatnya eksplisit. setelah memeriksa"
" tingkat rendah- Cairo Assembly kode, itu menjadi variabel yang "
"diimplementasikan sebagai gula yang diimplementasikan ke dalam proses "
"mutasi, yang diterjemahkan ke dalam rangkaian operasi yang sama."

#: src/ch02-01-variables-and-mutability.md:84
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr "Sebagai contoh, mari kita ubah _src/lib.cairo_ ke berikut:"

#: src/ch02-01-variables-and-mutability.md:95
msgid "When we run the program now, we get this:"
msgstr "Ketika kita menjalankan program sekarang, kita mendapatkan ini:"

#: src/ch02-01-variables-and-mutability.md:108
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is"
" used. Ultimately, deciding whether to use mutability or not is up to you "
"and depends on what you think is clearest in that particular situation."
msgstr ""
"Pada akhirnya, memutuskan apakah menggunakan mutability atau tidak "
"tergantung pada apa yang Anda pikir paling jelas dalam situasi seperti itu."

#: src/ch02-01-variables-and-mutability.md:112
msgid "Constants"
msgstr "Konstanta"

#: src/ch02-01-variables-and-mutability.md:114
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and are not allowed to change, but there are a few differences between "
"constants and variables."
msgstr ""
"Seperti variabel yang tidak dapat berubah, _konstant_ adalah nilai yang "
"terikat pada suatu nama dan tidak diperbolehkan untuk berubah, tetapi ada "
"beberapa perbedaan antara konstanta dan variabel."

#: src/ch02-01-variables-and-mutability.md:118
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just"
" immutable by default—they’re always immutable. You declare constants using "
"the `const` keyword instead of the `let` keyword, and the type of the value "
"_must_ be annotated. We’ll cover types and type annotations in the next "
"section, [“Data Types”](./ch02-02-data-types.md), so don’t worry about the "
"details right now. Just know that you must always annotate the type."
msgstr ""
"Pertama, Anda tidak diperbolehkan menggunakan kata kunci åconsté dengan "
"konstanta. Konstanta tidak hanya tidak dapat berubah secara baku. Anda "
"menyatakan konstanta menggunakan kata kunci åconst, bukan dengan kata kunci,"
" dan tipe nilai _must_dinotasi. kita akan menutup tipe dan mengetik annotasi"
" di bagian berikutnya, [Neta Types]. /ch02-data-types.md), jadi jangan "
"khawatir tentang rincian sekarang."

#: src/ch02-01-variables-and-mutability.md:125
msgid ""
"Constant variables can be declared with any usual data type, including "
"structs, enums and fixed-size arrays."
msgstr ""
"Variabel konstan dapat dideklarasikan dengan tipe data biasa, termasuk "
"struct, enums dan ukuran tetap."

#: src/ch02-01-variables-and-mutability.md:127
msgid ""
"Constants can only be declared in the global scope, which makes them useful "
"for values that many parts of code need to know about."
msgstr ""
"Konstanta hanya dapat dinyatakan dalam lingkup global, yang membuatnya "
"berguna bagi nilai-nilai yang perlu diketahui banyak bagian dari kode."

#: src/ch02-01-variables-and-mutability.md:130
msgid ""
"The last difference is that constants may natively be set only to a constant"
" expression, not the result of a value that could only be computed at "
"runtime."
msgstr ""
"Perbedaan terakhir adalah bahwa konstanta mungkin hanya diatur ke ekspresi "
"konstan, bukan hasil dari nilai yang hanya dapat dihitung pada waktu-jalan."

#: src/ch02-01-variables-and-mutability.md:133
msgid "Here’s an example of constants declaration:"
msgstr "Berikut ini adalah contoh dari pernyataan konstan:"

#: src/ch02-01-variables-and-mutability.md:152
msgid ""
"Nonetheless, it is possible to use the `consteval_int!` macro to create a "
"`const` variable that is the result of some computation:"
msgstr ""
"Meskipun demikian, kita dapat menggunakan kata \"consteval_int\"! makro "
"untuk membuat variabel ·const) yang merupakan hasil dari beberapa komputasi:"

#: src/ch02-01-variables-and-mutability.md:158
msgid ""
"We will dive into more detail about macros in the [dedicated "
"section](./ch11-05-macros.md)."
msgstr ""
"Kita akan menyelam lebih detail tentang makro di bagian [didedikasi]. "
"/ch11-05-macros.md)."

#: src/ch02-01-variables-and-mutability.md:160
msgid ""
"Cairo's naming convention for constants is to use all uppercase with "
"underscores between words."
msgstr ""
"Konvensi penamaan Cairo untuk konstanta adalah menggunakan semua huruf besar"
" dengan garis bawah antara kata-kata."

#: src/ch02-01-variables-and-mutability.md:162
msgid ""
"Constants are valid for the entire time a program runs, within the scope in "
"which they were declared. This property makes constants useful for values in"
" your application domain that multiple parts of the program might need to "
"know about, such as the maximum number of points any player of a game is "
"allowed to earn, or the speed of light."
msgstr ""
"Konstanta valid untuk seluruh waktu program berjalan, dalam lingkup di mana "
"mereka dideklarasikan. Properti ini membuat konstanta berguna untuk nilai-"
"nilai dalam domain aplikasi Anda bahwa beberapa bagian dari program mungkin "
"perlu tahu tentang, seperti jumlah maksimum poin setiap pemain game "
"diperbolehkan untuk menghasilkan, atau kecepatan cahaya."

#: src/ch02-01-variables-and-mutability.md:168
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in conveying the meaning of that value to future maintainers of the code. It"
" also helps to have only one place in your code you would need to change if "
"the hardcoded value needed to be updated in the future."
msgstr ""
"Nama nilai hardcode yang digunakan di seluruh program Anda sebagai konstanta"
" berguna untuk menyampaikan arti dari nilai tersebut kepada pengelola kode "
"di masa depan. Hal ini juga membantu untuk memiliki hanya satu tempat dalam "
"kode Anda Anda akan perlu berubah jika nilai hardcoded diperlukan untuk "
"diperbarui di masa depan."

#: src/ch02-01-variables-and-mutability.md:175
msgid "Shadowing"
msgstr "Membayangi"

#: src/ch02-01-variables-and-mutability.md:177
msgid ""
"Variable shadowing refers to the declaration of a new variable with the same"
" name as a previous variable. Caironautes say that the first variable is "
"_shadowed_ by the second, which means that the second variable is what the "
"compiler will see when you use the name of the variable. In effect, the "
"second variable overshadows the first, taking any uses of the variable name "
"to itself until either it itself is shadowed or the scope ends. We can "
"shadow a variable by using the same variable’s name and repeating the use of"
" the `let` keyword as follows:"
msgstr ""
"Variabel membayangkan sebuah deklarasi dari variabel baru dengan nama yang "
"sama sebagai variabel sebelumnya. Caironautes mengatakan bahwa variabel "
"pertama adalah _shadowed_ oleh yang kedua, yang berarti bahwa variabel kedua"
" adalah apa yang akan dilihat kompiler ketika Anda menggunakan nama variabel"
" yang sama. Pada efek, variabel kedua mengaburkan pertama, mengambil "
"penggunaan apapun dari nama variabel untuk dirinya sendiri sampai baik itu "
"sendiri dibayangi atau lingkup berakhir. Kita dapat bayangankan variabel "
"dengan menggunakan variabel yang sama dan mengulangi penggunaan kata kunci "
"{1}let Allah sebagai berikut:"

#: src/ch02-01-variables-and-mutability.md:192
msgid "\"Inner scope x value is: {}\""
msgstr "\"Inner scope x value is: {}\""

#: src/ch02-01-variables-and-mutability.md:194
msgid "\"Outer scope x value is: {}\""
msgstr "\"Outer scope x value is: {}\""

#: src/ch02-01-variables-and-mutability.md:198
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable `x` by repeating `let x =`, taking the original value and adding "
"`1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and "
"creates a new variable, multiplying the previous value by `2` to give `x` a "
"value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the "
"following:"
msgstr ""
"Program ini pertama-tama mengikatkan nilai åx. lalu, ia menciptakan variabel"
" baru dengan mengulangi x = 1, mengambil nilai asli dan menambahkan nilai "
"sebelumnya dengan nilai ·x. lalu, dalam ruang lingkup dalam yang dibuat "
"dengan braket keriting, pernyataan ketiga, juga bayangan xx, dan menciptakan"
" variabel baru, melipatgandakan nilai sebelumnya dengan 0,2, untuk "
"memberikan nilai sebesar 12."

#: src/ch02-01-variables-and-mutability.md:217
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a "
"compile-time error if we accidentally try to reassign to this variable "
"without using the `let` keyword. By using `let`, we can perform a few "
"transformations on a value but have the variable be immutable after those "
"transformations have been completed."
msgstr ""
"Pembayangan berbeda dengan menandai variabel sebagai ·muté karena kita akan "
"mendapatkan kesalahan kompilasi-waktu jika kita tidak sengaja mencoba untuk "
"mengubah variabel ini tanpa menggunakan kata kunci. Dengan menggunakan "
"·letâ, kita dapat melakukan beberapa transformasi pada suatu nilai tetapi "
"memiliki variabel dapat berubah setelah transformasi tersebut telah selesai."

#: src/ch02-01-variables-and-mutability.md:223
msgid ""
"Another distinction between `mut` and shadowing is that when we use the "
"`let` keyword again, we are effectively creating a new variable, which "
"allows us to change the type of the value while reusing the same name. As "
"mentioned before, variable shadowing and mutable variables are equivalent at"
" the lower level. The only difference is that by shadowing a variable, the "
"compiler will not complain if you change its type. For example, say our "
"program performs a type conversion between the `u64` and `felt252` types."
msgstr ""
"Perbedaan lain antara °M dan bayangan adalah bahwa ketika kita menggunakan "
"kata kunci lagi, kita secara efektif membuat variabel baru, yang "
"memungkinkan kita untuk mengubah tipe nilai ketika menggunakan kembali nama "
"yang sama. Seperti disebutkan sebelumnya, variabel bayangan dan variabel "
"mutable setara pada tingkat yang lebih rendah. Perbedaannya adalah bahwa "
"hanya dengan membayangi variabel, kompiler tidak akan mengeluh jika Anda "
"mengubah tipenya. Misalnya, katakanlah program kami melakukan konversi tipe "
"antara tipe É64 dan tipe 25°2."

#: src/ch02-01-variables-and-mutability.md:234
msgid "\"The value of x is {} of type u64\""
msgstr "\"Harta x adalah {} tipe u64\""

#: src/ch02-01-variables-and-mutability.md:235
msgid "// converts x to a felt, type annotation is required.\n"
msgstr "/// ubah x ke sebuah felt, tipe anotasi diperlukan.\n"

#: src/ch02-01-variables-and-mutability.md:236
msgid "\"The value of x is {} of type felt252\""
msgstr "\"Harta x adalah {} tipe merasa 252\""

#: src/ch02-01-variables-and-mutability.md:240
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type. Shadowing thus spares us from having to come up with "
"different names, such as `x_u64` and `x_felt252`; instead, we can reuse the "
"simpler `x` name. However, if we try to use `mut` for this, as shown here, "
"we’ll get a compile-time error:"
msgstr ""
"Variabel pertama memiliki tipe ·u64 ketika variabel kedua memiliki tipe "
"enomx252. Dengan demikian, bayangan menghindarkan kita dari datang dengan "
"nama yang berbeda, seperti x_u64 dan variabel kedua memiliki jenis 25; "
"sebagai gantinya, kita dapat menggunakan kembali nama sederhana. Namun, jika"
" kita mencoba menggunakan Émutía untuk ini, seperti ditunjukkan di sini, "
"kita akan mendapatkan kesalahan kompilasi:"

#: src/ch02-01-variables-and-mutability.md:254
msgid ""
"The error says we were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr ""
"Kesalahan mengatakan kami mengharapkan sebuah ·u64) (tipe aslinya) tapi kami"
" mendapat tipe yang berbeda:"

#: src/ch02-01-variables-and-mutability.md:269
msgid "{{#quiz ../quizzes/ch02-01-variables-and-mutability.toml}}"
msgstr "{{#quiz../quizzes/ch02-01-variables-and-mutability.toml}}"

#: src/ch02-01-variables-and-mutability.md:271
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they can have."
msgstr ""
"Sekarang kita sudah menjelajahi bagaimana variabel bekerja, mari kita lihat "
"lebih banyak tipe data yang dapat mereka miliki."

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what "
"kind of data is being specified so it knows how to work with that data. This"
" section covers two subsets of data types: scalars and compounds."
msgstr ""
"Setiap nilai di Cairo adalah tipe _data_ tertentu, yang memberitahu Cairo "
"jenis data apa yang sedang dispesifikasikan sehingga ia tahu bagaimana "
"bekerja dengan data itu. Bagian ini mencakup dua subset tipe data: skalar "
"dan senyawa."

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that "
"it must know the types of all variables at compile time. The compiler can "
"usually infer the desired type based on the value and its usage. In cases "
"when many types are possible, we can use a cast method where we specify the "
"desired output type."
msgstr ""
"Perlu diingat bahwa Cairo adalah _statis mengetik_ bahasa, yang berarti "
"bahwa ia harus tahu tipe dari semua variabel pada waktu kompilasi. Komiler "
"biasanya dapat infer tipe yang diinginkan berdasarkan nilai dan "
"penggunaannya. Dalam kasus ketika banyak tipe mungkin, kita dapat "
"menggunakan metode cast di mana kita menentukan tipe keluaran yang "
"diinginkan."

#: src/ch02-02-data-types.md:16
msgid "You’ll see different type annotations for other data types."
msgstr "Anda akan melihat notasi tipe yang berbeda untuk tipe data lain."

#: src/ch02-02-data-types.md:18
msgid "Scalar Types"
msgstr "Tipe Scalar"

#: src/ch02-02-data-types.md:20
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar "
"types: felts, integers, and booleans. You may recognize these from other "
"programming languages. Let’s jump into how they work in Cairo."
msgstr ""
"Tipe _skalar merupakan satu nilai. Cairo memiliki tiga tipe skalar primer: "
"merasa, integer, dan booleans. Anda mungkin mengenali ini dari bahasa "
"pemrograman lain. Biarkan mereka melompat ke bagaimana mereka bekerja di "
"Cairo."

#: src/ch02-02-data-types.md:24
msgid "Felt Type"
msgstr "Tipe Merasa"

#: src/ch02-02-data-types.md:26
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the "
"context of Cairo, when we say “a field element” we mean an integer in the "
"range \\\\( 0 \\leq x \\< P \\\\), where \\\\( P \\\\) is a very large prime"
" number currently equal to \\\\( {2^{251}} + 17 \\cdot {2^{192}} + 1 \\\\). "
"When adding, subtracting, or multiplying, if the result falls outside the "
"specified range of the prime number, an overflow (or underflow) occurs, and "
"an appropriate multiple of \\\\( P \\\\) is added or subtracted to bring the"
" result back within the range (i.e., the result is computed \\\\( \\mod P "
"\\\\) )."
msgstr ""
"Di Cairo, jika Anda tidak menspesifikasikan tipe variabel atau argumen, "
"tipenya default ke sebuah elemen lapangan, yang diwakili oleh kata kunci "
"\\<P\\\\\\\\ P\\\\) adalah bilangan prima yang sangat besar saat ini sama "
"dengan \\\\[2{251} +17 \\cdot {{[1}. Ketika menambahkan, penambahan, atau "
"hasil luar dari bilangan prima (atau overflow) dan menghasilkan p\\\\d "
"kembali."

#: src/ch02-02-data-types.md:29
msgid ""
"The most important difference between integers and field elements is "
"division: Division of field elements (and therefore division in Cairo) is "
"unlike regular CPUs division, where integer division \\\\( \\frac{x}{y} "
"\\\\) is defined as \\\\( \\left\\lfloor \\frac{x}{y} \\right\\rfloor \\\\) "
"where the integer part of the quotient is returned (so you get \\\\( "
"\\frac{7}{3} = 2 \\\\)) and it may or may not satisfy the equation \\\\( "
"\\frac{x}{y} \\cdot y == x \\\\), depending on the divisibility of `x` by "
"`y`."
msgstr ""
"Perbedaan yang paling penting antara integer dan elemen lapangan adalah "
"division of field elemens (dan karena itu pembagian di Cairo) adalah tidak "
"seperti pembagian CPU biasa, di mana pembagian integer \\frac{y}{y}\\\\y) "
"didefinisikan sebagai \\left\\l floor \\frac{y}{y} \\rstandar \\r di mana "
"bagian integer dari quotient dikembalikan (sehingga Anda mendapatkan "
"\\frac{7}{3}}) dan mungkin atau mungkin tidak dapat memuaskan persamaan "
"\\x\\{x}\\d0\\y \\t\\y), yvis) tergantung pada di sini."

#: src/ch02-02-data-types.md:34
msgid ""
"In Cairo, the result of \\\\( \\frac{x}{y} \\\\) is defined to always "
"satisfy the equation \\\\( \\frac{x}{y} \\cdot y == x \\\\). If y divides x "
"as integers, you will get the expected result in Cairo (for example \\\\( "
"\\frac{6}{2} \\\\) will indeed result in `3`). But when y does not divide x,"
" you may get a surprising result: for example, since \\\\( 2 \\cdot \\frac{P"
" + 1}{2} = P + 1 \\equiv 1 \\mod P \\\\), the value of \\\\( \\frac{1}{2} "
"\\\\) in Cairo is \\\\( \\frac{P + 1}{2} \\\\) (and not 0 or 0.5), as it "
"satisfies the above equation."
msgstr ""
"Di Cairo, hasil dari \\frac{x}\\\\y} \\\\\\) didefinisikan untuk selalu "
"memenuhi persamaan \\\\frac{x}{y}{y} \\cdot y == x \\\\). Jika y membagi x "
"sebagai integers, Anda akan mendapatkan hasil yang diharapkan di Cairo "
"(misalnya \\\\fak{6}\\\\) memang akan menghasilkan dalam Á3). Tapi ketika y "
"tidak membagi x, Anda mungkin mendapatkan hasil yang mengejutkan: karena "
"\\\\ánct\\\\\\\\2} 1} 1= 1\\\\\\\\\\\\\\\\\\\\\\ \\\\\\\\\\ \\\\ \\\\ \\\\ "
"\\\\\\\\,\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\}"

#: src/ch02-02-data-types.md:37
msgid "Integer Types"
msgstr "Tipe Integer"

#: src/ch02-02-data-types.md:39
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating"
" all types in the core library. However, it is highly recommended for "
"programmers to use the integer types instead of the `felt252` type whenever "
"possible, as the `integer` types come with added security features that "
"provide extra protection against potential vulnerabilities in the code, such"
" as overflow and underflow checks. By using these integer types, programmers"
" can ensure that their programs are more secure and less susceptible to "
"attacks or other security threats. An `integer` is a number without a "
"fractional component. This type declaration indicates the number of bits the"
" programmer can use to store the integer. Table 3-1 shows the built-in "
"integer types in Cairo. We can use any of these variants to declare the type"
" of an integer value."
msgstr ""
"Tipe integer adalah tipe fundamental yang berfungsi sebagai dasar untuk "
"membuat semua jenis di perpustakaan inti. Namun, sangat dianjurkan bagi "
"programmer untuk menggunakan tipe integer sebagai ganti tipe ÁN252 (jenis "
"integer) sebisa mungkin, sebagai jenis Áinteger yang datang dengan fitur "
"keamanan tambahan yang memberikan perlindungan ekstra terhadap potensi "
"kerentanan dalam kode, seperti overflow dan underflow checking. Dengan "
"menggunakan tipe integer ini, program dapat memastikan bahwa program mereka "
"lebih aman dan kurang rentan terhadap serangan atau ancaman keamanan "
"lainnya. Sebuah grointeger atau keamanan adalah nomor tanpa komponen "
"fraksional. Ini menunjukkan tipe yang dapat digunakan oleh program "
"pemerogram di Tabletete-tetete."

#: src/ch02-02-data-types.md:44
msgid "Length"
msgstr "Panjang"

#: src/ch02-02-data-types.md:44
msgid "Unsigned"
msgstr "Unsigned"

#: src/ch02-02-data-types.md:46
msgid "8-bit"
msgstr "8-bit"

#: src/ch02-02-data-types.md:46
msgid "`u8`"
msgstr "[ Gambar di hlm."

#: src/ch02-02-data-types.md:47
msgid "16-bit"
msgstr "16-bit"

#: src/ch02-02-data-types.md:47
msgid "`u16`"
msgstr "Ãu16_BAR_"

#: src/ch02-02-data-types.md:48 src/ch02-02-data-types.md:52
msgid "32-bit"
msgstr "32-bit"

#: src/ch02-02-data-types.md:48
msgid "`u32`"
msgstr "▪u32ltu."

#: src/ch02-02-data-types.md:49
msgid "64-bit"
msgstr "64-bit"

#: src/ch02-02-data-types.md:49
msgid "`u64`"
msgstr "·u64)"

#: src/ch02-02-data-types.md:50
msgid "128-bit"
msgstr "128-bit"

#: src/ch02-02-data-types.md:50
msgid "`u128`"
msgstr "Áu128"

#: src/ch02-02-data-types.md:51
msgid "256-bit"
msgstr "256-bit"

#: src/ch02-02-data-types.md:51
msgid "`u256`"
msgstr "·u256_BAR_"

#: src/ch02-02-data-types.md:52
msgid "`usize`"
msgstr "Gunakanlah."

#: src/ch02-02-data-types.md:57
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is "
"just an alias for `u32`; however, it might be useful when in the future "
"Cairo can be compiled to MLIR. As variables are unsigned, they can't contain"
" a negative number. This code will cause the program to panic:"
msgstr ""
"Setiap varian memiliki ukuran eksplisit. Perhatikan bahwa untuk saat ini, "
"tipe åusizeé hanyalah alias untuk åu32; namun, mungkin berguna ketika di "
"Cairo masa depan dapat dikompilasi ke MLIR. Sebagai variabel unsigned, "
"mereka tidak dapat berisi nomor negatif. Kode ini akan menyebabkan program "
"panik:"

#: src/ch02-02-data-types.md:70
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for "
"`u256` which needs 4 more bits to be stored. Under the hood, `u256` is "
"basically a struct with 2 fields: `u256 {low: u128, high: u128}`."
msgstr ""
"Semua tipe integer yang sebelumnya disebutkan cocok menjadi sebuah ±252, "
"kecuali untuk u256 yang membutuhkan 4 bit lebih untuk disimpan di bawah kap "
"mobil, pada dasarnya adalah sebuah struktur dengan 2 bidang: ·u256 {low: "
"u128, high: u128}."

#: src/ch02-02-data-types.md:72
msgid ""
"Cairo also provides support for signed integers, starting with the prefix "
"`i`. These integers can represent both positive and negative values, with "
"sizes ranging from `i8` to `i128`. Each signed variant can store numbers "
"from \\\\( -({2^{n - 1}}) \\\\) to \\\\( {2^{n - 1}} - 1 \\\\) inclusive, "
"where `n` is the number of bits that variant uses. So an i8 can store "
"numbers from \\\\( -({2^7}) \\\\) to \\\\( {2^7} - 1 \\\\), which equals "
"`-128` to `127`."
msgstr ""
"Integer ini dapat mewakili nilai positif dan negatif, dengan ukuran mulai "
"dari Éi8, mulai dengan prefiksnya. Integer ini dapat mewakili nilai positif "
"dan negatif, dengan ukuran yang berkisar dari ▪128. mulai dengan bilangan "
"awalan yang ditandatangani dapat menyimpan angka dari \\\\baha~{n - 1}}) "
"\\\\) ke \\\\ (\\\\2^{n {{n - 1} - 1\\\\) incluive, di mana \\n adalah "
"jumlah bit varian yang digunakan. Jadi sebuah i8 dapat menyimpan nomor dari "
"\\8 -{2)"

#: src/ch02-02-data-types.md:75
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note "
"that number literals that can be multiple numeric types allow a type suffix,"
" such as `57_u8`, to designate the type. It is also possible to use a visual"
" separator `_` for number literals, in order to improve code readability."
msgstr ""
"Anda dapat menulis integer literal dalam salah satu bentuk yang ditampilkan "
"di Tabel 3-2. Perhatikan bahwa angka literal yang dapat menjadi beberapa "
"tipe numerik memungkinkan sebuah akhiran tipe, seperti å57_u8, untuk "
"menunjukkan tipenya. Hal ini juga mungkin untuk menggunakan pemisah visual "
"untuk nomor literal, untuk meningkatkan kemampuan baca kode."

#: src/ch02-02-data-types.md:80
msgid "Numeric literals"
msgstr "Literal numerik"

#: src/ch02-02-data-types.md:80 src/appendix-02-operators-and-symbols.md:9
#: src/appendix-08-system-calls.md:177 src/appendix-08-system-calls.md:256
#: src/appendix-08-system-calls.md:331
msgid "Example"
msgstr "Contoh"

#: src/ch02-02-data-types.md:82
msgid "Decimal"
msgstr "Desimal"

#: src/ch02-02-data-types.md:82
msgid "`98222`"
msgstr "\"98222\""

#: src/ch02-02-data-types.md:83
msgid "Hex"
msgstr "Hex"

#: src/ch02-02-data-types.md:83
msgid "`0xff`"
msgstr "0xff"

#: src/ch02-02-data-types.md:84
msgid "Octal"
msgstr "Oktal"

#: src/ch02-02-data-types.md:84
msgid "`0o04321`"
msgstr "0o04321."

#: src/ch02-02-data-types.md:85
msgid "Binary"
msgstr "Biner"

#: src/ch02-02-data-types.md:85
msgid "`0b01`"
msgstr "0b01_BAR_"

#: src/ch02-02-data-types.md:90
msgid ""
"So how do you know which type of integer to use? Try to estimate the max "
"value your int can have and choose the good size. The primary situation in "
"which you’d use `usize` is when indexing some sort of collection."
msgstr ""
"Jadi bagaimana Anda tahu tipe integer mana yang akan Anda gunakan? Cobalah "
"untuk memperkirakan nilai maksimal yang dapat dimiliki dan memilih ukuran "
"yang baik."

#: src/ch02-02-data-types.md:93
msgid "Numeric Operations"
msgstr "Operasi Numerik"

#: src/ch02-02-data-types.md:95
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the "
"integer types: addition, subtraction, multiplication, division, and "
"remainder. Integer division truncates toward zero to the nearest integer. "
"The following code shows how you’d use each numeric operation in a `let` "
"statement:"
msgstr ""
"Cairo mendukung operasi matematika dasar yang Anda harapkan untuk semua tipe"
" integer: penambahan, pengurangan, perkalian, pembagian, dan sisanya."

#: src/ch02-02-data-types.md:102
msgid "// addition\n"
msgstr "//tambahan\n"

#: src/ch02-02-data-types.md:105
msgid "// subtraction\n"
msgstr "// pengurangan\n"

#: src/ch02-02-data-types.md:108
msgid "// multiplication\n"
msgstr "// multiplikasi\n"

#: src/ch02-02-data-types.md:111
msgid "// division\n"
msgstr "/Bagian\n"

#: src/ch02-02-data-types.md:112
msgid "//result is 1\n"
msgstr "//hasil adalah 1\n"

#: src/ch02-02-data-types.md:113
msgid "//result is 2\n"
msgstr "//hasil adalah 2\n"

#: src/ch02-02-data-types.md:115
msgid "// remainder\n"
msgstr "//tersisa\n"

#: src/ch02-02-data-types.md:116
msgid "// result is 3\n"
msgstr "//hasilnya adalah 3\n"

#: src/ch02-02-data-types.md:120
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates to a single value, which is then bound to a variable."
msgstr ""
"Setiap ekspresi dalam pernyataan ini menggunakan operator matematika dan "
"mengevaluasi ke satu nilai, yang kemudian terikat ke sebuah variabel."

#: src/ch02-02-data-types.md:123
msgid ""
"[Appendix B](./appendix-02-operators-and-symbols.md#operators) contains a "
"list of all operators that Cairo provides."
msgstr ""
"[Appendix B]Akuppendix-02-operator-and-symbols.md#operators) berisi daftar "
"dari semua operator yang disediakan Cairo."

#: src/ch02-02-data-types.md:127
msgid "The Boolean Type"
msgstr "Tipe Boolean"

#: src/ch02-02-data-types.md:129
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two "
"possible values: `true` and `false`. Booleans are one `felt252` in size. The"
" Boolean type in Cairo is specified using `bool`. For example:"
msgstr ""
"Seperti kebanyakan bahasa pemrograman lainnya, tipe Boolean di Cairo "
"memiliki dua nilai yang mungkin: benar dan salah satu istilah Booleans "
"adalah ukuran tipe Boolean di Cairo dispesifikasikan sebagai contoh:"

#: src/ch02-02-data-types.md:137
msgid "// with explicit type annotation\n"
msgstr "//dengan tipe anotasi eksplisit\n"

#: src/ch02-02-data-types.md:141
msgid ""
"When declaring a `bool` variable, it is mandatory to use either `true` or "
"`false` literals as value. Hence, it is not allowed to use integer literals "
"(i.e. `0` instead of false) for `bool` declarations."
msgstr ""
"Karena itu, tidak diperbolehkan menggunakan variabel integer literal "
"(misalnya 00) sebagai pengganti deklarasi palsu)."

#: src/ch02-02-data-types.md:143
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` "
"expression. We’ll cover how `if` expressions work in Cairo in the [\"Control"
" Flow\"](./ch02-05-control-flow.md) section."
msgstr ""
"Cara utama untuk menggunakan nilai-nilai Boolean adalah melalui kondisional,"
" seperti ekspresi æifs. kita akan menutupi bagaimana ekspresi bekerja di "
"Cairo di bagian [\"Kontrol Flow\"]./ch02-05-control-flow.md)."

#: src/ch02-02-data-types.md:148
msgid "String Types"
msgstr "Jenis String"

#: src/ch02-02-data-types.md:150
msgid ""
"Cairo doesn't have a native type for strings but provides two ways to handle"
" them: short strings using simple quotes and ByteArray using double quotes."
msgstr ""
"Cairo tidak memiliki tipe asli untuk string tetapi menyediakan dua cara "
"untuk menangani mereka: string pendek menggunakan kutipan sederhana dan "
"ByteArray menggunakan tanda kutip ganda."

#: src/ch02-02-data-types.md:152
msgid "Short strings"
msgstr "String pendek"

#: src/ch02-02-data-types.md:154
msgid ""
"A short string is an ASCII string where each character is encoded on one "
"byte (see the [ASCII table](https://www.asciitable.com/)). For example:"
msgstr ""
"String pendek adalah string ASCII di mana setiap karakter dikodekan pada "
"satu byte (lihat tabel [ASCII][https://www.ascitable.com/). Sebagai contoh:"

#: src/ch02-02-data-types.md:156
msgid "`'a'` is equivalent to `0x61`"
msgstr "Ini setara dengan 0x61."

#: src/ch02-02-data-types.md:157
msgid "`'b'` is equivalent to `0x62`"
msgstr "Ini setara dengan 0x62."

#: src/ch02-02-data-types.md:158
msgid "`'c'` is equivalent to `0x63`"
msgstr "Ini setara dengan 0x63."

#: src/ch02-02-data-types.md:159
msgid "`0x616263` is equivalent to `'abc'`."
msgstr "0x616263 sama saja dengan 'abc'."

#: src/ch02-02-data-types.md:161
msgid ""
"Cairo uses the `felt252` for short strings. As the `felt252` is on 251 bits,"
" a short string is limited to 31 characters (31 \\* 8 = 248 bits, which is "
"the maximum multiple of 8 that fits in 251 bits)."
msgstr ""
"Cairo menggunakan 252 sen untuk senar pendek. sebagaimana pada 251 bit, "
"sebuah string pendek dibatasi menjadi 31 karakter (31 \\* 8 = 248 bit, yang "
"merupakan jumlah maksimum 8 yang cocok dalam 251 bits)."

#: src/ch02-02-data-types.md:163
msgid ""
"You can choose to represent your short string with an hexadecimal value like"
" `0x616263` or by directly writing the string using simple quotes like "
"`'abc'`, which is more convenient."
msgstr ""
"Anda dapat memilih untuk mewakili string pendek Anda dengan nilai "
"heksadesimal seperti 0x616263 atau dengan secara langsung menulis string "
"menggunakan kutipan sederhana seperti å'abc'å, yang lebih nyaman."

#: src/ch02-02-data-types.md:165
msgid "Here are some examples of declaring short strings in Cairo:"
msgstr "Berikut adalah beberapa contoh menyatakan senar pendek di Cairo:"

#: src/ch02-02-data-types.md:169 src/ch02-02-data-types.md:187
msgid "'C'"
msgstr "'C'"

#: src/ch02-02-data-types.md:175 src/ch02-02-data-types.md:193
msgid "\"this is a string which has more than 31 characters\""
msgstr "\"Ini adalah string yang memiliki lebih dari 31 karakter\""

#: src/ch02-02-data-types.md:181
msgid "Byte Array Strings"
msgstr "String Byte Array"

#: src/ch02-02-data-types.md:183
msgid ""
"With the `ByteArray` struct added in Cairo 2.4.0, you are not limited to 31 "
"characters anymore. These `ByteArray` strings are written in double quotes "
"like in the following example:"
msgstr ""
"Dengan struktur ByteArray yang ditambahkan di Cairo 2.4.0, Anda tidak "
"terbatas pada 31 karakter lagi. string ByteArray ini ditulis dalam kutipan "
"ganda seperti dalam contoh berikut:"

#: src/ch02-02-data-types.md:197
msgid "Type Casting"
msgstr "Casting Tipe"

#: src/ch02-02-data-types.md:199
msgid ""
"In Cairo, you can convert scalar types from one type to another by using the"
" `try_into` and `into` methods provided by the `TryInto` and `Into` traits "
"from the core library."
msgstr ""
"Di Cairo, Anda dapat mengubah tipe skalar dari satu jenis ke jenis lain "
"dengan menggunakan sifat-sifat dari perpustakaan utama."

#: src/ch02-02-data-types.md:201
msgid ""
"The `try_into` method allows for safe type casting when the target type "
"might not fit the source value. Keep in mind that `try_into` returns an "
"`Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""
"Metode pembongkaran jenis aman ketika tipe target mungkin tidak sesuai "
"dengan nilai sumber. Perlu diingat bahwa åtry_into mengembalikan suatu tipe "
"<T>, yang perlu Anda unwrap untuk mengakses nilai baru."

#: src/ch02-02-data-types.md:203
msgid ""
"On the other hand, the `into` method can be used for type casting when "
"success is guaranteed, such as when the source type is smaller than the "
"destination type."
msgstr ""
"Di pihak lain, metode itu dapat digunakan untuk pengecoran jenis bila "
"dipastikan sukses, misalnya sewaktu jenis sumbernya lebih kecil daripada "
"jenis tujuan."

#: src/ch02-02-data-types.md:205
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the "
"source value to cast it to another type. The new variable's type must be "
"explicitly defined, as demonstrated in the example below."
msgstr ""
"Untuk melakukan konversi, panggil "
"Ávar.into----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------"

#: src/ch02-02-data-types.md:210
msgid ""
"// Since a felt252 might not fit in a u8, we need to unwrap the Option<T> "
"type\n"
msgstr ""
"//Karena felt2252 mungkin tidak cocok dalam sebuah u8, kita perlu membuka "
"tipe Opsi<T>\n"

#: src/ch02-02-data-types.md:216
msgid "// As a felt252 is smaller than a u256, we can use the into() method\n"
msgstr ""
"//Sebagai felt2 lebih kecil dari u256, kita dapat menggunakan metodenya ke "
"susah payah)\n"

#: src/ch02-02-data-types.md:224
msgid "The Tuple Type"
msgstr "Tipe Tuples"

#: src/ch02-02-data-types.md:226
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a "
"variety of types into one compound type. Tuples have a fixed length: once "
"declared, they cannot grow or shrink in size."
msgstr ""
"Sebuah _tuple_ adalah cara umum untuk mengelompokkan sejumlah nilai dengan "
"berbagai tipe ke dalam satu tipe majemuk. Tuples memiliki panjang tetap: "
"sekali dideklarasikan, mereka tidak dapat tumbuh atau mengecilkan ukuran."

#: src/ch02-02-data-types.md:230
msgid ""
"We create a tuple by writing a comma-separated list of values inside "
"parentheses. Each position in the tuple has a type, and the types of the "
"different values in the tuple don’t have to be the same. We’ve added "
"optional type annotations in this example:"
msgstr ""
"Kami membuat tuple dengan menulis daftar nilai-nilai yang dipisahkan koma di"
" dalam tanda kurung. setiap posisi di tuple memiliki tipe, dan jenis nilai "
"yang berbeda di tuple tidak harus sama. kami telah menambahkan notasi "
"opsional dalam contoh ini:"

#: src/ch02-02-data-types.md:241
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a"
" single compound element. To get the individual values out of a tuple, we "
"can use pattern matching to destructure a tuple value, like this:"
msgstr ""
"Variabel mengikat seluruh tuple karena sebuah tuple dianggap sebagai elemen "
"senyawa tunggal. untuk mendapatkan nilai individu dari sebuah tuple, kita "
"dapat menggunakan pencocokan pola untuk mendestruktur sebuah nilai tuple, "
"seperti ini:"

#: src/ch02-02-data-types.md:252
msgid "\"y is 6!\""
msgstr "\"Y adalah 6!\""

#: src/ch02-02-data-types.md:257
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then uses a pattern with `let` to take `tup` and turn it into three separate"
" variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints `y is "
"6!` as the value of `y` is `6`."
msgstr ""
"Program ini pertama kali menciptakan sebuah tuple dan mengikatnya ke "
"variabel yang disebut _destruction_ karena itu akan menghancurkan satu tuple"
" menjadi tiga bagian. akhirnya, program mencetak 6!"

#: src/ch02-02-data-types.md:263
msgid ""
"We can also declare the tuple with value and types, and destructure it at "
"the same time. For example:"
msgstr ""
"Kita juga dapat menyatakan tuple dengan nilai dan jenis, dan destruktur itu "
"pada saat yang sama."

#: src/ch02-02-data-types.md:272
msgid "The Unit Type ()"
msgstr "Satuan Tipe ()"

#: src/ch02-02-data-types.md:274
msgid ""
"A _unit type_ is a type which has only one value `()`. It is represented by "
"a tuple with no elements. Its size is always zero, and it is guaranteed to "
"not exist in the compiled code."
msgstr ""
"Tipe _unit_ adalah sebuah tipe yang hanya memiliki satu nilai. Ini diwakili "
"oleh sebuah tuple tanpa elemen. Ukurannya selalu nol, dan dijamin tidak ada "
"dalam kode yang dikompilasi."

#: src/ch02-02-data-types.md:278
msgid ""
"You might be wondering why you would even need a unit type? In Cairo, "
"everything is an expression, and an expression that returns nothing actually"
" returns `()` implicitly."
msgstr ""
"Di Cairo, semuanya adalah ekspresi, dan ekspresi yang tidak mengembalikan "
"apapun secara implisit."

#: src/ch02-02-data-types.md:280
msgid "{{#quiz ../quizzes/ch02-02-data-types.toml}}"
msgstr "{{#quiz../quizzes/ch02-02-data-types.toml}}}"

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry"
" point of many programs. You’ve also seen the `fn` keyword, which allows you"
" to declare new functions."
msgstr ""
"Fungsi-fungsi yang umum dalam kode Cairo. Anda juga telah melihat salah satu"
" fungsi yang paling penting dalam bahasa: fungsi åmain, yang merupakan titik"
" masuk dari banyak program. Anda juga telah melihat kata kunci yang "
"memungkinkan Anda untuk menyatakan fungsi-fungsi baru."

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr ""
"Kode Cairo menggunakan kotak _ular sebagai gaya konvensional untuk nama "
"fungsi dan variabel, di mana semua huruf adalah huruf kecil dan garis bawah "
"kata-kata terpisah. Ini adalah program yang berisi definisi fungsi contoh:"

#: src/ch02-03-functions.md:14
msgid "\"Another function.\""
msgstr "\" Fungsi lain. \""

#: src/ch02-03-functions.md:18
msgid "\"Hello, world!\""
msgstr "\"Halo, dunia!\""

#: src/ch02-03-functions.md:23
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr ""
"Kami mendefinisikan sebuah fungsi di Cairo dengan memasukinya dengan "
"mengikuti sebuah nama fungsi dan satu set tanda kurung keriting mengatakan "
"pada kompiler di mana tubuh fungsi dimulai dan berakhir."

#: src/ch02-03-functions.md:27
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it"
" can be called from inside the `main` function. Note that we defined "
"`another_function` _before_ the `main` function in the source code; we could"
" have defined it after as well. Cairo doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr ""
"Kita dapat memanggil fungsi apapun yang kita definisikan dengan memasukkan "
"namanya diikuti dengan satu set tanda kurung. karena fungsi "
"lain_fungsi_fungsi lain didefinisikan dalam program ini, dapat dipanggil "
"dari dalam fungsi thoseadiro. perhatikan bahwa kita mendefinisikan satu sama"
" lain_fungsi_before_ fungsi dalam kode sumber; kita dapat mendefinisikannya "
"juga. Cairo tidak peduli di mana Anda mendefinisikan fungsi-fungsi Anda, "
"hanya mereka didefinisikan di suatu tempat yang dapat dilihat oleh si "
"pemanggil."

#: src/ch02-03-functions.md:34
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions "
"further. Place the `another_function` example in _src/lib.cairo_ and run it."
" You should see the following output:"
msgstr ""
"Mari kita mulai proyek baru dengan Scarb bernama _functions_ untuk "
"mengeksplorasi fungsi lebih lanjut. Tempatkan contoh lain_fungsi di "
"_sc/lib.cairo_ dan jalankan. Anda harus melihat keluaran berikut:"

#: src/ch02-03-functions.md:49
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the `Hello, world!` message prints, and then `another_function` is "
"called and its message is printed."
msgstr ""
"Garis-garis yang dijalankan dalam urutan di mana mereka muncul dalam fungsi "
"åmain."

#: src/ch02-03-functions.md:53
msgid "Parameters"
msgstr "Parameter"

#: src/ch02-03-functions.md:55
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you"
" can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr ""
"Kita dapat mendefinisikan fungsi untuk memiliki _parameters_, yang merupakan"
" variabel khusus yang merupakan bagian dari fungsi ·s signature. Ketika "
"sebuah fungsi memiliki parameter, Anda dapat menyediakannya dengan nilai "
"konkret untuk parameter tersebut. Secara teknis, nilai konkrit disebut "
"_arguments_, tetapi dalam percakapan santai, orang cenderung menggunakan "
"kata _parameter_ dan _argument_ secara bergantian untuk baik variabel dalam "
"fungsi \\uel definisi atau nilai beton lewat ketika Anda memanggil sebuah "
"fungsi."

#: src/ch02-03-functions.md:63
msgid "In this version of `another_function` we add a parameter:"
msgstr "Dalam versi ini dari a_function lain kita menambahkan parameter:"

#: src/ch02-03-functions.md:75
msgid "Try running this program; you should get the following output:"
msgstr "Coba jalankan program ini; Anda harus mendapat keluaran berikut:"

#: src/ch02-03-functions.md:87
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `felt252`. When we pass `5` in to `another_function`,"
" the `println!` macro puts `5` where the pair of curly brackets containing "
"`x` was in the format string."
msgstr ""
"Jenis deklarasi dari fungsi lain memiliki satu parameter yang bernama åx. "
"Jenis dari makro yang dispesifikasikan sebagai 252."

#: src/ch02-03-functions.md:91
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Cairo’s design: requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also"
" able to give more helpful error messages if it knows what types the "
"function expects."
msgstr ""
"Dalam signature fungsi, Anda _must_ menyatakan tipe dari setiap parameter. "
"Ini adalah keputusan yang disengaja di Desain Cairoås: membutuhkan tipe "
"anotasi dalam definisi fungsi berarti kompiler hampir tidak pernah "
"membutuhkan Anda untuk menggunakannya di tempat lain dalam kode untuk "
"mencari tahu tipe apa yang Anda maksud. compiler juga dapat memberikan pesan"
" kesalahan yang lebih berguna jika ia tahu jenis fungsi yang diharapkan."

#: src/ch02-03-functions.md:97
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr ""
"Ketika mendefinisikan beberapa parameter, pisahkan deklarasi parameter "
"dengan koma, seperti ini:"

#: src/ch02-03-functions.md:102
msgid "\"h\""
msgstr "\"h\""

#: src/ch02-03-functions.md:106
msgid "\"The measurement is: {value}{unit_label}\""
msgstr "Pengukuran adalah: {nilai}{unit_label}\""

#: src/ch02-03-functions.md:110
msgid ""
"This example creates a function named `print_labeled_measurement` with two "
"parameters. The first parameter is named `value` and is a `u128`. The second"
" is named `unit_label` and is of type `ByteArray` - Cairo's internal type to"
" represent string literals. The function then prints text containing both "
"the `value` and the `unit_label`."
msgstr ""
"Contoh ini menciptakan sebuah fungsi bernama enomelat_labeled_measurement) "
"dengan dua parameter. Parameter pertama dinamakan enomavalue (nilai) dan "
"merupakan sebuah ·u128. Yang kedua dinamakan æult_label) dan merupakan tipe "
"tipe dari ByteArray - Cairo's internal untuk mewakili string literal. Fungsi"
" itu kemudian mencetak teks yang berisi keduanya dan genit_label."

#: src/ch02-03-functions.md:114
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/lib.cairo_ file with the preceding example and "
"run it using `scarb cairo-run`:"
msgstr ""
"Mari kita coba menjalankan kode ini. Ganti program yang saat ini berada "
"dalam _fungsi_ projek__mu; berkas _src/lib.cairo_ dengan contoh sebelumnya "
"dan jalankan dengan cairo-run:"

#: src/ch02-03-functions.md:127
msgid ""
"Because we called the function with `5` as the value for value and `\"h\"` "
"as the value for `unit_label`, the program output contains those values."
msgstr ""
"Karena kami menyebut fungsinya dengan 0,5 sebagai nilai untuk nilai dan "
"\"h\" sebagai nilai dari program yang mengandung nilai-nilai tersebut."

#: src/ch02-03-functions.md:129
msgid "Named Parameters"
msgstr "Parameter Bernama"

#: src/ch02-03-functions.md:131
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when "
"you call a function. This makes the function calls more readable and self-"
"descriptive. If you want to use named parameters, you need to specify the "
"name of the parameter and the value you want to pass to it. The syntax is "
"`parameter_name: value`. If you pass a variable that has the same name as "
"the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""
"Di Cairo, parameter bernama memungkinkan Anda untuk menentukan nama dari "
"parameter dan nilai yang ingin Anda masukkan. Ini membuat fungsi panggilan "
"yang lebih dapat dibaca dan deskriptif. Jika Anda ingin menggunakan "
"parameter bernama, Anda hanya perlu menentukan nama parameter dan nilai yang"
" ingin Anda masukkan ke dalamnya. Sintaks adalah nilai: nilai. Jika Anda "
"melewatkan variabel yang sama dengan parameter, Anda dapat menulis "
"▪:parameter_name: variable_name."

#: src/ch02-03-functions.md:134
#: src/ch09-01-unrecoverable-errors-with-panic.md:72
#: src/ch09-02-recoverable-errors.md:141
#: src/appendix-03-derivable-traits.md:151
#: src/appendix-03-derivable-traits.md:200
msgid "Here is an example:"
msgstr "Ini contohnya:"

#: src/ch02-03-functions.md:149
msgid "Statements and Expressions"
msgstr "Pernyataan dan Pernyataan"

#: src/ch02-03-functions.md:151
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Cairo is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions,"
" so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr ""
"Fungsi tubuh terdiri dari serangkaian pernyataan yang mungkin berakhir dalam"
" sebuah ekspresi. sejauh ini, fungsi-fungsi yang kita telah meliputi belum "
"termasuk ekspresi akhir, tetapi Anda telah melihat ekspresi sebagai bagian "
"dari pernyataan. karena Cairo adalah bahasa berbasis ekspresi, ini adalah "
"perbedaan penting untuk dipahami. bahasa lain tidak memiliki perbedaan yang "
"sama, sehingga biarkan orang melihat pernyataan dan ekspresi apa dan "
"bagaimana perbedaan mereka mempengaruhi tubuh fungsi."

#: src/ch02-03-functions.md:159
msgid ""
"**Statements** are instructions that perform some action and do not return a"
" value."
msgstr ""
"**Statements** adalah instruksi yang melakukan beberapa tindakan dan tidak "
"kembali nilai."

#: src/ch02-03-functions.md:161
msgid ""
"**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr "Coba kita lihat contoh-contohnya."

#: src/ch02-03-functions.md:163
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 2-1, `let y = 6;` is a statement."
msgstr ""
"Kami sebenarnya sudah menggunakan pernyataan dan ekspresi. membuat sebuah "
"variabel dan memberikan nilai kepadanya dengan kata kunci adalah sebuah "
"pernyataan. dalam daftar 2-1, biarkan y = 6; adalah sebuah pernyataan."

#: src/ch02-03-functions.md:173
msgid ""
"<span class=\"caption\">Listing 2-1: A `main` function declaration "
"containing one statement</span>"
msgstr ""
"<span class=\"caption\">Listing 2-1: Sebuah deklarasi fungsi æmainæu berisi "
"satu pernyataan</span>"

#: src/ch02-03-functions.md:175
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself."
msgstr ""
"Definisi fungsi juga merupakan pernyataan; seluruh contoh sebelumnya adalah "
"sebuah pernyataan."

#: src/ch02-03-functions.md:177
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get"
" an error:"
msgstr ""
"Pernyataan tidak mengembalikan nilai-nilai. Oleh karena itu, Anda tidak "
"dapat menetapkan pernyataan åleté ke variabel lain, sebagai kode berikut "
"mencoba untuk melakukan; Anda akan mendapatkan kesalahan:"

#: src/ch02-03-functions.md:186
msgid "When you run this program, the error you’ll get looks like this:"
msgstr ""
"Ketika Anda menjalankan program ini, kesalahan Anda akan mendapatkan "
"terlihat seperti ini:"

#: src/ch02-03-functions.md:226
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Cairo."
msgstr ""
"Pernyataan y = 6) tidak mengembalikan nilai, sehingga tidak ada sesuatu "
"untuk diikat. ini berbeda dari apa yang terjadi dalam bahasa lain, seperti C"
" dan Ruby, di mana tugas tersebut kembali nilai dari tugas tersebut. dalam "
"bahasa-bahasa itu, Anda dapat menulis ▪x = 6; dan memiliki keduanya ·x."

#: src/ch02-03-functions.md:232
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Cairo. Consider a math operation, such as `5 + 6`, "
"which is an expression that evaluates to the value `11`. Expressions can be "
"part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is"
" an expression that evaluates to the value `6`."
msgstr ""
"Ekspresi dievaluasi ke nilai dan membentuk sebagian besar kode yang Anda "
"tulis di Cairo."

#: src/ch02-03-functions.md:238
msgid ""
"Calling a function is an expression since it always evaluates to a value: "
"the function's explicit return value, if specified, or the 'unit' type `()` "
"otherwise."
msgstr ""
"Memanggil sebuah fungsi adalah sebuah ekspresi karena selalu dievaluasi ke "
"suatu nilai: nilai kembali fungsi secara eksplisit, jika dispesifikasikan, "
"atau tipe 'unit' quot; sebaliknya."

#: src/ch02-03-functions.md:240
msgid ""
"A new scope block created with curly brackets is an expression, for example:"
msgstr ""
"Sebuah blok lingkup baru dibuat dengan braket keriting adalah ekspresi, "
"misalnya:"

#: src/ch02-03-functions.md:249
msgid "\"The value of y is: {}\""
msgstr "Nilai y adalah: {}\""

#: src/ch02-03-functions.md:253
msgid "This expression:"
msgstr "Ekspresi ini:"

#: src/ch02-03-functions.md:262
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note that the `x + 1` line doesn’t have "
"a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to"
" the end of an expression, you turn it into a statement, and it will then "
"not return a value. Keep this in mind as you explore function return values "
"and expressions next."
msgstr ""
"adalah sebuah blok yang, dalam hal ini, dievaluasi ke semikolon pada "
"akhirnya, yang tidak seperti sebagian besar baris yang Anda lihat sejauh "
"ini. ekspresi tidak termasuk akhir dari semicolon. jika Anda menambahkan "
"semikolon ke ujung ekspresi, Anda mengubahnya menjadi sebuah pernyataan, dan"
" kemudian tidak akan mengembalikan nilai. tetap pikirkan ini dalam pikiran "
"saat Anda menjelajahi fungsi kembali dan selanjutnya."

#: src/ch02-03-functions.md:270
msgid "Functions with Return Values"
msgstr "Fungsi dengan Nilai Kembali"

#: src/ch02-03-functions.md:272
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Cairo, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr ""
"Fungsi dapat mengembalikan nilai-nilai ke kode yang menyebut mereka. kita "
"tidak dapat menyebutkan nilai-nilai pengembalian nama, tapi kita harus "
"menyatakan tipe mereka setelah panah. di Cairo, nilai kembali fungsi identik"
" dengan nilai dari ekspresi akhir dalam blok dari fungsi. Anda dapat kembali"
" lebih awal dari sebuah fungsi dengan menggunakan kata kunci ▪ dan "
"menspesifikasikan nilai, tetapi kebanyakan fungsi mengembalikan ekspresi "
"terakhir secara implisit. Di sini contoh dari fungsi yang menghasilkan "
"sebuah fungsi:"

#: src/ch02-03-functions.md:291
msgid ""
"There are no function calls, or even `let` statements in the `five` "
"function—just the number `5` by itself. That’s a perfectly valid function in"
" Cairo. Note that the function’s return type is specified too, as `-> u32`. "
"Try running this code; the output should look like this:"
msgstr ""
"Tidak ada panggilan fungsi, atau bahkan pernyataan ± lima fungsi hanya "
"dengan sendirinya. itu adalah fungsi yang sangat valid di Cairo. perhatikan "
"bahwa fungsi tipe kembali juga dispesifikasikan, seperti u32. coba jalankan "
"kode ini; keluarannya harus terlihat seperti ini:"

#: src/ch02-03-functions.md:306
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `u32`. Let’s examine this in more detail. There are two important "
"bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr ""
"Ada dua bagian penting: pertama, garis x = 5); yang menunjukkan bahwa kita "
"menggunakan nilai kembali dari fungsi untuk menginisialisasi variabel. "
"karena fungsinya menghasilkan 5, garis itu sama dengan berikut:"

#: src/ch02-03-functions.md:316
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon"
" because it’s an expression whose value we want to return. Let’s look at "
"another example:"
msgstr ""
"Kedua, fungsinya tidak memiliki parameter dan mendefinisikan jenis nilai "
"kembali, tetapi tubuh fungsinya adalah kesepian dengan tanpa semikolon "
"karena itu adalah ekspresi yang nilainya ingin kita kembalikan."

#: src/ch02-03-functions.md:333
msgid ""
"Running this code will print `x = 6`. But if we place a semicolon at the end"
" of the line containing `x + 1`, changing it from an expression to a "
"statement, we’ll get an error:"
msgstr ""
"Menjalankan kode ini akan mencetak 6x = 6. tetapi jika kita menempatkan "
"titik koma di akhir baris yang mengandung ıx + 1), mengubahnya dari ekspresi"
" ke pernyataan, kita akan mendapatkan kesalahan:"

#: src/ch02-03-functions.md:349
msgid ""
"```shell\n"
"$ scarb cairo-run \n"
"   Compiling no_listing_22_function_return_invalid v0.1.0 (listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml)\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".\n"
" --> listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:9:28\n"
"fn plus_one(x: u32) -> u32 {\n"
"                           ^\n"
"\n"
"error: could not compile `no_listing_22_function_return_invalid` due to previous error\n"
"error: `scarb metadata` exited with error\n"
"\n"
"```"
msgstr ""
"Scarb cairo-run Compiling no_listing_22_function_return_invalid v0.1.0 "
"(listings/ch02-comgrammming-"
"conses/no_listing_24_function_returnd_nvalid/Scarb.toml) error: tipe kembali"
" yang tidak diharapkan. Diduga: \"core:integer:32,\" ditemukan: "
"\"no_listing/ch02_com-com-com-"
"comgrampt/concepts/no_listing_turning_turned_rection/icricricricning/clert:9:9:32\""
" -> daftar _no_conturned error:+_n_noturning:proturning: "
"-no_proturning:provenction"

#: src/ch02-03-functions.md:362
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue "
"with this code. The definition of the function `plus_one` says that it will "
"return an `u32`, but statements don’t evaluate to a value, which is "
"expressed by `()`, the unit type. Therefore, nothing is returned, which "
"contradicts the function definition and results in an error."
msgstr ""
"Pesan galat utama, tipe balasan yang tidak terduga, mengungkapkan masalah "
"inti dengan kode ini. Definisi dari fungsi ·plus_one; mengatakan bahwa ia "
"akan mengembalikan sebuah ·u32--, tetapi pernyataan tidak mengevaluasi ke "
"suatu nilai, yang dinyatakan oleh Á), tipe satuan. Oleh karena itu, tidak "
"ada yang dikembalikan, yang bertentangan dengan definisi fungsi dan hasil "
"kesalahan."

#: src/ch02-03-functions.md:368
msgid "{{#quiz ../quizzes/ch02-03-functions.toml}}"
msgstr "{{#quiz../quizzes/ch02-03-functionions.toml}}}"

#: src/ch02-04-comments.md:3
msgid ""
"All programmers strive to make their code easy to understand, but sometimes "
"extra explanation is warranted. In these cases, programmers leave comments "
"in their source code that the compiler will ignore but people reading the "
"source code may find useful."
msgstr ""
"Semua programmer berusaha untuk membuat kode mereka mudah dimengerti, tetapi"
" kadang-kadang penjelasan tambahan dijamin. Dalam kasus ini, programmer "
"meninggalkan komentar dalam kode sumber mereka bahwa kompiler akan "
"mengabaikan tetapi orang-orang membaca kode sumber mungkin menemukan "
"berguna."

#: src/ch02-04-comments.md:5
msgid "Here’s a simple comment:"
msgstr "Berikut adalah komentar sederhana:"

#: src/ch02-04-comments.md:8
msgid "// hello, world\n"
msgstr "#/ hello, world\n"

#: src/ch02-04-comments.md:11
msgid ""
"In Cairo, the idiomatic comment style starts a comment with two slashes, and"
" the comment continues until the end of the line. For comments that extend "
"beyond a single line, you’ll need to include `//` on each line, like this:"
msgstr ""
"Di Cairo, gaya komentar idimatis dimulai dengan dua slash, dan komentar "
"berlanjut sampai akhir baris. Untuk komentar yang melampaui satu baris saja,"
" Anda harus memasukkan ▪// (slash) pada setiap baris, seperti ini:"

#: src/ch02-04-comments.md:14
msgid ""
"// So we’re doing something complicated here, long enough that we need\n"
"// multiple lines of comments to do it! Whew! Hopefully, this comment will\n"
"// explain what’s going on.\n"
msgstr ""
"Jadi kita melakukan sesuatu yang rumit di sini, cukup lama bahwa kita perlu "
"beberapa baris komentar untuk melakukannya! Mudah-mudahan, komentar ini akan"
" / / / / menjelaskan apa yang terjadi.\n"

#: src/ch02-04-comments.md:19
msgid "Comments can also be placed at the end of lines containing code:"
msgstr "Komentar juga dapat ditempatkan di akhir baris yang berisi kode:"

#: src/ch02-04-comments.md:23
msgid "// return the sum of 1 and 4\n"
msgstr "# # Return the sum of 1 and 4\n"

#: src/ch02-04-comments.md:27
msgid ""
"But you’ll more often see them used in this format, with the comment on a "
"separate line above the code it’s annotating:"
msgstr ""
"Tapi Anda akan lebih sering melihat mereka digunakan dalam format ini, "
"dengan komentar pada baris yang terpisah di atas kode itu menganotasi:"

#: src/ch02-04-comments.md:31
msgid "// this function performs a simple addition\n"
msgstr "//fungsi ini melakukan penambahan sederhana\n"

#: src/ch02-04-comments.md:36
msgid "Item-level Documentation"
msgstr "Dokumentasi Tingkat Butir"

#: src/ch02-04-comments.md:38
msgid ""
"Item-level documentation comments refer to specific items such as functions,"
" implementations, traits, etc. They are prefixed with three slashes (`///`)."
" These comments provide a detailed description of the item, examples of "
"usage, and any conditions that might cause a panic. In case of functions, "
"the comments may also include separate sections for parameter and return "
"value descriptions."
msgstr ""
"Komentar dokumentasi tingkat- ltem mengacu ke item spesifik seperti fungsi, "
"implementasi, sifat, dll. Mereka diprefiks dengan tiga garis miring. "
"Komentar ini memberikan deskripsi rinci dari item, contoh penggunaan, dan "
"kondisi apapun yang mungkin menyebabkan panik. Dalam kasus fungsi, komentar "
"mungkin juga termasuk bagian terpisah untuk parameter dan deskripsi nilai "
"kembali."

#: src/ch02-04-comments.md:41
msgid ""
"/// Returns the sum of `arg1` and `arg2`.\n"
"/// `arg1` cannot be zero.\n"
"///\n"
"/// # Panics\n"
"///\n"
"/// This function will panic if `arg1` is `0`.\n"
"///\n"
"/// # Examples\n"
"///\n"
"/// ```\n"
"/// let a: felt252 = 2;\n"
"/// let b: felt252 = 3;\n"
"/// let c: felt252 = add(a, b);\n"
"/// assert(c == a + b, \"Should equal a + b\");\n"
"/// ```\n"
msgstr ""
"///Kembalikan jumlah ·arg1) dan ·arg2. //// ·arg1) tidak dapat berupa nol. "
"///////////// # Paniks ////////// Ini fungsi akan panik jika Árg1. "
"///////////# Contoh/////// ///////// / biarkan satu:25 = 2; //bi/bi/biarkan "
"felt2 = 3; /////biarkan c: 25 = 25 = 2 = b); // / / / / //ccc disc == a alc "
"== a - alsoc + / b / / / / o)\n"

#: src/ch02-04-comments.md:62
msgid "Module Documentation"
msgstr "Dokumentasi Modul"

#: src/ch02-04-comments.md:64
msgid ""
"Module documentation comments provide an overview of the entire module, "
"including its purpose and examples of use. These comments are meant to be "
"placed above the module they're describing and are prefixed with `//!`. This"
" type of documentation gives a broad understanding of what the module does "
"and how it can be used."
msgstr ""
"Komentar dokumentasi modul menyediakan tinjauan seluruh modul, termasuk "
"tujuan dan contoh penggunaannya. Komentar-komentar ini dimaksudkan untuk "
"ditempatkan di atas modul yang mereka gambarkan dan diprefiks dengan ▪//!! "
"Tipe dokumentasi ini memberikan pemahaman luas tentang apa yang modul "
"lakukan dan bagaimana ia dapat digunakan."

#: src/ch02-04-comments.md:67
msgid ""
"//! # my_module and implementation\n"
"//!\n"
"//! This is an example description of my_module and some of its features.\n"
"//!\n"
"//! # Examples\n"
"//!\n"
"//! ```\n"
"//! mod my_other_module {\n"
"//!   use path::to::my_module;\n"
"//!\n"
"//!   fn foo() {\n"
"//!     my_module.bar();\n"
"//!   }\n"
"//! }\n"
"//! ```\n"
msgstr ""
"//! # my_module and implementation //! This is an example deskripsi dari "
"my_module and some of mys featurs. /! /! # Excess // //! /! /! Module.bar); "
"/!\n"

#: src/ch02-04-comments.md:82
msgid "// rest of implementation...\n"
msgstr "#/ rest of implementasi...\n"

#: src/ch02-04-comments.md:86
msgid "{{#quiz ../quizzes/ch02-04-comments.toml}}"
msgstr "{{#quiz../quizzes/ch02-04-comments.toml}}}"

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to"
" run some code repeatedly while a condition is true are basic building "
"blocks in most programming languages. The most common constructs that let "
"you control the flow of execution of Cairo code are if expressions and "
"loops."
msgstr ""
"Kemampuan untuk menjalankan beberapa kode tergantung pada apakah sebuah "
"kondisi benar dan untuk menjalankan beberapa kode berulang-ulang sementara "
"kondisi benar adalah blok bangunan dasar dalam bahasa pemrograman. konstruk "
"yang paling umum yang memungkinkan Anda mengendalikan aliran kode eksekusi "
"Cairo adalah jika ekspresi dan loop."

#: src/ch02-05-control-flow.md:5
msgid "`if` Expressions"
msgstr "Jika pernyataan itu memang benar."

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You"
" provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr ""
"Jika ekspresi memungkinkan anda untuk mencabangkan kode anda tergantung pada"
" kondisi. anda memberikan kondisi dan kemudian keadaan, jika kondisi ini "
"dipenuhi, jalankan blok kode ini. Jika kondisi tidak dipenuhi, jangan "
"jalankan blok kode ini."

#: src/ch02-05-control-flow.md:9
msgid ""
"Create a new project called _branches_ in your _cairo_projects_ directory to"
" explore the `if` expression. In the _src/lib.cairo_ file, input the "
"following:"
msgstr ""
"Buat projek baru yang disebut _branches_ dalam direktori _cairo_projects_ "
"anda untuk mengeksplorasi ekspresi ▪iftó. Dalam berkas _src/lib.cairo_, "
"masukan berikut:"

#: src/ch02-05-control-flow.md:16
msgid "\"condition was true and number = {}\""
msgstr "\"kondisi benar dan nomor = {}\""

#: src/ch02-05-control-flow.md:18
msgid "\"condition was false and number = {}\""
msgstr "\"kondisi adalah salah dan nomor = {}\""

#: src/ch02-05-control-flow.md:23
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value equal to 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets."
msgstr ""
"Semua ekspresi dimulai dengan kata kunci jika diikuti dengan sebuah kondisi."
" dalam hal ini, kondisi memeriksa apakah variabelnya memiliki nilai sama "
"dengan 5. kita menempatkan blok kode untuk mengeksekusi jika kondisi ini "
"benar-benar benar segera setelah kondisi dalam kurung keriting."

#: src/ch02-05-control-flow.md:25
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the"
" condition evaluate to `false`. If you don’t provide an `else` expression "
"and the condition is `false`, the program will just skip the `if` block and "
"move on to the next bit of code."
msgstr ""
"Sebaliknya, kita juga dapat menyertakan sebuah ekspresi æelse, yang kita "
"pilih untuk melakukan di sini, untuk memberikan program blok alternatif kode"
" untuk mengeksekusi kondisi yang akan dievaluasi ke Áfalse."

#: src/ch02-05-control-flow.md:27
msgid "Try running this code; you should see the following output:"
msgstr "Coba jalankan kode ini; Anda harus melihat keluaran berikut:"

#: src/ch02-05-control-flow.md:39
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition"
" `true` to see what happens:"
msgstr ""
"Mari kita coba mengubah nilai angka menjadi nilai yang membuat kondisi "
"menjadi benar untuk melihat apa yang terjadi:"

#: src/ch02-05-control-flow.md:51
msgid ""
"It’s also worth noting that the condition in this code must be a `bool`. If "
"the condition isn’t a `bool`, we’ll get an error. For example, try running "
"the following code:"
msgstr ""
"Ini juga layak dicatat bahwa kondisi dalam kode ini harus menjadi sebuah "
"°bool."

#: src/ch02-05-control-flow.md:58
msgid "\"number was three\""
msgstr "\"Nomornya tiga\""

#: src/ch02-05-control-flow.md:63
msgid ""
"The `if` condition evaluates to a value of 3 this time, and Cairo throws an "
"error:"
msgstr ""
"Kondisi evaluasi pada nilai 3 kali ini, dan Cairo melakukan kesalahan:"

#: src/ch02-05-control-flow.md:77
msgid ""
"The error indicates that Cairo inferred the type of `number` to be a `bool` "
"based on its later use as a condition of the `if` statement. It tries to "
"create a `bool` from the value `3`, but Cairo doesn't support instantiating "
"a `bool` from a numeric literal anyway - you can only use `true` or `false` "
"to create a `bool`. Unlike languages such as Ruby and JavaScript, Cairo will"
" not automatically try to convert non-Boolean types to a Boolean. If we want"
" the `if` code block to run only when a number is not equal to 0, for "
"example, we can change the if expression to the following:"
msgstr ""
"Kesalahan tersebut menunjukkan bahwa Cairo inferred tipe nomor ·bool) yang "
"merupakan tipe dari nilai tersebut, namun Cairo tidak mendukung "
"pengkonversian dari sebuah numerik literal pula - Anda hanya dapat "
"menggunakan kode yang benar atau salah untuk membuat sebuah foil. Tidak "
"seperti bahasa seperti Ruby dan JavaScript, Cairo tidak akan secara otomatis"
" mencoba untuk mengubah tipe bukan Boole ke Booan. Jika kita hanya ingin "
"menggunakan blok kode yang benar atau tidak benar, jika kita dapat mengubah "
"sebuah ekspresi sebagai contoh 0, jika kita dapat mengubah kata tersebut:"

#: src/ch02-05-control-flow.md:91
msgid "\"number was something other than zero\""
msgstr "\"Nomor adalah sesuatu yang lain dari nol\""

#: src/ch02-05-control-flow.md:97
msgid "Running this code will print `number was something other than zero`."
msgstr ""
"Menjalankan kode ini akan mencetak nomor adalah sesuatu yang lain dari nol."

#: src/ch02-05-control-flow.md:99
msgid "Handling Multiple Conditions with `else if`"
msgstr "Menangani Beragam Kondisi dengan sel jika"

#: src/ch02-05-control-flow.md:101
msgid ""
"You can use multiple conditions by combining `if` and `else` in an `else if`"
" expression. For example:"
msgstr "Anda dapat menggunakan beberapa kondisi dengan menggabungkannya."

#: src/ch02-05-control-flow.md:108
msgid "\"number is 12\""
msgstr "\"Nomornya 12\""

#: src/ch02-05-control-flow.md:110
msgid "\"number is 3\""
msgstr "\"Nomor adalah 3\""

#: src/ch02-05-control-flow.md:112
msgid "\"number minus 2 is 1\""
msgstr "\"Nomor minus 2 adalah 1\""

#: src/ch02-05-control-flow.md:114
msgid "\"number not found\""
msgstr "\"Nomor tidak ditemukan\""

#: src/ch02-05-control-flow.md:119
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr ""
"Program ini memiliki empat kemungkinan jalan yang dapat diambil. Setelah "
"menjalankannya, Anda harus melihat keluaran berikut:"

#: src/ch02-05-control-flow.md:131
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1` nor do we see the `number not found` text from the "
"`else` block. That’s because Cairo only executes the block for the first "
"true condition, and once it finds one, it doesn’t even check the rest. Using"
" too many `else if` expressions can clutter your code, so if you have more "
"than one, you might want to refactor your code. [Chapter 6](./ch06-02-the-"
"match-control-flow-construct.md) describes a powerful Cairo branching "
"construct called `match` for these cases."
msgstr ""
"Ketika program ini dijalankan, ia memeriksa setiap ekspresi di gilirannya "
"dan mengeksekusi tubuh pertama yang dievaluasi ke blok ·else. Perlu dicatat "
"bahwa meskipun nomor tersebut - 2 - 1 (1) benar-benar benar-benar adalah 1),"
" kita tidak melihat keluaran -2 adalah 1) juga tidak melihat jumlah teks "
"yang tidak ditemukan dalam blok ·else. Itu karena Cairo hanya menjalankan "
"blok untuk kondisi yang benar, dan sekali ia menemukan satu, ia bahkan tidak"
" memeriksa sisanya. menggunakan terlalu banyak ekspresi jika Anda tidak "
"menemukan kode, sehingga Anda mungkin memiliki kode yang lebih dari satu, "
"atau mungkin Anda ingin kode."

#: src/ch02-05-control-flow.md:135
msgid "Using `if` in a `let` Statement"
msgstr "Menggunakan kata 'if' dalam sebuah 'erjanjian'."

#: src/ch02-05-control-flow.md:137
msgid ""
"Because `if` is an expression, we can use it on the right side of a `let` "
"statement to assign the outcome to a variable."
msgstr ""
"Karena jika itu ungkapan, kita bisa menggunakannya di sisi kanan dari "
"pernyataan untuk menetapkan hasilnya pada variabel."

#: src/ch02-05-control-flow.md:149
msgid "\"condition was true and number is {}\""
msgstr "\"kondisi itu benar dan nomor adalah {}\""

#: src/ch02-05-control-flow.md:164
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression, which will be 5 here."
msgstr ""
"Variabel bernomor akan terikat pada nilai berdasarkan hasil dari ekspresi "
"irfa, yang akan menjadi 5 di sini."

#: src/ch02-05-control-flow.md:166
msgid "Repetition with Loops"
msgstr "Pengulangan dengan Loops"

#: src/ch02-05-control-flow.md:168
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Cairo provides a simple loop syntax, which will run through the code inside "
"the loop body to the end and then start immediately back at the beginning. "
"To experiment with loops, let’s create a new project called _loops_."
msgstr ""
"Untuk tugas ini, Cairo menyediakan sintaks loop sederhana, yang akan "
"berjalan melalui kode dalam tubuh loop ke akhir dan kemudian mulai segera "
"kembali di awal. Untuk bereksperimen dengan loop, biarkan mereka membuat "
"proyek baru yang disebut _loops_."

#: src/ch02-05-control-flow.md:170
msgid "Cairo has two kinds of loops: `loop` and `while`."
msgstr "Cairo memiliki dua jenis loop: vulopé dan sementara itu."

#: src/ch02-05-control-flow.md:172
msgid "Repeating Code with `loop`"
msgstr "Kode Pengulangan dengan ortexloop"

#: src/ch02-05-control-flow.md:174
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over "
"again forever or until you explicitly tell it to stop."
msgstr ""
"Kata kuncinya memberitahu Cairo untuk menjalankan satu blok kode lagi dan "
"lagi selamanya atau sampai Anda secara eksplisit menyuruhnya untuk berhenti."

#: src/ch02-05-control-flow.md:176
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to "
"look like this:"
msgstr ""
"Sebagai contoh, ubah berkas _src/lib.cairo_ dalam direktori _loops_ Anda "
"agar terlihat seperti ini:"

#: src/ch02-05-control-flow.md:181
msgid "\"again!\""
msgstr "\"lagi!\""

#: src/ch02-05-control-flow.md:189
msgid ""
"Note: This program would not compile without a break condition. For the "
"purpose of the example, we added a `break` statement that will never be "
"reached, but satisfies the compiler."
msgstr "Catatan: Program ini tidak akan dikompilasi tanpa kondisi yang rusak."

#: src/ch02-05-control-flow.md:191
msgid ""
"When we run this program, we’ll see `again!` printed over and over "
"continuously until either the program runs out of gas or we stop the program"
" manually. Most terminals support the keyboard shortcut ctrl-c to interrupt "
"a program that is stuck in a continual loop. Give it a try:"
msgstr ""
"Ketika kita menjalankan program ini, kita akan melihat lagi! dicetak "
"berulang-ulang sampai program kehabisan gas atau kita menghentikan program "
"secara manual. sebagian besar terminal mendukung jalan pintas papan ketik "
"ctrl-c untuk mengganggu program yang terjebak dalam loop terus-menerus."

#: src/ch02-05-control-flow.md:193
msgid ""
"```shell\n"
"$ scarb cairo-run --available-gas=20000000\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished release target(s) in 0 seconds\n"
"     Running loops\n"
"again!\n"
"again!\n"
"again!\n"
"^Cagain!\n"
"```"
msgstr ""
"Scarb cairo-run --available-gas=20000 Compiling loop v0.1.0 "
"(file:///projects/loops) Selesai rilis target 106s) dalam 0 detik Berjalan "
"loop lagi! lagi! ^C again!"

#: src/ch02-05-control-flow.md:204
msgid ""
"The symbol `^C` represents where you pressed ctrl-c. You may or may not see "
"the word `again!` printed after the ^C, depending on where the code was in "
"the loop when it received the interrupt signal."
msgstr ""
"Simbol ini mewakili dimana Anda menekan ctrl-c. Anda mungkin atau mungkin "
"tidak melihat kata tersebut lagi! dicetak setelah ^C, tergantung di mana "
"kode berada dalam loop ketika menerima sinyal interupsi."

#: src/ch02-05-control-flow.md:206
msgid ""
"Note: Cairo prevents us from running program with infinite loops by "
"including a gas meter. The gas meter is a mechanism that limits the amount "
"of computation that can be done in a program. By setting a value to the "
"`--available-gas` flag, we can set the maximum amount of gas available to "
"the program. Gas is a unit of measurement that expresses the computation "
"cost of an instruction. When the gas meter runs out, the program will stop. "
"In the previous case, we set the gas limit high enough for the program to "
"run for quite some time."
msgstr ""
"Cairo mencegah kita dari menjalankan program dengan putaran yang tak "
"terbatas dengan termasuk meteran gas. meteran gas adalah mekanisme yang "
"membatasi jumlah komputasi yang dapat dilakukan dalam sebuah program. dengan"
" menetapkan nilai untuk program tersebut - tersedia-gas yang dapat digunakan"
" dengan flag, kita dapat mengatur jumlah maksimum gas yang tersedia untuk "
"program tersebut. Gas adalah unit pengukuran yang mengekspresikan biaya "
"komputasi dari instruksi. ketika meteran gas berjalan keluar, program akan "
"berhenti. Dalam kasus sebelumnya, kami mengatur batas gas yang cukup tinggi "
"untuk program untuk berjalan selama beberapa waktu."

#: src/ch02-05-control-flow.md:208
msgid ""
"It is particularly important in the context of smart contracts deployed on "
"Starknet, as it prevents from running infinite loops on the network. If "
"you're writing a program that needs to run a loop, you will need to execute "
"it with the `--available-gas` flag set to a value that is large enough to "
"run the program."
msgstr ""
"Hal ini sangat penting dalam konteks kontrak cerdas dikerahkan di Starknet, "
"karena hal itu mencegah dari menjalankan loop yang tak terbatas pada "
"jaringan. jika Anda menulis sebuah program yang perlu menjalankan sebuah "
"loop, Anda harus melaksanakannya dengan those--available-gas-mount ke nilai "
"yang cukup besar untuk menjalankan program."

#: src/ch02-05-control-flow.md:211
msgid ""
"Now, try running the same program again, but this time with the "
"`--available-gas` flag set to `200000` instead of `2000000000000`. You will "
"see the program only prints `again!` 3 times before it stops, as it ran out "
"of gas to keep executing the loop."
msgstr ""
"Sekarang, coba jalankan program yang sama lagi, tapi kali ini dengan - "
"tersedia-gas yang diatur menjadi 200,000,000, bukan 00.000. Anda akan "
"melihat program hanya mencetak lagi! 3 kali sebelum berhenti, karena "
"kehabisan gas untuk tetap mengeksekusi loop."

#: src/ch02-05-control-flow.md:213
msgid ""
"Fortunately, Cairo also provides a way to break out of a loop using code. "
"You can place the `break` keyword within the loop to tell the program when "
"to stop executing the loop."
msgstr ""
"Untungnya, Cairo juga menyediakan cara untuk keluar dari loop menggunakan "
"kode. Anda dapat menempatkan kata kunci dalam loop untuk memberitahu program"
" ketika untuk berhenti mengeksekusi loop."

#: src/ch02-05-control-flow.md:222 src/ch02-05-control-flow.md:242
msgid "\"i = {}\""
msgstr "\"i = {}\""

#: src/ch02-05-control-flow.md:228
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the "
"loop and to skip the rest of the code in this iteration. Let's add a "
"`continue` statement to our loop to skip the `println!` statement when `i` "
"is equal to `5`."
msgstr ""
"Kata kunci yang diteruskan mengatakan kepada program untuk pergi ke iterasi "
"berikutnya dari loop dan untuk melewatkan sisa kode dalam iterasi ini."

#: src/ch02-05-control-flow.md:248
msgid ""
"Executing this program will not print the value of `i` when it is equal to "
"`5`."
msgstr ""
"Mengeksekusi program ini tidak akan mencetak nilai dari ▪i· ketika sama "
"dengan 5."

#: src/ch02-05-control-flow.md:250
msgid "Returning Values from Loops"
msgstr "Nilai Kembali dari Loops"

#: src/ch02-05-control-flow.md:252
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such as checking whether an operation has succeeded. You might also need to "
"pass the result of that operation out of the loop to the rest of your code. "
"To do this, you can add the value you want returned after the `break` "
"expression you use to stop the loop; that value will be returned out of the "
"loop so you can use it, as shown here:"
msgstr ""
"Salah satu dari penggunaan sebuah oopé adalah untuk mencoba ulang operasi "
"yang Anda tahu mungkin gagal, seperti memeriksa apakah operasi telah "
"berhasil. Anda mungkin juga perlu untuk melewatkan hasil dari operasi yang "
"keluar dari loop ke sisa kode Anda. Untuk melakukan ini, Anda dapat "
"menambahkan nilai yang Anda inginkan kembali setelah ekspresi istirahat yang"
" Anda gunakan untuk menghentikan loop, bahwa nilai akan dikembalikan keluar "
"dari loop sehingga Anda dapat menggunakannya, seperti yang ditunjukkan di "
"sini:"

#: src/ch02-05-control-flow.md:270
msgid "\"The result is {}\""
msgstr "\"Hasilnya adalah [}\""

#: src/ch02-05-control-flow.md:274
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to "
"`0`. Then we declare a variable named `result` to hold the value returned "
"from the loop. On every iteration of the loop, we check whether the "
"`counter` is equal to `10`, and then add `1` to the `counter` variable. When"
" the condition is met, we use the `break` keyword with the value `counter * "
"2`. After the loop, we use a semicolon to end the statement that assigns the"
" value to `result`. Finally, we print the value in `result`, which in this "
"case is `20`."
msgstr ""
"Sebelum putaran itu, kami menyatakan sebuah variabel yang dinamai \\ "
"Ncounter, dan menginisialisasinya menjadi 0;0; kemudian kami menyatakan "
"sebuah variabel bernama ·result. untuk mempertahankan nilai tersebut kembali"
" dari loop. pada setiap pengulangan loop, kami memeriksa apakah angka "
"tersebut sama dengan 0.0.0.0.0.00, dan kemudian menambahkan variabel "
"tersebut ke variabel 0.1; ketika kondisi itu terpenuhi, kita menggunakan "
"kata kunci dengan nilai 2. Setelah putaran, kita menggunakan sebuah "
"semicolon untuk mengakhiri pernyataan yang memberikan nilai yang menunjuk ke"
" angkaults, akhirnya kita mencetak dalam kasus ini."

#: src/ch02-05-control-flow.md:281
msgid "Conditional Loops with `while`"
msgstr "Kondisional Loops dengan ıwhile"

#: src/ch02-05-control-flow.md:283
msgid ""
"A program will often need to evaluate a condition within a loop. While the "
"condition is `true`, the loop runs. When the condition ceases to be `true`, "
"the program calls `break`, stopping the loop. It’s possible to implement "
"behavior like this using a combination of `loop`, `if`, `else`, and `break`;"
" you could try that now in a program, if you’d like. However, this pattern "
"is so common that Cairo has a built-in language construct for it, called a "
"`while` loop."
msgstr ""
"Sebuah program akan sering perlu untuk mengevaluasi sebuah kondisi dalam "
"sebuah putaran. sementara kondisi ini benar-benar berjalan. ketika kondisi "
"itu berhenti untuk menjadi benar-benar benar, program memanggil kita untuk "
"menghentikan putaran. namun, pola ini adalah umum bahwa Cairo memiliki "
"sebuah struktur bahasa yang dibangun untuk itu, disebut loop ·else."

#: src/ch02-05-control-flow.md:289
msgid ""
"In Listing 2-2, we use `while` to loop the program three times, counting "
"down each time after printing the value of `number`, and then, after the "
"loop, print a message and exit."
msgstr ""
"Dalam Listing 2-2, kita menggunakan Á while to loop the program three time, "
"menghitung mundur setiap kali setelah mencetak nilai dari nomor æa, dan "
"kemudian, setelah loop, mencetak pesan dan keluar."

#: src/ch02-05-control-flow.md:296
msgid "\"{number}!\""
msgstr "\"{number}\""

#: src/ch02-05-control-flow.md:300
msgid "\"LIFTOFF!!!\""
msgstr "\"LIFTOFF!!\""

#: src/ch02-05-control-flow.md:304
msgid ""
"<span class=\"caption\">Listing 2-2: Using a `while` loop to run code while "
"a condition holds `true`.</span>"
msgstr ""
"<span class=\"caption\">Listing 2-2: Menggunakan loop yang sedang digunakan "
"untuk menjalankan kode sementara sebuah kondisi memegang benar.</span>"

#: src/ch02-05-control-flow.md:306
msgid ""
"This construct eliminates a lot of nesting that would be necessary if you "
"used `loop`, `if`, `else`, and `break`, and it’s clearer. While a condition "
"evaluates to `true`, the code runs; otherwise, it exits the loop."
msgstr ""
"Pembangunan ini akan menghilangkan banyak sarang yang diperlukan jika Anda "
"menggunakan ·loope, jika tidak, dan kemudian keluar dari lingkaran."

#: src/ch02-05-control-flow.md:309
msgid "{{#quiz ../quizzes/ch02-05-control-flow.toml}}"
msgstr "{{#quiz../quizzes/ch02-05-control-flow.toml}}"

#: src/ch02-05-control-flow.md:313
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data "
"types, functions, comments, `if` expressions and loops! To practice with the"
" concepts discussed in this chapter, try building programs to do the "
"following:"
msgstr ""
"Anda berhasil! Ini adalah bab yang cukup besar: Anda belajar tentang "
"variabel, tipe data, fungsi, komentar, ekspresi dan loop! untuk berlatih "
"dengan konsep yang dibahas di bab ini, cobalah membuat program untuk "
"melakukan hal berikut:"

#: src/ch02-05-control-flow.md:317
msgid "Generate the _n_\\-th Fibonacci number."
msgstr "Hasilkan nomor Fibonacci."

#: src/ch02-05-control-flow.md:318
msgid "Compute the factorial of a number _n_."
msgstr "Hitung faktorial dari sebuah nomor _n_."

#: src/ch02-05-control-flow.md:320
msgid ""
"Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr "Sekarang, kita akan meninjau koleksi umum di Cairo di bab berikutnya."

#: src/ch03-00-common-collections.md
msgid ""
"Cairo provides a set of common collection types that can be used to store "
"and manipulate data. These collections are designed to be efficient, "
"flexible, and easy to use. This section introduces the primary collection "
"types available in Cairo: Arrays and Dictionaries."
msgstr ""
"Cairo menyediakan sekumpulan jenis koleksi umum yang dapat digunakan untuk "
"menyimpan dan memanipulasi data. Koleksi ini dirancang untuk menjadi "
"efisien, fleksibel, dan mudah digunakan. Bagian ini memperkenalkan jenis "
"koleksi utama yang tersedia di Cairo: Array dan Diactionaries."

#: src/ch03-01-arrays.md:3
msgid ""
"An array is a collection of elements of the same type. You can create and "
"use array methods by using the `ArrayTrait` trait from the core library."
msgstr ""
"Array adalah kumpulan elemen dari jenis yang sama Anda dapat membuat dan "
"menggunakan metode array dengan menggunakan sifat arrayTrait dari "
"perpustakaan inti."

#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modification options."
" Arrays are, in fact, queues whose values can't be modified. This has to do "
"with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of "
"an array and remove items from the front."
msgstr ""
"Sebuah hal penting untuk dicatat adalah bahwa array memiliki pilihan "
"modifikasi terbatas. Array adalah, pada kenyataannya, antrian yang nilai-"
"nilainya tidak dapat dimodifikasi. Ini berhubungan dengan fakta bahwa sekali"
" sebuah slot memori ditulis, tidak dapat ditulis ulang, tetapi hanya dibaca "
"dari itu. Anda hanya dapat menambahkan item ke akhir array dan menghapus "
"item dari depan."

#: src/ch03-01-arrays.md:8
msgid "Creating an Array"
msgstr "Membuat Larik"

#: src/ch03-01-arrays.md:10
msgid ""
"Creating an array is done with the `ArrayTrait::new()` call. Here's an "
"example of creating an array and appending 3 elements to it::"
msgstr ""
"Membuat sebuah array yang dibuat dengan arrayTrait:: panggilan baru (baru). "
"ini adalah contoh dari membuat sebuah array dan menambahkan 3 elemen:"

#: src/ch03-01-arrays.md:21
msgid ""
"When required, you can pass the expected type of items inside the array when"
" instantiating the array like this, or explicitly define the type of the "
"variable."
msgstr ""
"Bila diperlukan, Anda dapat melewatkan jenis item yang diharapkan di dalam "
"array ketika mengaktifkan array seperti ini, atau secara eksplisit "
"mendefinisikan tipe variabel."

#: src/ch03-01-arrays.md:31
msgid "Updating an Array"
msgstr "Memperbarui Sebuah Larik"

#: src/ch03-01-arrays.md:33
msgid "Adding Elements"
msgstr "Menambahkan Elemen"

#: src/ch03-01-arrays.md:35
msgid ""
"To add an element to the end of an array, you can use the `append()` method:"
msgstr ""
"Untuk menambahkan elemen ke ujung sebuah array, Anda dapat menggunakan "
"metode ·append Allah):"

#: src/ch03-01-arrays.md:46
msgid "Removing Elements"
msgstr "Elemen Penghapusan"

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the "
"`pop_front()` method. This method returns an `Option` that can be unwrapped,"
" containing the removed element, or `Option::None` if the array is empty."
msgstr ""
"Anda hanya dapat menghapus elemen dari suatu array dengan menggunakan metode"
" åpop_frontáne). Metode ini akan mengembalikan sebuah opsi yang dapat "
"dibuka, yang berisi elemen yang dihapus, atau opsi:: Tidak ada jika susunan "
"kosong."

#: src/ch03-01-arrays.md:59
msgid "\"The first value is {}\""
msgstr "\" Nilai pertama adalah {}\""

#: src/ch03-01-arrays.md:63
msgid ""
"The above code will print `The first value is 10` as we remove the first "
"element that was added."
msgstr ""
"Kode di atas akan mencetak nilai pertama adalah 10. Ketika kita menghapus "
"elemen pertama yang ditambahkan."

#: src/ch03-01-arrays.md:65
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify"
" the elements of an array once they've been added. You can only add elements"
" to the end of an array and remove elements from the front of an array. "
"These operations do not require memory mutation, as they involve updating "
"pointers rather than directly modifying the memory cells."
msgstr ""
"Di Cairo, memori tidak dapat berubah, yang berarti bahwa tidak mungkin untuk"
" mengubah elemen dari sebuah array setelah mereka telah ditambahkan. Anda "
"hanya dapat menambahkan elemen ke akhir dari sebuah array dan menghapus "
"elemen dari depan sebuah array. Operasi ini tidak memerlukan mutasi memori, "
"karena mereka melibatkan pemutakhiran pointer daripada secara langsung "
"mengubah sel memori."

#: src/ch03-01-arrays.md:67
msgid "Reading Elements from an Array"
msgstr "Membaca Elemen dari Array"

#: src/ch03-01-arrays.md:69
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that "
"return different types. Using `arr.at(index)` is equivalent to using the "
"subscripting operator `arr[index]`."
msgstr ""
"Untuk mengakses elemen array, Anda dapat menggunakan æget®) atau metode "
"array yang mengembalikan jenis yang berbeda. Menggunakan ·arrrr.at "
"1932index) adalah setara dengan menggunakan operator subscripting [erdex]."

#: src/ch03-01-arrays.md:71
msgid "`get()` Method"
msgstr "Metode ågetó)"

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an "
"option to a Box type (Cairo's smart-pointer type) containing a snapshot to "
"the element at the specified index if that element exists in the array. If "
"the element doesn't exist, `get` returns `None`. This method is useful when "
"you expect to access indices that may not be within the array's bounds and "
"want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [\"References and "
"Snapshots\"](./ch04-02-references-and-snapshots.md#snapshots) chapter."
msgstr ""
"Fungsinya kembali ke tipe cerdas (Tipe penunjukCairo) berisi snapshot ke "
"elemen pada indeks yang ditentukan jika elemen itu ada dalam susunan. Jika "
"elemen tidak ada, maka pilihan tersebut kembali ke tipe Kotak (Cairo). "
"Metode ini berguna ketika Anda menduga untuk mengakses indicses yang mungkin"
" tidak berada dalam batas jangkauan array dan ingin menangani kasus tersebut"
" secara anggun tanpa panik. Snapshots akan dijelaskan dalam rincian lebih "
"lanjut dalam [\"References\" dan Snaps]."

#: src/ch03-01-arrays.md:75
msgid "Here is an example with the `get()` method:"
msgstr "Berikut ini adalah sebuah contoh dengan metode ågetó):"

#: src/ch03-01-arrays.md:82
msgid ""
"// Change this value to see different results, what would happen if the "
"index doesn't exist?\n"
msgstr ""
"//Ubah nilai ini untuk melihat hasil yang berbeda, apa yang akan terjadi "
"jika indeks tidak ada?\n"

#: src/ch03-01-arrays.md:86
msgid ""
"// Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator\n"
"        // It basically means \"transform what get(idx) returned into a real value\"\n"
msgstr ""
"//Jangan khawatir tentang * untuk saat ini, jika anda penasaran lihat Bab "
"4.2 #desnap operator / / Ini pada dasarnya berarti \"transform apa yang "
"mendapatkan algoidx) dikembalikan ke nilai riil\"\n"

#: src/ch03-01-arrays.md:89
msgid "\"out of bounds\""
msgstr "\"di luar batas\""

#: src/ch03-01-arrays.md:96
msgid "`at()` Method"
msgstr "(Metode) Metode"

#: src/ch03-01-arrays.md:98
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the "
"element at the specified index using the `unbox()` operator to extract the "
"value stored in a box. If the index is out of bounds, a panic error occurs. "
"You should only use `at` when you want the program to panic if the provided "
"index is out of the array's bounds, which can prevent unexpected behavior."
msgstr ""
"Di sisi lain, fungsi åunbox) digunakan untuk mengekstrak nilai yang "
"tersimpan di dalam kotak. Jika indeks berada di luar batas, kesalahan panik "
"terjadi. Anda seharusnya hanya menggunakan indeks yang dispesifikasikan pada"
" saat Anda ingin program tersebut panik jika indeks yang diberikan berada di"
" luar batas, yang dapat mencegah perilaku yang tidak terduga."

#: src/ch03-01-arrays.md:100
msgid "Here is an example with the `at()` method:"
msgstr "Berikut ini adalah contoh dari metode tersebut:"

#: src/ch03-01-arrays.md:113
msgid ""
"In this example, the variable named `first` will get the value `0` because "
"that is the value at index `0` in the array. The variable named `second` "
"will get the value `1` from index `1` in the array."
msgstr ""
"Dalam contoh ini, variabel yang disebut pertama akan mendapatkan nilai "
"karena itu adalah nilai dari indeks dalam susunan."

#: src/ch03-01-arrays.md:117
msgid ""
"If you want to use the subscripting operator `arr[index]`, you will need to "
"explicitly define the type of the elements of the array, otherwise it will "
"not compile. For example:"
msgstr ""
"Jika Anda ingin menggunakan operator subscripting åarr[index], Anda perlu "
"secara eksplisit mendefinisikan tipe elemen dari array, jika tidak, ini "
"tidak akan dikompilasi. Sebagai contoh:"

#: src/ch03-01-arrays.md:130
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access "
"attempts, and use `get` when you prefer to handle such cases gracefully "
"without panicking."
msgstr ""
"Ringkasnya, gunakan åatété ketika Anda ingin panik pada percobaan akses "
"keluar, dan gunakan ågeté ketika Anda lebih memilih untuk menangani kasus-"
"kasus seperti itu dengan anggun tanpa panik."

#: src/ch03-01-arrays.md:132
msgid "Size-related Methods"
msgstr "Metode Berkaitan Ukuran"

#: src/ch03-01-arrays.md:134
msgid ""
"To determine the number of elements in an array, use the `len()` method. The"
" return value is of type `usize`."
msgstr ""
"Untuk menentukan jumlah elemen dalam suatu array, gunakan metode ålenó). "
"Nilai pengembaliannya adalah tipe åusize."

#: src/ch03-01-arrays.md:136
msgid ""
"If you want to check if an array is empty or not, you can use the "
"`is_empty()` method, which returns `true` if the array is empty and `false` "
"otherwise."
msgstr ""
"Jika Anda ingin memeriksa apakah sebuah array kosong atau tidak, Anda dapat "
"menggunakan metode ·is_empty), yang akan kembali jika susunannya kosong dan "
"false."

#: src/ch03-01-arrays.md:138 src/ch11-05-macros.md:25
msgid "`array!` Macro"
msgstr "Macro"

#: src/ch03-01-arrays.md:140
msgid ""
"Sometimes, we need to create arrays with values that are already known at "
"compile time. The basic way of doing that is redundant. You would first "
"declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, "
"the compiler will expand the macro to generate the code that appends the "
"items sequentially."
msgstr ""
"Kadang-kadang, kita perlu membuat array dengan nilai-nilai yang sudah "
"dikenal pada waktu kompilasi. Cara dasar untuk melakukannya adalah "
"berlebihan. Anda pertama-tama akan mendeklarasikan array dan kemudian "
"menambahkan setiap nilai satu per satu. ▪array! adalah cara yang lebih "
"sederhana untuk melakukan tugas ini dengan menggabungkan dua langkah. Pada "
"waktu kompilasi, kompiler akan memperluas makro untuk menghasilkan kode yang"
" appends items sequentilly."

#: src/ch03-01-arrays.md:143
msgid "Without `array!`:"
msgstr "Tanpa sinar matahari!"

#: src/ch03-01-arrays.md:154
msgid "With `array!`:"
msgstr "Dengan Ãarray!"

#: src/ch03-01-arrays.md:160
msgid "Storing Multiple Types with Enums"
msgstr "Menyimpan Berbagai Jenis dengan Enum"

#: src/ch03-01-arrays.md:162
msgid ""
"If you want to store elements of different types in an array, you can use an"
" `Enum` to define a custom data type that can hold multiple types. Enums "
"will be explained in more detail in the [\"Enums and Pattern "
"Matching\"](./ch06-00-enums-and-pattern-matching.md) chapter."
msgstr ""
"Jika Anda ingin menyimpan elemen-elemen berbagai jenis dalam sebuah array, "
"Anda dapat menggunakan sebuah \\\\enum} untuk mendefinisikan tipe data "
"gubahan yang dapat menyimpan berbagai tipe. Enums akan dijelaskan secara "
"lebih detail dalam bab [\"Enum dan Pola Yang Cocok\"]./ch06-00-enums-and-"
"patinter-matching.md)."

#: src/ch03-01-arrays.md:182
msgid "Span"
msgstr "Span"

#: src/ch03-01-arrays.md:184
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed "
"to provide safe and controlled access to the elements of an array without "
"modifying the original array. Span is particularly useful for ensuring data "
"integrity and avoiding borrowing issues when passing arrays between "
"functions or when performing read-only operations, as introduced in "
"[\"References and Snapshots\"](./ch04-02-references-and-snapshots.md)."
msgstr ""
"Sistem ini dirancang untuk menyediakan akses yang aman dan terkendali ke "
"unsur-unsur suatu array tanpa memodifikasi array aslinya. Span sangat "
"berguna untuk memastikan integritas data dan menghindari isu pinjaman ketika"
" melewati array antara fungsi atau ketika melakukan operasi baca-saja, "
"sebagaimana diperkenalkan dalam [\"References and Snapshots\"]./ch04-02 "
"referreferensis-and-nappshots.md)."

#: src/ch03-01-arrays.md:186
msgid ""
"All methods provided by `Array` can also be used with `Span`, except for the"
" `append()` method."
msgstr ""
"Semua metode yang disediakan oleh Array juga dapat digunakan dengan ▪Spané, "
"kecuali metodenya."

#: src/ch03-01-arrays.md:190
msgid "Turning an Array into Span"
msgstr "Mengubah array menjadi Span"

#: src/ch03-01-arrays.md:192
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr "Untuk membuat sebuah ▪Spané dari sebuah array, sebutlah metode ini:"

#: src/ch03-01-arrays.md:201
msgid "{{#quiz ../quizzes/ch03-01-arrays.toml}}"
msgstr "{{#quiz../quizzes/ch03-01-array.toml}}"

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The "
"`Felt252Dict<T>` data type represents a collection of key-value pairs where "
"each key is unique and associated with a corresponding value. This type of "
"data structure is known differently across different programming languages "
"such as maps, hash tables, associative arrays and many others."
msgstr ""
"Cairo menyediakan di perpustakaan intinya sebuah tipe mirip kamus. Jenis "
"struktur data Felt252Dict<T> Data tipe merepresentasikan koleksi pasangan "
"nilai kunci di mana setiap kunci unik dan terkait dengan nilai yang "
"berhubungan. Jenis struktur data ini dikenal berbeda dalam bahasa "
"pemrograman yang berbeda seperti peta, tabel hash, array asosiatif dan "
"banyak lainnya."

#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a"
" certain way for which using an `Array<T>` and indexing doesn't suffice. "
"Cairo dictionaries also allow the programmer to easily simulate the "
"existence of mutable memory when there is none."
msgstr ""
"Tipe Felt252Dict<T> berguna ketika Anda ingin mengatur data Anda dengan cara"
" tertentu yang menggunakan array<T> dan pengindeksan tidak cukup. Dictionary"
" Cairo juga memungkinkan programmer untuk dengan mudah mensimulasikan "
"keberadaan memori mutable ketika tidak ada."

#: src/ch03-02-dictionaries.md:7
msgid "Basic Use of Dictionaries"
msgstr "Penggunaan Kamus Dasar"

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the"
" data types of both key and value. In Cairo, the key type is restricted to "
"`felt252`, leaving only the possibility to specify the value data type, "
"represented by `T` in `Felt252Dict<T>`."
msgstr ""
"Hal ini normal dalam bahasa lain ketika membuat kamus baru untuk "
"mendefinisikan tipe data dari kunci dan nilai. Di Cairo, jenis kunci "
"dibatasi untuk <T>."

#: src/ch03-02-dictionaries.md:11
msgid ""
"The core functionality of a `Felt252Dict<T>` is implemented in the trait "
"`Felt252DictTrait` which includes all basic operations. Among them we can "
"find:"
msgstr ""
"Fungsi inti dari sebuah Felt252Dict<T> diimplementasikan dalam sifat yang "
"dapat kita temukan:"

#: src/ch03-02-dictionaries.md:13
msgid ""
"`insert(felt252, T) -> ()` to write values to a dictionary instance and"
msgstr "-> () Untuk menulis nilai ke kamus contoh dan"

#: src/ch03-02-dictionaries.md:14
msgid "`get(felt252) -> T` to read values from it."
msgstr "-> Untuk membaca nilai-nilai dari itu."

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other "
"language. In the following example, we create a dictionary to represent a "
"mapping between individuals and their balance:"
msgstr ""
"Fungsi-fungsi ini memungkinkan kita untuk memanipulasi kamus seperti dalam "
"bahasa lain. Dalam contoh berikut, kita membuat kamus untuk mewakili "
"pemetaan antara individu dan keseimbangan mereka:"

#: src/ch03-02-dictionaries.md:26
msgid "\"Balance is not 100\""
msgstr "\"Balance bukan 100\""

#: src/ch03-02-dictionaries.md:29
msgid "\"Balance is not 200\""
msgstr "\"Balance bukan 200\""

#: src/ch03-02-dictionaries.md:33
msgid ""
"We can create a new instance of `Felt252Dict<u64>` by using the `default` "
"method of the `Default` trait and add two individuals, each one with their "
"own balance, using the `insert` method. Finally, we check the balance of our"
" users with the `get` method. These methods are defined in the "
"`Felt252DictTrait` trait in the core library."
msgstr ""
"Kita dapat membuat sebuah contoh baru tentang faktor-felt252Dict<u64> dengan"
" menggunakan metode ådefault) dan menambahkan dua individu, masing-masing "
"dengan keseimbangan mereka sendiri, menggunakan metode ·inserté. Akhirnya, "
"kita memeriksa keseimbangan pengguna kita dengan metoda ågía. Metode-metode "
"ini didefinisikan dalam struktur folt2Drait."

#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, "
"meaning you can only write to a memory cell once but the `Felt252Dict<T>` "
"type represents a way to overcome this obstacle. We will explain how this is"
" implemented later on in [\"Dictionaries "
"Underneath\"](./ch03-02-dictionaries.md#dictionaries-underneath)."
msgstr ""
"Sepanjang buku yang telah kita bicarakan tentang bagaimana memori Cairo "
"tidak dapat berubah, berarti Anda hanya dapat menulis ke sebuah sel memori "
"sekali tetapi jenis font <2 Dict<T>. Kami akan menjelaskan bagaimana hal ini"
" diterapkan kemudian di dalam [\"Diction Underneath\"]. "
"/ch03-02-dictionarys.m#dictionarys-underneath)."

#: src/ch03-02-dictionaries.md:37
msgid ""
"Building upon our previous example, let us show a code example where the "
"balance of the same user changes:"
msgstr ""
"Building upon our user example, let us show a code example where the balance"
" of the same user changes:"

#: src/ch03-02-dictionaries.md:43
msgid "// Insert Alex with 100 balance\n"
msgstr "//Masukkan Alex dengan 100 keseimbangan\n"

#: src/ch03-02-dictionaries.md:45
msgid "// Check that Alex has indeed 100 associated with him\n"
msgstr "#/ Periksa bahwa Alex memang 100 berhubungan dengan dia\n"

#: src/ch03-02-dictionaries.md:47
msgid "\"Alex balance is not 100\""
msgstr "\"Lance Alex tidak 100\""

#: src/ch03-02-dictionaries.md:49
msgid "// Insert Alex again, this time with 200 balance\n"
msgstr "//Masukkan Alex lagi, kali ini dengan 200 keseimbangan\n"

#: src/ch03-02-dictionaries.md:51
msgid "// Check the new balance is correct\n"
msgstr "//Periksa keseimbangan baru adalah benar\n"

#: src/ch03-02-dictionaries.md:53
msgid "\"Alex balance is not 200\""
msgstr "\"Lance Alex bukan 200\""

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the 'Alex' individual twice, each time "
"using a different balance and each time that we checked for its balance it "
"had the last value inserted! `Felt252Dict<T>` effectively allows us to "
"\"rewrite\" the stored value for any given key."
msgstr ""
"Perhatikan bagaimana dalam contoh ini kita menambahkan individu 'Alex' dua "
"kali, setiap kali menggunakan keseimbangan yang berbeda dan setiap kali kita"
" memeriksa untuk keseimbangannya, itu memiliki nilai terakhir yang "
"dimasukkan!"

#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is "
"worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the "
"scenes all keys have their associated values initialized as zero. This means"
" that if for example, you tried to get the balance of an inexistent user you"
" will get 0 instead of an error or an undefined value. This also means there"
" is no way to delete data from a dictionary. Something to take into account "
"when incorporating this structure into your code."
msgstr ""
"Sebelum menuju dan menjelaskan bagaimana dictionary diimplementasikan itu "
"layak menyebutkan bahwa sekali Anda mencoba untuk mendapatkan keseimbangan "
"pengguna yang tidak ada Anda akan mendapatkan 0 bukan sebuah kesalahan atau "
"nilai yang tidak terdefinisi. Ini juga berarti tidak ada cara untuk "
"menghapus data dari kamus. Sesuatu untuk memperhitungkan ketika "
"menggabungkan struktur ini ke dalam kode Anda."

#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` "
"and how it mimics the same behavior as the corresponding data structures in "
"any other language, that is, externally of course. Cairo is at its core a "
"non-deterministic Turing-complete programming language, very different from "
"any other popular language in existence, which as a consequence means that "
"dictionaries are implemented very differently as well!"
msgstr ""
"Sampai titik ini, kita telah melihat semua fitur dasar dari åFelt252Dict<T> "
"dan bagaimana ia meniru perilaku yang sama seperti struktur data yang "
"berhubungan dalam bahasa lain, yaitu, secara eksternal tentu saja. Cairo "
"berada di intinya bahasa pemrograman yang tidak lengkap, sangat berbeda dari"
" bahasa populer lainnya yang ada, yang sebagai konsekuensi berarti bahwa "
"kamuri diterapkan sangat berbeda juga!"

#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about "
"`Felt252Dict<T>` inner mechanisms and the compromises that were taken to "
"make them work. After that, we are going to take a look at how to use "
"dictionaries with other data structures as well as use the `entry` method as"
" another way to interact with them."
msgstr ""
"Pada bagian-bagian berikut, kita akan memberikan beberapa wawasan tentang "
"ÉFelt252Dict<T> mekanisme dalam dan kompromi yang diambil untuk membuatnya "
"bekerja. Setelah itu, kita akan melihat bagaimana menggunakan kamus dengan "
"struktur data lainnya dan juga menggunakan metode Ánínís sebagai cara lain "
"untuk berinteraksi dengan mereka."

#: src/ch03-02-dictionaries.md:67
msgid "Dictionaries Underneath"
msgstr "Kamus Di Bawah"

#: src/ch03-02-dictionaries.md:69
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its "
"memory system is immutable, so in order to simulate mutability, the language"
" implements `Felt252Dict<T>` as a list of entries. Each of the entries "
"represents a time when a dictionary was accessed for "
"reading/updating/writing purposes. An entry has three fields:"
msgstr ""
"Salah satu kendala dari desain un-teteristik Cairo adalah bahwa sistem "
"memorinya tidak dapat diubah, sehingga untuk mensimulasikan mutability, "
"bahasa mengimplementasikan Felt252Dict<T> sebagai daftar entri. Setiap entri"
" mewakili waktu ketika sebuah kamus diakses untuk "
"membaca/memperbarui/menulis tujuan. Sebuah entri memiliki tiga bidang:"

#: src/ch03-02-dictionaries.md:71
msgid ""
"A `key` field that identifies the key for this key-value pair of the "
"dictionary."
msgstr ""
"Sebuah bidang åkey yang mengidentifikasi kunci untuk pasangan kunci bernilai"
" ini dari kamus."

#: src/ch03-02-dictionaries.md:72
msgid ""
"A `previous_value` field that indicates which previous value was held at "
"`key`."
msgstr ""
"Ruas previous_value yang menunjukkan nilai sebelumnya yang diadakan di åkey."

#: src/ch03-02-dictionaries.md:73
msgid ""
"A `new_value` field that indicates the new value that is held at `key`."
msgstr "Sebuah bidang baru yang menunjukkan nilai baru yang diadakan di åkey."

#: src/ch03-02-dictionaries.md:75
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would"
" internally define it as `Array<Entry<T>>` where each `Entry<T>` has "
"information about what key-value pair it represents and the previous and new"
" values it holds. The definition of `Entry<T>` would be:"
msgstr ""
"Jika kita mencoba mengimplementasikan Felt252Dict<T> menggunakan struktur "
"tingkat tinggi kita akan mendefinisikannya secara internal sebagai "
"ARray<Entry<T> di mana masing-masing entry<T> memiliki informasi tentang apa"
" pasangan nilai kunci itu mewakili dan nilai-nilai sebelumnya dan nilai-"
"nilai baru yang dipegang. Definisi dari <T> akan menjadi:"

#: src/ch03-02-dictionaries.md:85
msgid ""
"For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be "
"registered:"
msgstr ""
"Untuk setiap kali kita berinteraksi dengan sebuah Felt252Dict<T>, sebuah "
"Entry baru<T> akan didaftarkan:"

#: src/ch03-02-dictionaries.md:87
msgid ""
"A `get` would register an entry where there is no change in state, and "
"previous and new values are stored with the same value."
msgstr ""
"Sebuah masukan yang akan mendaftar di mana tidak ada perubahan dalam "
"keadaan, dan nilai-nilai sebelumnya dan baru disimpan dengan nilai yang "
"sama."

#: src/ch03-02-dictionaries.md:88
msgid ""
"An `insert` would register a new `Entry<T>` where the `new_value` would be "
"the element being inserted, and the `previous_value` the last element "
"inserted before this. In case it is the first entry for a certain key, then "
"the previous value will be zero."
msgstr ""
"Suatu elemen baru yang dimasukkan akan mendaftarkan elemen baru yang akan "
"dimasukkan sebelum ini. Dalam kasus ini adalah entri pertama untuk kunci "
"tertentu, maka nilai sebelumnya akan menjadi nol."

#: src/ch03-02-dictionaries.md:90
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the "
"creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an"
" example of this using the `balances` dictionary from the previous section "
"and inserting the users 'Alex' and 'Maria':"
msgstr ""
"Penggunaan daftar masukan ini menunjukkan bagaimana tidak ada lagi penulisan"
" ulang, hanya penciptaan sel memori baru per ▪Felt252Dict<T>. Mari kita "
"tunjukkan contoh ini menggunakan kamus kamus requamances dari bagian "
"sebelumnya dan menyisipkan pengguna 'Alex' dan 'Maria':"

#: src/ch03-02-dictionaries.md:108
msgid "These instructions would then produce the following list of entries:"
msgstr "Instruksi ini kemudian akan menghasilkan daftar berikut dari entri:"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "key"
msgstr "kunci"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "previous"
msgstr "sebelumnya"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "new"
msgstr "baru"

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:114
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:138
#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:141
#: src/ch03-02-dictionaries.md:147
msgid "Alex"
msgstr "Alex"

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:135
#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:147
#: src/ch03-02-dictionaries.md:148 src/ch03-02-dictionaries.md:149
msgid "0"
msgstr "0."

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:114
#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:137
msgid "100"
msgstr "100"

#: src/ch03-02-dictionaries.md:113 src/ch03-02-dictionaries.md:115
#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:137
#: src/ch03-02-dictionaries.md:140 src/ch03-02-dictionaries.md:148
msgid "Maria"
msgstr "Maria"

#: src/ch03-02-dictionaries.md:113 src/ch03-02-dictionaries.md:115
msgid "50"
msgstr "50"

#: src/ch03-02-dictionaries.md:114
msgid "200"
msgstr "200"

#: src/ch03-02-dictionaries.md:117
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the "
"`previous` and `current` values are set properly. Also reading from 'Maria' "
"registered an entry with no change from previous to current values."
msgstr ""
"Perhatikan bahwa sejak 'Alex' dimasukkan dua kali, ia muncul dua kali dan "
"nilai-nilai yang sebelumnya dan sekarang telah ditetapkan dengan benar. Juga"
" membaca dari 'Maria' mendaftarkan sebuah entri tanpa perubahan dari "
"sebelumnya ke nilai-nilai saat ini."

#: src/ch03-02-dictionaries.md:119
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each "
"read/write operation, there is a scan for the whole entry list in search of "
"the last entry with the same `key`. Once the entry has been found, its "
"`new_value` is extracted and used on the new entry to be added as the "
"`previous_value`. This means that interacting with `Felt252Dict<T>` has a "
"worst-case time complexity of `O(n)` where `n` is the number of entries in "
"the list."
msgstr ""
"Pendekatan ini untuk mengimplementasikan <T> Felt252Dict berarti bahwa untuk"
" setiap operasi baca/tulis, ada pemindaian untuk seluruh daftar entri dalam "
"pencarian entri terakhir dengan kode yang sama. Setelah entri telah "
"ditemukan, yang baru_nilai pernah diekstrak dan digunakan pada entri baru "
"untuk ditambahkan sebagai daftar pravious_vale. Ini berarti bahwa "
"berinteraksi dengan Felt252Dic<T> memiliki waktu terburuk dari kompleksitas "
"æogen) di mana nomor entri tersebut berada dalam daftar."

#: src/ch03-02-dictionaries.md:121
msgid ""
"If you pour some thought into alternate ways of implementing "
"`Felt252Dict<T>` you'd surely find them, probably even ditching completely "
"the need for a `previous_value` field, nonetheless, since Cairo is not your "
"normal language this won't work. One of the purposes of Cairo is, with the "
"STARK proof system, to generate proofs of computational integrity. This "
"means that you need to verify that program execution is correct and inside "
"the boundaries of Cairo restrictions. One of those boundary checks consists "
"of \"dictionary squashing\" and that requires information on both previous "
"and new values for every entry."
msgstr ""
"Jika Anda menuangkan beberapa pemikiran ke dalam bidang alternatif untuk "
"menerapkan bahasa biasa ini tidak akan bekerja. Salah satu tujuan Cairo "
"adalah, dengan sistem bukti STARK, untuk menghasilkan bukti integritas "
"komputasi. Ini berarti bahwa Anda perlu memverifikasi eksekusi program yang "
"benar dan di dalam batas-batas Cairo. Salah satu pemeriksaan batas tersebut "
"terdiri dari \"dictionary squashing\" dan yang membutuhkan informasi pada "
"setiap masukan sebelumnya dan nilai-nilai baru."

#: src/ch03-02-dictionaries.md:124
msgid "Squashing Dictionaries"
msgstr "Squashing Kamus"

#: src/ch03-02-dictionaries.md:126
msgid ""
"To verify that the proof generated by a Cairo program execution that used a "
"`Felt252Dict<T>` is correct, we need to check that there wasn't any illegal "
"tampering with the dictionary. This is done through a method called "
"`squash_dict` that reviews each entry of the entry list and checks that "
"access to the dictionary remains coherent throughout the execution."
msgstr ""
"Untuk memastikan bahwa bukti yang dihasilkan oleh eksekusi program Cairo "
"yang menggunakan ▪Felt252Dict<T> adalah benar, kita perlu memeriksa bahwa "
"tidak ada gangguan ilegal dengan kamus. Hal ini dilakukan melalui metode "
"yang disebut ·squash_dictà yang meninjau setiap entri daftar entri dan "
"memeriksa akses ke kamus tersebut tetap koheren sepanjang eksekusi."

#: src/ch03-02-dictionaries.md:128
msgid ""
"The process of squashing is as follows: given all entries with certain key "
"`k`, taken in the same order as they were inserted, verify that the ith "
"entry `new_value` is equal to the ith + 1 entry `previous_value`."
msgstr ""
"Proses squashing adalah sebagai berikut: mengingat semua masukan dengan "
"kunci tertentu, diambil dalam urutan yang sama seperti yang dimasukkan, "
"verifikasi bahwa entri ith baru_value sama dengan lith + 1 masukan "
"thoseprevious_value."

#: src/ch03-02-dictionaries.md:130
msgid "For example, given the following entry list:"
msgstr "Sebagai contoh, mengingat daftar berikut:"

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:138
msgid "150"
msgstr "150"

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:149
msgid "Charles"
msgstr "Charles"

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:149
msgid "70"
msgstr "70"

#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:140
msgid "250"
msgstr "250"

#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:139
msgid "40"
msgstr "40"

#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:141
msgid "300"
msgstr "300"

#: src/ch03-02-dictionaries.md:140 src/ch03-02-dictionaries.md:148
msgid "190"
msgstr "190"

#: src/ch03-02-dictionaries.md:141 src/ch03-02-dictionaries.md:147
msgid "90"
msgstr "90"

#: src/ch03-02-dictionaries.md:143
msgid "After squashing, the entry list would be reduced to:"
msgstr "Setelah squashing, daftar entri akan dikurangi menjadi:"

#: src/ch03-02-dictionaries.md:151
msgid ""
"In case of a change on any of the values of the first table, squashing would"
" have failed during runtime."
msgstr ""
"Dalam kasus perubahan pada setiap nilai dari tabel pertama, squashing akan "
"gagal selama runtime."

#: src/ch03-02-dictionaries.md:153
msgid "Dictionary Destruction"
msgstr "Penghancuran Kamus"

#: src/ch03-02-dictionaries.md:155
msgid ""
"If you run the examples from [\"Basic Use of "
"Dictionaries\"](./ch03-02-dictionaries.md#basic-use-of-dictionaries) "
"section, you'd notice that there was never a call to squash dictionary, but "
"the program compiled successfully nonetheless. What happened behind the "
"scene was that squash was called automatically via the `Felt252Dict<T>` "
"implementation of the `Destruct<T>` trait. This call occurred just before "
"the `balance` dictionary went out of scope."
msgstr ""
"Jika anda menjalankan contoh-contoh dari bagian [\"Basic Use of "
"Dictionaries\"]. /ch03-02-dictionary.md#basic-use-of-dictionaries), anda "
"akan memperhatikan bahwa tidak pernah ada panggilan ke kamus squash, tetapi "
"program yang dikompilasi tetap berhasil. Apa yang terjadi di belakang adegan"
" itu disebut squash secara otomatis melalui ▪Felt252Dict<T> mengimplementasi"
" sifat <T>. Panggilan ini terjadi tepat sebelum kamus lepassan hilang."

#: src/ch03-02-dictionaries.md:157
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of "
"scope apart from `Drop<T>`. The main difference between these two is that "
"`Drop<T>` is treated as a no-op operation, meaning it does not generate new "
"CASM while `Destruct<T>` does not have this restriction. The only type which"
" actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other "
"type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these"
" traits in [Drop and Destruct](./appendix-03-derivable-traits.md#drop-and-"
"destruct) section of Appendix C."
msgstr ""
"The destruct<T> sifat ini merupakan cara lain untuk menghilangkan contoh "
"dari lingkup terpisah dari <T>. Perbedaan utama di antara keduanya adalah "
"bahwa <T> diperlakukan sebagai operasi no-op, yang berarti tidak "
"menghasilkan CASM baru sementara <T> Destruct <T> tidak memiliki batasan "
"ini. Satu-satunya jenis yang aktif menggunakan sifat <Dstruct<T> adalah  "
"(Felt252Dict<T>), untuk setiap jenis lain <T> destrucct-destruct-"
"andprognable. Anda dapat membaca tentang sifat-sifat ini [Deroct-and-and-"
"devix]."

#: src/ch03-02-dictionaries.md:159
msgid ""
"Later in [\"Dictionaries as Struct Members\"](./ch11-01-custom-data-"
"structures.html#dictionaries-as-struct-members) section, we will have a "
"hands-on example where we implement the `Destruct<T>` trait for a custom "
"type."
msgstr ""
"Kemudian di [\"Dictionary as Struct Members\"]][ch11-01-custom-data-"
"structures.html#dictionarys-as-struct- members], kita akan memiliki contoh "
"manual di mana kita menerapkan sifat <T> Destruct untuk tipe kustom."

#: src/ch03-02-dictionaries.md:165
msgid "More Dictionaries"
msgstr "Lebih Banyak Kamus"

#: src/ch03-02-dictionaries.md:167
msgid ""
"Up to this point, we have given a comprehensive overview of the "
"functionality of `Felt252Dict<T>` as well as how and why it is implemented "
"in a certain way. If you haven't understood all of it, don't worry because "
"in this section we will have some more examples using dictionaries."
msgstr ""
"Sampai pada titik ini, kami telah memberikan gambaran komprehensif tentang "
"fungsionalitas <T25D> dan bagaimana dan mengapa diterapkan dengan cara "
"tertentu. Jika Anda belum memahami semua itu, jangan khawatir karena di "
"bagian ini kita akan memiliki beberapa contoh lagi menggunakan kamus."

#: src/ch03-02-dictionaries.md:169
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary"
" basic functionality included in `Felt252DictTrait<T>` which we didn't "
"mention at the beginning. Soon after, we will see examples of how to use "
"`Felt252Dict<T>` with other [complex "
"types](./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-"
"natively) such as `Array<T>`."
msgstr ""
"Kita akan mulai dengan menjelaskan metode entry) yang merupakan bagian dari "
"fungsi dasar kamus yang termasuk dalam ▪Felt252DictTT> yang tidak kita "
"sebutkan di awal. Segera setelah itu, kita akan melihat contoh-contoh "
"tentang bagaimana menggunakan ▪Felt252Dict<T> dengan tipe lain [kompleks] "
"OFCH03-dictionarys.md#dictionarys-of-no-no-supportated-ative) seperti "
"ÁArray<T>."

#: src/ch03-02-dictionaries.md:173
msgid "Entry and Finalize"
msgstr "Entri dan Finalize"

#: src/ch03-02-dictionaries.md:175
msgid ""
"In the [\"Dictionaries Underneath\"](./ch03-02-dictionaries.md#dictionaries-"
"underneath) section, we explained how `Felt252Dict<T>` internally worked. It"
" was a list of entries for each time the dictionary was accessed in any "
"manner. It would first find the last entry given a certain `key` and then "
"update it accordingly to whatever operation it was executing. The Cairo "
"language gives us the tools to replicate this ourselves through the `entry` "
"and `finalize` methods."
msgstr ""
"Dalam bagian [\"Dictionary Underneath\"] (Dictionary Underneath\"). "
"/ch03-02-Dictionary.md#dictionary-underneground), kami menjelaskan bagaimana"
" \"Felt252Dict<T> secara internal bekerja. Ini adalah daftar masukan untuk "
"setiap kali kamus diakses dengan cara apapun. Pertama kali akan menemukan "
"entri terakhir diberikan ▪keyán dan kemudian memperbaruinya sesuai dengan "
"operasi apapun itu. Bahasa Cairo memberi kita alat untuk mereplikasi ini "
"melalui metode SPEAKentry dan quest finalisasi."

#: src/ch03-02-dictionaries.md:177
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose "
"of creating a new entry given a certain key. Once called, this method takes "
"ownership of the dictionary and returns the entry to update. The method "
"signature is as follows:"
msgstr ""
"Metode reentry datang sebagai bagian dari åFelt252DictTrait<T> dengan tujuan"
" membuat entri baru yang diberikan kunci tertentu. Setelah dipanggil, metode"
" ini mengambil kepemilikan kamus dan mengembalikan entri untuk memperbarui. "
"Metode signature adalah sebagai berikut:"

#: src/ch03-02-dictionaries.md:183
msgid ""
"The first input parameter takes ownership of the dictionary while the second"
" one is used to create the appropriate entry. It returns a tuple containing "
"a `Felt252DictEntry<T>`, which is the type used by Cairo to represent "
"dictionary entries, and a `T` representing the value held previously. The "
"`nopanic` notation simply indicates that the function is guaranteed to never"
" panic."
msgstr ""
"Parameter masukan pertama mengambil kepemilikan kamus sementara yang kedua "
"digunakan untuk membuat entri yang sesuai. Ini mengembalikan sebuah tuple "
"yang berisi nolet 252 Dict Entry<T>, yang merupakan tipe yang digunakan oleh"
" Cairo untuk mewakili masukan kamus, dan sebuah tuple yang mewakili nilai "
"yang diadakan sebelumnya. Nopanicâ notasi hanya menunjukkan bahwa fungsi "
"dijamin untuk tidak pernah panik."

#: src/ch03-02-dictionaries.md:186
msgid ""
"The next thing to do is to update the entry with the new value. For this, we"
" use the `finalize` method which inserts the entry and returns ownership of "
"the dictionary:"
msgstr ""
"Hal berikutnya yang harus dilakukan adalah memperbarui entri dengan nilai "
"baru untuk ini, kita menggunakan metode akhir yang menyisipkan entri dan "
"mengembalikan kepemilikan kamus:"

#: src/ch03-02-dictionaries.md:192
msgid ""
"This method receives the entry and the new value as parameters, and returns "
"the updated dictionary."
msgstr ""
"Metode ini menerima entri dan nilai baru sebagai parameter, dan "
"mengembalikan kamus yang diperbarui."

#: src/ch03-02-dictionaries.md:194
msgid ""
"Let us see an example using `entry` and `finalize`. Imagine we would like to"
" implement our own version of the `get` method from a dictionary. We should "
"then do the following:"
msgstr "Mari kita lihat sebuah contoh yang menggunakan kamus."

#: src/ch03-02-dictionaries.md:196
msgid "Create the new entry to add using the `entry` method."
msgstr "Buat entry baru untuk menambahkan menggunakan metoda réentry."

#: src/ch03-02-dictionaries.md:197
msgid ""
"Insert back the entry where the `new_value` equals the `previous_value`."
msgstr ""
"Masukkan kembali ke tempat di mana nilai baru sama dengan previous_value."

#: src/ch03-02-dictionaries.md:198
msgid "Return the value."
msgstr "Kembalikan nilainya."

#: src/ch03-02-dictionaries.md:200
msgid "Implementing our custom get would look like this:"
msgstr ""
"Mengimplementasikan kustom kami mendapatkan akan terlihat seperti ini:"

#: src/ch03-02-dictionaries.md:208 src/ch03-02-dictionaries.md:252
msgid "// Get the new entry and the previous value held at `key`\n"
msgstr "//Dapatkan entri baru dan nilai sebelumnya disimpan di åkey\n"

#: src/ch03-02-dictionaries.md:211 src/ch03-02-dictionaries.md:255
msgid "// Store the value to return\n"
msgstr "//Simpan nilai untuk kembali\n"

#: src/ch03-02-dictionaries.md:214 src/ch03-02-dictionaries.md:258
msgid ""
"// Update the entry with `prev_value` and get back ownership of the "
"dictionary\n"
msgstr ""
"//Perbarui entri dengan óprev_value dan dapatkan kembali kepemilikan kamus\n"

#: src/ch03-02-dictionaries.md:217 src/ch03-02-dictionaries.md:261
msgid "// Return the read value\n"
msgstr "//Kembalikan nilai baca\n"

#: src/ch03-02-dictionaries.md:222
msgid ""
"The `ref` keyword means that the ownership of the variable will be given "
"back at the end of the function. This concept will be explained in more "
"detail in the [\"References and Snapshots\"](./ch04-02-references-and-"
"snapshots.md) section."
msgstr ""
"Kata kuncinya berarti kepemilikan variabel akan diberikan kembali pada akhir"
" fungsi. Konsep ini akan dijelaskan secara lebih rinci dalam bagian "
"[\"Perubahan dan Snapshots\"]./ch04-02-referensi-and-snappshots.md)."

#: src/ch03-02-dictionaries.md:225
msgid ""
"Implementing the `insert` method would follow a similar workflow, except for"
" inserting a new value when finalizing. If we were to implement it, it would"
" look like the following:"
msgstr ""
"Mengimplementasikan metode æinserté akan mengikuti alur kerja yang sama, "
"kecuali untuk menyisipkan nilai baru ketika menyelesaikan."

#: src/ch03-02-dictionaries.md:233
msgid ""
"// Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exist, `_prev_value` will\n"
"    // be the default value of T.\n"
msgstr ""
"//Dapatkan masukan terakhir yang berhubungan dengan ıkey / / / / Perhatikan "
"bahwa jika åkey tidak ada, 'prev_value' akan / / menjadi nilai baku dari "
"T.\n"

#: src/ch03-02-dictionaries.md:238
msgid ""
"// Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
msgstr ""
"//Masukkan kembali dalam kamus dengan nilai terbaru,//dan menerima "
"kepemilikan kamus\n"

#: src/ch03-02-dictionaries.md:244
msgid ""
"As a finalizing note, these two methods are implemented in a similar way to "
"how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows"
" some example usage:"
msgstr ""
"Sebagai catatan akhir, kedua metode ini diterapkan dengan cara yang sama "
"dengan bagaimana åinsert dan ågetÃ diimplementasikan untuk <T 252 Dict. Kode"
" ini menunjukkan beberapa contoh penggunaan:"

#: src/ch03-02-dictionaries.md:268
msgid "// Get the last entry associated with `key`\n"
msgstr "//Dapatkan entri terakhir yang terkait dengan kunci\n"

#: src/ch03-02-dictionaries.md:269
msgid "// Notice that if `key` does not exist, `_prev_value` will\n"
msgstr "//perhatian jika kunci tidak ada,_prev_value akan\n"

#: src/ch03-02-dictionaries.md:270
msgid "// be the default value of T.\n"
msgstr "///Jadilah nilai dasar dari T.\n"

#: src/ch03-02-dictionaries.md:273
msgid "// Insert `entry` back in the dictionary with the updated value,\n"
msgstr "//Masukkan kembali dalam kamus dengan nilai terbaru,\n"

#: src/ch03-02-dictionaries.md:274
msgid "// and receive ownership of the dictionary\n"
msgstr "//dan menerima kepemilikan kamus\n"

#: src/ch03-02-dictionaries.md:281 src/ch03-02-dictionaries.md:283
msgid "'0'"
msgstr "'0'"

#: src/ch03-02-dictionaries.md:285
msgid "\"Expecting 100\""
msgstr "\"Menduga 100\""

#: src/ch03-02-dictionaries.md:294
msgid "Dictionaries of Types not Supported Natively"
msgstr "Kamus Tipe yang Tidak Didukung Asli"

#: src/ch03-02-dictionaries.md:296
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the "
"trait `Felt252DictValue<T>`. This trait defines the `zero_default` method "
"which is the one that gets called when a value does not exist in the "
"dictionary. This is implemented by some common data types, such as most "
"unsigned integers, `bool` and `felt252` - but it is not implemented for more"
" complex types such as arrays, structs (including `u256`), and other types "
"from the core library. This means that making a dictionary of types not "
"natively supported is not a straightforward task, because you would need to "
"write a couple of trait implementations in order to make the data type a "
"valid dictionary value type. To compensate this, you can wrap your type "
"inside a `Nullable<T>`."
msgstr ""
"Salah satu pembatasan dari Felt252Dict<T> yang belum kita bicarakan adalah "
"sifat yang tidak ada dalam kamus. Ini diterapkan oleh beberapa tipe data "
"umum, seperti tipe integer yang belum ditandai, ▪bool dan ERTI252-- tapi itu"
" tidak diterapkan untuk tipe yang lebih kompleks seperti array, struct "
"(termasuk 25), dan dari tipe-tipe inti lainnya. Ini berarti bahwa membuat "
"kamu tidak akan membutuhkan sebuah tipe yang tepat untuk membuat sebuah tipe"
" data yang valid karena kamu akan membuat sebuah tipe yang valid."

#: src/ch03-02-dictionaries.md:302
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be"
" `null` in the absence of value. It is usually used in Object Oriented "
"Programming Languages when a reference doesn't point anywhere. The "
"difference with `Option` is that the wrapped value is stored inside a "
"`Box<T>` data type. The `Box<T>` type is a smart pointer that allows us to "
"use a dedicated `boxed_segment` memory segment for our data, and access this"
" segment using a pointer that can only be manipulated in one place at a "
"time. See [Smart Pointers Chapter](./ch11-02-smart-pointers.md) for more "
"information."
msgstr ""
"Dalam tidak adanya nilai. Hal ini biasanya digunakan dalam tipe Programming "
"Bahasa Oriented Objek ketika sebuah referensi tidak menunjuk di mana saja. "
"Perbedaan dengan otopsi adalah bahwa nilai yang dibungkus dalam tipe data "
"ÉBox<T>. Tipe data tersebut adalah tipe penunjuk cerdas yang memungkinkan "
"kita untuk menggunakan segmen memori yang didedikasikan untuk data kita, dan"
" ini hanya dapat digunakan di satu tempat pada satu tempat."

#: src/ch03-02-dictionaries.md:304
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a"
" dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are "
"storing a `Span<T>` and not an `Array<T>` because the latter does not "
"implement the `Copy<T>` trait which is required for reading from a "
"dictionary."
msgstr ""
"Mari kita tunjukkan dengan menggunakan contoh. Kita akan mencoba untuk "
"menyimpan sebuah ·Span<felt2> di dalam kamus. Untuk itu, kita akan "
"menggunakan <T> yang dapat dibuang dan juga Box<T>. Juga, kita menyimpan "
"sebuah span <T> dan bukan sebuah array <T> karena yang terakhir tidak "
"mengimplementasikan sifat <T> yang diperlukan untuk membaca kamus."

#: src/ch03-02-dictionaries.md:310 src/ch03-02-dictionaries.md:359
msgid "// Create the dictionary\n"
msgstr "//Buat kamus\n"

#: src/ch03-02-dictionaries.md:313 src/ch03-02-dictionaries.md:362
msgid "// Create the array to insert\n"
msgstr "//Buat array untuk menyisipkan\n"

#: src/ch03-02-dictionaries.md:316 src/ch03-02-dictionaries.md:365
msgid "// Insert it as a `Span`\n"
msgstr "//Masukkan sebagai sebuah ¤Spané\n"

#: src/ch03-02-dictionaries.md:318 src/ch03-02-dictionaries.md:329
msgid "//...\n"
msgstr "//...\n"

#: src/ch03-02-dictionaries.md:322
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary "
"`d`. We want it to hold a `Nullable<Span>`. After that, we created an array "
"and filled it with values."
msgstr ""
"Dalam snippet kode ini, hal pertama yang kami lakukan adalah membuat kamus "
"baru. kami ingin agar dapat menyimpan <Span> yang dapat dibuang. setelah "
"itu, kami membuat sebuah array dan mengisinya dengan nilai-nilai."

#: src/ch03-02-dictionaries.md:324
msgid ""
"The last step is inserting the array as a span inside the dictionary. Notice"
" that we do this using the `new` function of the `NullableTrait`."
msgstr ""
"Langkah terakhir adalah memasukkan array sebagai rentang di dalam kamus."

#: src/ch03-02-dictionaries.md:326
msgid ""
"Once the element is inside the dictionary, and we want to get it, we follow "
"the same steps but in reverse order. The following code shows how to achieve"
" that:"
msgstr ""
"Setelah elemennya ada di dalam kamus, dan kita ingin mendapatkannya, kita "
"mengikuti langkah yang sama tetapi secara terbalik."

#: src/ch03-02-dictionaries.md:331 src/ch03-02-dictionaries.md:368
msgid "// Get value back\n"
msgstr "//Kembalikan nilai\n"

#: src/ch03-02-dictionaries.md:334 src/ch03-02-dictionaries.md:371
msgid "// Search the value and assert it is not null\n"
msgstr "//Cari nilai dan tegaskan itu tidak kosong\n"

#: src/ch03-02-dictionaries.md:336 src/ch03-02-dictionaries.md:373
msgid "\"No value found\""
msgstr "\"Tidak ada nilai yang ditemukan\""

#: src/ch03-02-dictionaries.md:340 src/ch03-02-dictionaries.md:377
msgid "// Verify we are having the right values\n"
msgstr "//Perverifikasikan kita memiliki nilai yang benar\n"

#: src/ch03-02-dictionaries.md:341 src/ch03-02-dictionaries.md:378
msgid "\"Expecting 8\""
msgstr "\"Menduga 8\""

#: src/ch03-02-dictionaries.md:342 src/ch03-02-dictionaries.md:379
msgid "\"Expecting 9\""
msgstr "\"Menduga 9\""

#: src/ch03-02-dictionaries.md:343 src/ch03-02-dictionaries.md:380
msgid "\"Expecting 10\""
msgstr "\"Menduga 10\""

#: src/ch03-02-dictionaries.md:347
msgid "Here we:"
msgstr "Di sini kita:"

#: src/ch03-02-dictionaries.md:349
msgid "Read the value using `get`."
msgstr "Baca nilainya dengan menggunakan égeté."

#: src/ch03-02-dictionaries.md:350
msgid "Verified it is non-null using the `match_nullable` function."
msgstr "Diverifikasi itu non-null menggunakan fungsi cocok-nullable."

#: src/ch03-02-dictionaries.md:351
msgid "Unwrapped the value inside the box and asserted it was correct."
msgstr "Unwrapped nilai dalam kotak dan menegaskan itu benar."

#: src/ch03-02-dictionaries.md:353
msgid "The complete script would look like this:"
msgstr "Naskah lengkap akan terlihat seperti ini:"

#: src/ch03-02-dictionaries.md:385
msgid "Using Arrays inside Dictionaries"
msgstr "Menggunakan Larik di dalam Kamus"

#: src/ch03-02-dictionaries.md:387
msgid ""
"In the previous section, we explored how to store and retrieve complex types"
" inside a dictionary using `Nullable<T>` and `Box<T>`. Now, let's take a "
"look at how to store an array inside a dictionary and dynamically modify its"
" contents."
msgstr ""
"Di bagian sebelumnya, kami menjelajahi cara menyimpan dan mengambil jenis "
"kompleks di dalam kamus menggunakan <T> yang dapat diubah dan secara "
"dinamis. Sekarang, mari kita lihat bagaimana menyimpan sebuah array di dalam"
" kamus dan mengubah isinya secara dinamis."

#: src/ch03-02-dictionaries.md:389
msgid ""
"Storing arrays in dictionaries in Cairo is slightly different from storing "
"other types. This is because arrays are more complex data structures that "
"require special handling to avoid issues with memory copying and references."
msgstr ""
"Menyimpan array dalam kamus di Cairo sedikit berbeda dengan menyimpan tipe "
"lain. Ini karena array adalah struktur data yang lebih kompleks yang "
"memerlukan penanganan khusus untuk menghindari masalah dengan penyalinan "
"memori dan referensi."

#: src/ch03-02-dictionaries.md:391
msgid ""
"First, let's look at how to create a dictionary and insert an array into it."
" This process is pretty straightforward and follows a similar pattern to "
"inserting other types of data:"
msgstr ""
"Pertama, mari kita lihat bagaimana membuat kamus dan memasukkan sebuah array"
" ke dalamnya. Proses ini cukup sederhana dan mengikuti pola serupa untuk "
"menyisipkan tipe data lain:"

#: src/ch03-02-dictionaries.md:398
msgid "\"Array inserted successfully.\""
msgstr "\"Array dimasukkan dengan sukses.\""

#: src/ch03-02-dictionaries.md:402
msgid ""
"However, attempting to read an array from the dictionary using the `get` "
"method will result in a compiler error. This is because `get` tries to copy "
"the array in memory, which is not possible for arrays (as we've already "
"mentioned in the [previous section](./ch03-02-dictionaries.md#dictionaries-"
"of-types-not-supported-natively), `Array<T>` does not implement the "
"`Copy<T>` trait):"
msgstr ""
"Namun, mencoba untuk membaca sebuah array dari kamus menggunakan metode yang"
" sebelumnya akan menghasilkan kesalahan kompiler. Ini adalah karena "
"iarier.md#dictionary-of-type-no-supported-native), --Array<T> tidak "
"mengimplementasikan sifat <T>:"

#: src/ch03-02-dictionaries.md:411
msgid "\"Array: {:?}\""
msgstr "\"Array: [:]\""

#: src/ch03-02-dictionaries.md:415
msgid "// This will cause a compiler error\n"
msgstr "//Ini akan menyebabkan kesalahan kompiler\n"

#: src/ch03-02-dictionaries.md:417
msgid "\"No value!\""
msgstr "\"Tidak ada nilai!\""

#: src/ch03-02-dictionaries.md:424
msgid ""
"```shell\n"
"$ scarb cairo-run \n"
"   Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 (listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)\n"
"error: Trait has no implementation in context: core::traits::Copy::<core::nullable::Nullable::<core::array::Array::<core::integer::u8>>>\n"
" --> listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:12:20\n"
"    let val = dict.get(0); // This will cause a compiler error\n"
"                   ^*^\n"
"\n"
"error: could not compile `no_listing_15_dict_of_array_attempt_get` due to previous error\n"
"error: `scarb metadata` exited with error\n"
"\n"
"```"
msgstr "Alih Bahasa Pulpy"

#: src/ch03-02-dictionaries.md:437
msgid ""
"To correctly read an array from the dictionary, we need to use dictionary "
"entries. This allows us to get a reference to the array value without "
"copying it:"
msgstr ""
"Untuk membaca sebuah array dari kamus, kita perlu menggunakan entri kamus. "
"Hal ini memungkinkan kita untuk mendapatkan referensi ke nilai array tanpa "
"menyalinnya:"

#: src/ch03-02-dictionaries.md:449
msgid ""
"Note: We must convert the array to a `Span` before finalizing the entry, "
"because calling `NullableTrait::new(arr)` moves the array, thus making it "
"impossible to return it from the function."
msgstr ""
"Catatan: Kita harus mengubah arraynya menjadi ÁSpané sebelum menyelesaikan "
"entrinya, karena memanggil NullableTrait:::new--arrr). Menggerakkan "
"susunannya, sehingga mustahil untuk mengembalikannya dari fungsi."

#: src/ch03-02-dictionaries.md:451
msgid ""
"To modify the stored array, such as appending a new value, we can use a "
"similar approach. The following `append_value` function demonstrates this:"
msgstr ""
"Untuk mengubah array yang tersimpan, seperti menambahkan nilai baru, kita "
"dapat menggunakan pendekatan yang sama. Fungsi berikut ini adalah:"

#: src/ch03-02-dictionaries.md:462
msgid ""
"In the `append_value` function, we access the dictionary entry, dereference "
"the array, append the new value, and finalize the entry with the updated "
"array."
msgstr ""
"Dalam fungsi åappend_value, kita mengakses entri kamus, dereferensi array, "
"menambahkan nilai baru, dan menyelesaikan entri dengan array terbaru."

#: src/ch03-02-dictionaries.md:464
msgid ""
"Note: Removing an item from a stored array can be implemented in a similar "
"manner."
msgstr ""
"Catatan: Menghapus suatu butir dari suatu array yang disimpan dapat "
"diimplementasikan dengan cara yang sama."

#: src/ch03-02-dictionaries.md:466
msgid ""
"Below is the complete example demonstrating the creation, insertion, "
"reading, and modification of an array in a dictionary:"
msgstr ""
"Di bawah ini adalah contoh lengkap menunjukkan penciptaan, penyisipan, "
"membaca, dan modifikasi sebuah array dalam kamus:"

#: src/ch03-02-dictionaries.md:491
msgid "\"Before insertion: {:?}\""
msgstr "\"Sebelum penyisipan: {:?}\""

#: src/ch03-02-dictionaries.md:495
msgid "\"After insertion: {:?}\""
msgstr "\"Setelah penyisipan: {:?}\""

#: src/ch03-02-dictionaries.md:499
msgid "{{#quiz ../quizzes/ch03-02-dictionaries.toml}}"
msgstr "{{#quiz../quizzes/ch03-02-dictionaries.toml}}}"

#: src/ch04-00-understanding-ownership.md
msgid "Understanding Cairo's Ownership system"
msgstr "Memahami sistem kepemilikan Cairo"

#: src/ch04-00-understanding-ownership.md
msgid ""
"Cairo is a language built around a linear type system that allows us to "
"statically ensure that in every Cairo program, a value is used exactly once."
" This linear type system helps prevent runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory "
"cell, are detected at compile time. This is achieved by implementing an "
"ownership system and forbidding copying and dropping values by default. In "
"this chapter, we’ll talk about Cairo's ownership system as well as "
"references and snapshots."
msgstr ""
"Cairo adalah bahasa yang dibangun di sekitar sistem linear yang memungkinkan"
" kita untuk memastikan secara statis bahwa dalam setiap program Cairo, nilai"
" digunakan tepat sekali. Sistem linear ini membantu mencegah kesalahan waktu"
" berjalan dengan memastikan bahwa operasi yang dapat menyebabkan kesalahan "
"tersebut, seperti menulis dua kali ke sel memori, terdeteksi pada waktu "
"kompilasi. Hal ini dicapai dengan mengimplementasikan sistem kepemilikan dan"
" melarang menyalin dan menjatuhkan nilai secara baku. Dalam bab ini, kita "
"akan berbicara tentang sistem kepemilikan Cairo serta referensi dan laporan."

#: src/ch04-01-what-is-ownership.md:1
msgid "Ownership Using a Linear Type System"
msgstr "Kepemilikan Menggunakan Sistem Tipe Linear"

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"Cairo uses a linear type system. In such a type system, any value (a basic "
"type, a struct, an enum) must be used and must only be used once. 'Used' "
"here means that the value is either _destroyed_ or _moved_."
msgstr ""
"Cairo menggunakan sistem tipe linear. Dalam sistem tipe seperti itu, nilai "
"apapun (tipe dasar, struct, enum) harus digunakan dan harus hanya digunakan "
"sekali. 'Digunakan' di sini berarti bahwa nilai adalah baik _destroyed_ atau"
" _moved_."

#: src/ch04-01-what-is-ownership.md:5
msgid "_Destruction_ can happen in several ways:"
msgstr "_Destruksi_ dapat terjadi dalam beberapa cara:"

#: src/ch04-01-what-is-ownership.md:7
msgid "a variable goes out of scope."
msgstr "variabel pergi keluar dari ruang lingkup."

#: src/ch04-01-what-is-ownership.md:8
msgid "a struct is destructured."
msgstr "struktur yang didestrukturisasi."

#: src/ch04-01-what-is-ownership.md:9
msgid "explicit destruction using `destruct()`."
msgstr "Penghancuran eksplisit menggunakan Connell)."

#: src/ch04-01-what-is-ownership.md:11
msgid "_Moving_ a value simply means passing that value to another function."
msgstr "_Moving_ nilai hanya berarti melewati nilai itu ke fungsi lain."

#: src/ch04-01-what-is-ownership.md:13
msgid ""
"This results in somewhat similar constraints to the Rust ownership model, "
"but there are some differences. In particular, the Rust ownership model "
"exists (in part) to avoid data races and concurrent mutable access to a "
"memory value. This is obviously impossible in Cairo since the memory is "
"immutable. Instead, Cairo leverages its linear type system for two main "
"purposes:"
msgstr ""
"Hal ini menghasilkan batasan yang sama dengan model kepemilikan Rust, tetapi"
" ada beberapa perbedaan. Secara khusus, model kepemilikan Rust ada (di "
"bagian) untuk menghindari ras data dan akses yang dapat diubah ke suatu "
"nilai memori. Hal ini jelas tidak mungkin di Cairo karena memori itu tidak "
"dapat berubah. Sebaliknya, Cairo memanfaatkan sistem linear untuk dua tujuan"
" utama:"

#: src/ch04-01-what-is-ownership.md:17
msgid "Ensuring that all code is provable and thus verifiable."
msgstr ""
"Memastikan bahwa semua kode dapat dibuktikan dan dengan demikian dapat "
"diverifikasi."

#: src/ch04-01-what-is-ownership.md:18
msgid "Abstracting away the immutable memory of the Cairo VM."
msgstr "Abstracting jauh memori abadi dari VM Cairo."

#: src/ch04-01-what-is-ownership.md:20
msgid "Ownership"
msgstr "Kepemilikan"

#: src/ch04-01-what-is-ownership.md:22
msgid ""
"In Cairo, ownership applies to _variables_ and not to _values_. A value can "
"safely be referred to by many different variables (even if they are mutable "
"variables), as the value itself is always immutable. Variables however can "
"be mutable, so the compiler must ensure that constant variables aren't "
"accidentally modified by the programmer. This makes it possible to talk "
"about ownership of a variable: the owner is the code that can read (and "
"write if mutable) the variable."
msgstr ""
"Di Cairo, kepemilikan berlaku untuk _variables_ dan tidak ke _nilai_. Nilai "
"dengan aman dapat dirujuk oleh berbagai variabel (walaupun mereka variabel "
"yang dapat dimutasi), karena nilai itu sendiri selalu dapat diubah. Variabel"
" namun dapat bermutasi, sehingga kompiler harus memastikan bahwa variabel "
"konstan tidak dapat diubah secara tidak sengaja oleh programmer. Hal ini "
"memungkinkan untuk berbicara tentang kepemilikan dari variabel: pemilik "
"adalah kode yang dapat membaca (dan menulis jika dapat dimutasi) variabel "
"tersebut."

#: src/ch04-01-what-is-ownership.md:26
msgid ""
"This means that variables (not values) follow similar rules to Rust values:"
msgstr ""
"Ini berarti bahwa variabel (bukan nilai) mengikuti aturan serupa ke nilai "
"Rust:"

#: src/ch04-01-what-is-ownership.md:28
msgid "Each variable in Cairo has an owner."
msgstr "Setiap variabel di Cairo memiliki pemilik."

#: src/ch04-01-what-is-ownership.md:29
msgid "There can only be one owner at a time."
msgstr "Hanya ada satu pemilik pada suatu waktu."

#: src/ch04-01-what-is-ownership.md:30
msgid "When the owner goes out of scope, the variable is destroyed."
msgstr "Ketika pemilik keluar dari lingkup, variabel hancur."

#: src/ch04-01-what-is-ownership.md:32
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() "
"{` code in examples, so if you’re following along, make sure to put the "
"following examples inside a main function manually. As a result, our "
"examples will be a bit more concise, letting us focus on the actual details "
"rather than boilerplate code."
msgstr ""
"Sekarang kita melewati sintaks dasar Cairo, kita tidak akan memasukkan semua"
" kode utama pada contoh-contoh, jadi jika Anda mengikuti bersama-sama, "
"pastikan untuk menempatkan contoh-contoh berikut dalam fungsi utama secara "
"manual. sebagai hasilnya, contoh-contoh kita akan menjadi sedikit lebih "
"ringkas, membiarkan kita fokus pada rincian sebenarnya daripada kode "
"boilerplate."

#: src/ch04-01-what-is-ownership.md:34
msgid "Variable Scope"
msgstr "Scope Variabel"

#: src/ch04-01-what-is-ownership.md:36
msgid ""
"As a first example of the linear type system, we’ll look at the _scope_ of "
"some variables. A scope is the range within a program for which an item is "
"valid. Take the following variable:"
msgstr ""
"Sebagai contoh pertama dari sistem linear, kita akan melihat pada _scope_ "
"dari beberapa variabel. Sebuah lingkup adalah jangkauan dalam sebuah program"
" dimana sebuah item valid. Ambil variabel berikut:"

#: src/ch04-01-what-is-ownership.md:44
msgid ""
"The variable `s` refers to a short string. The variable is valid from the "
"point at which it’s declared until the end of the current _scope_. Listing "
"4-1 shows a program with comments annotating where the variable `s` would be"
" valid."
msgstr ""
"Variabelnya mengacu pada string pendek. Variabel valid dari titik dimana ia "
"menyatakan sampai akhir _scope_. Daftar 4-1 menunjukkan sebuah program "
"dengan komentar yang menunjukkan di mana variabel tersebut akan valid."

#: src/ch04-01-what-is-ownership.md:49
msgid "//TAG: ignore_fmt\n"
msgstr "//TAG: abaikan_fmt\n"

#: src/ch04-01-what-is-ownership.md:51
msgid "// s is not valid here, it’s not yet declared\n"
msgstr "//s tidak valid disini, ini belum dideklarasikan\n"

#: src/ch04-01-what-is-ownership.md:52
msgid ""
"// s is valid from this point forward\n"
"    // do stuff with s\n"
msgstr "//s valid dari titik ini ke depan///lakukan hal-hal dengan s\n"

#: src/ch04-01-what-is-ownership.md:54
msgid "// this scope is now over, and s is no longer valid\n"
msgstr "//opong ini sekarang berakhir, dan s tidak lagi valid\n"

#: src/ch04-01-what-is-ownership.md:58
msgid ""
"<span class=\"caption\">Listing 4-1: A variable and the scope in which it is"
" valid</span>"
msgstr ""
"<span class=\"caption\">Listing 4-1: Sebuah variabel dan lingkup dimana itu "
"valid</span>"

#: src/ch04-01-what-is-ownership.md:60
msgid "In other words, there are two important points in time here:"
msgstr "Dengan kata lain, ada dua poin penting dalam waktu di sini:"

#: src/ch04-01-what-is-ownership.md:62
msgid "When `s` comes _into_ scope, it is valid."
msgstr "Ketika datang ke dalam lingkup, itu valid."

#: src/ch04-01-what-is-ownership.md:63
msgid "It remains valid until it goes _out of_ scope."
msgstr "Ini tetap berlaku sampai keluar dari jangkauan."

#: src/ch04-01-what-is-ownership.md:65
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is similar to that in other programming languages. Now we’ll build on top of"
" this understanding by using the `Array` type we introduced in the previous "
"[\"Arrays\"](./ch03-01-arrays.md) section."
msgstr ""
"Pada titik ini, hubungan antara lingkup dan ketika variabel valid serupa "
"dengan yang dalam bahasa pemrograman lain. Sekarang kita akan membangun di "
"atas pemahaman ini dengan menggunakan tipe Árray (jenis array) yang kita "
"perkenalkan di bagian sebelumnya [\"Arrays\"]./ch03-01-array.md)."

#: src/ch04-01-what-is-ownership.md:69
msgid "Moving values"
msgstr "Memindahkan nilai"

#: src/ch04-01-what-is-ownership.md:71
msgid ""
"As said earlier, _moving_ a value simply means passing that value to another"
" function. When that happens, the variable referring to that value in the "
"original scope is destroyed and can no longer be used, and a new variable is"
" created to hold the same value."
msgstr ""
"Seperti yang dikatakan sebelumnya, _bergerak_ sebuah nilai hanya berarti "
"melewati nilai itu ke fungsi lain. Ketika itu terjadi, variabel yang mengacu"
" pada nilai yang dalam lingkup asli dihancurkan dan tidak dapat lagi "
"digunakan, dan variabel baru dibuat untuk menyimpan nilai yang sama."

#: src/ch04-01-what-is-ownership.md:73
msgid ""
"Arrays are an example of a complex type that is moved when passing it to "
"another function. Here is a short reminder of what an array looks like:"
msgstr ""
"Array adalah contoh dari jenis kompleks yang dipindahkan ketika melewatinya "
"ke fungsi lain. Berikut adalah pengingat singkat tentang apa yang array "
"terlihat seperti:"

#: src/ch04-01-what-is-ownership.md:84
msgid ""
"How does the type system ensure that the Cairo program never tries to write "
"to the same memory cell twice? Consider the following code, where we try to "
"remove the front of the array twice:"
msgstr ""
"Bagaimana sistem tipe memastikan bahwa program Cairo tidak pernah mencoba "
"untuk menulis ke sel memori yang sama dua kali? Pertimbangkan kode berikut, "
"di mana kita mencoba untuk menghapus depan array dua kali:"

#: src/ch04-01-what-is-ownership.md:99
msgid ""
"In this case, we try to pass the same value (the array in the `arr` "
"variable) to both function calls. This means our code tries to remove the "
"first element twice, which would try to write to the same memory cell twice "
"- which is forbidden by the Cairo VM, leading to a runtime error. "
"Thankfully, this code does not actually compile. Once we have passed the "
"array to the `foo` function, the variable `arr` is no longer usable. We get "
"this compile-time error, telling us that we would need Array to implement "
"the Copy Trait:"
msgstr ""
"Dalam hal ini, kami mencoba untuk melewati nilai yang sama (array dalam "
"variabel ·arjan) untuk kedua panggilan fungsi. Ini berarti kode kami mencoba"
" menghapus elemen pertama dua kali, yang akan mencoba menulis ke sel memori "
"yang sama dua kali - yang dilarang oleh Cairo VM, mengarah ke runtime error."
" Syukurlah, kode ini tidak benar-benar mengkompilasi. Setelah kita telah "
"melewati array fungsi ▪foo (profeo), Varia tidak lagi dapat digunakan."

#: src/ch04-01-what-is-ownership.md:125
msgid "The `Copy` Trait"
msgstr "Trait"

#: src/ch04-01-what-is-ownership.md:127
msgid ""
"If a type implements the `Copy` trait, passing a value of that type to a "
"function does not move the value. Instead, a new variable is created, "
"referring to the same value. The important thing to note here is that this "
"is a completely free operation because variables are a Cairo abstraction "
"only and because _values_ in Cairo are always immutable. This, in "
"particular, conceptually differs from the Rust version of the `Copy` trait, "
"where the value is potentially copied in memory."
msgstr ""
"Jika sebuah tipe menerapkan sifat tersebut, memberikan nilai dari sebuah "
"fungsi tidak menggerakkan nilai. Sebaliknya, sebuah variabel baru "
"diciptakan, mengacu pada nilai yang sama. Hal yang penting untuk dicatat di "
"sini adalah bahwa ini adalah operasi yang benar-benar bebas karena variabel "
"adalah abstraksi Cairo saja dan karena _vales_ Cairo selalu tidak dapat "
"berubah. Hal ini, khususnya, secara konsep yang berbeda dari versi Rust dari"
" sifat  (comp), di mana nilai tersebut berpotensi disalin dalam memori."

#: src/ch04-01-what-is-ownership.md:130
msgid ""
"All basic types previously described in [\"Data Types\"](./ch02-02-data-"
"types.md) implement by default the `Copy` trait."
msgstr ""
"Semua tipe dasar yang digambarkan sebelumnya dalam [\"Data Types\"]. "
"/ch02-02-data-types.md) mengimplementasikan secara baku ciri-cirinya."

#: src/ch04-01-what-is-ownership.md:132
msgid ""
"While Arrays and Dictionaries can't be copied, custom types that don't "
"contain either of them can be. You can implement the `Copy` trait on your "
"type by adding the `#[derive(Copy)]` annotation to your type definition. "
"However, Cairo won't allow a type to be annotated with Copy if the type "
"itself or any of its components doesn't implement the Copy trait."
msgstr ""
"Sementara Arrays dan Dictionary tidak dapat disalin, tipe kustom yang tidak "
"dapat memuat salah satu dari mereka dapat. Anda dapat mengimplementasikan "
"sifat pada tipe Anda dengan menambahkan \\u2002). Namun, Cairo tidak akan "
"membiarkan sebuah tipe dinotasi dengan Copy jika tipe itu sendiri atau salah"
" satu komponennya tidak mengimplementasikan sifat Copy."

#: src/ch04-01-what-is-ownership.md:148
msgid "// do something with p\n"
msgstr "#/ Do something with p\n"

#: src/ch04-01-what-is-ownership.md:152
msgid ""
"In this example, we can pass `p1` twice to the foo function because the "
"`Point` type implements the `Copy` trait. This means that when we pass `p1` "
"to `foo`, we are actually passing a copy of `p1`, so `p1` remains valid. In "
"ownership terms, this means that the ownership of `p1` remains with the "
"`main` function. If you remove the `Copy` trait derivation from the `Point` "
"type, you will get a compile-time error when trying to compile the code."
msgstr ""
"Dalam contoh ini, kita dapat melewati titik 1 dua kali fungsi foo karena "
"tipe foo menerapkan sifat tersebut."

#: src/ch04-01-what-is-ownership.md:155
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter "
"5](./ch05-00-using-structs-to-structure-related-data.md)._"
msgstr ""
"_Jangan khawatir tentang kata kuncinya. Kami akan memperkenalkan ini pada "
"[Chapter 5] Allahlog./ch05-00-structs-to-structural-dikaitkan-data.md)._"

#: src/ch04-01-what-is-ownership.md:160
msgid "Destroying Values - Example with FeltDict"
msgstr "Menghancurkan Nilai - Teladan dengan Perasaan"

#: src/ch04-01-what-is-ownership.md:162
msgid ""
"The other way linear types can be _used_ is by being destroyed. Destruction "
"must ensure that the 'resource' is now correctly released. In Rust, for "
"example, this could be closing the access to a file, or locking a mutex. In "
"Cairo, one type that has such behaviour is `Felt252Dict`. For provability, "
"dicts must be 'squashed' when they are destructed. This would be very easy "
"to forget, so it is enforced by the type system and the compiler."
msgstr ""
"Jenis linear lainnya dapat _used_ adalah dengan dihancurkan. Pemusnah harus "
"memastikan bahwa'resource' sekarang dibebaskan dengan benar. Di Rust, "
"misalnya, ini dapat menutup akses ke file, atau mengunci sebuah bisus. Di "
"Cairo, satu tipe yang memiliki perilaku tersebut adalah  OobetFelt252Dictic."
" Untuk provability, terdicts harus'squashed' ketika mereka dihancurkan. Ini "
"akan sangat mudah untuk melupakan, sehingga itu dipaksa oleh sistem tipe dan"
" kompiler."

#: src/ch04-01-what-is-ownership.md:166
msgid "No-op Destruction: the `Drop` Trait"
msgstr "Pemusnahan no-op: Trait"

#: src/ch04-01-what-is-ownership.md:168
msgid ""
"You may have noticed that the `Point` type in the previous example also "
"implements the `Drop` trait. For example, the following code will not "
"compile, because the struct `A` is not moved or destroyed before it goes out"
" of scope:"
msgstr ""
"Anda mungkin telah memperhatikan bahwa jenis etta dalam contoh sebelumnya "
"juga menerapkan sifat-sifat tersebut. sebagai contoh, kode berikut tidak "
"akan dikompilasi, karena struct ÉA tidak dipindahkan atau dihancurkan "
"sebelum keluar dari jangkauan:"

#: src/ch04-01-what-is-ownership.md:175
msgid "// error: Variable not dropped.\n"
msgstr "//kesalahan: Variabel tidak dijatuhkan.\n"

#: src/ch04-01-what-is-ownership.md:179
msgid ""
"However, types that implement the `Drop` trait are automatically destroyed "
"when going out of scope. This destruction does nothing, it is a no-op - "
"simply a hint to the compiler that this type can safely be destroyed once "
"it's no longer useful. We call this \"dropping\" a value."
msgstr ""
"Namun, tipe yang mengimplementasikan sifat ÉDropán secara otomatis "
"dihancurkan ketika keluar dari ruang lingkup. kehancuran ini tidak melakukan"
" apa-apa, itu adalah no-op - hanya petunjuk untuk kompiler bahwa jenis ini "
"dapat dihancurkan dengan aman setelah itu tidak lagi berguna. kami "
"menyebutnya \"menjatuhkan\" nilai."

#: src/ch04-01-what-is-ownership.md:181
msgid ""
"At the moment, the `Drop` implementation can be derived for all types, "
"allowing them to be dropped when going out of scope, except for dictionaries"
" (`Felt252Dict`) and types containing dictionaries. For example, the "
"following code compiles:"
msgstr ""
"Pada saat ini, implementasi ÉDropé dapat dibuat untuk semua jenis, "
"memungkinkan mereka untuk dijatuhkan ketika keluar dari lingkup, kecuali "
"untuk kamus (æFelt252Dict) dan tipe yang mengandung kamus. Sebagai contoh, "
"kode berikut mengkompilasi:"

#: src/ch04-01-what-is-ownership.md:189
msgid "// Now there is no error.\n"
msgstr "/Sekarang tidak ada kesalahan.\n"

#: src/ch04-01-what-is-ownership.md:193
msgid "Destruction with a Side-effect: the `Destruct` Trait"
msgstr "Penghancuran dengan efek-sisi: Trait Destruct"

#: src/ch04-01-what-is-ownership.md:195
msgid ""
"When a value is destroyed, the compiler first tries to call the `drop` "
"method on that type. If it doesn't exist, then the compiler tries to call "
"`destruct` instead. This method is provided by the `Destruct` trait."
msgstr ""
"Ketika nilai dihancurkan, kompiler pertama kali mencoba untuk memanggil "
"metode ådropé pada jenis itu. Jika tidak ada, maka kompiler mencoba untuk "
"memanggil ·destructé sebagai gantinya. Metode ini disediakan oleh sifat yang"
" didestruksikan."

#: src/ch04-01-what-is-ownership.md:197
msgid ""
"As said earlier, dictionaries in Cairo are types that must be \"squashed\" "
"when destructed, so that the sequence of access can be proven. This is easy "
"for developers to forget, so instead dictionaries implement the `Destruct` "
"trait to ensure that all dictionaries are _squashed_ when going out of "
"scope. As such, the following example will not compile:"
msgstr ""
"Seperti yang dikatakan sebelumnya, kamus di Cairo adalah tipe yang harus "
"\"dihancurkan\" ketika dihancurkan, sehingga urutan akses dapat dibuktikan."

#: src/ch04-01-what-is-ownership.md:210
msgid "If you try to run this code, you will get a compile-time error:"
msgstr ""
"Jika Anda mencoba menjalankan kode ini, Anda akan mendapatkan galat waktu "
"kompilasi:"

#: src/ch04-01-what-is-ownership.md:227
msgid ""
"When `A` goes out of scope, it can't be dropped as it implements neither the"
" `Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the "
"`Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr ""
"Ketika ia keluar dari ruang lingkup, ia tidak dapat dijatuhkan karena ia "
"tidak mengimplementasikannya baik karena ia berisi kamus dan tidak dapat "
"Éderive (proprop) maupun sifat yang terdestruksi. Untuk memperbaiki hal ini,"
" kita dapat mendapatkan implementasi sifat yang didestruksikan untuk tipe ▪A"
" TM:"

#: src/ch04-01-what-is-ownership.md:236
msgid "// No error here\n"
msgstr "# No error here\n"

#: src/ch04-01-what-is-ownership.md:240
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically "
"`squashed`, and the program will compile."
msgstr ""
"Sekarang, ketika A keluar dari ruang lingkup, kamusnya akan otomatis "
"berkubang, dan program ini akan dikompilasi."

#: src/ch04-01-what-is-ownership.md:242
msgid "Copy Array Data with `clone`"
msgstr "Salin Data Array dengan Áclone"

#: src/ch04-01-what-is-ownership.md:244
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common "
"method called `clone`. We’ll discuss method syntax in a dedicated section in"
" [Chapter 5](./ch05-03-method-syntax.md), but because methods are a common "
"feature in many programming languages, you’ve probably seen them before."
msgstr ""
"Jika kita ingin benar-benar menyalin data dari sebuah array, kita dapat "
"menggunakan metode umum yang disebut ·clonenene. kita akan membahas metode "
"sintaks dalam bagian yang didedikasikan di [Chapter 5] Allah. /ch05-method-"
"syntax.md), tetapi karena metode adalah fitur umum dalam banyak bahasa "
"pemrograman, Anda mungkin pernah melihatnya sebelumnya."

#: src/ch04-01-what-is-ownership.md:246
msgid "Here’s an example of the `clone` method in action."
msgstr "Berikut ini adalah contoh metode åclone dalam tindakan."

#: src/ch04-01-what-is-ownership.md:255
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being "
"executed and that code may be expensive. It’s a visual indicator that "
"something different is going on. In this case, the _value_ `arr1` refers to "
"is being copied, resulting in new memory cells being used, and a new "
"_variable_ `arr2` is created, referring to the new copied value."
msgstr ""
"Ketika Anda melihat panggilan ke åclone, Anda tahu bahwa beberapa kode "
"sewenang-wenang sedang dijalankan dan kode tersebut mungkin mahal. Ini "
"indikator visual yang berbeda yang sedang terjadi. Dalam hal ini, _value_ "
"·arr1; yang mengacu pada salinan, sehingga sel memori baru digunakan, dan "
"_variable_ ·ar2 yang baru dibuat, mengacu pada nilai salinan baru."

#: src/ch04-01-what-is-ownership.md:260
msgid "Return Values and Scope"
msgstr "Nilai Kembali dan Cakupan"

#: src/ch04-01-what-is-ownership.md:262
msgid ""
"Returning values is equivalent to _moving_ them. Listing 4-2 shows an "
"example of a function that returns some value, with similar annotations as "
"those in Listing 4-1."
msgstr ""
"Mengembalikan nilai setara dengan memindahkan _mereka. Mendaftarkan 4-2 "
"menampilkan sebuah contoh dari sebuah fungsi yang mengembalikan beberapa "
"nilai, dengan notasi serupa seperti yang ada dalam Daftar 4-1."

#: src/ch04-01-what-is-ownership.md:272
msgid ""
"// gives_ownership moves its return\n"
"                                          // value into a1\n"
msgstr "#/ gives_ownership moves its return // value into a1\n"

#: src/ch04-01-what-is-ownership.md:275
msgid "// a2 comes into scope\n"
msgstr "//a2 masuk ke dalam lingkup\n"

#: src/ch04-01-what-is-ownership.md:277
msgid ""
"// a2 is moved into\n"
"                                          // takes_and_gives_back, which also\n"
"                                          // moves its return value into a3\n"
msgstr ""
"#/ a2 is moved into // takes_and_gives_back, which also // moves its return "
"value into a3\n"

#: src/ch04-01-what-is-ownership.md:281
msgid ""
"// Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
msgstr ""
"# # Here, a3 goes out of scope and is dropped. a2 was moved, so nothing /// "
"happens. a1 goes out of scope and is dropp.\n"

#: src/ch04-01-what-is-ownership.md:284
msgid ""
"// gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
msgstr ""
"// gives_ownership akan memindahkan nilai//kembalinya ke dalam fungsi // "
"yang menyebutnya\n"

#: src/ch04-01-what-is-ownership.md:288 src/ch04-01-what-is-ownership.md:296
msgid "// some_a comes into scope\n"
msgstr "#/ some_a comes into scope\n"

#: src/ch04-01-what-is-ownership.md:290
msgid ""
"// some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""
"/// some_a dikembalikan dan //pindahkan kepemilikan ke panggilan // fungsi\n"

#: src/ch04-01-what-is-ownership.md:294
msgid "// This function takes an instance some_a of A and returns it\n"
msgstr "# # This function takes an instance some_a of A and return it\n"

#: src/ch04-01-what-is-ownership.md:298
msgid ""
"// some_a is returned and \n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""
"/// some_a dikembalikan dan //pindahkan kepemilikan ke panggilan // fungsi\n"

#: src/ch04-01-what-is-ownership.md:304
msgid "<span class=\"caption\">Listing 4-2: Moving return values</span>"
msgstr ""
"<span class=\"caption\">Listing 4-2: Memindahkan nilai pengembalian</span>"

#: src/ch04-01-what-is-ownership.md:306
msgid ""
"While this works, moving into and out of every function is a bit tedious. "
"What if we want to let a function use a value but not move the value? It’s "
"quite annoying that anything we pass in also needs to be passed back if we "
"want to use it again, in addition to any data resulting from the body of the"
" function that we might want to return as well."
msgstr ""
"Meskipun ini bekerja, bergerak ke dalam dan keluar dari setiap fungsi adalah"
" sedikit membosankan. bagaimana jika kita ingin membiarkan fungsi "
"menggunakan nilai tetapi tidak memindahkan nilai? sangat menjengkelkan bahwa"
" apa pun yang kita masuk juga perlu dilewatkan kembali jika kita ingin "
"menggunakannya lagi, selain data apapun yang dihasilkan dari tubuh fungsi "
"yang mungkin kita ingin kembali juga."

#: src/ch04-01-what-is-ownership.md:308
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing "
"4-3."
msgstr ""
"Cairo tidak membiarkan kita mengembalikan beberapa nilai menggunakan tuple, "
"seperti yang ditunjukkan dalam Daftar 4-3."

#: src/ch04-01-what-is-ownership.md:320
msgid "// len() returns the length of an array\n"
msgstr "//len Allah) mengembalikan panjang sebuah array\n"

#: src/ch04-01-what-is-ownership.md:326
msgid "<span class=\"caption\">Listing 4-3: Returning many values</span>"
msgstr "<span class=\"caption\">Listing 4-3: Mengembalikan banyak nilai</span>"

#: src/ch04-01-what-is-ownership.md:328
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be"
" common. Luckily for us, Cairo has two features for passing a value without "
"destroying or moving it, called _references_ and _snapshots_."
msgstr ""
"Tapi ini terlalu banyak upacara dan banyak pekerjaan untuk konsep yang harus"
" umum. Untungnya bagi kita, Cairo memiliki dua fitur untuk melewati nilai "
"tanpa menghancurkan atau memindahkannya, disebut _referensi_ dan "
"_snapshots_."

#: src/ch04-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in previous Listing 4-3 is that we have to "
"return the `Array` to the calling function so we can still use the `Array` "
"after the call to `calculate_length`, because the `Array` was moved into "
"`calculate_length`."
msgstr ""
"Masalah dengan kode tuple di Listing 4-3 sebelumnya adalah bahwa kita harus "
"kembali Array yang ke fungsi panggilan sehingga kita masih dapat menggunakan"
" thoseArray setelah panggilan ke ·calcululate_length, karena array itu "
"dipindahkan ke ▪calcululate_length_length."

#: src/ch04-02-references-and-snapshots.md:8
msgid "Snapshots"
msgstr "Snapshot"

#: src/ch04-02-references-and-snapshots.md:10
msgid ""
"In the previous chapter, we talked about how Cairo's ownership system "
"prevents us from using a variable after we've moved it, protecting us from "
"potentially writing twice to the same memory cell. However, it's not very "
"convenient. Let's see how we can retain ownership of the variable in the "
"calling function using snapshots."
msgstr ""
"Dalam bab sebelumnya, kita berbicara tentang bagaimana sistem kepemilikan "
"Cairo mencegah kita dari menggunakan variabel setelah kita memindahkannya, "
"melindungi kita dari berpotensi menulis dua kali ke sel memori yang sama. "
"namun, itu sangat tidak nyaman. mari kita lihat bagaimana kita dapat "
"mempertahankan kepemilikan variabel dalam fungsi panggilan menggunakan "
"snapshots."

#: src/ch04-02-references-and-snapshots.md:15
msgid ""
"In Cairo, a snapshot is an immutable view of a value at a certain point in "
"time. Recall that memory is immutable, so modifying a value actually creates"
" a new memory cell. The old memory cell still exists, and snapshots are "
"variables that refer to that \"old\" value. In this sense, snapshots are a "
"view \"into the past\"."
msgstr ""
"Di Cairo, sebuah snapshot adalah pandangan yang tak dapat berubah dari suatu"
" nilai pada suatu waktu. Ingatlah bahwa memori tidak dapat berubah, sehingga"
" mengubah sebuah nilai sebenarnya menciptakan sebuah sel memori baru. Sel "
"memori lama masih ada, dan snapshot adalah variabel yang mengacu ke nilai "
"\"tua.\" Dalam arti ini, snapshots adalah tampilan \"ke masa lalu.\""

#: src/ch04-02-references-and-snapshots.md:20
msgid ""
"Here is how you would define and use a `calculate_length` function that "
"takes a snapshot of an array as a parameter instead of taking ownership of "
"the underlying value. In this example, the `calculate_length` function "
"returns the length of the array passed as a parameter. As we're passing it "
"as a snapshot, which is an immutable view of the array, we can be sure that "
"the `calculate_length` function will not mutate the array, and ownership of "
"the array is kept in the `main` function."
msgstr ""
"Berikut adalah bagaimana Anda akan mendefinisikan dan menggunakan fungsi "
"·calculated_length (kalgulate_length) yang mengambil snapshot dari sebuah "
"array sebagai sebuah parameter bukan mengambil kepemilikan dari nilai yang "
"mendasarinya. Dalam contoh ini, fungsi calcululate_length_length akan "
"kembali panjang array yang melewati sebagai parameter. Ketika kita "
"melewatinya sebagai snapshot, yang merupakan pandangan yang tak dapat "
"berubah dari array, kita dapat yakin bahwa fungsi "
"▪calcululate_length_lengthate tidak akan bermutasi array, dan kepemilikan "
"array disimpan dalam fungsi valemain."

#: src/ch04-02-references-and-snapshots.md:31
msgid "// Take a snapshot of `arr1` at this point in time\n"
msgstr "#/ Take a snapshot of ör1 those at this point in time\n"

#: src/ch04-02-references-and-snapshots.md:32
msgid "// Mutate `arr1` by appending a value\n"
msgstr "//Mutate Áarr1) dengan menambahkan suatu nilai\n"

#: src/ch04-02-references-and-snapshots.md:35
msgid "// Calculate the length of the array when the snapshot was taken\n"
msgstr "//Perhitungkan panjang dari array ketika snapshot diambil\n"

#: src/ch04-02-references-and-snapshots.md:36
#: src/ch04-02-references-and-snapshots.md:67
msgid "// Calculate the current length of the array\n"
msgstr "//Perhitungkan panjang kini dari array\n"

#: src/ch04-02-references-and-snapshots.md:37
msgid "\"The length of the array when the snapshot was taken is {}\""
msgstr "\" Panjang array ketika snapshot diambil adalah {}\""

#: src/ch04-02-references-and-snapshots.md:38
msgid "\"The current length of the array is {}\""
msgstr "\" Panjang array saat ini adalah {}\""

#: src/ch04-02-references-and-snapshots.md:46
msgid ""
"Note: it is only possible to call the `len()` method on an array snapshot "
"because it is defined as such in the `ArrayTrait` trait. If you try to call "
"a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on "
"non-snapshot types."
msgstr ""
"Catatan: hanya mungkin untuk memanggil metode  mendapatkan snapshot dalam "
"array karena itu didefinisikan seperti dalam sifat ▪ArrayTraitå. Jika Anda "
"mencoba untuk memanggil metode yang tidak didefinisikan untuk snapshot pada "
"snapshot, Anda akan mendapatkan kesalahan kompilasi. Namun, Anda dapat "
"memanggil metode mengharapkan snapshot pada tipe bukan-snappshot."

#: src/ch04-02-references-and-snapshots.md:48
msgid "The output of this program is:"
msgstr "Keluaran program ini adalah:"

#: src/ch04-02-references-and-snapshots.md:61
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note that we pass `@arr1` into "
"`calculate_length` and, in its definition, we take `@Array<u128>` rather "
"than `Array<u128>`."
msgstr ""
"Pertama, perhatikan bahwa semua kode tuple dalam deklarasi variabel dan "
"nilai kembali fungsi hilang. Kedua, perhatikan bahwa kita lulus @arrr1) ke "
"dalam ·calculate_length dan, dalam definisinya, kita ambil @Array<u128>, "
"daripada Array<u128>."

#: src/ch04-02-references-and-snapshots.md:64
msgid "Let’s take a closer look at the function call here:"
msgstr "Mari kita lihat lebih dekat pada panggilan fungsi di sini:"

#: src/ch04-02-references-and-snapshots.md:70
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because"
" a snapshot is an immutable view of a value at a specific point in time, the"
" usual rules of the linear type system are not enforced. In particular, "
"snapshot variables always implement the `Drop` trait, never the `Destruct` "
"trait, even dictionary snapshots."
msgstr ""
"Sintaks @arr1) memungkinkan kita membuat snapshot dari nilai dalam ·arr1. "
"Karena sebuah snapshot adalah pandangan yang tak dapat berubah dari nilai "
"pada suatu titik tertentu dalam waktu tertentu, aturan biasa dari sistem "
"tipe linear tidak dipaksakan. Secara khusus, variabel snapshot selalu "
"mengimplementasikan sifat ådropía, tidak pernah merusak sifat kamus, bahkan "
"snapshots kamus."

#: src/ch04-02-references-and-snapshots.md:72
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type "
"of the parameter `arr` is a snapshot. Let’s add some explanatory "
"annotations:"
msgstr ""
"Serupa dengan itu, tanda tangan dari fungsi tersebut menggunakan <@) untuk "
"menunjukkan bahwa tipe parameternya adalah sebuah snapshot. Mari kita "
"tambahkan beberapa penjelasan:"

#: src/ch04-02-references-and-snapshots.md:76
msgid "// array_snapshot is a snapshot of an Array\n"
msgstr "// array_snapshot adalah snapshot dari sebuah Array\n"

#: src/ch04-02-references-and-snapshots.md:79
msgid ""
"// Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` contains, the original `arr` can still be used.\n"
msgstr ""
"//Di sini, array_snapshot keluar dari lingkup dan dijatuhkan. / Namun, "
"karena itu hanya pandangan dari apa yang asli array yang ada, yang asli "
"masih dapat digunakan.\n"

#: src/ch04-02-references-and-snapshots.md:83
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any"
" function parameter’s scope, but the underlying value of the snapshot is not"
" dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to "
"return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""
"Lingkup di mana variabel ·array_snapshoté valid sama dengan lingkup "
"parameter fungsi apapun, tetapi nilai dasar dari snapshot tidak dijatuhkan "
"ketika ·array_snappshot_s berhenti digunakan. Ketika fungsi memiliki "
"snapshots sebagai parameter daripada nilai sebenarnya, kita tidak perlu "
"mengembalikan nilai dalam rangka untuk memberikan kepemilikan kembali dari "
"nilai asli, karena kita tidak pernah memilikinya."

#: src/ch04-02-references-and-snapshots.md:85
msgid "Desnap Operator"
msgstr "Operator Desnap"

#: src/ch04-02-references-and-snapshots.md:87
msgid ""
"To convert a snapshot back into a regular variable, you can use the `desnap`"
" operator `*`, which serves as the opposite of the `@` operator."
msgstr ""
"Untuk mengubah snapshot kembali ke variabel biasa, Anda dapat menggunakan "
"operator ådesnapé, yang berfungsi sebagai kebalikan dari operator."

#: src/ch04-02-references-and-snapshots.md:89
msgid ""
"Only `Copy` types can be desnapped. However, in the general case, because "
"the value is not modified, the new variable created by the `desnap` operator"
" reuses the old value, and so desnapping is a completely free operation, "
"just like `Copy`."
msgstr ""
"Namun, dalam kasus umum, karena nilai tersebut tidak diubah, variabel baru "
"yang dibuat oleh operator yang menggunakan kembali nilai lama, sehingga "
"desnapping adalah operasi bebas sepenuhnya, sama seperti Connell."

#: src/ch04-02-references-and-snapshots.md:91
msgid ""
"In the following example, we want to calculate the area of a rectangle, but "
"we don't want to take ownership of the rectangle in the `calculate_area` "
"function, because we might want to use the rectangle again after the "
"function call. Since our function doesn't mutate the rectangle instance, we "
"can pass the snapshot of the rectangle to the function, and then transform "
"the snapshots back into values using the `desnap` operator `*`."
msgstr ""
"Dalam contoh berikut, kami ingin menghitung luas persegi panjang, tapi kami "
"tidak ingin mengambil kepemilikan persegi panjang dalam fungsi "
"·calcululate_areaá, karena kami mungkin ingin menggunakan persegi panjang "
"lagi setelah panggilan fungsi. karena fungsi kami tidak dapat mengubah "
"snapshot dari rectule ke fungsi, dan kemudian mengubah foto-foto kembali "
"menjadi nilai-nilai menggunakan operator Ásnapáno."

#: src/ch04-02-references-and-snapshots.md:103
msgid "\"Area: {}\""
msgstr "\"Area: [}\""

#: src/ch04-02-references-and-snapshots.md:107
msgid ""
"// As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.\n"
"    // We need to transform the snapshots back into values using the desnap operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.\n"
msgstr ""
"//Seperti recc adalah snapshot ke rectangle, bidangnya juga merupakan foto "
"dari jenis bidang. /Kita perlu mengubah snapshot kembali ke nilai "
"menggunakan operator desnap*. /Hal ini hanya mungkin jika jenisnya dapat "
"disalin, yang merupakan kasus untuk u64. / Di sini, digunakan untuk "
"memperkalian tinggi dan lebar dan untuk meniru snapshots.\n"

#: src/ch04-02-references-and-snapshots.md:115
msgid ""
"But, what happens if we try to modify something we’re passing as a snapshot?"
" Try the code in Listing 4-4. Spoiler alert: it doesn’t work!"
msgstr ""
"Tapi, apa yang terjadi jika kita mencoba mengubah sesuatu yang kita lewati "
"sebagai foto?"

#: src/ch04-02-references-and-snapshots.md:140
msgid ""
"<span class=\"caption\">Listing 4-4: Attempting to modify a snapshot "
"value</span>"
msgstr ""
"<span class=\"caption\">Listing 4-4: Mencoba untuk mengubah nilai "
"snapshot</span>"

#: src/ch04-02-references-and-snapshots.md:142
msgid "Here’s the error:"
msgstr "Ini kesalahannya:"

#: src/ch04-02-references-and-snapshots.md:162
msgid ""
"The compiler prevents us from modifying values associated to snapshots."
msgstr ""
"kompiler mencegah kita dari mengubah nilai yang terkait dengan snapshot."

#: src/ch04-02-references-and-snapshots.md:164
msgid "Mutable References"
msgstr "Referensi yang Dapat Dimutasi"

#: src/ch04-02-references-and-snapshots.md:166
msgid ""
"We can achieve the behavior we want in Listing 4-4 by using a _mutable "
"reference_ instead of a snapshot. Mutable references are actually mutable "
"values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they "
"allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution. In Cairo, a "
"parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""
"Kita dapat mencapai perilaku yang kita inginkan di Listing 4-4 dengan "
"menggunakan referensi _mutable_ bukan sebuah snapshot. referensi yang dapat "
"diubah sebenarnya dilewatkan ke sebuah fungsi yang secara implisit "
"dikembalikan pada akhir fungsi, mengembalikan kepemilikan ke konteks "
"panggilan. Dengan melakukan itu, mereka memungkinkan Anda untuk mengubah "
"nilai yang diberikan saat menjaga kepemilikannya dengan mengembalikannya "
"secara otomatis pada akhir eksekusi. Di Cairo, parameter dapat dilewatkan "
"sebagai _muable reference_ menggunakan pemodifikasi."

#: src/ch04-02-references-and-snapshots.md:169
msgid ""
"**Note**: In Cairo, a parameter can only be passed as _mutable reference_ "
"using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""
"**Note**: Di Cairo, sebuah parameter hanya dapat dilewatkan sebagai "
"referensi _mutable_ menggunakan pemodifikasi ·refé jika variabel "
"dideklarasikan dapat dimutasi dengan thosemuté."

#: src/ch04-02-references-and-snapshots.md:171
msgid ""
"In Listing 4-5, we use a mutable reference to modify the value of the "
"`height` and `width` fields of the `Rectangle` instance in the `flip` "
"function."
msgstr ""
"Di Listing 4-5, kami menggunakan referensi yang dapat berubah untuk mengubah"
" nilai dari fungsi åflip."

#: src/ch04-02-references-and-snapshots.md:183
msgid "\"height: {}, width: {}\""
msgstr "\"tinggi: {}, lebar: {}\""

#: src/ch04-02-references-and-snapshots.md:193
msgid ""
"<span class=\"caption\">Listing 4-5: Use of a mutable reference to modify a "
"value</span>"
msgstr ""
"<span class=\"caption\">Listing 4-5: Gunakan dari sebuah referensi mutable "
"untuk mengubah nilai</span>"

#: src/ch04-02-references-and-snapshots.md:195
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of "
"`rec` into `flip` with `ref rec`, and update the function signature to "
"accept a mutable reference with `ref rec: Rectangle`. This makes it very "
"clear that the `flip` function will mutate the value of the `Rectangle` "
"instance passed as parameter."
msgstr ""
"Pertama-tama, kita mengubah diri kita menjadi mutét. lalu kita menyampaikan "
"referensi yang dapat diubah dari ·recé ke dalam ·flip dengan recé, dan "
"memperbarui tanda tangan fungsi untuk menerima referensi mutabel dengan "
"recref: rectangle. Hal ini membuat sangat jelas bahwa fungsi flip yang akan "
"bermutasi nilai dari ÁRectle yang telah diberikan sebagai parameter."

#: src/ch04-02-references-and-snapshots.md:197
msgid "The output of the program is:"
msgstr "Keluaran program ini adalah:"

#: src/ch04-02-references-and-snapshots.md:209
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been"
" swapped."
msgstr ""
"Seperti yang diharapkan, luas dan lebar bidang dari variabel recés telah "
"ditukar."

#: src/ch04-02-references-and-snapshots.md:211
msgid "{{#quiz ../quizzes/ch04-02-references-and-snapshots.toml}}"
msgstr "{{#quiz../quizzes/ch04-02-references-and-snapsshots.toml}}}"

#: src/ch04-02-references-and-snapshots.md:213
msgid "Small Recap"
msgstr "Kecil Recap"

#: src/ch04-02-references-and-snapshots.md:215
msgid ""
"Let’s recap what we’ve discussed about the linear type system, ownership, "
"snapshots, and references:"
msgstr ""
"Mari kita ulangi apa yang telah kita bahas tentang sistem linear, "
"kepemilikan, snapshot, dan referensi:"

#: src/ch04-02-references-and-snapshots.md:217
msgid "At any given time, a variable can only have one owner."
msgstr "Pada setiap waktu, variabel hanya dapat memiliki satu pemilik."

#: src/ch04-02-references-and-snapshots.md:218
msgid ""
"You can pass a variable by-value, by-snapshot, or by-reference to a "
"function."
msgstr ""
"Anda dapat melewati variabel dengan nilai, dengan-snapshot, atau dengan-"
"referensi ke sebuah fungsi."

#: src/ch04-02-references-and-snapshots.md:219
msgid ""
"If you pass-by-value, ownership of the variable is transferred to the "
"function."
msgstr ""
"Jika Anda lulus-oleh-nilai, kepemilikan variabel ditransfer ke fungsi."

#: src/ch04-02-references-and-snapshots.md:220
msgid ""
"If you want to keep ownership of the variable and know that your function "
"won’t mutate it, you can pass it as a snapshot with `@`."
msgstr ""
"Jika Anda ingin tetap memiliki variabel dan tahu bahwa fungsi Anda tidak "
"akan bermutasi itu, Anda dapat melewatinya sebagai snapshot dengan@awi."

#: src/ch04-02-references-and-snapshots.md:221
msgid ""
"If you want to keep ownership of the variable and know that your function "
"will mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""
"Jika Anda ingin tetap memiliki variabel dan tahu bahwa fungsi Anda akan "
"bermutasi itu, Anda dapat melewatinya sebagai referensi yang dapat berubah "
"dengan ·refé."

#: src/ch05-00-using-structs-to-structure-related-data.md
msgid ""
"A struct, or structure, is a custom data type that lets you package together"
" and name multiple related values that make up a meaningful group. If you’re"
" familiar with an object-oriented language, a struct is like an object’s "
"data attributes. In this chapter, we’ll compare and contrast tuples with "
"structs to build on what you already know and demonstrate when structs are a"
" better way to group data."
msgstr ""
"Sebuah struktur, atau struktur, adalah tipe data gubahan yang memungkinkan "
"Anda mempack bersama-sama dan menyebutkan beberapa nilai terkait yang "
"membentuk grup yang bermakna. Jika Anda terbiasa dengan bahasa yang "
"berorientasi objek, sebuah struktur adalah seperti objek yang atribut data. "
"Dalam bab ini, kita akan membandingkan dan mengontraskan tuples dengan "
"struktur untuk membangun pada apa yang sudah Anda ketahui dan menunjukkan "
"ketika struktur adalah cara yang lebih baik untuk grup data."

#: src/ch05-00-using-structs-to-structure-related-data.md
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called methods, to specify behavior associated with a struct type. Structs "
"and enums (discussed in the [next chapter](ch06-01-enums.md)) are the "
"building blocks for creating new types in your program’s domain to take full"
" advantage of Cairo's compile-time type checking."
msgstr ""
"Kami akan mendemonstrasikan bagaimana mendefinisikan dan menstruktur instan."
" kami akan membahas bagaimana mendefinisikan fungsi yang terkait, khususnya "
"jenis fungsi yang terkait yang disebut metode, untuk menentukan perilaku "
"yang terkait dengan tipe struktur. Struktur dan enums (didiskusikan dalam "
"bab berikutnya][wreums-01-enums.md) adalah blok bangunan untuk menciptakan "
"jenis baru dalam program anda domain untuk mengambil keuntungan penuh dari "
"pengesahan tipe waktu kompilasi Cairo."

#: src/ch05-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in the [Data Types](ch02-02-data-"
"types.md) section, in that both hold multiple related values. Like tuples, "
"the pieces of a struct can be different types. Unlike with tuples, in a "
"struct you’ll name each piece of data so it’s clear what the values mean. "
"Adding these names means that structs are more flexible than tuples: you "
"don’t have to rely on the order of the data to specify or access the values "
"of an instance."
msgstr ""
"Structs mirip dengan tuples, yang dibahas di bagian [Data Types] (Data "
"Types] (Data-02-data-types.md), dalam hal kedua nilai yang terkait. Seperti "
"tuples, potongan-potongan struktur dapat berbeda. Tidak seperti dengan "
"tuples, dalam structural nama anda setiap bagian dari data sehingga itu "
"jelas apa arti nilai-nilai. Menambahkan nama-nama ini berarti bahwa struktur"
" lebih fleksibel dari tuples: anda tidak harus mengandalkan urutan data "
"untuk menentukan atau menspesifikasikan nilai-nilai suatu contoh."

#: src/ch05-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call fields. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""
"Untuk mendefinisikan sebuah struktur, kita masukkan kata kunci ·structé dan "
"namakan seluruh struktur. Nama struct harus menjelaskan arti penting dari "
"potongan-potongan data yang dikelompokkan bersama-sama. Kemudian, di dalam "
"braket keriting, kita mendefinisikan nama dan jenis-jenis dari potongan "
"data, yang kita sebut field. Sebagai contoh, Mendaftar 5-1 menunjukkan "
"struktur informasi tentang akun pengguna."

#: src/ch05-01-defining-and-instantiating-structs.md:20
msgid "<span class=\"caption\">Listing 5-1: A `User` struct definition</span>"
msgstr "<span class=\"caption\">Listing 5-1: Sebuah definisi struktur </span>"

#: src/ch05-01-defining-and-instantiating-structs.md:22
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for"
" the type, and instances fill in that template with particular data to "
"create values of the type."
msgstr ""
"Untuk menggunakan sebuah struktur setelah kami mendefinisikannya, kami "
"membuat sebuah _instance_ dari struktur itu dengan menspesifikasikan nilai "
"beton untuk setiap bidang. Kami membuat suatu contoh dengan menyatakan nama "
"struct dan kemudian menambahkan cucket keriting yang berisi _key: "
"nilai_pasang, di mana kunci adalah nama dari bidang dan nilai-nilai adalah "
"data yang ingin kami simpan di bidang tersebut. Kita tidak perlu "
"menspesifikasikan bidang-bidang tersebut dalam urutan yang sama di mana kita"
" menyatakan mereka dalam struktur. Dalam kata lain, definisi struktur adalah"
" seperti template umum untuk tipe, dan contoh mengisi data dengan tipe "
"tertentu untuk membuat nilai-nilai tersebut."

#: src/ch05-01-defining-and-instantiating-structs.md:25
msgid ""
"For example, we can declare two particular users as shown in Listing 5-2."
msgstr ""
"Misalnya, kita dapat menyatakan dua pengguna khusus seperti yang ditunjukkan"
" dalam Listing 5-2."

#: src/ch05-01-defining-and-instantiating-structs.md:40
#: src/ch05-01-defining-and-instantiating-structs.md:43
#: src/ch05-01-defining-and-instantiating-structs.md:65
#: src/ch05-01-defining-and-instantiating-structs.md:101
#: src/ch05-01-defining-and-instantiating-structs.md:137
#: src/ch05-01-defining-and-instantiating-structs.md:182
#: src/ch05-01-defining-and-instantiating-structs.md:219
msgid "\"someusername123\""
msgstr "\"someusername123\""

#: src/ch05-01-defining-and-instantiating-structs.md:40
#: src/ch05-01-defining-and-instantiating-structs.md:43
#: src/ch05-01-defining-and-instantiating-structs.md:65
#: src/ch05-01-defining-and-instantiating-structs.md:101
#: src/ch05-01-defining-and-instantiating-structs.md:137
#: src/ch05-01-defining-and-instantiating-structs.md:182
#: src/ch05-01-defining-and-instantiating-structs.md:219
msgid "\"someone@example.com\""
msgstr "\"Seseorang@example.com\""

#: src/ch05-01-defining-and-instantiating-structs.md:49
msgid ""
"<span class=\"caption\">Listing 5-2: Creating two instances of the `User` "
"struct</span>"
msgstr ""
"<span class=\"caption\">Listing 5-2: Membuat dua contoh dari ▪Userå "
"struct</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:51
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access `user1`'s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email`"
" field of a mutable `User` instance."
msgstr ""
"Untuk mendapatkan nilai spesifik dari sebuah struct, kita menggunakan notasi"
" titik. Sebagai contoh, untuk mengakses alamat email ·user1, kita "
"menggunakan åuser1.email. Jika contoh ini dapat dimutasi, kita dapat "
"mengubah nilai dengan menggunakan notasi titik dan menetapkan ke bidang "
"tertentu. Daftar 5-3 menunjukkan bagaimana mengubah nilai dalam medan yang "
"dapat dimutasikan dengan sebuah contoh User."

#: src/ch05-01-defining-and-instantiating-structs.md:67
#: src/ch05-01-defining-and-instantiating-structs.md:103
#: src/ch05-01-defining-and-instantiating-structs.md:139
msgid "\"anotheremail@example.com\""
msgstr "\"exemail@example.com\""

#: src/ch05-01-defining-and-instantiating-structs.md:81
msgid ""
"<span class=\"caption\">Listing 5-3: Changing the value in the email field "
"of a `User` instance</span>"
msgstr ""
"<span class=\"caption\">Listing 5-3: Mengubah nilai dalam ruas surel dari "
"sebuah User_Instance</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:83
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to "
"mark only certain fields as mutable."
msgstr ""
"Perhatikan bahwa seluruh contoh harus bermutasi; Cairo tidak memungkinkan "
"kita untuk menandai hanya bidang tertentu sebagai mutable."

#: src/ch05-01-defining-and-instantiating-structs.md:85
msgid ""
"As with any expression, we can construct a new instance of the struct as the"
" last expression in the function body to implicitly return that new "
"instance."
msgstr ""
"Seperti dengan ekspresi apapun, kita dapat membangun sebuah contoh baru dari"
" struktur sebagai ekspresi terakhir dalam tubuh fungsi untuk secara implisit"
" kembali bahwa contoh baru."

#: src/ch05-01-defining-and-instantiating-structs.md:87
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""
"Daftar 5-4 menunjukkan sebuah fungsi Ábuild_useré yang mengembalikan sebuah "
"contoh User_user dengan nama surel dan pengguna yang diberikan. ruas yang "
"aktif mendapat nilai dari Á1."

#: src/ch05-01-defining-and-instantiating-structs.md:117
msgid ""
"<span class=\"caption\">Listing 5-4: A `build_user` function that takes an "
"email and username and returns a `User` instance.</span>"
msgstr ""
"<span class=\"caption\">Listing 5-4: Sebuah fungsi yang dibangun_userå yang "
"mengambil sebuah email dan nama pengguna dan mengembalikan sebuah instance "
"User.</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:119
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""
"Masuk akal untuk menamai parameter fungsi dengan nama yang sama dengan "
"bidang struct, tetapi harus mengulangi åemail åeername dan nama-nama dan "
"variabel agak membosankan. Jika struktur memiliki lebih banyak bidang, "
"mengulangi setiap nama akan mendapatkan lebih menjengkelkan."

#: src/ch05-01-defining-and-instantiating-structs.md:121
msgid "Using the Field Init Shorthand"
msgstr "Menggunakan Field Imnit Shorthand"

#: src/ch05-01-defining-and-instantiating-structs.md:123
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the field init shorthand syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 5-5."
msgstr ""
"Karena nama parameter dan nama struct field persis sama dalam Listing 5-4, "
"kita dapat menggunakan field init sintaks pendek tangan untuk menulis ulang "
"åuser_user--sehingga berperilaku persis sama tetapi tidak memiliki "
"pengulangan dari ▪usernameà dan ıemail à, seperti yang ditunjukkan dalam "
"Listing 5-5."

#: src/ch05-01-defining-and-instantiating-structs.md:153
msgid ""
"<span class=\"caption\">Listing 5-5: A `build_user` function that uses field"
" init shorthand because the `username` and `email` parameters have the same "
"name as struct fields.</span>"
msgstr ""
"<span class=\"caption\">Listing 5-5: A Ábuild_useró fungsi yang menggunakan "
"tangan pendek field init karena parameter ·userà dan ·email memiliki nama "
"yang sama dengan bidang struktur.</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:155
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""
"Di sini, kita akan membuat contoh baru dari struktur User, yang memiliki "
"bidang yang bernama ·email. kita ingin mengatur parameter medan yang sama, "
"kita hanya perlu menulis di email daripada email: email."

#: src/ch05-01-defining-and-instantiating-structs.md:157
msgid "Creating Instances from Other Instances with Struct Update Syntax"
msgstr ""
"Membuat Instansi dari Instances Lain dengan Sintaks Pemutakhiran Struct"

#: src/ch05-01-defining-and-instantiating-structs.md:159
msgid ""
"It’s often useful to create a new instance of a struct that includes most of"
" the values from another instance, but changes some. You can do this using "
"_struct update syntax_."
msgstr ""
"Sering kali sangat berguna untuk membuat contoh baru dari sebuah struktur "
"yang mencakup sebagian besar nilai dari contoh lain, tetapi mengubah "
"beberapa. Anda dapat melakukan ini menggunakan sintaks pemutakhiran "
"_struct_."

#: src/ch05-01-defining-and-instantiating-structs.md:163
msgid ""
"First, in Listing 5-6 we show how to create a new `User` instance in `user2`"
" regularly, without the update syntax. We set a new value for `email` but "
"otherwise use the same values from `user1` that we created in Listing 5-2."
msgstr ""
"Pertama, di Listing 5-6 kita menunjukkan bagaimana untuk membuat sebuah "
"contoh User yang baru secara teratur, tanpa sintaks update. kita menetapkan "
"nilai baru untuk email tetapi jika tidak menggunakan nilai yang sama dari "
"▪user1▪ yang kita buat dalam Listing 5-2."

#: src/ch05-01-defining-and-instantiating-structs.md:179
#: src/ch05-01-defining-and-instantiating-structs.md:216
msgid "// --snip--\n"
msgstr "/ --snip--\n"

#: src/ch05-01-defining-and-instantiating-structs.md:188
#: src/ch05-01-defining-and-instantiating-structs.md:222
msgid "\"another@example.com\""
msgstr "\"@example.com\" lain"

#: src/ch05-01-defining-and-instantiating-structs.md:197
msgid ""
"<span class=\"caption\">Listing 5-6: Creating a new `User` instance using "
"all but one of the values from `user1`</span>"
msgstr ""
"<span class=\"caption\">Listing 5-6: Membuat sebuah contoh baru menggunakan "
"semua tapi salah satu nilai dari </span>"

#: src/ch05-01-defining-and-instantiating-structs.md:199
msgid ""
"Using struct update syntax, we can achieve the same effect with less code, "
"as shown in Listing 5-7. The syntax `..` specifies that the remaining fields"
" not explicitly set should have the same value as the fields in the given "
"instance."
msgstr ""
"Menggunakan sintaks pemutakhiran struktur, kita dapat mencapai efek yang "
"sama dengan kode yang lebih sedikit, seperti yang ditunjukkan dalam Listing "
"5-7. Sintaks..spesifikasikan bahwa bagian-bagian yang tersisa tidak secara "
"eksplisit diset harus memiliki nilai yang sama dengan ruas yang diberikan."

#: src/ch05-01-defining-and-instantiating-structs.md:229
msgid ""
"<span class=\"caption\">Listing 5-7: Using struct update syntax to set a new"
" `email` value for a `User` instance but to use the rest of the values from "
"`user1`</span>"
msgstr ""
"<span class=\"caption\">Listing 5-7: Menggunakan sintaks update struct untuk"
" mengatur nilai baru </span>"

#: src/ch05-01-defining-and-instantiating-structs.md:232
msgid ""
"The code in Listing 5-7 also creates an instance of `user2` that has a "
"different value for `email` but has the same values for the `username`, "
"`active`, and `sign_in_count` fields as `user1`. The `..user1` part must "
"come last to specify that any remaining fields should get their values from "
"the corresponding fields in `user1`, but we can choose to specify values for"
" as many fields as we want in any order, regardless of the order of the "
"fields in the struct’s definition."
msgstr ""
"Kode di Listing 5-7 juga menciptakan sebuah contoh dari Án_in_count bidang "
"yang memiliki nilai yang berbeda untuk åemail..user1 bagian harus datang "
"terakhir untuk menentukan bahwa setiap bidang yang tersisa harus mendapatkan"
" nilai-nilai mereka dari ▪ Áuser1, tapi kita dapat memilih untuk menentukan "
"nilai-nilai sebanyak yang kita inginkan, terlepas dari urutan struktur "
"bidang."

#: src/ch05-01-defining-and-instantiating-structs.md:240
msgid ""
"Note that the struct update syntax uses `=` like an assignment; this is "
"because it moves the data, just as we saw in the [\"Moving "
"Values\"](ch04-01-what-is-ownership.md#moving-values)<!-- ignore --> "
"section. In this example, we can no longer use `user1` as a whole after "
"creating `user2` because the `ByteArray` in the `username` field of `user1` "
"was moved into `user2`. If we had given `user2` new `ByteArray` values for "
"both `email` and `username`, and thus only used the `active` and "
"`sign_in_count` values from `user1`, then `user1` would still be valid after"
" creating `user2`. Both `active` and `sign_in_count` are types that "
"implement the `Copy` trait, so the behavior we discussed in the [\"`Copy` "
"Trait\"](ch04-01-what-is-ownership.md#the-copy-trait)<!-- ignore --> section"
" would apply."
msgstr ""
"Perhatikan bahwa struct update syntax menggunakan sintaks.=seperti sebuah "
"tugas; ini adalah karena ia memindahkan data, seperti yang kita lihat dalam "
"[\"Moving Vales\"] (Ukraych04-01-what-is-ownership.md#moving-nilai)<!-- "
"abaikan --> bagian. Dalam contoh ini, kita tidak dapat lagi menggunakan "
"thoseer1 user1 setelah menciptakan nilai-nilai ías2] karena aluncheArray di "
"bidang auxername íauser1;"

#: src/ch05-01-defining-and-instantiating-structs.md:249
msgid "{{#quiz ../quizzes/ch05-01-defining-and-instantiating-structs.toml}}"
msgstr "{{#quiz../quizzes/ch05-01-defining-and-instansi-struct.toml}}}"

#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr ""
"Untuk memahami kapan kita mungkin ingin menggunakan struct, mari kita tulis "
"sebuah program yang menghitung area dari persegi panjang. kita akan mulai "
"dengan menggunakan variabel tunggal, dan kemudian merefaktor program sampai "
"kita menggunakan struktur sebagai gantinya."

#: src/ch05-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the "
"width and height of a rectangle specified in pixels and calculate the area "
"of the rectangle. Listing 5-8 shows a short program with one way of doing "
"exactly that in our project’s _src/lib.cairo_."
msgstr ""
"Lets make a new project with Scarb calling _rectangles_ that will take the "
"wide and height of a recntangle dispesifikasikan dalam piksel dan menghitung"
" area of the recntangle. Listing 5-8 shows a short program with one way of "
"doing extect that in our projectbahes _src/lib.cairo_."

#: src/ch05-02-an-example-program-using-structs.md:14
#: src/ch05-02-an-example-program-using-structs.md:56
#: src/ch05-02-an-example-program-using-structs.md:86
#: src/ch05-03-method-syntax.md:28 src/ch05-03-method-syntax.md:70
msgid "\"Area is {}\""
msgstr "\"Area adalah [}\""

#: src/ch05-02-an-example-program-using-structs.md:22
msgid ""
"<span class=\"caption\">Listing 5-8: Calculating the area of a rectangle "
"specified by separate width and height variables.</span>"
msgstr ""
"<span class=\"caption\">Listing 5-8: Menghitung area dari sebuah persegi "
"panjang dispesifikasikan dengan variabel lebar dan tinggi terpisah.</span>"

#: src/ch05-02-an-example-program-using-structs.md:24
msgid "Now run the program with `scarb cairo-run`:"
msgstr "Sekarang jalankan programnya dengan cairo-run:"

#: src/ch05-02-an-example-program-using-structs.md:36
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr ""
"Kode ini berhasil dalam mencari tahu luas persegi panjang dengan memanggil "
"fungsi åareaé dengan setiap dimensi, tetapi kita dapat berbuat lebih banyak "
"untuk membuat kode ini jelas dan dapat dibaca."

#: src/ch05-02-an-example-program-using-structs.md:38
msgid "The issue with this code is evident in the signature of `area`:"
msgstr "Masalah dengan kode ini jelas terlihat dalam tanda tangan åarea--"

#: src/ch05-02-an-example-program-using-structs.md:44
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our"
" program that the parameters are related. It would be more readable and more"
" manageable to group width and height together. We’ve already discussed one "
"way we might do that in the [Tuple Section of Chapter 2](ch02-02-data-"
"types.html#the-tuple-type)."
msgstr ""
"Fungsi ini seharusnya dapat dihitung dari satu segi persegi panjang, tetapi "
"fungsi yang kita tulis memiliki dua parameter, dan tidak jelas di mana saja "
"dalam program kita bahwa parameter terkait. akan lebih mudah dibaca dan "
"lebih mudah dikelola pada lebar dan tinggi kelompok. kita sudah membahas "
"satu cara kita dapat melakukannya dalam [Tuple Bagian Bab "
"2.34ch02-types.html#tu-type)."

#: src/ch05-02-an-example-program-using-structs.md:46
msgid "Refactoring with Tuples"
msgstr "Refaktor dengan Tuples"

#: src/ch05-02-an-example-program-using-structs.md:48
msgid "Listing 5-9 shows another version of our program that uses tuples."
msgstr ""
"Daftar 5-9 menunjukkan versi lain dari program kami yang menggunakan tuples."

#: src/ch05-02-an-example-program-using-structs.md:65
msgid ""
"<span class=\"caption\">Listing 5-9: Specifying the width and height of the "
"rectangle with a tuple.</span>"
msgstr ""
"<span class=\"caption\">Listing 5-9: Spesifikasikan lebar dan tinggi dari "
"persegi panjang dengan sebuah tuple.</span>"

#: src/ch05-02-an-example-program-using-structs.md:67
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is"
" less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""
"Dengan satu cara, program ini lebih baik. dan sekarang kita hanya melewati "
"satu argumen. tapi dengan cara lain, versi ini kurang jelas: tuples tidak "
"menyebutkan elemen mereka, jadi kita harus mengindeks ke bagian-bagian "
"tuple, membuat perhitungan kita kurang jelas."

#: src/ch05-02-an-example-program-using-structs.md:69
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but"
" if we want to calculate the difference, it would matter! We would have to "
"keep in mind that `width` is the tuple index `0` and `height` is the tuple "
"index `1`. This would be even harder for someone else to figure out and keep"
" in mind if they were to use our code. Because we haven’t conveyed the "
"meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""
"Mencampur lebar dan tinggi tidak akan peduli untuk perhitungan daerah, "
"tetapi jika kita ingin menghitung perbedaan, itu akan penting! karena kita "
"belum menyampaikan makna data kita dalam kode kita, ini akan lebih mudah "
"untuk menyampaikan kesalahan."

#: src/ch05-02-an-example-program-using-structs.md:71
msgid "Refactoring with Structs: Adding More Meaning"
msgstr "Refaktor dengan Structs: Menambahkan Lebih banyak Arti"

#: src/ch05-02-an-example-program-using-structs.md:73
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts."
msgstr ""
"Kita dapat mengubah tuple yang kita gunakan menjadi struct dengan nama untuk"
" keseluruhan dan juga nama untuk bagian-bagiannya."

#: src/ch05-02-an-example-program-using-structs.md:94
msgid ""
"<span class=\"caption\">Listing 5-10: Defining a `Rectangle` struct.</span>"
msgstr ""
"<span class=\"caption\">Listing 5-10: Definisi sebuah ▪Rectangleáne "
"struct.</span>"

#: src/ch05-02-an-example-program-using-structs.md:96
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u64`. Then, in `main`, we created a particular instance of `Rectangle`"
" that has a width of `30` and a height of `10`. Our `area` function is now "
"defined with one parameter, which we’ve named `rectangle` which is of type "
"`Rectangle` struct. We can then access the fields of the instance with dot "
"notation, and it gives descriptive names to the values rather than using the"
" tuple index values of `0` and `1`."
msgstr ""
"Di sini kita mendefinisikan struct dan menamainya Rectangle. di dalam braket"
" keriting, kita mendefinisikan bidang-bidangnya sebagai struktur yang dapat "
"didefinisikan sebagai struktur, yang keduanya memiliki tipe dan dinamainya. "
"Kemudian, di thosemain, kita membuat contoh khusus dari thoserangle yang "
"memiliki lebar 30 dan tinggi medan yang sama dengan 10. Fungsi kita sekarang"
" didefinisikan dengan satu parameter, yang kita namai rectgle yang merupakan"
" tipe Rectangle."

#: src/ch05-02-an-example-program-using-structs.md:98
msgid "{{#quiz ../quizzes/ch05-02-an-example-program-using-structs.toml}}"
msgstr "{{#quiz../quizzes/ch05-02-an-example-program-withing-structs.toml}}"

#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a name, they can have parameters and a return value, and they contain "
"some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a struct (or an enum "
"which we cover in [Chapter 6](./ch06-01-enums.md)), and their first "
"parameter is always `self`, which represents the instance of the type the "
"method is being called on."
msgstr ""
"_Metods_ serupa dengan fungsi: kita menyatakan mereka dengan kata kunci dan "
"nama, mereka dapat memiliki parameter dan nilai kembali, dan mereka berisi "
"beberapa kode yang menjalankan ketika metode dipanggil dari tempat lain. "
"Tidak seperti fungsi, metode didefinisikan dalam konteks dari sebuah "
"struktur (atau enum yang kita meliputi [Chapter 6]./ch06-enums-m), dan "
"parameter pertama mereka selalu oryself, yang merupakan contoh dari tipe "
"metode yang sedang dipanggil."

#: src/ch05-03-method-syntax.md:5
msgid "Defining Methods"
msgstr "Metode Definisi"

#: src/ch05-03-method-syntax.md:7
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter and instead make an `area` method defined on the `Rectangle` "
"struct, as shown in Listing 5-11"
msgstr ""
"Mari kita ubah fungsi yang memiliki sebuah Rectangle sebagai parameter dan "
"sebagai gantinya buatlah sebuah metode yang didefinisikan pada struktur "
"Rectangle, seperti yang ditunjukkan dalam Listing 5-11"

#: src/ch05-03-method-syntax.md:32
msgid "Listing 5-11: Defining an `area` method on the `Rectangle` struct."
msgstr ""
"Terdaftar 5-11: Mendefinisikan sebuah metode Áareaé pada struktur Rectangle."

#: src/ch05-03-method-syntax.md:34
msgid ""
"To define the function within the context of `Rectangle`, we start an `impl`"
" (implementation) block for a trait `RectangleTrait` that defines the "
"methods that can be called on a `Rectangle` instance. As impl blocks can "
"only be defined for traits and not types, we need to define this trait first"
" - but it's not meant to be used for anything else."
msgstr ""
"Untuk mendefinisikan fungsi dalam konteks Rectangle, kita memulai sebuah "
"blok Éimplo (implementasi) untuk sebuah sifat ▪RectangTrait) yang "
"mendefinisikan metode-metode yang dapat disebut pada contoh ▪Rectangle. "
"sebagai blok impl hanya dapat didefinisikan untuk sifat-sifat dan bukan "
"tipe, kita perlu mendefinisikan sifat ini terlebih dahulu - tetapi tidak "
"dimaksudkan untuk digunakan untuk hal lain."

#: src/ch05-03-method-syntax.md:36
msgid ""
"Everything within this `impl` block will be associated with the `Rectangle` "
"type. Then we move the `area` function within the `impl` curly brackets and "
"change the first (and in this case, only) parameter to be `self` in the "
"signature and everywhere within the body. In `main`, where we called the "
"`area` function and passed `rect1` as an argument, we can instead use "
"_method syntax_ to call the `area` method on our `Rectangle` instance. The "
"method syntax goes after an instance: we add a dot followed by the method "
"name, parentheses, and any arguments."
msgstr ""
"Segala sesuatu yang ada di dalam blok ini akan dihubungkan dengan tipe "
"Rectangle. Kemudian kita memindahkan fungsi ·area) dalam kurung keriting dan"
" mengubah pertama (dan dalam kasus ini, hanya) parameter untuk menjadi "
"dirinya sendiri dalam tanda tangan dan di mana-mana dalam tubuh. Dalam hal "
"ini, di mana kita disebut fungsi ·areaán dan melewati Árect1 sebagai "
"argumen, kita dapat menggunakan metode _method syntax untuk memanggil metode"
" di lingkungan kita."

#: src/ch05-03-method-syntax.md:38
msgid ""
"In the signature for `area`, we use `self: @Rectangle` instead of "
"`rectangle: @Rectangle`. Methods must have a parameter named `self`, for "
"their first parameter, and the type of `self` indicates the type that method"
" can be called on. Methods can take ownership of `self`, but `self` can also"
" be passed by snapshot or by reference, just like any other parameter."
msgstr ""
"Dalam tanda tangan untuk mahkluka, kita menggunakan diri sendiri: "
"@Rectangle, dan jenis dari dirinya sendiri menunjukkan tipe yang dapat "
"dipanggil. Metoda dapat mengambil kepemilikan dari diri sendiri, tetapi "
"▪selfself can be pass by snapshot or referion, just the parameter."

#: src/ch05-03-method-syntax.md:41
msgid ""
"There is no direct link between a type and a trait. Only the type of the "
"`self` parameter of a method defines the type from which this method can be "
"called. That means, it is technically possible to define methods on multiple"
" types in a same trait (mixing `Rectangle` and `Circle` methods, for "
"example). But **this is not a recommended practice** as it can lead to "
"confusion."
msgstr ""
"Tidak ada hubungan langsung antara tipe dan sifat. hanya tipe dari sebuah "
"metode yang mendefinisikan tipe metode ini yang dapat disebut. itu berarti, "
"secara teknis dapat menentukan metode pada berbagai tipe dalam sifat yang "
"sama (menggabungkan Rectleán dan metode sirkula, misalnya)."

#: src/ch05-03-method-syntax.md:43
msgid ""
"The main reason for using methods instead of functions, in addition to "
"providing method syntax, is for organization. We’ve put all the things we "
"can do with an instance of a type in one `impl` block rather than making "
"future users of our code search for capabilities of `Rectangle` in various "
"places in the library we provide."
msgstr ""
"Alasan utama untuk menggunakan metode sebagai ganti fungsi, selain "
"menyediakan metode sintaks, adalah untuk organisasi."

#: src/ch05-03-method-syntax.md:45
msgid "The `generate_trait` Attribute"
msgstr "Atribut Atribut T_generate_trait)"

#: src/ch05-03-method-syntax.md:47
msgid ""
"If you are familiar with Rust, you may find Cairo's approach confusing "
"because methods cannot be defined directly on types. Instead, you must "
"define a [trait](./ch08-02-traits-in-cairo.md) and an implementation of this"
" trait associated with the type for which the method is intended. However, "
"defining a trait and then implementing it to define methods on a specific "
"type is verbose, and unnecessary: the trait itself will not be reused."
msgstr ""
"Jika Anda akrab dengan Rust, Anda mungkin menemukan pendekatan Cairo "
"membingungkan karena metode tidak dapat didefinisikan secara langsung pada "
"tipe. Sebaliknya, Anda harus mendefinisikan [trait] Figaro./ch08-02-traits-"
"in-cairo.md) dan impletasi dari sifat yang terkait dengan tipe yang "
"dimaksudkan. Namun, mendefinisikan sebuah sifat dan kemudian "
"mengimplementasikannya untuk mendefinisikan metode pada tipe tertentu adalah"
" verbose, dan tidak perlu: sifat itu sendiri tidak akan digunakan kembali."

#: src/ch05-03-method-syntax.md:50
msgid ""
"So, to avoid defining useless traits, Cairo provides the `#[generate_trait]`"
" attribute to add above a trait implementation, which tells to the compiler "
"to generate the corresponding trait definition for you, and let's you focus "
"on the implementation only. Both approaches are equivalent, but it's "
"considered a best practice to not explicitly define traits in this case."
msgstr ""
"Jadi, untuk menghindari mendefinisikan sifat-sifat yang tidak berguna, Cairo"
" menyediakan ·generate_trait]# [atribut untuk menambahkan di atas sebuah "
"implementasi sifat, yang mengatakan kepada kompiler untuk menghasilkan "
"definisi sifat yang sesuai untuk Anda, dan mari kita fokus pada implementasi"
" saja. Keduanya pendekatan adalah ekuivalen, tetapi itu dianggap merupakan "
"praktek terbaik untuk tidak secara eksplisit mendefinisikan sifat dalam "
"kasus ini."

#: src/ch05-03-method-syntax.md:52
msgid "The previous example can also be written as follows:"
msgstr "Contoh sebelumnya juga dapat ditulis sebagai berikut:"

#: src/ch05-03-method-syntax.md:75
msgid ""
"Let's use this `#[generate_trait]` in the following chapters to make our "
"code cleaner."
msgstr ""
"Mari kita gunakan ini # [generate_trait] dalam bab-bab berikut untuk membuat"
" kode kita bersih."

#: src/ch05-03-method-syntax.md:77
msgid "Snapshots and References"
msgstr "Snapshot dan Referensi"

#: src/ch05-03-method-syntax.md:79
msgid ""
"As the `area` method does not modify the calling instance, `self` is "
"declared as a snapshot of a `Rectangle` instance with the `@` snapshot "
"operator. But, of course, we can also define some methods receiving a "
"mutable reference of this instance, to be able to modify it."
msgstr ""
"Sebagaimana metode tersebut tidak mengubah contoh panggilan, kita juga dapat"
" menentukan beberapa metode menerima referensi yang dapat berubah dari "
"contoh ini, untuk dapat memodifikasinya."

#: src/ch05-03-method-syntax.md:81
msgid ""
"Let's write a new method `scale` which resizes a rectangle of a `factor` "
"given as parameter:"
msgstr ""
"Mari kita menulis sebuah metode baru skala yang mengubah ukuran persegi "
"panjang dari sebuah factor yang diberikan sebagai parameter:"

#: src/ch05-03-method-syntax.md:98
msgid "\"The new size is (width: {}, height: {})\""
msgstr "\"Ukuran baru adalah (width: {}, tinggi: {}) \""

#: src/ch05-03-method-syntax.md:102
msgid ""
"It is also possible to define a method which takes ownership of the instance"
" by using just `self` as the first parameter but it is rare. This technique "
"is usually used when the method transforms `self` into something else and "
"you want to prevent the caller from using the original instance after the "
"transformation."
msgstr ""
"Teknik ini biasanya digunakan ketika metode mengubah dirinya sendiri menjadi"
" sesuatu yang lain dan Anda ingin mencegah si penelpon menggunakan contoh "
"asli setelah transformasi."

#: src/ch05-03-method-syntax.md:104
msgid ""
"Look at the [Understanding Ownership](ch04-00-understanding-ownership.md) "
"chapter for more details about these important notions."
msgstr ""
"Lihatlah bab [Mengerti Pemilik][Dimengerti Pemilik][Kh04-00-mengerti-"
"pemilik] untuk rincian lebih lanjut tentang gagasan-gagasan penting ini."

#: src/ch05-03-method-syntax.md:106
msgid "Methods with Several Parameters"
msgstr "Metode dengan Beberapa Parameter"

#: src/ch05-03-method-syntax.md:108
msgid ""
"Let’s practice using methods by implementing another method on the "
"`Rectangle` struct. This time we want to write the method `can_hold` which "
"accepts another instance of `Rectangle` and returns `true` if this rectangle"
" can fit completely within self; otherwise, it should return false."
msgstr ""
"Mari kita berlatih menggunakan metode dengan menerapkan metode lain pada "
"struktur Rectangle. kali ini kita ingin menulis metode tersebut yang "
"menerima contoh lain dari Rectangle dan kembali benar-benar jika persegi ini"
" dapat cocok sepenuhnya dalam diri kita; sebaliknya, harus kembali salah."

#: src/ch05-03-method-syntax.md:132
msgid "\"Can rect1 hold rect2? {}\""
msgstr "\"Bisakah rect1 menahan rect2?"

#: src/ch05-03-method-syntax.md:133
msgid "\"Can rect1 hold rect3? {}\""
msgstr "\"Bisakah rect1 menahan rect3?"

#: src/ch05-03-method-syntax.md:137
msgid "Here, we expect that `rect1` can hold `rect2` but not `rect3`."
msgstr ""
"Di sini, kita berharap bahwa kita dapat bertahan tapi tidak dapat mencapai "
"3."

#: src/ch05-03-method-syntax.md:139
msgid "Associated functions"
msgstr "Fungsi yang terkait"

#: src/ch05-03-method-syntax.md:141
msgid ""
"We call _associated functions_ all functions that are defined inside an "
"`impl` block that are associated to a specific type. While this is not "
"enforced by the compiler, it is a good practice to keep associated functions"
" related to the same type in the same `impl` block - for example, all "
"functions related to `Rectangle` will be grouped in the same `impl` block "
"for `RectangleTrait`."
msgstr ""
"Kami sebut fungsi _asosiasi_ semua fungsi yang didefinisikan dalam sebuah "
"blok Éimplo yang terkait dengan tipe tertentu. Sementara ini tidak "
"diwajibkan oleh kompiler, adalah praktek yang baik untuk menjaga fungsi yang"
" terkait dengan jenis yang sama dalam blok ▪implpla - misalnya, semua fungsi"
" yang terkait dengan ▪Rectangle TM akan dikelompokkan dalam blok ▪impppplum "
"yang sama untuk ÁRectlerait."

#: src/ch05-03-method-syntax.md:143
msgid ""
"Methods are a special kind of associated function, but we can also define "
"associated functions that don’t have `self` as their first parameter (and "
"thus are not methods) because they don’t need an instance of the type to "
"work with, but are still associated with that type."
msgstr ""
"Metode adalah jenis khusus fungsi terkait, tetapi kita juga dapat "
"mendefinisikan fungsi terkait yang tidak memiliki dirinya sendiri sebagai "
"parameter pertama mereka (dan dengan demikian tidak metode) karena mereka "
"tidak membutuhkan contoh dari jenis untuk bekerja dengan, tetapi masih "
"terkait dengan jenis itu."

#: src/ch05-03-method-syntax.md:145
msgid ""
"Associated functions that aren’t methods are often used for constructors "
"that will return a new instance of the type. These are often called `new`, "
"but `new` isn’t a special name and isn’t built into the language. For "
"example, we could choose to provide an associated function named `square` "
"that would have one dimension parameter and use that as both width and "
"height, thus making it easier to create a square `Rectangle` rather than "
"having to specify the same value twice:"
msgstr ""
"Fungsi-fungsi yang terkait dengan metode yang sering digunakan untuk "
"konstruktor yang akan memberikan contoh baru dari jenis tersebut."

#: src/ch05-03-method-syntax.md:153
msgid ""
"Let's create the function `new` which creates a `Rectangle` from a `width` "
"and a `height`, `square` which creates a square `Rectangle` from a `size` "
"and `avg` which computes the average of two `Rectangle` instances:"
msgstr ""
"Mari kita buat fungsinya yang baru yang menciptakan sebuah sudut pandang "
"yang berbeda dari yang lain dan yang menghitung rata-rata dari dua contoh "
"Rectangle:"

#: src/ch05-03-method-syntax.md:182
msgid "\"The average Rectangle of {:?} and {:?} is {:?}\""
msgstr "\"Perrataan persegi panjang {:?} dan {:} adalah {:}\""

#: src/ch05-03-method-syntax.md:190
msgid ""
"To call the `square` associated function, we use the `::` syntax with the "
"struct name; `let sq = Rectangle::square(3);` is an example. This function "
"is namespaced by the struct: the `::` syntax is used for both associated "
"functions and namespaces created by modules. We’ll discuss modules in "
"[Chapter 7](./ch07-02-defining-modules-to-control-scope.md)."
msgstr ""
"Untuk memanggil fungsi yang terkait, kita menggunakan sintaks dengan nama "
"struktur; squaregle = requareáne3); yang contohnya. Fungsi ini diberi nama "
"struct: sintaks:::: sintaks digunakan untuk fungsi yang terkait dan ruang "
"nama yang dibuat oleh modul. Kita akan membahas modul di [Capter 7]. "
"/ch07-defining-moles-to control-scope.d)."

#: src/ch05-03-method-syntax.md:196
msgid ""
"Note that the `avg` function could also be written as a method with `self` "
"as the first rectangle. In this case, instead of using the method with "
"`RectangleTrait::avg(@rect1, @rect2)`, it would be called with "
"`rect1.avg(rect2)`."
msgstr ""
"Perhatikan bahwa fungsi thoseavgán juga dapat ditulis sebagai metode dengan "
"sendirinya sebagai persegi panjang pertama. dalam hal ini, daripada "
"menggunakan metode dengan ▪RectangleTrait::avg Allahlt1, @rect2), ia akan "
"dipanggil dengan ·rect1.avgcaprect2)."

#: src/ch05-03-method-syntax.md:198
msgid "Multiple Traits and `impl` Blocks"
msgstr "Multiple Traits and æimplo Blocks"

#: src/ch05-03-method-syntax.md:200
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For "
"example, the following code is equivalent to the code shown in the _Methods "
"with several parameters_ section, which has each method in its own `trait` "
"and `impl` blocks."
msgstr ""
"Setiap struktur diijinkan untuk memiliki multiple traitétémpl. Sebagai "
"contoh, kode berikut ini setara dengan kode yang ditampilkan dalam _Metoda "
"dengan beberapa bagian parameter_, yang memiliki setiap metode dalam sendiri"
" blok ·trait. dan ▪implpl."

#: src/ch05-03-method-syntax.md:219
msgid ""
"There’s no strong reason to separate these methods into multiple `trait` and"
" `impl` blocks here, but this is valid syntax."
msgstr ""
"Tidak ada alasan kuat untuk memisahkan metode-metode ini ke dalam beberapa "
"blok atau blok yang valid di sini, tapi ini adalah sintaks yang valid."

#: src/ch05-03-method-syntax.md:222
msgid "{{#quiz ../quizzes/ch05-03-method-syntax.toml}}"
msgstr "{{#quiz../quizzes/ch05-03-method-syntax.toml}}}"

#: src/ch06-00-enums-and-pattern-matching.md
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. "
"Enums allow you to define a type by enumerating its possible _variants_. "
"First, we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called "
"`Option`, which expresses that a value can be either something or nothing. "
"Finally, we’ll look at how pattern matching in the `match` expression makes "
"it easy to run different code for different values of an enum."
msgstr ""
"Dalam bab ini, kita akan melihat pada _enumerations_, juga disebut _enum_. "
"Enums memungkinkan anda untuk mendefinisikan sebuah tipe dengan menyebutkan "
"kemungkinan _variants_. Pertama, kita akan mendefinisikan dan menggunakan "
"enum untuk menunjukkan bagaimana enum dapat encodes makna bersama dengan "
"data. Berikutnya, kita akan mengeksplorasi sebuah enum yang sangat berguna, "
"yang disebut ÉOption (Option), yang menyatakan bahwa nilai dapat menjadi "
"sesuatu atau tidak sama sekali. Akhirnya, kita akan melihat bagaimana pola "
"pencocokan dalam ekspresi enomatik dapat memudahkan untuk menjalankan kode "
"yang berbeda dari nilai yang berbeda."

#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type "
"that consists of a fixed set of named values, called _variants_. Enums are "
"useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""
"Enums, singkatan dari \"enumerasi,\" adalah cara untuk mendefinisikan tipe "
"data gubahan yang terdiri dari set tetap dari nilai-nilai bernama, yang "
"disebut _variants_. Enums berguna untuk mewakili koleksi nilai-nilai terkait"
" di mana setiap nilai berbeda dan memiliki arti spesifik."

#: src/ch06-01-enums.md:5
msgid "Enum Variants and Values"
msgstr "Varian dan Nilai Enum"

#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr "Ini contoh sederhana dari sebuah enum:"

#: src/ch06-01-enums.md:19
msgid ""
"In this example, we've defined an enum called `Direction` with four "
"variants: `North`, `East`, `South`, and `West`. The naming convention is to "
"use PascalCase for enum variants. Each variant represents a distinct value "
"of the `Direction` type. In this particular example, variants don't have any"
" associated value. One variant can be instantiated using this syntax:"
msgstr ""
"Dalam contoh ini, kami telah mendefinisikan sebuah enum yang disebut "
"direction (Direction) dengan empat varian: (Direction), Timur, dan West). "
"Konvensi penamaan adalah untuk menggunakan PascalCase untuk varian: setiap "
"varian mewakili nilai yang berbeda dari tipe direction (Direction). Dalam "
"contoh tertentu, varian tidak memiliki nilai terkait. Satu varian dapat "
"langsung menggunakan sintaks ini:"

#: src/ch06-01-enums.md:36
msgid ""
"Now let's imagine that our variants have associated values, that store the "
"exact degree of the direction. We can define a new `Direction` enum:"
msgstr ""
"Sekarang mari kita bayangkan bahwa varian kita memiliki nilai-nilai yang "
"terkait, bahwa menyimpan tingkat yang tepat arah."

#: src/ch06-01-enums.md:52
msgid "and instantiate it as follows:"
msgstr "dan seketika itu sebagai berikut:"

#: src/ch06-01-enums.md:68
msgid ""
"In this code, each variant is associated with a `u128` value, representing "
"the direction in degrees. In the next example, we will see that it is also "
"possible to associate different data types with each variant."
msgstr ""
"Dalam kode ini, setiap varian dikaitkan dengan nilai ·u128, mewakili arah "
"dalam derajat. Pada contoh berikutnya, kita akan melihat bahwa mungkin juga "
"untuk mengasosiasikan tipe data yang berbeda dengan setiap varian."

#: src/ch06-01-enums.md:70
msgid ""
"It's easy to write code that acts differently depending on the variant of an"
" enum instance, in this example to run specific code according to a "
"direction. You can learn more about it in the [Match Control Flow "
"Construct](./ch06-02-the-match-control-flow-construct.md) section."
msgstr ""
"Sangat mudah untuk menulis kode yang bertindak berbeda tergantung pada "
"varian dari sebuah enum, dalam contoh ini untuk menjalankan kode spesifik "
"sesuai dengan sebuah arah. Anda dapat belajar lebih lanjut tentang hal itu "
"di bagian [Motch Control Flow Construct]./ch06-02-the-match-concract-flow-"
"construct.md)."

#: src/ch06-01-enums.md:74
msgid "Enums Combined with Custom Types"
msgstr "Enum Dikombinasikan dengan Tipe Gubahan"

#: src/ch06-01-enums.md:76
msgid ""
"Enums can also be used to store more interesting custom data associated with"
" each variant. For example:"
msgstr ""
"Enums juga dapat digunakan untuk menyimpan data gubahan yang lebih menarik "
"yang berhubungan dengan setiap varian. Sebagai contoh:"

#: src/ch06-01-enums.md:87
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo`, and "
"`Move`, all with different types:"
msgstr "Dalam contoh ini, email memiliki tiga varian:"

#: src/ch06-01-enums.md:89
msgid "`Quit` doesn't have any associated value."
msgstr "Berhenti tidak memiliki nilai terkait."

#: src/ch06-01-enums.md:90
msgid "`Echo` is a single `felt252`."
msgstr "Echo adalah satu-satunya yang berjumlah 252."

#: src/ch06-01-enums.md:91
msgid "`Move` is a tuple of two `u128` values."
msgstr "Pindah adalah salah satu dari dua nilai yang sama."

#: src/ch06-01-enums.md:93
msgid ""
"You could even use a Struct or another enum you defined inside one of your "
"enum variants."
msgstr ""
"Anda bahkan bisa menggunakan Struct atau enum lain Anda didefinisikan dalam "
"salah satu varian enum Anda."

#: src/ch06-01-enums.md:95
msgid "Trait Implementations for Enums"
msgstr "Implementasi Trait bagi Enums"

#: src/ch06-01-enums.md:97
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. "
"This allows you to define methods and behaviors associated with the enum. "
"Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""
"Di Cairo, Anda dapat mendefinisikan sifat-sifat dan menerapkannya untuk "
"enums gubahan Anda. Hal ini memungkinkan Anda untuk mendefinisikan metode "
"dan perilaku yang terkait dengan enum. ini adalah contoh dari mendefinisikan"
" suatu sifat dan mengimplementasikannya untuk enum EMSage sebelumnya:"

#: src/ch06-01-enums.md:107 src/ch06-01-enums.md:133
msgid "\"quitting\""
msgstr "\"Menyingkir\""

#: src/ch06-01-enums.md:108 src/ch06-01-enums.md:134
msgid "\"echoing {}\""
msgstr "\"Menggema []\""

#: src/ch06-01-enums.md:109 src/ch06-01-enums.md:135
msgid "\"moving from {} to {}\""
msgstr "\" pindah dari {} ke {}\""

#: src/ch06-01-enums.md:115
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here "
"is how it could be used to process a Quit message:"
msgstr ""
"Dalam contoh ini, kami menerapkan sifat yang meng-Proses-kan untuk pesan "
"keluar:"

#: src/ch06-01-enums.md:147
msgid "Running this code would print `quitting`."
msgstr "Menjalankan kode ini akan mencetaknya."

#: src/ch06-01-enums.md:149
msgid "The `Option` Enum and Its Advantages"
msgstr "Enum dan Keuntungannya"

#: src/ch06-01-enums.md:151
msgid ""
"The `Option` enum is a standard Cairo enum that represents the concept of an"
" optional value. It has two variants: `Some: T` and `None`. `Some: T` "
"indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr ""
"Enum standar Cairo yang mewakili konsep nilai opsional. memiliki dua varian:"
" T Rasule."

#: src/ch06-01-enums.md:160
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent "
"the possibility of a value being absent, making your code more expressive "
"and easier to reason about. Using `Option` can also help prevent bugs caused"
" by using uninitialized or unexpected `null` values."
msgstr ""
"Enum enum sangat membantu karena memungkinkan Anda untuk secara eksplisit "
"mewakili kemungkinan nilai yang tidak hadir, membuat kode Anda lebih "
"ekspresif dan lebih mudah untuk dipikirkan. menggunakan Opsi dapat juga "
"membantu mencegah bug yang disebabkan dengan menggunakan nilai-nilai yang "
"tidak terinisialisasi atau tidak terduga."

#: src/ch06-01-enums.md:162
msgid ""
"To give you an example, here is a function which returns the index of the "
"first element of an array with a given value, or `None` if the element is "
"not present."
msgstr ""
"Sebagai contoh, ini adalah fungsi yang mengembalikan indeks elemen pertama "
"array dengan nilai tertentu, atau åNONA jika elemennya tidak ada."

#: src/ch06-01-enums.md:164
msgid "We are demonstrating two approaches for the above function:"
msgstr "Kami menunjukkan dua pendekatan untuk fungsi di atas:"

#: src/ch06-01-enums.md:166
msgid "Recursive approach with `find_value_recursive`."
msgstr "Pendekatan rekursif dengan 'find_value_recursive'."

#: src/ch06-01-enums.md:167
msgid "Iterative approach with `find_value_iterative`."
msgstr "Pendekatan iteratif dengan æfind_value_iteratif those."

#: src/ch06-01-enums.md:199
msgid ""
"Enums can be useful in many situations, especially when using the `match` "
"flow construct that we just used. We will describe it in the next section."
msgstr ""
"Enums dapat berguna dalam banyak situasi, khususnya ketika menggunakan "
"konstruk aliran åmatché yang baru saja kita gunakan."

#: src/ch06-01-enums.md:201
msgid ""
"Other enums are used very often, such as the `Result` enum, allowing to "
"handle errors gracefully. We will explain the `Result` enum in detail in the"
" [\"Error Handling\"](./ch09-02-recoverable-errors.md#the-result-enum) "
"chapter."
msgstr ""
"Enum lain sering digunakan, seperti enum result, yang memungkinkan untuk "
"menangani kesalahan dengan anggun. Kami akan menjelaskan enum resolult di "
"bab [\"Error Handling\"]]./ch09-02-coverable-error.md#the-result-enum)."

#: src/ch06-01-enums.md:203
msgid "{{#quiz ../quizzes/ch06-01-enums.toml}}"
msgstr "{{#quiz./quizzes/ch06-01-enums.toml}}}"

#: src/ch06-02-the-match-control-flow-construct.md:3
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of "
"`match` comes from the expressiveness of the patterns and the fact that the "
"compiler confirms that all possible cases are handled."
msgstr ""
"Cairo memiliki sebuah konstruk arus kontrol yang sangat kuat yang disebut "
"æmatché yang memungkinkan Anda untuk membandingkan nilai dari serangkaian "
"pola dan kemudian menjalankan kode berdasarkan pola yang cocok. pola dapat "
"terdiri dari nilai harfiah, nama variabel, huruf liar, dan banyak hal "
"lainnya. kekuatan ketidakcocokan berasal dari ekspresif pola dan fakta bahwa"
" kompiler dapat memastikan bahwa semua kasus mungkin ditangani."

#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Think of a `match` expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the "
"value “fits”, the value falls into the associated code block to be used "
"during execution."
msgstr ""
"Pikirkan ekspresi yang cocok seperti mesin pemecah koin: koin meluncur ke "
"bawah trek dengan berbagai lubang berukuran, dan setiap koin jatuh melalui "
"lubang pertama yang bertemu dengannya. dengan cara yang sama, nilai melalui "
"setiap pola dalam pertandingan, dan pada pola pertama, nilai tersebut jatuh "
"ke dalam blok kode yang terkait untuk digunakan selama eksekusi."

#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Speaking of coins, let’s use them as an example using `match`! We can write "
"a function that takes an unknown US coin and, in a similar way as the "
"counting machine, determines which coin it is and returns its value in "
"cents, as shown in Listing 6-1."
msgstr ""
"Kita dapat menulis sebuah fungsi yang membutuhkan koin AS yang tidak "
"diketahui dan, dengan cara yang sama seperti mesin penghitung, menentukan "
"koin mana yang mana dan mengembalikan nilainya dalam sen, seperti yang "
"ditunjukkan dalam Listing 6-1."

#: src/ch06-02-the-match-control-flow-construct.md:27
msgid ""
"<span class=\"caption\">Listing 6-1: An enum and a `match` expression that "
"has the variants of the enum as its patterns</span>"
msgstr ""
"<span class=\"caption\">Listing 6-1: Sebuah enum dan sebuah ekspresi åmatché"
" yang memiliki varian dari enum sebagai pola</span>"

#: src/ch06-02-the-match-control-flow-construct.md:29
msgid ""
"Let’s break down the `match` expression in the `value_in_cents` function. "
"First, we list the `match` keyword followed by an expression, which in this "
"case is the value `coin`. This seems very similar to a conditional "
"expression used with the `if` statement, but there’s a big difference: with "
"`if`, the condition needs to evaluate to a boolean value, but here it can be"
" any type. The type of `coin` in this example is the `Coin` enum that we "
"defined on the first line."
msgstr ""
"Pertama-tama, kita daftarkan kata kunci yang diikuti dengan ungkapan, yang "
"dalam hal ini adalah nilai enomavalue_in_cents. ini tampak sangat mirip "
"dengan pernyataan thoseafin_cents, tapi ada perbedaan besar: dengan kata "
"kunci berikut, kondisi perlu dievaluasi untuk nilai boolean, tetapi di sini "
"dapat menjadi tipe apapun. tipe enomcoin dalam contoh ini adalah encomin "
"enum yang kita definisikan pada baris pertama."

#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with"
" a comma."
msgstr ""
"Berikutnya adalah lengan yang cocok. lengan memiliki dua bagian: pola dan "
"beberapa kode. lengan pertama memiliki pola yang bernilai, yaitu: \"Penny.\""
" dan kemudian operator yang memisahkan pola dan kode untuk dijalankan. kode "
"dalam kasus ini hanya nilai ·1. masing-masing lengan dipisahkan dari "
"berikutnya dengan koma."

#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in the order they are given. If a pattern "
"matches the value, the code associated with that pattern is executed. If "
"that pattern doesn’t match the value, execution continues to the next arm, "
"much as in a coin-sorting machine. We can have as many arms as we need: in "
"the above example, our `match` has four arms."
msgstr ""
"Jika sebuah pola cocok dengan nilai yang sama dengan pola tersebut tidak "
"sesuai dengan nilai, eksekusi terus berlanjut ke lengan berikutnya, seperti "
"dalam mesin pemotong koin. kita dapat memiliki senjata sebanyak yang kita "
"butuhkan: dalam contoh di atas, senjata kita memiliki empat senjata."

#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire match expression."
msgstr ""
"Kode yang terkait dengan setiap lengan adalah sebuah ekspresi, dan nilai "
"hasil dari ekspresi dalam lengan yang cocok adalah nilai yang akan "
"dikembalikan untuk seluruh ekspresi kecocokan."

#: src/ch06-02-the-match-control-flow-construct.md:37
msgid ""
"We don’t typically use curly brackets if the `match` arm code is short, as "
"it is in our example where each arm just returns a value. If you want to run"
" multiple lines of code in a `match` arm, you must use curly brackets, with "
"a comma following the arm. For example, the following code prints “Lucky "
"penny!” every time the method is called with a `Coin::Penny`, but still "
"returns the last value of the block, `1`:"
msgstr ""
"Kami biasanya tidak menggunakan braket keriting jika hurufnya pendek, karena"
" dalam contoh kami, masing-masing lengan hanya mengembalikan nilai. jika "
"Anda ingin menjalankan beberapa baris kode dalam lengan yang cocok, Anda "
"harus menggunakan braket yang keriting, dengan sebuah koma berikut lengan."

#: src/ch06-02-the-match-control-flow-construct.md:43
msgid "\"Lucky penny!\""
msgstr "\"Lucky penny!\""

#: src/ch06-02-the-match-control-flow-construct.md:53
msgid "Patterns That Bind to Values"
msgstr "Pola yang Ikatan dengan Nilai - Nilai"

#: src/ch06-02-the-match-control-flow-construct.md:55
msgid ""
"Another useful feature of `match` arms is that they can bind to the parts of"
" the values that match the pattern. This is how we can extract values out of"
" enum variants."
msgstr ""
"Fitur lain yang berguna dari lengan yang cocok adalah bahwa mereka dapat "
"mengikat bagian dari nilai-nilai yang sesuai dengan pola ini adalah "
"bagaimana kita dapat mengekstrak nilai-nilai dari varian enum."

#: src/ch06-02-the-match-control-flow-construct.md:57
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it."
" From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information"
" to our `enum` by changing the `Quarter` variant to include a `UsState` "
"value stored inside it, which we’ve done in Listing 6-2."
msgstr ""
"Sebagai contoh, mari kita ubah salah satu varian enum kita untuk menyimpan "
"data di dalamnya. dari tahun 1999 sampai 2008, Amerika Serikat mencetak koin"
" dengan desain yang berbeda untuk setiap 50 negara bagian di satu sisi. "
"tidak ada koin lain yang memiliki desain negara bagian lain, jadi hanya "
"seperempat yang memiliki nilai ekstra ini. kita dapat menambahkan informasi "
"ini kepada varian kita dengan mengubah varian ▪Quarteráríastasi yang "
"tersimpan di dalamnya, yang telah kita lakukan dalam Listling-2 6."

#: src/ch06-02-the-match-control-flow-construct.md:61
msgid "// Debug so we can inspect the state in a minute\n"
msgstr "#/ Debug sehingga kita dapat memeriksa negara dalam satu menit\n"

#: src/ch06-02-the-match-control-flow-construct.md:76
msgid ""
"<span class=\"caption\">Listing 6-2: A `Coin` enum in which the `Quarter` "
"variant also holds a `UsState` value</span>"
msgstr ""
"<span class=\"caption\">Listing 6-2: A åCoiném di mana varian </span> juga "
"menyimpan sebuah nilai ▪Usstate preference</span>"

#: src/ch06-02-the-match-control-flow-construct.md:78
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of"
" the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""
"Mari kita bayangkan bahwa seorang teman mencoba mengumpulkan seluruh 50 "
"koin, sementara kita menyortir uang receh kita, kita juga akan memanggil "
"nama negara yang terkait dengan setiap kuartal sehingga jika itu adalah "
"salah satu teman kita tidak memiliki, mereka dapat menambahkannya ke koleksi"
" mereka."

#: src/ch06-02-the-match-control-flow-construct.md:80
msgid ""
"In the `match` expression for this code, we add a variable called `state` to"
" the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that"
" quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""
"Dalam ekspresi yang cocok untuk kode ini, kami menambahkan variabel yang "
"disebut åstate those to pola yang cocok dengan nilai dari varian "
"Coin:::Qarter. Ketika sebuah åCoin:::Quarter, variabel negara bagian akan "
"mengikat ke nilai negara seperempat itu."

#: src/ch06-02-the-match-control-flow-construct.md:89
msgid "\"State quarter from {:?}!\""
msgstr "\"State quarter from {:?}!\""

#: src/ch06-02-the-match-control-flow-construct.md:96
msgid ""
"Because `state` is an `UsState` enum which implements the `Debug` trait, we "
"can print `state` value with `println!` macro."
msgstr ""
"Karena negara bagian ini adalah sebuah enum Usstate yang mengimplementasikan"
" sifat debug, kita dapat mencetak nilai negara dengan akselerasi!"

#: src/ch06-02-the-match-control-flow-construct.md:98
msgid ""
"Note: `{:?}` is a special formatting syntax that allows to print a debug "
"form of the parameter passed to the `println!` macro. You can find more "
"information about it in [Appendix C](./appendix-03-derivable-"
"traits.html#debug-for-printing-and-debugging)."
msgstr ""
"Catatan: ▪{:?} merupakan sintaks format khusus yang memungkinkan menampilkan"
" bentuk debug dari parameter yang dilewatkan ke makro!"

#: src/ch06-02-the-match-control-flow-construct.md:100
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` "
"would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with "
"each of the match arms, none of them match until we reach "
"`Coin::Quarter(state)`. At that point, the binding for `state` will be the "
"value `UsState::Alaska`. We can then use that binding in `println!` macro, "
"thus getting the inner state value out of the `Coin` enum variant for "
"`Quarter`."
msgstr ""
"Jika kita harus memanggil årvalue_in_cents[Coin::Qarter "
"Allahnate::::Alaska), kita harus memanggil åcoin_Coinin:Quarter "
"Allahtate::Alaska. Ketika kita membandingkan nilai tersebut dengan setiap "
"senjata, tidak satupun dari mereka cocok sampai kita mencapai \"Coin:Quarter"
" Nation\". Pada saat itu, mengikat untuk negara bagian Ástate:Alaska:Alaska."

#: src/ch06-02-the-match-control-flow-construct.md:104
msgid "Matching with `Option<T>`"
msgstr "Cocok dengan <T>"

#: src/ch06-02-the-match-control-flow-construct.md:106
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same."
msgstr ""
"Di bagian sebelumnya, kami juga ingin mendapatkan nilai dari bagian dalam "
"dari kasus tersebut. Daripada membandingkan koin, kami akan membandingkan "
"varian dari <T>, tapi cara ekspresi yang cocok tetap sama."

#: src/ch06-02-the-match-control-flow-construct.md:108
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if "
"there’s a value inside, adds `1` to that value. If there is no value inside,"
" the function should return the `None` value and not attempt to perform any "
"operations."
msgstr ""
"Katakanlah kita ingin menulis sebuah fungsi yang mengambil sebuah opsi<u8> "
"dan, jika ada suatu nilai di dalamnya, menambahkannya pada nilai tersebut. "
"jika tidak ada nilai di dalamnya, fungsinya harus mengembalikan nilai "
"tersebut dan tidak mencoba melakukan operasi apapun."

#: src/ch06-02-the-match-control-flow-construct.md:110
msgid ""
"This function is very easy to write, thanks to `match`, and will look like "
"Listing 6-3."
msgstr ""
"Fungsi ini sangat mudah untuk ditulis, berkat ketidakcocokan, dan akan "
"terlihat seperti Listing 6-3."

#: src/ch06-02-the-match-control-flow-construct.md:127
msgid ""
"<span class=\"caption\">Listing 6-3: A function that uses a `match` "
"expression on an `Option<u8>`</span>"
msgstr ""
"<span class=\"caption\">Listing 6-3: Sebuah fungsi yang menggunakan ekspresi"
" Ématché pada sebuah <u8></span>"

#: src/ch06-02-the-match-control-flow-construct.md:129
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call"
" `plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each `match` arm:"
msgstr ""
"Mari kita periksa eksekusi pertama dari ·plus_one dalam detail yang lebih "
"lanjut. ketika kita sebut ·plus_one Allah lima), variabel di dalam tubuh "
"·plus_one."

#: src/ch06-02-the-match-control-flow-construct.md:135
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does!"
" We have the same variant. The `val` binds to the value contained in "
"`Option::Some`, so `val` takes the value `5`. The code in the `match` arm is"
" then executed, so we add `1` to the value of `val` and create a new "
"`Option::Some` value with our total `6` inside. Because the first arm "
"matched, no other arms are compared."
msgstr "Apakah ada varian yang sama."

#: src/ch06-02-the-match-control-flow-construct.md:137
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where"
" `x` is `Option::None`. We enter the `match` and compare to the first arm:"
msgstr ""
"Sekarang mari kita mempertimbangkan panggilan kedua dari ·plus_one dalam "
"fungsi utama kita, di mana åxá adalah Option:::: tidak ada. kita masuk ke "
"åmatché dan membandingkan dengan lengan pertama:"

#: src/ch06-02-the-match-control-flow-construct.md:143
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so "
"we continue to the next arm:"
msgstr "Pilihan: Nilai beberapa orang tidak sesuai dengan pola:"

#: src/ch06-02-the-match-control-flow-construct.md:149
msgid ""
"It matches! There’s no value to add to, so the matching construct ends and "
"returns the `Option::None` value on the right side of `=>`."
msgstr ""
"Cocok! Tidak ada nilai yang bisa ditambahkan, sehingga konstruksi yang cocok"
" berakhir dan kembali pada pilihan:: Tidak ada nilai di sisi kanan dari <>."

#: src/ch06-02-the-match-control-flow-construct.md:151
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Cairo code: `match` against an enum, bind a variable to the"
" data inside, and then execute code based on it. It’s a bit tricky at first,"
" but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""
"Mengkombinasikan dan enums sangat berguna dalam banyak situasi Anda akan "
"melihat pola ini banyak dalam kode Cairo: Anda akan berharap Anda "
"memilikinya dalam semua bahasa."

#: src/ch06-02-the-match-control-flow-construct.md:153
msgid "Matches Are Exhaustive"
msgstr "Kecocokan Itu Melelahkan"

#: src/ch06-02-the-match-control-flow-construct.md:155
msgid ""
"There’s one other aspect of `match` we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr ""
"Ada satu aspek lain yang perlu kita bahas: pola lengan harus menutupi semua "
"kemungkinan."

#: src/ch06-02-the-match-control-flow-construct.md:165
msgid ""
"We didn’t handle the `None` case, so this code will cause a bug. Luckily, "
"it’s a bug Cairo knows how to catch. If we try to compile this code, we’ll "
"get this error:"
msgstr "Kami tidak menangani kasus ini, jadi kode ini akan menyebabkan bug."

#: src/ch06-02-the-match-control-flow-construct.md:181
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the [billion-dollar "
"mistake](https://en.wikipedia.org/wiki/Null_pointer#History) discussed "
"earlier impossible."
msgstr ""
"Cairo tahu bahwa kita tidak menutup setiap kasus yang mungkin, dan bahkan "
"tahu pola mana yang kita lupakan! Matches di Cairo adalah knalpot: kita "
"harus membuang setiap kemungkinan terakhir agar kode tersebut valid. "
"terutama dalam kasus Option<T>, ketika Cairo mencegah kita untuk lupa untuk "
"eksplisit menangani kasus åNneíatic, itu melindungi kita dari asumsi bahwa "
"kita mungkin memiliki nilai ketika kita gagal, sehingga membuat [miliar-"
"domen] kesalahan://T.wikipedia.org/Nwiwi/Nultler#cerita sebelumnya tidak "
"mungkin dibahas.)"

#: src/ch06-02-the-match-control-flow-construct.md:185
msgid "Catch-all with the `_` Placeholder"
msgstr "Tangkap semua dengan pemegang tempat."

#: src/ch06-02-the-match-control-flow-construct.md:187
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. `_` is a special pattern "
"that matches any value and does not bind to that value. You can use it by "
"simply adding a new arm with `_` as the pattern for the last arm of the "
"`match` expression."
msgstr ""
"Menggunakan enums, kita juga dapat mengambil tindakan khusus untuk beberapa "
"nilai tertentu, tetapi untuk semua nilai lain mengambil satu tindakan baku."

#: src/ch06-02-the-match-control-flow-construct.md:191
msgid ""
"Imagine we have a vending machine that only accepts Dime coins. We want to "
"have a function that processes inserted coins and returns `true` only if the"
" coin is accepted."
msgstr ""
"Bayangkan kita memiliki mesin penjual otomatis yang hanya menerima koin "
"Dime. kita ingin memiliki fungsi yang proses dimasukkan koin dan kembali "
"hanya jika koin itu diterima."

#: src/ch06-02-the-match-control-flow-construct.md:194
msgid "Here's a `vending_machine_accept` function that implements this logic:"
msgstr "Ini adalah fungsi mesin-mesin yang menerapkan logika ini:"

#: src/ch06-02-the-match-control-flow-construct.md:205
msgid ""
"This example also meets the exhaustiveness requirement because we’re "
"explicitly ignoring all other values in the last arm; we haven’t forgotten "
"anything."
msgstr ""
"Contoh ini juga memenuhi kebutuhan yang melelahkan karena kita secara "
"eksplisit mengabaikan semua nilai lain di lengan terakhir; kita belum "
"melupakan apa pun."

#: src/ch06-02-the-match-control-flow-construct.md:207
msgid ""
"There's no catch-all pattern in Cairo that allows you to use the value of "
"the pattern."
msgstr ""
"Tidak ada pola menangkap semua di Cairo yang memungkinkan Anda untuk "
"menggunakan nilai pola."

#: src/ch06-02-the-match-control-flow-construct.md:213
msgid "Multiple Patterns with the `|` Operator"
msgstr "Beberapa Pola dengan Operator."

#: src/ch06-02-the-match-control-flow-construct.md:215
msgid ""
"In `match` expressions, you can match multiple patterns using the `|` "
"syntax, which is the pattern _or_ operator."
msgstr ""
"Dalam ekspresi yang cocok, Anda dapat mencocokkan beberapa pola menggunakan "
"sintaks those, yang merupakan pola operator _or_."

#: src/ch06-02-the-match-control-flow-construct.md:217
msgid ""
"For example, in the following code we modified the `vending_machine_accept` "
"function to accept both `Dime` and `Quarter` coins in a single arm:"
msgstr ""
"Sebagai contoh, dalam kode berikut kami memodifikasi koin "
"ivending_machine_accepté fungsi untuk menerima baik åDimeán dan quarrter; "
"dalam satu lengan:"

#: src/ch06-02-the-match-control-flow-construct.md:228
msgid "Matching Tuples"
msgstr "Tuples Cocok"

#: src/ch06-02-the-match-control-flow-construct.md:230
msgid "It is possible to match tuples. Let's introduce a new `DayType` enum:"
msgstr ""
"Hal ini dimungkinkan untuk mencocokkan tuples. mari kita memperkenalkan "
"sebuah hari baru enum:"

#: src/ch06-02-the-match-control-flow-construct.md:242
msgid ""
"Now, let's suppose that our vending machine accepts any coin on weekdays, "
"but only accepts quarters and dimes on weekends and holidays. We can modify "
"the `vending_machine_accept` function to accept a tuple of a `Coin` and a "
"`Weekday` and return `true` only if the given coin is accepted on the "
"specified day:"
msgstr ""
"Sekarang, mari kita asumsikan bahwa mesin penjual kita menerima koin apapun "
"pada hari kerja, tetapi hanya menerima seperempat dan sepeser pun pada akhir"
" pekan dan liburan."

#: src/ch06-02-the-match-control-flow-construct.md:255
msgid ""
"Writing `(_, _)` for the last arm of a tuple matching pattern might feel "
"superfluous. Hence, we can use the `_ =>` syntax if we want, for example, "
"that our vending machine only accepts quarters on weekdays:"
msgstr ""
"Oleh karena itu, kita dapat menggunakan sintaks yang terakhir jika kita "
"ingin, misalnya, bahwa mesin penjual kita hanya menerima seperempat pada "
"hari kerja:"

#: src/ch06-02-the-match-control-flow-construct.md:266
msgid "Matching `felt252` and Integer Variables"
msgstr "Variabel Integer dan Integer yang sesuai dengan 252"

#: src/ch06-02-the-match-control-flow-construct.md:268
msgid ""
"You can also match `felt252` and integer variables. This is useful when you "
"want to match against a range of values. However, there are some "
"restrictions:"
msgstr ""
"Anda juga dapat mencocokkan variabel integer dengan 252 dan variabel "
"integer. namun, ada beberapa pembatasan:"

#: src/ch06-02-the-match-control-flow-construct.md:271
msgid ""
"Only integers that fit into a single `felt252` are supported (i.e. `u256` is"
" not supported)."
msgstr ""
"Hanya bilangan integer yang cocok dengan satu angka 252, yang didukung "
"(misalnya u256)."

#: src/ch06-02-the-match-control-flow-construct.md:272
msgid "The first arm must be 0."
msgstr "Lengan pertama harus 0."

#: src/ch06-02-the-match-control-flow-construct.md:273
msgid ""
"Each arm must cover a sequential segment, contiguously with other arms."
msgstr ""
"Setiap lengan harus mencakup segmen sequential, kontiguously dengan lengan "
"lain."

#: src/ch06-02-the-match-control-flow-construct.md:275
msgid ""
"Imagine we’re implementing a game where you roll a six-sided die to get a "
"number between 0 and 5. If you have 0, 1 or 2 you win. If you have 3, you "
"can roll again. For all other values you lose."
msgstr ""
"Bayangkan kita menerapkan sebuah permainan di mana Anda memutar enam kali "
"mati untuk mendapatkan angka antara 0 dan 5. jika Anda memiliki 0, 1 atau 2 "
"Anda menang. jika Anda memiliki 3, Anda dapat roll lagi. untuk semua nilai-"
"nilai lain Anda kehilangan."

#: src/ch06-02-the-match-control-flow-construct.md:278
msgid "Here's a match that implements that logic:"
msgstr "Inilah kecocokan yang menerapkan logika itu:"

#: src/ch06-02-the-match-control-flow-construct.md:283
msgid "\"you won!\""
msgstr "\"Kau menang!\""

#: src/ch06-02-the-match-control-flow-construct.md:284
msgid "\"you can roll again!\""
msgstr "\"Kau bisa berguling lagi!\""

#: src/ch06-02-the-match-control-flow-construct.md:285
msgid "\"you lost...\""
msgstr "\"Kau kalah...\""

#: src/ch06-02-the-match-control-flow-construct.md:290
msgid "{{#quiz ../quizzes/ch06-02-match.toml}}"
msgstr "{{#quiz../quizzes/ch06-02-match.toml}}"

#: src/ch06-02-the-match-control-flow-construct.md:292
msgid ""
"These restrictions are planned to be relaxed in future versions of Cairo."
msgstr "Pembatasan ini direncanakan untuk santai di masa depan versi Cairo."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:3
msgid "`if let`"
msgstr "Jika kita biarkan saja."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:5
msgid ""
"The `if let` syntax lets you combine `if` and `let` into a less verbose way "
"to handle values that match one pattern while ignoring the rest. Consider "
"the program in Listing 6-4 that matches on an `Option::Some<u8>` value in "
"the `config_max` variable but only wants to execute code if the value is "
"`Option::Some` variant."
msgstr ""
"Sintaks memungkinkan Anda menggabungkannya menjadi cara yang kurang verbose "
"untuk menangani nilai-nilai yang cocok dengan satu pola ketika mengabaikan "
"sisanya. Pertimbangkan program di Listing 6-4 yang cocok dengan sebuah opsi:"
" Beberapa nilai <u8> dalam variabel ▪config_max tetapi hanya ingin "
"mengeksekusi kode jika nilai adalah Option: Beberapa varian."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:11
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:33
msgid "\"The maximum is configured to be {}\""
msgstr "\"Maksimum dikonfigurasikan untuk {}\""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:17
msgid ""
"<span class=\"caption\">Listing 6-4: A `match` that only cares about "
"executing code when the value is `Option::Some`</span>"
msgstr ""
"<span class=\"caption\">Listing 6-4: A åmatché yang hanya peduli tentang "
"eksekusi kode ketika nilai adalah ▪Opsi:: Beberapa</span>"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:20
msgid ""
"If the value is `Option::Some`, we print out the value in the `Option::Some`"
" variant by binding the value to the variable `max` in the pattern. We don’t"
" want to do anything with the `None` value. To satisfy the `match` "
"expression, we have to add `_ => ()` after processing just one variant, "
"which is annoying boilerplate code to add."
msgstr ""
"Jika nilainya adalah: \"Beberapa, kami mencetak nilai dalam ukuran tersebut:"
" \"Beberapa varian dengan mengikat nilai ke variabel maksimal dalam pola. "
"kami tidak ingin melakukan apa-apa dengan nilai ▪None. Untuk memenuhi "
"ekspresi thosematch,\" kami harus menambahkan satu varian saja, yang "
"merupakan kode ketelitian yang mengganggu untuk ditambahkan."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:26
msgid ""
"Instead, we could write this in a shorter way using `if let`. The following "
"code behaves the same as the `match` in Listing 6-4:"
msgstr ""
"Sebaliknya, kita bisa menulis ini dengan cara yang lebih singkat dengan "
"menggunakan jika memungkinkan. kode berikut berperilaku sama dengan yang "
"cocok dalam Listing 6-4:"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:39
msgid ""
"The syntax `if let` takes a pattern and an expression separated by an equal "
"sign. It works the same way as a `match`, where the expression is given to "
"the `match` and the pattern is its first arm. In this case, the pattern is "
"`Option::Some(max)`, and `max` binds to the value inside `Option::Some`. We "
"can then use `max` in the body of the `if let` block in the same way we used"
" `max` in the corresponding `match` arm. The code in the `if let` block "
"isn’t run if the value doesn’t match the pattern."
msgstr ""
"Sintaksnya adalah pola dan ekspresi yang dipisahkan oleh tanda yang sama. ia"
" bekerja dengan cara yang sama dengan sebuah ekspresi yang diberikan kepada "
"lengan pertama dan pola yang sama. dalam hal ini, polanya sama: Beberapa "
"majemuk, dan terikat pada nilai di dalam tubuh."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:47
msgid ""
"Using `if let` means less typing, less indentation, and less boilerplate "
"code. However, you lose the exhaustive checking that `match` enforces. "
"Choosing between `match` and `if let` depends on what you’re doing in your "
"particular situation and whether gaining conciseness is an appropriate "
"trade-off for losing exhaustive checking."
msgstr ""
"Namun, Anda kehilangan pemeriksaan yang melelahkan yang cocok untuk berlaku."
" memilih antara ketidakcocokan dan biarkan bergantung pada apa yang Anda "
"lakukan dalam situasi tertentu dan apakah mendapatkan konsisensi adalah "
"pertukaran yang sesuai untuk kehilangan pemeriksaan menyeluruh."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:53
msgid ""
"In other words, you can think of `if let` as syntactic sugar for a `match` "
"that runs code when the value matches one pattern and then ignores all other"
" values."
msgstr ""
"Dengan kata lain, Anda dapat membayangkan jika membiarkan gula sintaktik "
"untuk sebuah åmatch yang menjalankan kode ketika nilai cocok dengan satu "
"pola dan kemudian mengabaikan semua nilai lainnya."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:56
msgid ""
"We can include an `else` with an `if let`. The block of code that goes with "
"`else` is the same as the block of code that would go with the `_` case in "
"the `match` expression. Recall the `Coin` enum definition in Listing 6-2, "
"where the `Quarter` variant also held a `UsState` value. If we wanted to "
"count all non-quarter coins we see while also announcing the state of the "
"quarters, we could do that with a `match` expression, like this:"
msgstr ""
"Kita dapat menyertakan sebuah blok dari kode yang akan masuk ke dalam "
"ekspresi yang tidak tertandingi. ingat lagi definisi kode tersebut dalam "
"daftar 6-2, di mana varian árse yang juga memiliki nilai yang sama. jika "
"kita ingin menghitung semua koin bukan seperempat yang kita lihat sambil "
"mengumumkan negara bagian, kita dapat melakukannya dengan ekspresi yang "
"cocok, seperti ini:"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:76
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:97
msgid "\"You got a quarter!\""
msgstr "\"Kau punya seperempat!\""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:82
msgid "Or we could use an `if let` and `else` expression, like this:"
msgstr ""
"Atau kita bisa menggunakan ekspresi æif biarkan dan élse, seperti ini:"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:101
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:120
#: src/ch11-08-printing.md:59 src/ch11-08-printing.md:112
#: src/ch11-08-printing.md:130 src/ch11-08-printing.md:156
msgid "\"{}\""
msgstr "\"{]\""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:106
msgid ""
"If you have a situation in which your program has logic that is too verbose "
"to express using `match`, remember that `if let` is in your Cairo toolbox as"
" well."
msgstr ""
"Jika Anda memiliki situasi di mana program Anda memiliki logika yang terlalu"
" rinci untuk mengekspresikan penggunaan åmatch, ingatlah bahwa jika Anda "
"membiarkan program Anda berada di dalam kotak peralatan Cairo juga."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:109
msgid "`while let`"
msgstr "Sementara itu mari kita lakukan."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:111
msgid ""
"The `while let` syntax is similar to the `if let` syntax, but it allows you "
"to loop over a collection of values and execute a block of code for each "
"value that matches a specified pattern. In the case below, the pattern is "
"`Option::Some(x)`, which matches any `Some` variant of the `Option` enum."
msgstr ""
"Sementara itu mari kita biarkan satu blok kode yang cocok dengan pola "
"tertentu. Dalam kasus di bawah ini, polanya adalah ·Option:: Some Allahx), "
"yang cocok dengan varian apapun dari enum ·Option."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:124
msgid ""
"Using `while let` provides a more concise and idiomatic way of writing this "
"loop compared to a traditional `while` loop with explicit pattern matching "
"or handling of the `Option` type. However, as with `if let`, you lose the "
"exhaustive checking that a `match` expression provides, so you need to be "
"careful to handle any remaining cases outside the `while let` loop if "
"necessary."
msgstr ""
"Dengan menggunakan pola pencocokan yang jelas atau penanganan jenis "
"áOptioné. Namun, jika Anda membiarkan loop ini, Anda akan kehilangan "
"pemeriksaan menyeluruh yang diberikan ekspresi yang tidak cocok, sehingga "
"Anda perlu berhati-hati untuk menangani kasus-kasus yang tersisa di luar "
"jenis tersebut."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"As you write large programs, organizing your code will become increasingly "
"important. By grouping related functionality and separating code with "
"distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""
"Ketika Anda menulis program besar, mengatur kode Anda akan menjadi semakin "
"penting. dengan mengelompokkan fungsi yang terkait dan memisahkan kode "
"dengan fitur yang berbeda, Anda akan menjelaskan di mana untuk menemukan "
"kode yang menerapkan fitur tertentu dan di mana untuk mengubah bagaimana "
"fitur bekerja."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"The programs we’ve written so far have been in one module in one file. As a "
"project grows, you should organize code by splitting it into multiple "
"modules and then multiple files. As a package grows, you can extract parts "
"into separate crates that become external dependencies. This chapter covers "
"all these techniques."
msgstr ""
"Program yang kita tulis sejauh ini telah berada dalam satu modul dalam satu "
"berkas. Ketika sebuah proyek bertumbuh, Anda harus mengatur kode dengan "
"memecahnya menjadi beberapa modul dan kemudian beberapa berkas. Sebagai "
"paket tumbuh, Anda dapat mengekstrak bagian ke dalam peti terpisah yang "
"menjadi ketergantungan eksternal. Bab ini mencakup semua teknik ini."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse code at a higher level: once you’ve implemented an operation, other "
"code can call your code without having to know how the implementation works."
msgstr ""
"Kami juga akan membahas rincian implementasi yang memungkinkan Anda "
"menggunakan ulang kode pada tingkat yang lebih tinggi: setelah Anda "
"mengimplementasikan operasi, kode lain dapat menghubungi kode Anda tanpa "
"harus tahu bagaimana implementasi bekerja."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a set of names that are defined as “in scope”. When reading, writing, and "
"compiling code, programmers and compilers need to know whether a particular "
"name at a particular spot refers to a variable, function, struct, enum, "
"module, constant, or other item and what that item means. You can create "
"scopes and change which names are in or out of scope. You can’t have two "
"items with the same name in the same scope."
msgstr ""
"Konsep yang terkait adalah ruang lingkup: konteks sarang di mana kode "
"ditulis memiliki satu set nama yang didefinisikan sebagai ▪in scope. Ketika "
"membaca, menulis, dan menyusun kode, programmer dan kompiler perlu tahu "
"apakah nama tertentu pada tempat tertentu mengacu pada variabel, fungsi, "
"struktur, enum, modul, konstan, atau item lainnya dan apa artinya. Anda "
"dapat membuat ruang lingkup dan mengubah nama mana yang ada di dalam atau di"
" luar lingkup. Anda tidak dapat memiliki dua item dengan nama yang sama "
"dalam lingkup yang sama."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"Cairo has a number of features that allow you to manage your code’s "
"organization. These features, sometimes collectively referred to as the "
"_module system_, include:"
msgstr ""
"Cairo memiliki sejumlah fitur yang memungkinkan Anda mengelola organisasi "
"kode. Fitur-fitur ini, kadang-kadang secara kolektif disebut sebagai sistem "
"_modul_, termasuk:"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Packages:** A Scarb feature that lets you build, test, and share crates."
msgstr ""
"** Packages: ** Sebuah fitur Scarb yang memungkinkan Anda membangun, "
"menguji, dan berbagi peti."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Crates:** A tree of modules that corresponds to a single compilation unit."
" It has a root directory, and a root module defined at the _lib.cairo_ file "
"under this directory."
msgstr ""
"**Crates:** Sebuah pohon modul yang berhubungan dengan satu unit kompilasi. "
"Ia memiliki direktori root, dan modul root didefinisikan di berkas "
"_lib.cairo_ di bawah direktori ini."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Modules** and **use:** Let you control the organization and scope of "
"items."
msgstr ""
"** Modules** dan ** menggunakan:** Biarkan Anda mengontrol organisasi dan "
"lingkup barang."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Paths:** A way of naming an item, such as a struct, function, or module."
msgstr "** Paths:** Cara penamaan item, seperti struct, fungsi, atau modul."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and explain how to use them to manage scope. By the end, you should have a "
"solid understanding of the module system and be able to work with scopes "
"like a pro!"
msgstr ""
"Di bab ini, kita akan membahas semua fitur ini, membahas bagaimana mereka "
"berinteraksi, dan menjelaskan bagaimana mereka untuk mengelola ruang "
"lingkup. pada akhirnya, Anda harus memiliki pemahaman yang solid tentang "
"sistem modul dan dapat bekerja dengan ruang lingkup seperti pro!"

#: src/ch07-01-packages-and-crates.md:3
msgid "What is a Crate?"
msgstr "Apa itu Crate?"

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is a subset of a package that is used in the actual Cairo "
"compilation. This includes:"
msgstr ""
"Peti adalah subset dari paket yang digunakan dalam kompilasi Cairo yang "
"sebenarnya. Ini termasuk:"

#: src/ch07-01-packages-and-crates.md:7
msgid ""
"The package source code, identified by the package name and the crate root, "
"which is the main entry point of the package."
msgstr ""
"Kode sumber paket, yang diidentifikasi dengan nama paket dan akar peti, yang"
" merupakan titik masuk utama paket."

#: src/ch07-01-packages-and-crates.md:8
msgid ""
"A subset of the package metadata that identifies crate-level settings of the"
" Cairo compiler, for example, the `edition` field in the _Scarb.toml_ file."
msgstr ""
"Sebuah subset metadata paket yang mengidentifikasi pengaturan tingkat peti "
"dari kompiler Cairo, misalnya, daerah ·editioná dalam berkas _Scarb.toml."

#: src/ch07-01-packages-and-crates.md:10
msgid ""
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as will be discussed in the subsequent "
"sections."
msgstr ""
"Crates dapat berisi modul, dan modul dapat didefinisikan dalam berkas lain "
"yang dikompile dengan peti, seperti yang akan dibahas di bagian selanjutnya."

#: src/ch07-01-packages-and-crates.md:12
msgid "What is the Crate Root?"
msgstr "Apa itu Crate Root?"

#: src/ch07-01-packages-and-crates.md:14
msgid ""
"The crate root is the _lib.cairo_ source file that the Cairo compiler starts"
" from and makes up the root module of your crate. We’ll explain modules in "
"depth in the [\"Defining Modules to Control Scope\"](./ch07-02-defining-"
"modules-to-control-scope.md) chapter."
msgstr ""
"Akar peti adalah berkas sumber _lib.cairo_ yang dimulai oleh kompiler Cairo "
"dan membentuk modul root dari peti anda. Kami akan menjelaskan modul dalam "
"kedalaman di bab [\"Defining Modules to Control Scope\"]]./ch07-02-defining-"
"modules-to-control-scope.md)."

#: src/ch07-01-packages-and-crates.md:18
msgid "What is a Package?"
msgstr "Apa itu Paket?"

#: src/ch07-01-packages-and-crates.md:20
msgid "A Cairo package is a directory (or equivalent) containing:"
msgstr "Paket Cairo adalah direktori (atau ekuivalen) yang berisi:"

#: src/ch07-01-packages-and-crates.md:22
msgid "A _Scarb.toml_ manifest file with a `[package]` section."
msgstr "Berkas nyata _Scarb.toml dengan bagian [paket]."

#: src/ch07-01-packages-and-crates.md:23
msgid "Associated source code."
msgstr "Kode sumber yang terkait."

#: src/ch07-01-packages-and-crates.md:25
msgid ""
"This definition implies that a package might contain other packages, with a "
"corresponding _Scarb.toml_ file for each package."
msgstr ""
"Definisi ini menyiratkan bahwa paket mungkin berisi paket lain, dengan "
"berkas _Scarb.toml_ yang sesuai untuk setiap paket."

#: src/ch07-01-packages-and-crates.md:27
msgid "Creating a Package with Scarb"
msgstr "Membuat Paket dengan Scarb"

#: src/ch07-01-packages-and-crates.md:29
msgid ""
"You can create a new Cairo package using the Scarb command-line tool. To "
"create a new package, run the following command:"
msgstr ""
"Anda dapat membuat paket baru Cairo menggunakan alat baris perintah Scarb. "
"Untuk membuat paket baru, jalankan perintah berikut:"

#: src/ch07-01-packages-and-crates.md:35
msgid ""
"This command will generate a new package directory named _my_package_ with "
"the following structure:"
msgstr ""
"Perintah ini akan membuat direktori paket baru bernama _my_package_ dengan "
"struktur berikut:"

#: src/ch07-01-packages-and-crates.md:44
msgid ""
"_src/_ is the main directory where all the Cairo source files for the "
"package will be stored."
msgstr ""
"_src/_ adalah direktori utama di mana semua berkas sumber Cairo untuk paket "
"tersebut akan disimpan."

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"_lib.cairo_ is the default root module of the crate, which is also the main "
"entry point of the package."
msgstr ""
"_lib.cairo_ adalah modul root baku dari peti, yang juga merupakan titik "
"masuk utama dari paket."

#: src/ch07-01-packages-and-crates.md:46
msgid ""
"_Scarb.toml_ is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, "
"version, and authors. You can find documentation about it on the [Scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""
"_Scarb.toml_ adalah berkas manifes paket, yang berisi pilihan metadata dan "
"konfigurasi untuk paket, seperti dependensi, nama paket, versi, dan penulis."
" Anda dapat menemukan dokumentasi tentang hal itu di [Scarb "
"acuan]bah://docs.swmansion.com/scarb/docts/referensi/manast.html)."

#: src/ch07-01-packages-and-crates.md:48
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"edition = \"2023_11\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"\"My_package\" versi = \"0.1.0\" edisi = \"2023_11\" [ketergantungan] # foo "
"= { path = \"vendor/foo\" }"

#: src/ch07-01-packages-and-crates.md:58
msgid ""
"As you develop your package, you may want to organize your code into "
"multiple Cairo source files. You can do this by creating additional _.cairo_"
" files within the _src_ directory or its subdirectories."
msgstr ""
"Ketika Anda mengembangkan paket Anda, Anda mungkin ingin mengatur kode Anda "
"ke dalam beberapa berkas sumber Cairo. Anda dapat melakukan ini dengan "
"membuat _.cairo_ berkas tambahan dalam direktori _src_ atau subdirektorinya."

#: src/ch07-01-packages-and-crates.md:60
msgid "{{#quiz ../quizzes/ch07-01-packages-crates.toml}}"
msgstr "{{#quiz../quizzes/ch07-01-packages-crates.toml}}}"

#: src/ch07-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system, namely _paths_ that allow you to name items and the `use` keyword "
"that brings a path into scope."
msgstr ""
"Di bagian ini, kita akan berbicara tentang modul dan bagian lain dari sistem"
" modul, yaitu _paths_ yang memungkinkan Anda untuk menamai item dan kata "
"kunci yang membawa jalur ke ruang lingkup."

#: src/ch07-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when "
"you’re organizing your code in the future. Then we’ll explain each of the "
"rules in detail."
msgstr ""
"Pertama, kita akan mulai dengan daftar aturan untuk referensi mudah ketika "
"Anda menyusun kode Anda di masa depan."

#: src/ch07-02-defining-modules-to-control-scope.md:11
msgid "Modules Cheat Sheet"
msgstr "Modul Menyontek Lembaran"

#: src/ch07-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` "
"keyword work in the compiler, and how most developers organize their code. "
"We’ll be going through examples of each of these rules throughout this "
"chapter, but this is a great place to refer to as a reminder of how modules "
"work. You can create a new Scarb project with `scarb new backyard` to follow"
" along."
msgstr ""
"Di sini kita memberikan referensi singkat tentang bagaimana modul, jalur, "
"dan kata kunci yang digunakan dalam kompiler, dan bagaimana kebanyakan "
"pengembang mengatur kode mereka. kita akan melalui contoh-contoh dari setiap"
" aturan ini di seluruh bab ini, tapi ini adalah tempat yang bagus untuk "
"mengacu sebagai pengingat bagaimana modul bekerja. Anda dapat membuat proyek"
" Scarb baru dengan halaman belakang OCARB baru untuk diikuti."

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first "
"looks in the crate root file (_src/lib.cairo_) for code to compile."
msgstr ""
"** Mulai dari root** peti: Ketika menyusun peti, kompiler pertama kali "
"terlihat dalam berkas root peti (_src/lib.cairo_) untuk mengkompilasi kode."

#: src/ch07-02-defining-modules-to-control-scope.md:21
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; "
"say, you declare a “garden” module with `mod garden;`. The compiler will "
"look for the module’s code in these places:"
msgstr ""
"** Menurunkan moduls**: Dalam berkas root peti, anda dapat menyatakan modul "
"baru; katakanlah, anda menyatakan modul ·gartená dengan åmod garden;ltu "
"kompiler akan mencari kode modul (mod) di tempat-tempat ini:"

#: src/ch07-02-defining-modules-to-control-scope.md:25
msgid ""
"Inline, within curly brackets that replace the semicolon following `mod "
"garden`."
msgstr ""
"Inline, dalam tanda kurung keriting yang menggantikan semikolon berikut "
"taman åmod."

#: src/ch07-02-defining-modules-to-control-scope.md:28
msgid "// crate root file (src/lib.cairo)\n"
msgstr "//frat root file (src/lib.cairo)\n"

#: src/ch07-02-defining-modules-to-control-scope.md:30
msgid "// code defining the garden module goes here\n"
msgstr "//kode mendefinisikan modul kebun di sini\n"

#: src/ch07-02-defining-modules-to-control-scope.md:34
msgid "In the file _src/garden.cairo_."
msgstr "Dalam file _src/garden.cairo_."

#: src/ch07-02-defining-modules-to-control-scope.md:36
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can "
"declare submodules. For example, you might declare `mod vegetables;` in "
"_src/garden.cairo_. The compiler will look for the submodule’s code within "
"the directory named for the parent module in these places:"
msgstr ""
"**Declaring submodules**: Dalam berkas apapun selain akar peti, Anda dapat "
"mendeklarasikan submodules. Sebagai contoh, Anda dapat mendeklarasikan "
"sayur-sayuran ▪ di _src/garden.cairo_. compiler akan mencari kode submoduel "
"dalam direktori yang bernama untuk modul induk di tempat-tempat ini:"

#: src/ch07-02-defining-modules-to-control-scope.md:41
msgid ""
"Inline, directly following `mod vegetables`, within curly brackets instead "
"of the semicolon."
msgstr ""
"Inline, langsung mengikuti sayuran ltumod, dalam kurung keriting bukan "
"semikolon."

#: src/ch07-02-defining-modules-to-control-scope.md:45
msgid "// src/garden.cairo file\n"
msgstr "// src/garden.cairo file\n"

#: src/ch07-02-defining-modules-to-control-scope.md:47
msgid "// code defining the vegetables submodule goes here\n"
msgstr "//kode mendefinisikan submodul sayuran di sini\n"

#: src/ch07-02-defining-modules-to-control-scope.md:51
msgid "In the file _src/garden/vegetables.cairo_."
msgstr "Dalam file _src/garden/vegetables.cairo_."

#: src/ch07-02-defining-modules-to-control-scope.md:53
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can "
"refer to code in that module from anywhere else in that same crate, using "
"the path to the code. For example, an `Asparagus` type in the `vegetables` "
"submodule would be found at `backyard::garden::vegetables::Asparagus`."
msgstr ""
"**Paths to code in modules**: Sekali sebuah modul adalah bagian dari peti "
"Anda, Anda dapat mengacu pada kode dalam modul tersebut dari mana saja dalam"
" peti yang sama, menggunakan jalur ke kode. Sebagai contoh, sebuah tipe "
"▪Asparagus dalam submodule ▪ akan ditemukan di ▪backyard:garden::veables: "
"Asparagus."

#: src/ch07-02-defining-modules-to-control-scope.md:57
msgid ""
"**Private vs public**: Code within a module is private from its parent "
"modules by default. This means that it may only be accessed by the current "
"module and its descendants. To make a module public, declare it with `pub "
"mod` instead of `mod`. To make items within a public module public as well, "
"use `pub` before their declarations. Cairo also provides the `pub(crate)` "
"keyword, allowing an item or module to be only visible within the crate in "
"which the definition is included."
msgstr ""
"*Private vs public**: Kode dalam sebuah modul adalah privat dari modul induk"
" secara baku. Ini berarti bahwa ia hanya dapat diakses oleh modul saat ini "
"dan keturunannya. Untuk membuat modul publik, menyatakannya dengan modul "
"modul modul Épub modåmod. Untuk membuat barang-barang dalam modul publik "
"juga, gunakan åpubå sebelum deklarasi mereka. Cairo juga menyediakan kata "
"kunci Ápubauxrate), mengijinkan sebuah item atau modul hanya terlihat dalam "
"definisi tersebut."

#: src/ch07-02-defining-modules-to-control-scope.md:59
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to items to reduce repetition of long paths. In any scope that can refer to "
"`backyard::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use backyard::garden::vegetables::Asparagus;` and from then on you only "
"need to write `Asparagus` to make use of that type in the scope."
msgstr ""
"* Kata kunci yang digunakan: Dalam lingkup, kata kunci yang digunakan dapat "
"membuat jalan pintas untuk mengurangi pengulangan jalur yang panjang. Dalam "
"ruang lingkup yang dapat mengacu ke halaman belakang: Gardenen::vegeles: "
"Asparagus::: Asparagus, Anda dapat membuat jalan pintas dengan halaman "
"belakang thoseus::::::veables:: Asparagus; dan mulai saat itu Anda hanya "
"perlu menulis ▪Asparagaux untuk membuat tipe tersebut dalam ruang lingkup."

#: src/ch07-02-defining-modules-to-control-scope.md:65
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The "
"crate’s directory, also named `backyard`, contains these files and "
"directories:"
msgstr ""
"Di sini kita membuat sebuah peti bernama °backyard yang menggambarkan "
"aturan-aturan ini."

#: src/ch07-02-defining-modules-to-control-scope.md:78
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr "Berkas root peti dalam kasus ini adalah _src/lib.cairo_, dan berisi:"

#: src/ch07-02-defining-modules-to-control-scope.md:88
msgid "\"I'm growing {:?}!\""
msgstr "\"Aku tumbuh [:]!\""

#: src/ch07-02-defining-modules-to-control-scope.md:92
msgid ""
"The `pub mod garden;` line imports the `garden` module. Using `pub` to make "
"`garden` publicly accessible, or `pub(crate)` if you really want to make "
"`garden` only available for your crate, is optional to run our program here,"
" as the `main` function resides in the same module as `pub mod garden;` "
"declaration. Nevertheless, not declaring `garden` as `pub` will make it not "
"accessible from any other package. This line tells the compiler to include "
"the code it finds in _src/garden.cairo_, which is:"
msgstr ""
"Dengan menggunakan modul 'copub mod garden' untuk membuat akses publik, atau"
" 'pub://crate' jika Anda benar-benar ingin membuat 'production' hanya "
"tersedia untuk peti Anda, adalah pilihan untuk menjalankan program kami di "
"sini, sebagai fungsi ▪mainan' berada di modul yang sama dengan modifikasi "
"kebun; walaupun demikian, tidak menyatakan  (trbi) sebagai ·bub 1932 yang "
"tidak akan membuatnya dapat diakses dari paket lain. Garis ini berisi kode "
"untuk menemukan _s / erc / ergard_, yang mana."

#: src/ch07-02-defining-modules-to-control-scope.md:95
msgid "<span class=\"filename\">Filename: src/garden.cairo</span>"
msgstr "<nama berkas=\"pan\"> Nama berkas: src/garden.cairo</span>"

#: src/ch07-02-defining-modules-to-control-scope.md:101
msgid ""
"Here, `pub mod vegetables;` means the code "
"in _src/garden/vegetables.cairo_ is included too. That code is:"
msgstr ""
"Ini, sayuran mod åpub; itu berarti kode dalam _src/garden/vegetables.cairo_ "
"termasuk juga."

#: src/ch07-02-defining-modules-to-control-scope.md:108
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us bring the `Asparagus` "
"type into scope, so we can use it in the `main` function."
msgstr ""
"Barisan kebun åuse:: vegetables: Asparagus; lets us bring the åAsparagus "
"type into scope, so we can use it in the åmain function."

#: src/ch07-02-defining-modules-to-control-scope.md:111
msgid ""
"Now let’s get into the details of these rules and demonstrate them in "
"action!"
msgstr ""
"Sekarang, mari kita bahas perincian peraturan - aturan ini dan "
"mempertunjukkan tindakan mereka!"

#: src/ch07-02-defining-modules-to-control-scope.md:113
msgid "Grouping Related Code in Modules"
msgstr "Kode Berkaitan Kelompok dalam Modul"

#: src/ch07-02-defining-modules-to-control-scope.md:115
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse. Modules also allow us to control the privacy of items, because code "
"within a module is private by default. Private items are internal "
"implementation details not available for outside use. We can choose to make "
"modules and the items within them public, which exposes them to allow "
"external code to use and depend on them."
msgstr ""
"_Modules_ mari kita mengatur kode dalam sebuah peti untuk dibaca kembali dan"
" mudah digunakan. Modul juga memungkinkan kita untuk mengontrol privasi "
"item, karena kode dalam modul adalah privat secara baku. Objek pribadi "
"adalah rincian implementasi internal yang tidak tersedia untuk penggunaan "
"luar. Kita dapat memilih untuk membuat modul dan item di dalamnya publik, "
"yang mengekspos mereka untuk mengijinkan kode eksternal untuk digunakan dan "
"bergantung pada mereka."

#: src/ch07-02-defining-modules-to-control-scope.md:121
msgid ""
"As an example, let’s write a library crate that provides the functionality "
"of a restaurant. We’ll define the signatures of functions but leave their "
"bodies empty to concentrate on the organization of the code, rather than the"
" implementation of a restaurant."
msgstr ""
"Sebagai contoh, mari kita tulis sebuah peti perpustakaan yang menyediakan "
"fungsi sebuah restoran."

#: src/ch07-02-defining-modules-to-control-scope.md:126
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as "
"_front of house_ and others as _back of house_. Front of house is where "
"customers are; this encompasses where the hosts seat customers, servers take"
" orders and payment, and bartenders make drinks. Back of house is where the "
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do "
"administrative work."
msgstr ""
"Dalam industri restoran, beberapa bagian dari sebuah restoran disebut _front"
" of house_ and others as _back of house_. Front of house is where custoers "
"are; this melingles where the host seat pelanggan, server mengambil pesanan "
"dan pembayaran, dan bartender membuat minuman. Back of house is where the "
"chefs and cooks works in the kitry, pencuci piring membersihkan, dan manajer"
" melakukan pekerjaan administratif."

#: src/ch07-02-defining-modules-to-control-scope.md:133
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested modules. Create a new package named _restaurant_ by running `scarb "
"new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to "
"define some modules and function signatures. Here’s the front of house "
"section:"
msgstr ""
"Untuk menyusun peti dengan cara ini, kita dapat mengatur fungsinya ke modul "
"nested. Buat paket baru bernama _restaurant_ dengan menjalankan restoran "
"baru åscarb; kemudian masukkan kode dalam Listing 7-1 ke _src/lib.cairo_ "
"untuk menentukan beberapa modul dan tanda-tangan fungsi. Di sini sini adalah"
" bagian depan daerah rumah:"

#: src/ch07-02-defining-modules-to-control-scope.md:157
msgid ""
"<span class=\"caption\">Listing 7-1: A `front_of_house` module containing "
"other modules that then contain functions</span>"
msgstr ""
"<span class=\"caption\">Listing 7-1: Sebuah modul di muka_of_house# yang "
"berisi modul lain yang kemudian berisi fungsi</span>"

#: src/ch07-02-defining-modules-to-control-scope.md:159
msgid ""
"We define a module with the `mod` keyword followed by the name of the module"
" (in this case, `front_of_house`). The body of the module then goes inside "
"curly brackets. Inside modules, we can place other modules, as in this case "
"with the modules `hosting` and `serving`. Modules can also hold definitions "
"for other items, such as structs, enums, constants, traits, and functions."
msgstr ""
"Kami mendefinisikan modul dengan kata kunci ·modà diikuti dengan nama modul "
"(dalam hal ini, di depan_of_house). Tubuh modul kemudian masuk ke dalam "
"braket keriting. Di dalam modul, kita dapat menempatkan modul lain, seperti "
"dalam hal ini modul-modil ·hosting, dan ▪serviderà. Modul-modulasi juga "
"dapat menyimpan definisi untuk hal-hal lain, seperti struktur, enum, "
"konstanta, karakter, dan fungsi."

#: src/ch07-02-defining-modules-to-control-scope.md:165
msgid ""
"By using modules, we can group related definitions together and name why "
"they’re related. Programmers using this code can navigate the code based on "
"the groups rather than having to read through all the definitions, making it"
" easier to find the definitions relevant to them. Programmers adding new "
"functionality to this code would know where to place the code to keep the "
"program organized."
msgstr ""
"Dengan menggunakan modul, kita dapat menghubungkan definisi bersama-sama dan"
" nama mengapa mereka terkait. Programmer menggunakan kode ini dapat "
"menavigasi kode berdasarkan pada kelompok daripada harus membaca melalui "
"semua definisi, membuatnya lebih mudah untuk menemukan definisi yang relevan"
" dengan mereka. Programmer menambahkan fungsionalitas baru ke kode ini akan "
"tahu di mana untuk menempatkan kode untuk menjaga program terorganisir."

#: src/ch07-02-defining-modules-to-control-scope.md:171
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The "
"reason for this name is that the content of this file forms a module named "
"after the crate name at the root of the crate’s module structure, known as "
"the _module tree_."
msgstr ""
"Sebelumnya, kami menyebutkan bahwa _src/lib.cairo_ disebut akar peti. Alasan"
" untuk nama ini adalah bahwa isi dari berkas ini membentuk sebuah modul "
"bernama setelah nama peti di akar struktur modul peti yang dikenal sebagai "
"_module tree_."

#: src/ch07-02-defining-modules-to-control-scope.md:174
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr "Daftar 7-2 menunjukkan pohon modul untuk struktur dalam Daftar 7-1."

#: src/ch07-02-defining-modules-to-control-scope.md:188
msgid ""
"<span class=\"caption\">Listing 7-2: The module tree for the code in Listing"
" 7-1</span>"
msgstr ""
"<span class=\"caption\">Listing 7-2: The module tree for the code in Listing"
" 7-1</span>"

#: src/ch07-02-defining-modules-to-control-scope.md:190
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example, `hosting` nests inside `front_of_house`. The tree also shows that "
"some modules are _siblings_ to each other, meaning they’re defined in the "
"same module; `hosting` and `serving` are siblings defined within "
"`front_of_house`. If module A is contained inside module B, we say that "
"module A is the _child_ of module B and that module B is the _parent_ of "
"module A. Notice that the entire module tree is rooted under the explicit "
"name of the crate _restaurant_."
msgstr ""
"Pohon ini menunjukkan bagaimana beberapa modul saling bersarang satu sama "
"lain, sebagai contoh, sarang-sarang di dalam sarang di depan_of_house. Pohon"
" ini juga menunjukkan bahwa beberapa modul adalah _siblings_ untuk satu sama"
" lain, yang berarti mereka didefinisikan dalam modul yang sama; ôhosing "
"(hosing) dan åserving) adalah saudara kandung didefinisikan dalam "
"▪f_of_house. Jika modul A dimuat di dalam modul B, kita mengatakan bahwa "
"modul A adalah _child_ B dan modul B adalah _parent_ modul A. Perhatikan "
"bahwa seluruh modul ini berakar secara eksplisit di bawah nama _resan."

#: src/ch07-02-defining-modules-to-control-scope.md:198
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your "
"computer; this is a very apt comparison! Just like directories in a "
"filesystem, you use modules to organize your code. And just like files in a "
"directory, we need a way to find our modules."
msgstr ""
"Pohon modul mungkin mengingatkan Anda pada pohon direktori filesystem di "
"komputer Anda; ini adalah perbandingan yang sangat tepat! Sama seperti "
"direktori dalam sistem berkas, Anda menggunakan modul untuk mengatur kode "
"Anda. Dan seperti berkas dalam direktori, kita perlu cara untuk menemukan "
"modul kami."

#: src/ch07-02-defining-modules-to-control-scope.md:203
msgid "{{#quiz ../quizzes/ch07-02-defining-modules-to-control-scope.toml}}"
msgstr "{{#quiz../quizzes/ch07-02-defining-modules-to-control-scope.toml}}"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr ""
"Untuk menunjukkan Cairo di mana untuk menemukan item dalam pohon modul, kita"
" menggunakan jalur dengan cara yang sama kita menggunakan jalur ketika "
"menavigasi sistem berkas. Untuk memanggil sebuah fungsi, kita perlu tahu "
"jalurnya."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr "Sebuah jalur dapat mengambil dua bentuk:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"An _absolute path_ is the full path starting from a crate root. The absolute"
" path begins with the crate name."
msgstr ""
"Path _absolute_ adalah jalur penuh mulai dari akar peti. Path absolut "
"dimulai dengan nama peti."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:8
msgid "A _relative path_ starts from the current module."
msgstr "Path _relatif_ dimulai dari modul saat ini."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:10
msgid ""
"Both absolute and relative paths are followed by one or more identifiers "
"separated by double colons (`::`)."
msgstr ""
"Baik jalur absolut maupun relatif diikuti oleh satu atau lebih "
"pengidentifikasi dipisahkan oleh titik dua (Negara ganda)."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:12
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the "
"restaurant we used in the last chapter. We have a crate named _restaurant_ "
"in which we have a module named `front_of_house` that contains a module "
"named `hosting`. The `hosting` module contains a function named "
"`add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr ""
"Untuk menggambarkan gagasan ini mari kita ambil kembali contoh kami Listing "
"7-1 untuk restoran yang kami gunakan di bab terakhir. kami memiliki sebuah "
"peti bernama _restaurant_ di mana kami memiliki modul yang bernama "
"▪front_of_house_house yang berisi modul bernama åhossingé. modul terakhir "
"yang kami gunakan berisi sebuah fungsi bernama ádd_t_waité. Kami ingin "
"menghubungi Ád_t_waitlistée fungsi dari fungsi eat_rest_reurantó. Kita perlu"
" memberitahu Caia jalan ke daftar fungsi yang dapat Anda tunggui sehingga "
"dapat menemukan fungsinya."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:35
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:100
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:126
msgid "// Absolute path\n"
msgstr "//Lokasi absolut\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:38
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:103
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:129
msgid "// Relative path\n"
msgstr "Path relatif\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:43
msgid ""
"<span class=\"caption\">Listing 7-3: Calling the `add_to_waitlist` function "
"using absolute and relative paths</span>"
msgstr ""
"<span class=\"caption\">Listing 7-3: Memanggil fungsi absolut dan "
"relatif</span>"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:45
msgid ""
"The `eat_at_restaurant` function is part of our library's public API, so we "
"mark it with the `pub` keyword. We’ll go into more detail about `pub` in "
"the [\"Exposing Paths with the `pub` Keyword\"](./ch07-03-paths-for-"
"referring-to-an-item-in-the-module-tree.md#exposing-paths-with-the-pub-"
"keyword) section."
msgstr ""
"The eat_at_retaurant_retauráne adalah bagian dari API publik perpustakaan "
"kami, jadi kami menandainya dengan kata kunci. Kami akan membahas lebih "
"rinci tentang åpubà di [\"Exposing Paths-pates-with-pub-"
"keyword\"]./ch07-pathpers-for-referring-to-an-ite-m-in-module-"
"tree.m#exexexs-paths-with-the-pub-key) bagian."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:47
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function"
" is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute "
"paths start from the crate root, which you need to refer to by using the "
"crate name. You can imagine a filesystem with the same structure: we’d "
"specify the path _/front_of_house/hosting/add_to_waitlist_ to run the "
"_add_to_waitlist_ program; using the crate name to start from the crate root"
" is like using a slash (`/`) to start from the filesystem root in your "
"shell."
msgstr ""
"Pertama kali kita sebut fungsi ·add_to_waitlist_waitlistít_at_restaurantán, "
"kita menggunakan jalur absolut. Fungsi yang kita sebut sebagai fungsi "
"absolut. Anda dapat membayangkan sistem berkas dengan struktur yang sama: "
"kami menentukan jalur _/front_house_host_posurant. Di Cairo, jalur absolut "
"dimulai dari akar peti, yang Anda butuhkan untuk merujuk dengan menggunakan "
"nama peti. Anda dapat membayangkan sistem berkas dengan struktur yang sama: "
"kami menspesifikasikan path _/front_house/hos_host_to_waitlist untuk "
"menjalankan _d_t_list; menggunakan nama peti untuk mulai dari akar/zoom."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:51
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path "
"starts with `front_of_house`, the name of the module defined at the same "
"level of the module tree as `eat_at_restaurant`. Here the filesystem "
"equivalent would be using the path "
"_./front_of_house/hosting/add_to_waitlist_. Starting with a module name "
"means that the path is relative to the current module."
msgstr ""
"Kedua kalinya kita memanggil modul yang sama dengan pohon modul sebagai "
"áeat_resturant_quot; di sini sistem berkas setara akan menggunakan jalur "
"_./front_house/hos/adto_waitlist. Memulai dengan nama modul berarti jalur "
"relatif terhadap modul saat ini."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:53
msgid ""
"Let’s try to compile Listing 7-3 and find out why it won’t compile yet! We "
"get the following error:"
msgstr ""
"Mari kita coba menyusun Listing 7-3 dan mencari tahu mengapa hal itu belum "
"dapat dikompilasi!"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:78
msgid ""
"The error messages say that module `hosting` and the `add_to_waitlist` "
"function are not visible. In other words, we have the correct paths for the "
"`hosting` module and the `add_to_waitlist` function, but Cairo won’t let us "
"use them because it doesn’t have access to them. In Cairo, all items "
"(functions, methods, structs, enums, modules, and constants) are private to "
"parent modules by default. If you want to make an item like a function or "
"struct private, you put it in a module."
msgstr ""
"Pesan kesalahan mengatakan bahwa modul ·hosing-- dan fungsi "
"·add_to_waitlist_wait tidak terlihat. Dengan kata lain, kita memiliki jalur "
"yang benar untuk modul åhosting (mengatur, enums, modul, dan "
"konstanta_to_wait, tetapi Cairo tidak membiarkan kita menggunakannya karena "
"ia tidak memiliki akses ke mereka. Di Cairo, semua item (fungsi, metode, "
"struktur, modul, dan konstanta) adalah untuk modul induk secara baku. Jika "
"Anda ingin membuat item seperti fungsi atau struktur pribadi, Anda masukkan "
"ke dalam modul pribadi."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:80
msgid ""
"Items in a parent module can’t use the private items inside child modules, "
"but items in child modules can use the items in their ancestor modules. This"
" is because child modules wrap and hide their implementation details, but "
"the child modules can see the context in which they’re defined. To continue "
"with our metaphor, think of the privacy rules as being like the back office "
"of a restaurant: what goes on in there is private to restaurant customers, "
"but office managers can see and do everything in the restaurant they "
"operate."
msgstr ""
"Item dalam modul induk dapat menggunakan barang-barang pribadi di dalam "
"modul anak, tetapi item dalam modul anak dapat menggunakan item dalam modul "
"nenek moyang mereka. Ini karena modul anak membungkus dan menyembunyikan "
"rincian implementasi mereka, tapi modul anak dapat melihat konteks di mana "
"mereka didefinisikan. Untuk melanjutkan metafora kita, pikirkan aturan "
"privasi seperti kantor belakang restoran: apa yang terjadi di sana adalah "
"pribadi bagi pelanggan restoran, tetapi manajer kantor dapat melihat dan "
"melakukan segala sesuatu di restoran yang mereka kerjakan."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:82
msgid ""
"Cairo chose to have the module system function this way so that hiding inner"
" implementation details is the default. That way, you know which parts of "
"the inner code you can change without breaking outer code. However, Cairo "
"does give you the option to expose inner parts of child modules’ code to "
"outer ancestor modules by using the `pub` keyword to make an item public."
msgstr ""
"Cairo memilih untuk memiliki fungsi sistem modul dengan cara ini sehingga "
"menyembunyikan rincian implementasi batin adalah hal yang baku. Dengan cara "
"itu, Anda tahu bagian mana dari kode dalam yang dapat Anda ubah tanpa "
"melanggar kode luar. Namun, Cairo memberikan pilihan untuk mengekspos bagian"
" dalam modul anak."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:86
msgid "Exposing Paths with the `pub` Keyword"
msgstr "Alamat Eksposing dengan Kata Kunci åpub)"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:88
msgid ""
"Let’s return to the previous error that told us the `hosting` module and the"
" `add_to_waitlist` function are not visible. We want the `eat_at_restaurant`"
" function in the parent module to have access to the `add_to_waitlist` "
"function in the child module, so we mark the `hosting` module with the `pub`"
" keyword, as shown in Listing 7-4."
msgstr ""
"Mari kita kembali ke kesalahan sebelumnya yang mengatakan kepada kita bahwa "
"modul tersebut dan modul ·add_to_waitlist tidak terlihat."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:108
msgid ""
"<span class=\"caption\">Listing 7-4: Declaring the `hosting` module as `pub`"
" to use it from `eat_at_restaurant`</span>"
msgstr "<kelas lebar=\"caption\">Listing 7-4: Menyatakan modul </span>"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:110
msgid "Unfortunately, the code in Listing 7-4 still results in an error."
msgstr "Sayangnya, kode dalam Daftar 7-4 masih menghasilkan kesalahan."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:112
msgid ""
"What happened? Adding the `pub` keyword in front of `mod hosting;` makes the"
" module public. With this change, if we can access `front_of_house`, we can "
"access `hosting`. But the contents of `hosting` are still private; making "
"the module public doesn’t make its contents public. The `pub` keyword on a "
"module only lets code in its ancestor modules refer to it, not access its "
"inner code. Because modules are containers, there’s not much we can do by "
"only making the module public; we need to go further and choose to make one "
"or more of the items within the module public as well."
msgstr ""
"Apa yang terjadi? Menambahkan kata kunci di depan hosting ·mod; membuat "
"modul publik. dengan perubahan ini, jika kita dapat mengaksesnya di "
"depan_house, kita dapat mengakses modul leluhurnya, namun isi dari "
"entertainer ·hostingà masih pribadi; membuat modul publik tidak membuat isi "
"publik publik. Kata kunci pada modul hanya memungkinkan kode dalam modul "
"nenek moyang yang mengacu, tidak mengakses kode batinnya. karena modul-"
"modulnya, tidak banyak yang dapat kita lakukan dengan modul publik; kita "
"perlu untuk membuat modul lebih lanjut; kita memilih satu modul atau lebih "
"banyak modul publik yang ada di dalamnya."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:114
msgid ""
"Let’s also make the `add_to_waitlist` function public by adding the `pub` "
"keyword before its definition, as in Listing 7-5."
msgstr ""
"Mari juga membuat daftar fungsi publik dengan menambahkan kata kunci sebelum"
" definisinya, seperti dalam Listing 7-5."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:127
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:130
msgid "// ✅ Compiles\n"
msgstr "//compils\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:134
msgid ""
"<span class=\"caption\">Listing 7-5: Declaring the `hosting` module as `pub`"
" to use it from `eat_at_restaurant`</span>"
msgstr "<span class=\"caption\">Listing 7-5: Menyatakan modul </span>"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:136
msgid ""
"Now the code will compile! To see why adding the `pub` keyword lets us use "
"these paths in `add_to_waitlist` with respect to the privacy rules, let’s "
"look at the absolute and the relative paths."
msgstr ""
"Sekarang kode akan dikompilasi! Untuk melihat mengapa menambahkan kata kunci"
" ·pubé memungkinkan kita menggunakan jalur ini dalam ·add_to_waitlist; "
"terhadap aturan privasi, mari kita lihat pada absolut dan jalur relatif."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:138
msgid ""
"In the absolute path, we start with the crate root, the root of our crate’s "
"module tree. The `front_of_house` module is defined in the crate root. While"
" `front_of_house` isn’t public, because the `eat_at_restaurant` function is "
"defined in the same module as `front_of_house` (that is, `front_of_house` "
"and `eat_at_restaurant` are siblings), we can refer to `front_of_house` from"
" `eat_at_restaurant`. Next is the `hosting` module marked with `pub`. We can"
" access the parent module of `hosting`, so we can access `hosting` itself. "
"Finally, the `add_to_waitlist` function is marked with `pub` and we can "
"access its parent module, so this function call works!"
msgstr ""
"Di jalan absolut, kita mulai dengan akar peti, akar dari pohon modul peti "
"kita. Modul depan_of_house didefinisikan dalam akar peti. Sementara "
"difront_house_of_house tidak bersifat umum, karena fungsi "
"petit_at_returant_productía didefinisikan dalam modul yang sama dengan modul"
" selanjutnya (yang ditandai dengan modul Á_of_house. dan "
"Á_part_reaten_reatent_storiant turis), kita dapat mereferensikan ke "
"depan_of_parte_oat_s_storeat_rest_s."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:140
msgid ""
"In the relative path, the logic is the same as the absolute path except for "
"the first step: rather than starting from the crate root, the path starts "
"from `front_of_house`. The `front_of_house` module is defined within the "
"same module as `eat_at_restaurant`, so the relative path starting from the "
"module in which `eat_at_restaurant` is defined works. Then, because "
"`hosting` and `add_to_waitlist` are marked with `pub`, the rest of the path "
"works, and this function call is valid!"
msgstr ""
"Dalam jalur relatif, logika adalah sama dengan jalur absolut kecuali untuk "
"langkah pertama: daripada memulai dari akar peti, jalan dimulai dari bagian "
"depan_of_house, modul yang sama dengan modul absolut_of_house. Kemudian, "
"karena ▪hosting odd_wait_ature_at_retaurantía, jadi jalur relatif dimulai "
"dari modul di mana  Johnnye_at_rest_stouránue didefinisikan bekerja. "
"Kemudian, karena ·hos_adto_waitánilist ditandai dengan ábáb, sisa dari jalur"
" kerja ini, dan panggilan ini valid!"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:142
msgid "{{#quiz ../quizzes/ch07-03-paths-in-module-tree-1.toml}}"
msgstr "{{#quiz../quizzes/ch07-03-paths-in-module-tree-1.toml}}}"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:144
msgid "Starting Relative Paths with `super`"
msgstr "Memulai Jalur Relatif dengan Superhero"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:146
msgid ""
"We can construct relative paths that begin in the parent module, rather than"
" the current module or the crate root, by using `super` at the start of the "
"path. This is like starting a filesystem path with the `..` syntax. Using "
"`super` allows us to reference an item that we know is in the parent module,"
" which can make rearranging the module tree easier when the module is "
"closely related to the parent, but the parent might be moved elsewhere in "
"the module tree someday."
msgstr ""
"Kita dapat membangun jalur relatif yang dimulai pada modul induk, daripada "
"modul atau akar peti saat ini, dengan menggunakan ·superå di awal jalur. Ini"
" seperti memulai jalur sistem berkas dengan syntax  (motorx). Menggunakan "
"hal yang kita ketahui pada modul induk, yang dapat membuat menyusun ulang "
"pohon modul lebih mudah ketika modul itu berhubungan erat dengan induk, "
"tetapi orang tua dapat dipindahkan ke tempat lain di pohon suatu hari nanti."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:148
msgid ""
"Consider the code in Listing 7-6 that models the situation in which a chef "
"fixes an incorrect order and personally brings it out to the customer. The "
"function `fix_incorrect_order` defined in the `back_of_house` module calls "
"the function `deliver_order` defined in the parent module by specifying the "
"path to `deliver_order` starting with `super`:"
msgstr ""
"Pertimbangkan kode dalam Listing 7-6 yang model situasi di mana seorang koki"
" memperbaiki urutan yang salah dan secara pribadi membawanya ke pelanggan. "
"Fungsi ▪fix_incord_orderdedededect dalam ▪back_of_house#house modul "
"panggilan fungsi ▪deliver_orderal didefinisikan dalam modul induk dengan "
"menspesifikasikan jalur ke Édeliver_ preserve:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:165
msgid ""
"<span class=\"caption\">Listing 7-6: Calling a function using a relative "
"path starting with `super`</span>"
msgstr ""
"<span class=\"caption\">Listing 7-6: Memanggil sebuah fungsi menggunakan "
"jalur relatif dimulai dengan super</span>"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:167
msgid ""
"Here you can see directly that you access a parent's module easily using "
"`super`, which wasn't the case previously. Note that the `back_of_house` is "
"kept private, as external users are not supposed to interact with the back "
"of house directly."
msgstr ""
"Di sini Anda dapat melihat secara langsung bahwa Anda mengakses modul orang "
"tua dengan mudah menggunakan superepsi, yang tidak pernah terjadi "
"sebelumnya."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:170
msgid "Making Structs and Enums Public"
msgstr "Membuat Struktur dan Publik Enums"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:172
msgid ""
"We can also use `pub` to designate structs and enums as public, but there "
"are a few extra details to consider when using `pub` with structs and enums."
msgstr ""
"Kita juga dapat menggunakan åpub) untuk mengartikan struktur dan enums "
"sebagai publik, tetapi ada beberapa rincian tambahan untuk dipertimbangkan "
"sewaktu menggunakan ·pub dengan struct dan enums."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:174
msgid ""
"If we use `pub` before a struct definition, we make the struct public, but "
"the struct’s fields will still be private. We can make each field public or "
"not on a case-by-case basis."
msgstr ""
"Jika kita menggunakan °pub sebelum definisi struct, kita membuat struct "
"publik, tetapi structing fields masih akan menjadi pribadi. kita dapat "
"membuat setiap lapangan publik atau tidak pada kasus-per-kasus."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:175
msgid ""
"In contrast, if we make an enum public, all of its variants are then public."
" We only need the `pub` before the `enum` keyword."
msgstr "Sebaliknya, jika kita membuat publik enum, semua varian maka publik."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:177
msgid ""
"There’s one more situation involving `pub` that we haven’t covered, and that"
" is our last module system feature: the `use` keyword. We’ll cover `use` by "
"itself first, and then we’ll show how to combine `pub` and `use`."
msgstr ""
"Ada satu situasi lagi yang melibatkan diri sendiri, dan itu adalah fitur "
"sistem modul terakhir kita: kata kunci."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:179
msgid "{{#quiz ../quizzes/ch07-03-paths-in-module-tree-2.toml}}"
msgstr "{{#quiz../quizzes/ch07-03-paths-in-module-tree-2.toml}}}"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can "
"create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr ""
"Setelah menuliskan jalan untuk memanggil fungsi dapat merasa tidak nyaman "
"dan berulang-ulang. untungnya, ada cara untuk menyederhanakan proses ini: "
"kita dapat membuat jalan pintas dengan kata kunci yang digunakan sekali, dan"
" kemudian menggunakan nama pendek di mana-mana dalam lingkup."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 7-7, we bring the `restaurant::front_of_house::hosting` module "
"into the scope of the `eat_at_restaurant` function so we only have to "
"specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in"
" `eat_at_restaurant`."
msgstr ""
"Di Listing 7-7, kami membawa ·restaurant:front_of_house::hosing those module"
" into the scope of the · eat_at_restaurantá jadi kami hanya perlu menentukan"
" Ásting: add_to_waitlist to call the ·ad_to waitlist fungsi in "
"▪at_reater_stoatent_stourantá."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:13
msgid ""
"// Assuming \"front_of_house\" module is contained in a crate called \"restaurant\", as mentioned in the section \"Defining Modules to Control Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in the use statement\n"
msgstr ""
"/// Asumsikan modul \"front_of_house\" terkandung dalam peti yang disebut "
"\"restourant\", seperti disebutkan dalam bagian \"Defining Modules to "
"Control Scope\" / Jika jalur dibuat dalam peti yang sama, \"restoran\" "
"adalah opsional dalam pernyataan penggunaan\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:25
msgid "// ✅ Shorter path\n"
msgstr "// Jalan Shorter\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid ""
"<span class=\"caption\">Listing 7-7: Bringing a module into scope with "
"`use`</span>"
msgstr ""
"<span class=\"caption\">Listing 7-7: Membawa sebuah modul ke dalam lingkup "
"dengan </span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:31
msgid ""
"Adding `use` and a path in a scope is similar to creating a symbolic link in"
" the filesystem. By adding `use restaurant::front_of_house::hosting;` in the"
" crate root, `hosting` is now a valid name in that scope, just as though the"
" `hosting` module had been defined in the crate root."
msgstr ""
"Menambahkan åuseé dan sebuah jalur dalam sebuah lingkup mirip dengan membuat"
" link simbolik dalam sistem berkas. Dengan menambahkan restoran "
"·us::front_of_house:::hosting; (hosting) dalam akar peti, thosehosting) "
"sekarang merupakan nama yang valid dalam lingkup itu, sama seperti modul "
"yang didefinisikan dalam akar peti."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:33
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-8 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile:"
msgstr ""
"Perhatikan bahwa hanya menciptakan jalan pintas untuk lingkup tertentu yang "
"kemudian merupakan ruang lingkup yang berbeda dari pernyataan thoseuse, "
"sehingga fungsi tubuh memenangkan kompilasi:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:54
msgid ""
"<span class=\"caption\">Listing 7-8: A `use` statement only applies in the "
"scope it’s in.</span>"
msgstr ""
"<span class=\"caption\">Listing 7-8: Sebuah pernyataan yang digunakan hanya "
"berlaku dalam lingkup itu masuk.</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr ""
"Kesalahan kompiler menunjukkan bahwa jalan pintas tidak lagi berlaku dalam "
"modul åcustomerå:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:75
msgid "Creating Idiomatic `use` Paths"
msgstr "Membuat Path yang Idiomatik"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
msgid ""
"In Listing 7-7, you might have wondered why we specified `use "
"restaurant::front_of_house::hosting` and then called "
"`hosting::add_to_waitlist` in `eat_at_restaurant` rather than specifying the"
" `use` path all the way out to the `add_to_waitlist` function to achieve the"
" same result, as in Listing 7-9."
msgstr ""
"Di Listing 7-7, Anda mungkin bertanya-tanya mengapa kami menyatakan restoran"
" ·eat_resturant:front_of_house::hostingé and then calling {::::: "
"add_to_waitlist in ▪ eat_rest_resturantâ than dispesifikasikan jalur "
"óuse_out to the ▪ad_towaitlistite fungsi untuk mencapai hasil yang sama, "
"seperti dalam Listing 7-9."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:97
msgid ""
"<span class=\"caption\">Listing 7-9: Bringing the `add_to_waitlist` function"
" into scope with `use`, which is unidiomatic</span>"
msgstr ""
"<span class=\"caption\">Listing 7-9: Membawa fungsi </span> yang tidak "
"terdidik"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:99
msgid ""
"Although both Listing 7-7 and 7-9 accomplish the same task, Listing 7-7 is "
"the idiomatic way to bring a function into scope with `use`. Bringing the "
"function’s parent module into scope with `use` means we have to specify the "
"parent module when calling the function. Specifying the parent module when "
"calling the function makes it clear that the function isn’t locally defined "
"while still minimizing repetition of the full path. The code in Listing 7-9 "
"is unclear as to where `add_to_waitlist` is defined."
msgstr ""
"Meskipun Listing 7-7 dan 7-9 mencapai tugas yang sama, Listing 7-7 adalah "
"cara terdiomatitik untuk membawa sebuah fungsi ke dalam lingkup dengan åuse."
" Membawa modul induk ke ruang lingkup dengan thoseuse yang sama berarti kita"
" harus menentukan modul induk ketika memanggil fungsi. Spesifikasikan modul "
"induk ketika memanggil fungsi membuat jelas bahwa fungsi secara lokal tidak "
"didefinisikan secara lokal sementara masih meminimalkan pengulangan dari "
"jalur penuh. Kode dalam List 7-9 tidak jelas seperti di mana "
"fmad_dto_warrylist didefinisikan."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:107
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items "
"with `use`, it’s idiomatic to specify the full path. Listing 7-10 shows the "
"idiomatic way to bring the core library’s `BitSize` trait into the scope, "
"allowing to call `bits` method to retrieve the size in bits of a type."
msgstr ""
"Di sisi lain, ketika membawa struct, enums, ciri-ciri, dan benda-benda lain "
"yang memiliki fungsi lain, ia dapat menentukan jalur yang lengkap."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:114
msgid "\"A u8 variable has {} bits\""
msgstr "\"A u8 variabel has {} bits\""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"<span class=\"caption\">Listing 7-10: Bringing `BitSize` trait into scope in"
" an idiomatic way</span>"
msgstr ""
"<span class=\"caption\">Listing 7-10: Membawa sifat ▪BitSizeó ke dalam "
"lingkup dalam cara yang idimatis</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:120
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has emerged in the Rust community, and folks have gotten used to reading and"
" writing Rust code this way. As Cairo shares many idioms with Rust, we "
"follow this convention as well."
msgstr ""
"Tidak ada alasan yang kuat di balik ungkapan ini: itu hanya konvensi yang "
"telah muncul di komunitas Rust, dan orang-orang terbiasa membaca dan menulis"
" kode Rust seperti ini."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:124
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Cairo doesn’t allow that."
msgstr ""
"Pengecualian untuk idiom ini adalah jika kita membawa dua item dengan nama "
"yang sama ke dalam lingkup dengan pernyataan åuse, karena Cairo tidak "
"memungkinkan itu."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid "Providing New Names with the `as` Keyword"
msgstr "Menyediakan Nama Baru dengan Kata Kunci ·as)"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:129
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: after the path, we can specify `as` and"
" a new local name, or _alias_, for the type. Listing 7-11 shows how you can "
"rename an import with `as`:"
msgstr ""
"Ada solusi lain untuk masalah membawa dua jenis nama yang sama ke dalam "
"lingkup yang sama dengan Áuse: setelah jalan itu, kita dapat menentukan nama"
" lokal yang baru, atau _alias_, untuk tipenya. Daftar 7-11 menunjukkan "
"bagaimana Anda dapat mengubah nama impor dengan:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:139
msgid "// ArrayTrait was renamed to Arr\n"
msgstr "//ArrayTrait diubah namanya menjadi Arr\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:144
msgid ""
"<span class=\"caption\">Listing 7-11: Renaming a trait when it’s brought "
"into scope with the `as` keyword</span>"
msgstr ""
"<span class=\"caption\">Listing 7-11: Mengubah suatu sifat ketika itu dibawa"
" ke dalam lingkup dengan kata kunci </span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:146
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now "
"access the trait's methods with the `Arr` identifier."
msgstr ""
"Di sini, kami membawa arrayTrait ke dalam lingkup dengan nama alias tersebut"
" sekarang kita dapat mengakses metode sifat dengan identifier."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:148
msgid "Importing Multiple Items from the Same Module"
msgstr "Mengimpor Multiple Item dari Modul yang Sama"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:150
msgid ""
"When you want to import multiple items (like functions, structs or enums) "
"from the same module in Cairo, you can use curly braces `{}` to list all of "
"the items that you want to import. This helps to keep your code clean and "
"easy to read by avoiding a long list of individual `use` statements."
msgstr ""
"Bila Anda ingin mengimpor beberapa item (seperti fungsi, struktur, atau "
"enums) dari modul yang sama di Cairo, Anda dapat menggunakan kurung keriting"
" untuk daftar semua item yang ingin Anda impor. Hal ini membantu untuk "
"menjaga kode Anda tetap bersih dan mudah dibaca dengan menghindari daftar "
"panjang dari setiap pernyataan yang digunakan."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:155
msgid ""
"The general syntax for importing multiple items from the same module is:"
msgstr ""
"Sintaks umum untuk mengimpor beberapa butir dari modul yang sama adalah:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:161
msgid ""
"Here is an example where we import three structures from the same module:"
msgstr ""
"Ini adalah contoh di mana kita mengimpor tiga struktur dari modul yang sama:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:164
msgid ""
"// Assuming we have a module called `shapes` with the structures `Square`, "
"`Circle`, and `Triangle`.\n"
msgstr ""
"//Berasumsikan kita memiliki sebuah modul yang disebut pembentukan dengan "
"strukturnya, dan berukuran besar.\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:182
msgid ""
"// We can import the structures `Square`, `Circle`, and `Triangle` from the "
"`shapes` module like this:\n"
msgstr ""
"/Kita dapat mengimpor strukturnya, dan dari modul yang berbeda seperti "
"ini:\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:185
msgid ""
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
msgstr ""
"/Sekarang kita bisa langsung menggunakan istilah, Circle, dan Triangle dalam"
" kode kita.\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:190
#: src/ch17-01-general-recommendations.md:143
#: src/ch17-01-general-recommendations.md:148
msgid "// ...\n"
msgstr "//...\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:195
msgid ""
"<span class=\"caption\">Listing 7-12: Importing multiple items from the same"
" module</span>"
msgstr ""
"<span class=\"caption\">Listing 7-12: Mengimpor beberapa item dari modul "
"yang sama</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:197
msgid "Re-exporting Names in Module Files"
msgstr "Mengekspor ulang Nama dalam Berkas Modul"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:199
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in the new scope can be imported as if it had been defined in that code’s "
"scope. This technique is called _re-exporting_ because we’re bringing an "
"item into scope, but also making that item available for others to bring "
"into their scope, with the `pub` keyword."
msgstr ""
"Ketika kita membawa nama ke dalam lingkup dengan kata kunci yang digunakan, "
"nama yang tersedia dalam lingkup baru dapat diimpor seolah-olah telah "
"didefinisikan dalam lingkup kode tersebut. Teknik ini disebut _re-exporting_"
" karena kita membawa item ke dalam lingkup, tetapi juga membuat item yang "
"tersedia bagi orang lain untuk membawa ke dalam lingkup mereka, dengan kata "
"kunci Épubá."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:204
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the "
"restaurant example:"
msgstr "Sebagai contoh, mari kita tunjukkan kembali fungsi dari restoran:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:222
msgid ""
"<span class=\"caption\">Listing 7-13: Making a name available for any code "
"to use from a new scope with `pub use`</span>"
msgstr ""
"<span class=\"caption\">Listing 7-13: Membuat nama tersedia untuk kode "
"apapun untuk digunakan dari lingkup baru dengan </span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path "
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this `pub"
" use` has re-exported the `hosting` module from the root module, external "
"code can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""
"Sebelum perubahan ini, kode eksternal harus menghubungi ·add_to_waitlist "
"dengan menggunakan jalur "
"▪restaurant::front_of_house:::hosting::::add_waitlist Allaht_to_waitlist). "
"Sekarang bahwa fungsi ▪pub ini menggunakan kembali modul dari modul root, "
"kode eksternal sekarang dapat menggunakan path "
"Áretaurant::hos:hos:ad_wait:ad_waitlist) sebagai gantinya."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:229
msgid ""
"Re-exporting is useful when the internal structure of your code is different"
" from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `pub use`, we can write our code with one structure but expose a"
" different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library."
msgstr ""
"Pengeksporan ulang berguna ketika struktur internal kode Anda berbeda dari "
"bagaimana programmer memanggil kode Anda akan berpikir tentang domain. "
"misalnya, dalam metafora restoran ini, orang-orang yang menjalankan restoran"
" berpikir tentang ·front rumah# dan kembalinya rumah."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:238
msgid "Using External Packages in Cairo with Scarb"
msgstr "Menggunakan Paket Eksternal di Cairo dengan Scarb"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:240
msgid ""
"You might need to use external packages to leverage the functionality "
"provided by the community. Scarb allows you to use dependencies by cloning "
"packages from their Git repositories. To use an external package in your "
"project with Scarb, simply declare the Git repository URL of the dependency "
"you want to add in a dedicated `[dependencies]` section in your _Scarb.toml_"
" configuration file. Note that the URL might correspond to the main branch, "
"or any specific commit, branch or tag. For this, you will have to pass an "
"extra `rev`, `branch`, or `tag` field, respectively. For example, the "
"following code imports the main branch of _alexandria_math_ crate from "
"_alexandria_ package:"
msgstr ""
"Anda mungkin perlu menggunakan paket eksternal untuk memanfaatkan "
"fungsionalitas yang disediakan oleh komunitas. Scarb memungkinkan Anda untuk"
" menggunakan ketergantungan dengan mengkloning paket dari Git repositoris "
"mereka. Untuk menggunakan paket eksternal di proyek Anda dengan Scarb, cukup"
" menyatakan URL repositori Git dari ketergantungan yang ingin Anda tambahkan"
" dalam sebuah daerah yang didedikasikan[dependncy] dalam berkas konfigurasi "
"_Scarb.toml_ Anda. Perlu dicatat bahwa URL mungkin sesuai dengan cabang "
"utama, atau spesifik apa pun yang dilakukan, atau tag. Untuk ini, Anda harus"
" melewati sebuah bagian tambahan, Ábranch, atau bidang lain. Sebagai contoh."
" Untuk kode import, kode utama _ria_exat_ex_and paket:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:244
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:251
msgid "\"https://github.com/keep-starknet-strange/alexandria.git\""
msgstr "\"https://github.com/keep-starknet-strange/alexandria.git\""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:247
msgid ""
"while the following code imports a specific branch (which is deprecated and "
"should not be used):"
msgstr ""
"sementara kode berikut mengimpor sebuah cabang tertentu (yang sudah "
"ditinggalkan dan tidak boleh digunakan):"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:251
msgid "\"cairo-v2.3.0-rc0\""
msgstr "\"cairo-v2.3.0-rc0\""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:254
msgid ""
"If you want to import multiple packages in your project, you need to create "
"only one `[dependencies]` section and list all the desired packages beneath "
"it. You can also specify development dependencies by declaring a `[dev-"
"dependencies]` section."
msgstr ""
"Jika Anda ingin mengimpor beberapa paket dalam proyek Anda, Anda hanya perlu"
" membuat satu bagian å[dependency] dan daftar semua paket yang diinginkan di"
" bawahnya. Anda juga dapat menentukan ketergantungan pengembangan dengan "
"menyatakan sebuah bagian å[dev-dependency]."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:256
msgid ""
"After that, simply run `scarb build` to fetch all external dependencies and "
"compile your package with all the dependencies included."
msgstr ""
"Setelah itu, berlarilah dengan mudah untuk mengambil semua ketergantungan "
"dari luar dan menyusun paket Anda dengan segala ketergantungan yang "
"termasuk."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:258
msgid ""
"Note that it is also possible to add dependencies with the `scarb add` "
"command, which will automatically edit the _Scarb.toml_ file for you. For "
"development dependencies, just use the `scarb add --dev` command."
msgstr ""
"Perhatikan bahwa ada kemungkinan juga untuk menambahkan ketergantungan "
"dengan perintah åscarb, yang secara otomatis akan mengubah berkas "
"_Scarb.toml_ untuk anda. Untuk ketergantungan pembangunan, gunakan saja "
"menambahkan --devcarb perintah."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:260
msgid ""
"To remove a dependency, simply remove the corresponding line from your "
"_Scarb.toml_ file, or use the `scarb rm` command."
msgstr ""
"Untuk menghapus ketergantungan, cukup hapus baris yang berhubungan dari "
"berkas _Scarb.toml_ Anda, atau gunakan perintah åscarb rmå."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:262
msgid "{{#quiz ../quizzes/ch07-04-bringing-paths-into-scope.toml}}"
msgstr "[{#quiz../quizzes/ch07-04- bringing-paths-into-scope.toml] ]"

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file. When modules get large, you might want to move their definitions to a "
"separate file to make the code easier to navigate."
msgstr ""
"Sejauh ini, semua contoh dalam bab ini didefinisikan beberapa modul dalam "
"satu berkas. Ketika modul mendapatkan besar, Anda mungkin ingin memindahkan "
"definisi mereka ke berkas terpisah untuk membuat kode lebih mudah untuk "
"menavigasi."

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-7 that had multiple "
"restaurant modules. We’ll extract modules into files instead of having all "
"the modules defined in the crate root file. In this case, the crate root "
"file is _src/lib.cairo_."
msgstr ""
"Sebagai contoh, mari kita mulai dari kode dalam Daftar 7-7 yang memiliki "
"beberapa modul restoran. Kami akan mengekstrak modul ke dalam berkas "
"daripada memiliki semua modul yang didefinisikan dalam berkas root peti. "
"Dalam hal ini, berkas root peti adalah _src/lib.cairo_."

#: src/ch07-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the"
" code inside the curly brackets for the `front_of_house` module, leaving "
"only the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains"
" the code shown in Listing 7-14. Note that this won’t compile until we "
"create the _src/front_of_house.cairo_ file."
msgstr ""
"Pertama, kami akan mengekstrak modul 'front' of_house' ke filenya sendiri. "
"Hapus kode dalam braket keriting untuk modul 'front'_of'house', hanya "
"menyisakan modul depan_of_house; (pro deklarasi): sehingga _src/lib.cairo_ "
"berisi kode yang ditampilkan dalam Daftar 7-14. Perhatikan bahwa ini tidak "
"akan dikompilasi sampai kita membuat file _sc/front_house_cairo_.cairo."

#: src/ch07-05-separating-modules-into-different-files.md:30
msgid ""
"<span class=\"caption\">Listing 7-14: Declaring the `front_of_house` module "
"whose body will be in _src/front_of_house.cairo_</span>"
msgstr ""
"<span class=\"caption\">Listing 7-14: Menyatakan modul depan_of_house] yang "
"tubuhnya akan berada di _src/front_of_house.cairo_</span>"

#: src/ch07-05-separating-modules-into-different-files.md:32
msgid ""
"Next, place the code that was in the curly brackets into a new file named "
"_src/front_of_house.cairo_, as shown in Listing 7-15. The compiler knows to "
"look in this file because it came across the module declaration in the crate"
" root with the name `front_of_house`."
msgstr ""
"Selanjutnya, tempatkan kode yang ada dalam kurung keriting ke dalam berkas "
"baru bernama _src/front_of_house.cairo_, seperti yang ditunjukkan di Listing"
" 7-15. Koiler tahu untuk melihat dalam file ini karena ia menemukan "
"deklarasi modul dalam akar peti dengan nama ▪front_of_house."

#: src/ch07-05-separating-modules-into-different-files.md:37
#: src/ch07-05-separating-modules-into-different-files.md:63
msgid "<span class=\"filename\">Filename: src/front_of_house.cairo</span>"
msgstr "<nama berkas=\"> Nama berkas: src/front_of_house.cairo</span>"

#: src/ch07-05-separating-modules-into-different-files.md:45
msgid ""
"<span class=\"caption\">Listing 7-15: Definitions inside the "
"`front_of_house` module in _src/front_of_house.cairo_</span>"
msgstr ""
"<span class=\"caption\">Listing 7-15: Definisi di dalam modul.front_of_house"
" dalam _src/front_of_house.cairo_</span>"

#: src/ch07-05-separating-modules-into-different-files.md:47
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your module tree. Once the compiler knows the file is part of the project "
"(and knows where in the module tree the code resides because of where you’ve"
" put the `mod` statement), other files in your project should refer to the "
"loaded file’s code using a path to where it was declared, as covered in the "
"[\"Paths for Referring to an Item in the Module Tree\"](./ch07-03-paths-for-"
"referring-to-an-item-in-the-module-tree.md) chapter. In other words, `mod` "
"is _not_ an “include” operation that you may have seen in other programming "
"languages."
msgstr ""
"Perhatikan bahwa Anda hanya perlu memuat sebuah berkas dengan menggunakan "
"sebuah deklarasi _sekali_ dalam pohon modul Anda. Sekali kompiler tahu bahwa"
" file itu adalah bagian dari proyek (dan tahu di mana di pohon modul ada "
"kode karena di mana anda menuliskan pernyataan Áe_on_once_on), berkas lain "
"dalam proyek anda harus mengacu ke kode berkas yang dimuat menggunakan jalur"
" ke mana berkas tersebut dinyatakan, sebagaimana yang tercakup dalam [\"Path"
" for Referning to anem in the Tree\"]. /ch07-path03-for-referring-an-to-in-"
"the-mod-mod-moded-mod). Dalam bab lainnya, _BAR_"

#: src/ch07-05-separating-modules-into-different-files.md:55
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit different because `hosting` is a child module of `front_of_house`, not "
"of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case "
"_src/front_of_house/_."
msgstr ""
"Selanjutnya, kami akan mengekstrak modul ·hosingé ke filenya sendiri. Proses"
" ini agak berbeda karena modul anak dari ·front_house, bukan modul root. "
"Kami akan menempatkan berkas tersebut dalam direktori baru yang akan dinamai"
" untuk leluhurnya di pohon modul, dalam kasus ini _sc/front_of_house/__."

#: src/ch07-05-separating-modules-into-different-files.md:60
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain "
"only the declaration of the `hosting` module:"
msgstr ""
"Untuk mulai bergerak ·hostingé, kami mengubah _src/front_of_house.cairo_ "
"untuk hanya berisi deklarasi modul tersebut:"

#: src/ch07-05-separating-modules-into-different-files.md:69
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ "
"to contain the definitions made in the `hosting` module:"
msgstr ""
"Kemudian kami membuat direktori _sc/front_of_house_ dan sebuah berkas "
"_hosting.cairo_ untuk memuat definisi yang dibuat dalam modul ·hostingá:"

#: src/ch07-05-separating-modules-into-different-files.md:72
msgid "<span class=\"filename\">Filename: src/front_of_house/hosting.cairo</span>"
msgstr "<nama berkas=\"> Nama berkas: src/front_of_house/hosting.cairo</span>"

#: src/ch07-05-separating-modules-into-different-files.md:78
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would"
" expect the _hosting.cairo_ code to be in a `hosting` module declared in the"
" crate root, and not declared as a child of the `front_of_house` module. The"
" compiler’s rules for which files to check for which modules’ code means the"
" directories and files more closely match the module tree."
msgstr ""
"Jika kita alih-alih menempatkan _hosting.cairo_ dalam direktori _sc_, "
"kompiler akan mengharapkan kode _hosting.cairo_ berada dalam modul "
"·hostingácting root, dan tidak dideklarasikan sebagai anak dari modul "
"▪front_of_houseól. The compiler Aturan mana berkas untuk memeriksa yang "
"modul-modul dan files lebih dekat cocok dengan pohon modul."

#: src/ch07-05-separating-modules-into-different-files.md:84
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains the same. The function calls in `eat_at_restaurant` will work "
"without any modification, even though the definitions live in different "
"files. This technique lets you move modules to new files as they grow in "
"size."
msgstr ""
"Kami telah memindahkan setiap modul kode ke file terpisah, dan pohon modul "
"tetap sama. Panggilan fungsi dalam eat_at_restaurán akan bekerja tanpa "
"modifikasi apapun, meskipun definisi hidup dalam berkas yang berbeda. Teknik"
" ini memungkinkan Anda memindahkan modul ke berkas baru saat mereka tumbuh "
"dalam ukuran yang berbeda."

#: src/ch07-05-separating-modules-into-different-files.md:89
msgid ""
"Note that the `use restaurant::front_of_house::hosting;` statement in "
"_src/lib.cairo_ also hasn’t changed, nor does `use` have any impact on what "
"files are compiled as part of the crate. The `mod` keyword declares modules,"
" and Cairo looks in a file with the same name as the module for the code "
"that goes into that module."
msgstr ""
"Perhatikan bahwa restoran åuse:front_of_house::hosting; pernyataan dalam "
"_src/lib.cairo_ juga belum berubah, atau memiliki dampak apapun pada apa "
"file disusun sebagai bagian dari peti. Kata kunci menyatakan modul, dan "
"Cairo tampak dalam file dengan nama yang sama sebagai modul untuk kode yang "
"masuk ke modul tersebut."

#: src/ch07-05-separating-modules-into-different-files.md:99
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules"
" so you can refer to items defined in one module from another module. You "
"can do this by specifying absolute or relative paths. These paths can be "
"brought into scope with a `use` statement so you can use a shorter path for "
"multiple uses of the item in that scope. Module code is **private** by "
"default."
msgstr ""
"Cairo memungkinkan Anda membagi paket ke dalam beberapa peti dan peti "
"menjadi modul sehingga Anda dapat mengacu pada item yang didefinisikan dalam"
" satu modul dari modul lain. Anda dapat melakukan ini dengan menentukan "
"jalur absolut atau relatif. Jalur ini dapat dibawa ke dalam lingkup dengan "
"pernyataan €use € sehingga Anda dapat menggunakan sebuah path pendek untuk "
"beberapa penggunaan objek dalam lingkup tersebut. Kode modul adalah "
"**private** secara baku."

#: src/ch07-05-separating-modules-into-different-files.md:105
msgid "{{#quiz ../quizzes/ch07-05-separate-modules.toml}}"
msgstr "{{#quiz../quizzes/ch07-05-separate-modules.toml}}}"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Cairo, one such tool is generics: abstract "
"stand-ins for concrete types or other properties. We can express the "
"behavior of generics or how they relate to other generics without knowing "
"what will be in their place when compiling and running the code."
msgstr ""
"Setiap bahasa pemrograman memiliki alat yang efektif untuk menangani "
"duplikasi konsep. Di Cairo, salah satu alat seperti itu adalah generik: "
"stand-in abstrak untuk tipe beton atau sifat lainnya. Kita dapat "
"mengekspresikan perilaku generik atau bagaimana mereka berhubungan dengan "
"generik lain tanpa mengetahui apa yang akan ada di tempat mereka ketika "
"kompilasi dan menjalankan kode."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Functions can take parameters of some generic type, instead of a concrete "
"type like `u32` or `bool`, in the same way a function takes parameters with "
"unknown values to run the same code on multiple concrete values. In fact, "
"we’ve already used generics in [Chapter 6](./ch06-01-enums.html#the-option-"
"enum-and-its-advantages) with `Option<T>`."
msgstr ""
"Fungsi dapat mengambil parameter dari beberapa tipe generik, bukan tipe "
"beton seperti åu32 (produc) atau åbool), dengan cara yang sama sebuah fungsi"
" mengambil parameter dengan nilai-nilai yang tidak diketahui untuk "
"menjalankan kode yang sama pada beberapa nilai konkrit. Sebenarnya, kita "
"telah menggunakan generik di [Chapter 6]./ch06-01-enums.html#the-option-and-"
"it-apons) dengan ▪Option<T>."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"In this chapter, you’ll explore how to define your own types, functions, and"
" traits with generics."
msgstr ""
"Dalam bab ini, Anda akan mengeksplorasi bagaimana mendefinisikan jenis, "
"fungsi, dan sifat Anda sendiri dengan generik."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication. Upon compilation, the "
"compiler creates a new definition for each concrete type that replaces a "
"generic type, reducing development time for the programmer, but code "
"duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which "
"will cause contract size to increment."
msgstr ""
"Generik memungkinkan kita untuk mengganti tipe spesifik dengan pemegang "
"tempat yang mewakili beberapa tipe untuk menghapus duplikasi kode. "
"Sehubungan dengan kompilasi, kompiler menciptakan definisi baru untuk setiap"
" tipe beton yang menggantikan tipe generik, mengurangi waktu pengembangan "
"programmer, tapi kode duplikasi pada tingkat kompilasi masih ada. Ini "
"mungkin penting jika Anda menulis kontrak Starknet dan menggunakan generik "
"untuk berbagai tipe yang akan menyebabkan ukuran kontrak untuk meningkat."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You"
" can combine traits with generic types to constrain a generic type to accept"
" only those types that have a particular behavior, as opposed to just any "
"type."
msgstr ""
"Kemudian Anda akan belajar bagaimana menggunakan sifat untuk mendefinisikan "
"perilaku dengan cara yang umum. Anda dapat menggabungkan sifat-sifat dengan "
"tipe umum untuk membatasi jenis generik untuk menerima hanya jenis-jenis "
"yang memiliki perilaku tertentu, sebagai lawan dari sembarang tipe."

#: src/ch08-00-generic-types-and-traits.md
msgid "Removing Duplication by Extracting a Function"
msgstr "Menghapus Duaplikasi dengan Mengekstrak Suatu Fungsi"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication. Before diving into "
"generics syntax, let’s first look at how to remove duplication in a way that"
" doesn’t involve generic types by extracting a function that replaces "
"specific values with a placeholder that represents multiple values. Then "
"we’ll apply the same technique to extract a generic function! By learning "
"how to identify duplicated code that can be extracted into a function, "
"you'll start to recognize instances where generics can be used to reduce "
"duplication."
msgstr ""
"Generik memungkinkan kita mengganti tipe spesifik dengan pemegang tempat "
"yang mewakili berbagai jenis untuk menghapus duplikasi kode. Sebelum "
"menyelam ke sintak generik, mari kita lihat dulu bagaimana menghilangkan "
"duplikasi dengan cara yang tidak melibatkan tipe umum dengan mengekstrak "
"fungsi yang menggantikan nilai-nilai spesifik dengan pemegang tempat yang "
"mewakili beberapa nilai. Kemudian kita akan menerapkan teknik yang sama "
"untuk mengekstrak fungsi umum! Dengan belajar bagaimana mengidentifikasi "
"kode duplikat yang dapat diekstrak ke dalam fungsi, Anda akan mulai "
"mengenali contoh di mana generic dapat digunakan untuk mengurangi duplikasi."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We begin with a short program that finds the largest number in an array of "
"`u8`:"
msgstr ""
"Kita mulai dengan program singkat yang menemukan jumlah terbesar dalam array"
" Áu8:"

#: src/ch08-00-generic-types-and-traits.md
msgid "\"The largest number is {}\""
msgstr "\" Angka terbesar adalah {}\""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We store an array of `u8` in the variable `number_list` and extract the "
"first number in the array in a variable named `largest`. We then iterate "
"through all the numbers in the array, and if the current number is greater "
"than the number stored in `largest`, we update the value of `largest`. "
"However, if the current number is less than or equal to the largest number "
"seen so far, the variable doesn’t change, and the code moves on to the next "
"number in the list. After considering all the numbers in the array, "
"`largest` should contain the largest number, which in this case is 100."
msgstr ""
"Kami menyimpan sebuah array yang berukuran besar. kami menyimpan sebuah "
"array dalam sebuah variabel yang disebut besar. kami kemudian merangkumkan "
"seluruh angka dalam array, dan jika angka saat ini lebih besar daripada "
"nomor yang disimpan dalam daftar yang lebih besar. setelah mengingat semua "
"angka dalam array, harus mengandung angka yang lebih besar. namun, jika "
"angka saat ini kurang atau sama dengan angka terbesar yang terlihat sejauh "
"ini, variabel tersebut tidak berubah, dan kode bergerak ke angka berikutnya "
"dalam daftar berikutnya. setelah mengingat semua angka-angka dalam array, "
"seharusnya berisi angka-angka yang paling besar, yang seharusnya berisi "
"angka terbesar dalam 100 kasus ini."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We've now been tasked with finding the largest number in two different "
"arrays of numbers. To do so, we can choose to duplicate the previous code "
"and use the same logic at two different places in the program, as follows:"
msgstr ""
"Kita sekarang telah ditugaskan untuk menemukan angka terbesar dalam dua "
"array angka yang berbeda untuk melakukannya, kita dapat memilih untuk "
"menduplikasi kode sebelumnya dan menggunakan logika yang sama di dua tempat "
"yang berbeda dalam program ini, sebagai berikut:"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Although this code works, duplicating code is tedious and error-prone. We "
"also have to remember to update the code in multiple places when we want to "
"change it."
msgstr ""
"Meskipun kode ini bekerja, duplikasi kode membosankan dan prone kesalahan. "
"kita juga harus ingat untuk memperbarui kode di beberapa tempat ketika kita "
"ingin mengubahnya."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"To eliminate this duplication, we’ll create an abstraction by defining a "
"function that operates on any array of `u8` passed in a parameter. This "
"solution makes our code clearer and lets us express the concept of finding "
"the largest number in an array abstractly."
msgstr ""
"Untuk menghilangkan duplikasi ini, kita akan menciptakan sebuah abstraksi "
"dengan mendefinisikan sebuah fungsi yang beroperasi pada berbagai array yang"
" melewati parameter. solusi ini membuat kode kita lebih jelas dan "
"memungkinkan kita mengungkapkan konsep untuk menemukan angka terbesar dalam "
"array abstrak."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"To do that, we extract the code that finds the largest number into a "
"function named `largest`. Then we call the function to find the largest "
"number in the two arrays. We could also use the function on any other array "
"of `u8` values we might have in the future."
msgstr ""
"Untuk melakukan itu, kami mengekstrak kode yang menemukan angka terbesar ke "
"dalam sebuah fungsi yang bernama Árst."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"The largest function has a parameter called `number_list`, passed by "
"reference, which represents any concrete array of `u8` values we might pass "
"into the function. As a result, when we call the function, the code runs on "
"the specific values that we pass in."
msgstr ""
"Fungsi terbesar memiliki parameter yang disebut nomor_listé, yang dilewatkan"
" oleh referensi, yang mewakili susunan beton dari nilai-nilai yang mungkin "
"kita masukkan ke dalam fungsi. sebagai hasilnya, ketika kita sebut fungsi, "
"kode berjalan pada nilai-nilai spesifik yang kita masukkan ke dalam."

#: src/ch08-00-generic-types-and-traits.md
msgid "In summary, here are the steps we took to change the code:"
msgstr ""
"Sebagai ringkasan, inilah langkah-langkah yang kami ambil untuk mengubah "
"kode:"

#: src/ch08-00-generic-types-and-traits.md
msgid "Identify duplicate code."
msgstr "Identifikasi kode duplikat."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Extract the duplicate code into the body of the function and specify the "
"inputs and return values of that code in the function signature."
msgstr ""
"Ekstrak kode duplikat ke dalam tubuh fungsi dan spesifikasikan masukan dan "
"kembalikan nilai dari kode tersebut dalam tanda-tangan fungsi."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Update the two instances of duplicated code to call the function instead."
msgstr ""
"Perbarui dua contoh kode duplikat untuk memanggil fungsi sebagai gantinya."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Next, we’ll use these same steps with generics to reduce code duplication. "
"In the same way that the function body can operate on an abstract `Array<T>`"
" instead of specific `u8` values, generics allow code to operate on abstract"
" types."
msgstr ""
"Selanjutnya, kita akan menggunakan langkah-langkah yang sama dengan generik "
"untuk mengurangi duplikasi kode. dengan cara yang sama bahwa tubuh fungsi "
"dapat beroperasi pada sebuah abstrak array <T>, bukan nilai-nilai spesifik, "
"generik memungkinkan kode untuk beroperasi pada tipe abstrak."

#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs"
" and functions, which we can then use with many different concrete data "
"types. In Cairo, we can use generics when defining functions, structs, "
"enums, traits, implementations and methods. In this chapter, we are going to"
" take a look at how to effectively use generic types with all of them."
msgstr ""
"Kami menggunakan generik untuk membuat definisi untuk deklarasi butir, "
"seperti struct dan fungsi, yang kemudian dapat kita gunakan dengan berbagai "
"tipe data konkrit. Di Cairo, kita dapat menggunakan generik ketika "
"mendefinisikan fungsi, struktur, enum, sifat, implementasi, dan metode. "
"Dalam bab ini, kita akan melihat bagaimana menggunakan tipe umum secara "
"efektif dengan semua itu."

#: src/ch08-01-generic-data-types.md:5
msgid ""
"Generics allow us to write reusable code that works with many types, thus "
"avoiding code duplication, while enhancing code maintainability."
msgstr ""
"Generik memungkinkan kita menulis kode yang dapat digunakan kembali yang "
"bekerja dengan banyak tipe, dengan demikian menghindari duplikasi kode, "
"sementara meningkatkan ketahanan kode."

#: src/ch08-01-generic-data-types.md:7
msgid "Generic Functions"
msgstr "Fungsi Generik"

#: src/ch08-01-generic-data-types.md:9
msgid ""
"Making a function generic means it can operate on different types, avoiding "
"the need for multiple, type-specific implementations. This leads to "
"significant code reduction and increases the flexibility of the code."
msgstr ""
"Membuat sebuah fungsi generik berarti ia dapat beroperasi pada berbagai "
"jenis, menghindari kebutuhan untuk berbagai, implementasi spesifik tipe. Hal"
" ini menyebabkan pengurangan kode yang signifikan dan meningkatkan "
"fleksibilitas kode."

#: src/ch08-01-generic-data-types.md:11
msgid ""
"When defining a function that uses generics, we place the generics in the "
"function signature, where we would usually specify the data types of the "
"parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If "
"we need to perform this operation for lists of different types, then we "
"would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr ""
"Ketika kita biasanya menentukan tipe data dari parameter dan nilai kembali. "
"misalnya, bayangkan kita ingin membuat sebuah fungsi yang diberikan dua "
"array pada item, akan mengembalikan yang terbesar. jika kita perlu melakukan"
" operasi ini untuk daftar jenis yang berbeda, maka kita harus mendefinisikan"
" ulang fungsi setiap saat. Untungnya kita dapat mengimplementasikan fungsi "
"menggunakan generik dan bergerak ke tugas lain."

#: src/ch08-01-generic-data-types.md:14
msgid "// Specify generic type T between the angulars\n"
msgstr "// Spesifikasikan tipe generik T diantara angular\n"

#: src/ch08-01-generic-data-types.md:27
msgid ""
"// There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
msgstr ""
"//Tidak perlu untuk menspesifikasikan tipe beton dari T karena // itu "
"diferred oleh kompiler\n"

#: src/ch08-01-generic-data-types.md:33
msgid ""
"The `largest_list` function compares two lists of the same type and returns "
"the one with more elements and drops the other. If you compile the previous "
"code, you will notice that it will fail with an error saying that there are "
"no traits defined for dropping an array of a generic type. This happens "
"because the compiler has no way to guarantee that an `Array<T>` is droppable"
" when executing the `main` function. In order to drop an array of `T`, the "
"compiler must first know how to drop `T`. This can be fixed by specifying in"
" the function signature of `largest_list` that `T` must implement the `Drop`"
" trait. The correct function definition of `largest_list` is as follows:"
msgstr ""
"Fungsi pembesaran_list_terbesar membandingkan dua daftar dengan jenis umum "
"yang sama. Hal ini terjadi karena kompiler tidak memiliki cara untuk "
"menjamin bahwa array <T> akan droppable ketika menjalankan fungsi Áy. Dalam "
"rangka untuk menjatuhkan array \\t."

#: src/ch08-01-generic-data-types.md:45
msgid ""
"The new `largest_list` function includes in its definition the requirement "
"that whatever generic type is placed there, it must be droppable. This is "
"what we call _trait bounds_. The `main` function remains unchanged, the "
"compiler is smart enough to deduce which concrete type is being used and if "
"it implements the `Drop` trait."
msgstr ""
"Fungsi _list_list_besar baru termasuk dalam definisinya persyaratan bahwa "
"jenis generik apa pun ditempatkan di sana, itu harus droppable. Ini adalah "
"apa yang kita sebut _trait bounds_. Fungsi æuía tetap tidak berubah, "
"compiler cukup pintar untuk menyimpulkan jenis beton mana yang digunakan dan"
" jika alat itu menerapkan sifat."

#: src/ch08-01-generic-data-types.md:47
msgid "Constraints for Generic Types"
msgstr "Kendala bagi Tipe Generik"

#: src/ch08-01-generic-data-types.md:49
msgid ""
"When defining generic types, it is useful to have information about them. "
"Knowing which traits a generic type implements allows us to use it more "
"effectively in a function's logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this "
"previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compiler's requirements, we can also add constraints to benefit our function"
" logic."
msgstr ""
"Ketika mendefinisikan tipe generik, sangat berguna untuk memiliki informasi "
"tentang mereka. Mengetahui sifat mana yang diimplementasikan suatu tipe umum"
" memungkinkan kita untuk menggunakannya lebih efektif dalam logika fungsi "
"dengan biaya membatasi jenis umum yang dapat digunakan dengan fungsi. kita "
"melihat contoh ini sebelumnya dengan menambahkan implementasi ÁTDROP "
"bertautan sebagai bagian dari argumen umum Ást_listé. Sementara ÁTROP "
"(penguasa umum) ditambahkan untuk memenuhi persyaratan kompiler, kita juga "
"dapat menambahkan batasan untuk membantu logika fungsi kita."

#: src/ch08-01-generic-data-types.md:51
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, to "
"find the smallest element among them. Initially, we know that for an element"
" of type `T` to be comparable, it must implement the `PartialOrd` trait. The"
" resulting function would be:"
msgstr ""
"Bayangkan bahwa kita ingin, mengingat daftar unsur-unsur dari beberapa jenis"
" generik, untuk menemukan elemen terkecil di antara mereka."

#: src/ch08-01-generic-data-types.md:54
msgid ""
"// Given a list of T get the smallest one\n"
"// The PartialOrd trait implements comparison operations for T\n"
msgstr ""
"//Diberikan daftar T mendapatkan yang terkecil satu /The ParsialOrd sifat "
"mengimplementasikan operasi perbandingan untuk T\n"

#: src/ch08-01-generic-data-types.md:57
msgid ""
"// This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
msgstr ""
"//Ini merepresentasikan elemen terkecil melalui iterasi / // Perhatikan "
"bahwa kita menggunakan operator desnap (*)\n"

#: src/ch08-01-generic-data-types.md:61
msgid "// The index we will use to move through the list\n"
msgstr "# # The indeks we will use to move through the list\n"

#: src/ch08-01-generic-data-types.md:64
msgid "// Iterate through the whole list storing the smallest\n"
msgstr "//Tuliskan melalui seluruh daftar menyimpan yang terkecil\n"

#: src/ch08-01-generic-data-types.md:79
msgid ""
"// We need to specify that we are passing a snapshot of `list` as an "
"argument\n"
msgstr ""
"/Kita perlu menentukan bahwa kita melewati snapshot dari ælisté sebagai "
"argumen\n"

#: src/ch08-01-generic-data-types.md:85
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and "
"returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so"
" we are not required to implement the `Drop` trait for `T` as well. Why does"
" it not compile then?"
msgstr ""
"Fungsi umumnya menggunakan tipe umum yang menerapkan sifat \"Partial Ord,\" "
"mengambil snapshot dari sebuah array<T> sebagai sebuah parameter dan "
"mengembalikan salinan dari elemen terkecil. Karena parameternya bertipe tipe"
" atau Array<T>, kita tidak perlu lagi menjatuhkannya pada akhir eksekusi dan"
" jadi kita tidak diharuskan menerapkan sifat irpropánebi untuk saat itu "
"juga. Mengapa tidak disusun kemudian?"

#: src/ch08-01-generic-data-types.md:87
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element,"
" and unless `PartialOrd` is implemented for `@T` we need to desnap the "
"element using `*`. The `*` operation requires a copy from `@T` to `T`, which"
" means that `T` needs to implement the `Copy` trait. After copying an "
"element of type `@T` to `T`, there are now variables with type `T` that need"
" to be dropped, requiring `T` to implement the `Drop` trait as well. We must"
" then add both `Drop` and `Copy` traits implementation for the function to "
"be correct. After updating the `smallest_element` function the resulting "
"code would be:"
msgstr ""
"Ketika meng-indeks pada daftar, nilai yang dihasilkan dalam penyerapan "
"elemen terindeks, dan kecuali jika 'Partial Ord' diimplementasikan untuk "
"sifat 'product' kita perlu mengubah elemen tersebut menggunakan \\t\\. "
"Operasi ini memerlukan salinan dari ▪T), yang berarti bahwa kita harus "
"mengimplementasikan sifat ▪T. Setelah menyalin elemen ke tipe níT, sekarang "
"ada variabel dengan tipe yang perlu diturunkan, yang membutuhkan untuk "
"mengimplementasikan sifat tersebut."

#: src/ch08-01-generic-data-types.md:108
msgid "Anonymous Generic Implementation Parameter (`+` Operator)"
msgstr "Parameter Implementasi Generik Anonymous (Neunim + Operator)"

#: src/ch08-01-generic-data-types.md:110
msgid ""
"Until now, we have always specified a name for each implementation of the "
"required generic trait: `TPartialOrd` for `PartialOrd<T>`, `TDrop` for "
"`Drop<T>`, and `TCopy` for `Copy<T>`."
msgstr ""
"Sampai sekarang, kita selalu menentukan nama untuk setiap implementasi sifat"
" umum yang diperlukan: ÁTPartialOrd untuk ÁPartialOrd<T>, ÁTDROPOPE untuk  "
"(DROP) <T>, dan UBJUK) untuk <T>."

#: src/ch08-01-generic-data-types.md:112
msgid ""
"However, most of the time, we don't use the implementation in the function "
"body; we only use it as a constraint. In these cases, we can use the `+` "
"operator to specify that the generic type must implement a trait without "
"naming the implementation. This is referred to as an _anonymous generic "
"implementation parameter_."
msgstr ""
"Namun, sebagian besar waktu, kita tidak menggunakan implementasi dalam tubuh"
" fungsi; kita hanya menggunakannya sebagai kendala. Dalam kasus ini, kita "
"dapat menggunakan operator á+ (transporter) untuk menyatakan bahwa tipe umum"
" harus mengimplementasikan suatu sifat tanpa menyebutkan implementasi. Ini "
"disebut sebagai sebuah parameter umum yang umum _anomous."

#: src/ch08-01-generic-data-types.md:114
msgid ""
"For example, `+PartialOrd<T>` is equivalent to `impl TPartialOrd: "
"PartialOrd<T>`."
msgstr ""
"Sebagai contoh, 'PartialOrd'<T> setara dengan 'imp TPartialOrd': "
"ParsialOrd<T>."

#: src/ch08-01-generic-data-types.md:116
msgid "We can rewrite the `smallest_element` function signature as follows:"
msgstr ""
"Kita dapat menulis ulang fungsi signature æsmallest_element sebagai berikut:"

#: src/ch08-01-generic-data-types.md:134
msgid "Structs"
msgstr "Struktur"

#: src/ch08-01-generic-data-types.md:136
msgid ""
"We can also define structs to use a generic type parameter for one or more "
"fields using the `<>` syntax, similar to function definitions. First, we "
"declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct "
"definition where we would otherwise specify concrete data types. The next "
"code example shows the definition `Wallet<T>` which has a `balance` field of"
" type `T`."
msgstr ""
"Kita juga dapat mendefinisikan struktur untuk menggunakan parameter tipe "
"generik untuk satu atau lebih bidang menggunakan sintaks <>, mirip dengan "
"definisi fungsi. Pertama, kita menyatakan nama parameter tipe di dalam "
"kurung sudut hanya setelah nama struct. Kemudian kita menggunakan tipe umum "
"dalam definisi struktur di mana kita akan menentukan tipe data konkrit. "
"Contoh kode selanjutnya menunjukkan definisi ▪Wallet<T> yang memiliki daerah"
" yang seimbang dengan tipe ▪T."

#: src/ch08-01-generic-data-types.md:149
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically."
" It is equivalent to writing the following code:"
msgstr ""
"Kode di atas memperoleh sifat lturop untuk tipe allet yang secara otomatis. "
"sama saja dengan menulis kode berikut:"

#: src/ch08-01-generic-data-types.md:163
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and "
"instead define our own `WalletDrop` implementation. Notice that we must "
"define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying"
" that the struct `Wallet<T>` is droppable as long as `T` is also droppable."
msgstr ""
"Kita menghindari penggunaan makro UBROP untuk implementasi ÁWalletó dan "
"sebaliknya mendefinisikan implementasi smua kita sendiri. Perhatikan bahwa "
"kita harus mendefinisikan, seperti fungsi, sebuah jenis umum tambahan untuk "
"walletDropóc mengatakan bahwa kita juga menerapkan sifat yang dapat "
"diturunkan. kita pada dasarnya mengatakan bahwa struktur <T> juga dapat "
"dijatuhkan."

#: src/ch08-01-generic-data-types.md:165
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and "
"we want that field to be different than `T` but generic as well, we can "
"simply add another generic type between the `<>`:"
msgstr ""
"Akhirnya, jika kita ingin menambahkan lapangan ke ▪Wallet yang mewakili "
"alamatnya dan kita ingin medan itu berbeda dari biasanya, tapi juga umum, "
"kita dapat menambahkan jenis umum lain antara <>:"

#: src/ch08-01-generic-data-types.md:179
msgid ""
"We add to the `Wallet` struct definition a new generic type `U` and then "
"assign this type to the new field member `address`. Notice that the `derive`"
" attribute for the `Drop` trait works for `U` as well."
msgstr ""
"Kami menambahkan definisi struktur baru untuk tipe umum lalu memberikan tipe"
" ini ke anggota lapangan yang baru."

#: src/ch08-01-generic-data-types.md:183
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. For example the `Option<T>` enum provided by the Cairo core "
"library:"
msgstr ""
"Seperti yang kita lakukan dengan struktur, kita dapat mendefinisikan enums "
"untuk menyimpan tipe data generik dalam varian mereka. Sebagai contoh yang "
"<T> enum disediakan oleh perpustakaan inti Cairo:"

#: src/ch08-01-generic-data-types.md:192
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: "
"`Some`, which holds one value of type `T` and `None` that doesn't hold any "
"value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic "
"type `T` we can use this abstraction with any type."
msgstr ""
"Enyam umum di atas sebuah tipe T dan memiliki dua varians: quot; yang "
"memiliki satu nilai tipe (T) dan tidak ada yang memiliki nilai apapun. "
"Dengan menggunakan enum (Option <T), mungkin bagi kita untuk mengekspresikan"
" konsep abstrak tentang nilai opsional dan karena nilai tersebut memiliki "
"tipe umum (st) kita dapat menggunakan abstrakisasi ini dengan tipe apapun."

#: src/ch08-01-generic-data-types.md:194
msgid ""
"Enums can use multiple generic types as well, like the definition of the "
"`Result<T, E>` enum that the core library provides:"
msgstr ""
"Enums dapat menggunakan multiple generic types juga, seperti definisi dari "
"<T, E>) enum yang disediakan oleh perpustakaan inti:"

#: src/ch08-01-generic-data-types.md:203 src/ch09-02-recoverable-errors.md:16
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two "
"variants: `Ok` which holds the value of type `T` and `Err` which holds the "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (by returning a value "
"of type `T`) or fail (by returning a value of type `E`)."
msgstr ""
"Result<T, E> enum memiliki dua tipe generic, dan dua varian, dan dua "
"varians: yang memiliki nilai dari tipe ÁT dan  (err). Definisi ini membuat "
"kita lebih nyaman menggunakan operasi ini di mana saja kita bisa berhasil "
"(dengan mengembalikan nilai dari tipe t) atau gagal (dengan mengembalikan "
"nilai dari tipe ÉE)."

#: src/ch08-01-generic-data-types.md:205
msgid "Generic Methods"
msgstr "Metode Generik"

#: src/ch08-01-generic-data-types.md:207
msgid ""
"We can implement methods on structs and enums, and use the generic types in "
"their definitions, too. Using our previous definition of `Wallet<T>` struct,"
" we define a `balance` method for it:"
msgstr ""
"Kita dapat mengimplementasikan metode pada struct dan enums, dan menggunakan"
" tipe umum dalam definisi mereka, juga. Menggunakan definisi kita sebelumnya"
" tentang struktur Wallet<T>, kita mendefinisikan metode keseimbangan untuk "
"itu:"

#: src/ch08-01-generic-data-types.md:231
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which "
"defines a method that returns the value of the field `balance` from "
"`Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. "
"Note that you need to include a generic type in both definitions of the "
"trait and the implementation."
msgstr ""
"Pertama, kita mendefinisikan WalletTrait<T> dengan menggunakan tipe umum "
"yang mendefinisikan suatu metode yang mengembalikan nilai dari bidang "
"kesetaraan dari wallet, lalu kita memberikan sebuah implementasi untuk sifat"
" dalam ▪Walletlpl<T>. Perhatikan bahwa Anda perlu memasukkan tipe umum dalam"
" kedua definisi sifat dan implementasi."

#: src/ch08-01-generic-data-types.md:233
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only for `Wallet<u128>` "
"instances rather than `Wallet<T>`. In the code example, we define an "
"implementation for wallets which have a concrete type of `u128` for the "
"`balance` field."
msgstr ""
"Kita juga dapat menentukan batasan pada tipe umum ketika mendefinisikan "
"metode pada tipenya. Sebagai contoh, kita dapat, menerapkan metode hanya "
"untuk ▪Wallet<u128>: contoh daripada ▪Wallet<T>. Dalam contoh kode, kita "
"mendefinisikan sebuah implementasi untuk dompet yang memiliki tipe konkrit "
"<u128) untuk bidang keseimbangan."

#: src/ch08-01-generic-data-types.md:240
msgid "/// Generic trait for wallets\n"
msgstr "/ / sifat Generik untuk dompet\n"

#: src/ch08-01-generic-data-types.md:251
msgid "/// Trait for wallets of type u128\n"
msgstr "#/ Trait for wallets of type u128\n"

#: src/ch08-01-generic-data-types.md:272
msgid ""
"The new method `receive` increments the size of `balance` of any instance of"
" a `Wallet<u128>`. Notice that we changed the `main` function making `w` a "
"mutable variable in order for it to be able to update its balance. If we "
"were to change the initialization of `w` by changing the type of `balance` "
"the previous code wouldn't compile."
msgstr ""
"Metode baru yang muncul secara bertahap membuat variabel yang dapat berubah "
"agar dapat memperbarui keseimbangannya. Jika kita mengubah "
"penginisialisasian atau pengimbangan kode sebelumnya tidak akan "
"mengkombinasikannya."

#: src/ch08-01-generic-data-types.md:274
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. "
"Using the past implementation from `Wallet<U, V>` we are going to define a "
"trait that picks two wallets of different generic types and creates a new "
"one with a generic type of each. First, let's rewrite the struct definition:"
msgstr ""
"Cairo memungkinkan kita untuk mendefinisikan metode generik di dalam sifat "
"generik juga. Menggunakan implementasi masa lalu dari <U, V>-- kita akan "
"mendefinisikan sifat yang mengambil dua dompet dari jenis generik yang "
"berbeda dan menciptakan jenis baru dengan tipe umum masing-masing. Pertama, "
"kita tulis ulang definisi struktur:"

#: src/ch08-01-generic-data-types.md:283
msgid ""
"Next, we are going to naively define the mixup trait and implementation:"
msgstr ""
"Selanjutnya, kita akan dengan naif mendefinisikan sifat dan implementasi "
"mixup:"

#: src/ch08-01-generic-data-types.md:286
msgid "// This does not compile!\n"
msgstr "//Ini tidak dikompilasi!\n"

#: src/ch08-01-generic-data-types.md:299
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` "
"method which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` "
"creates a new `Wallet<T1, U2>`. As `mixup` signature specifies, both `self` "
"and `other` are getting dropped at the end of the function, which is why "
"this code does not compile. If you have been following from the start until "
"now you would know that we must add a requirement for all the generic types "
"specifying that they will implement the `Drop` trait for the compiler to "
"know how to drop instances of `Wallet<T, U>`. The updated implementation is "
"as follows:"
msgstr ""
"Kami sedang membuat sebuah sifat WalletTrait<T1, U1> dengan metode baru U1> "
"dengan metode <T2, U2> yang memberikan contoh khasiat <T1, U1> dan U1> "
"Wallet dan UALlet<T2, U2> menciptakan sebuah kode baru yang baru, U2>. "
"Sebagaimana yang diberikan sebuah tipe khusus menspesifikasikan diri sendiri"
" dan lainnya akan diturunkan pada akhir fungsi, yang mana adalah mengapa "
"kode ini tidak dikompilasi. Jika Anda telah mulai dari sekarang kita harus "
"tahu bahwa kita harus menambahkan semua tipe yang mensifikasikan ciri-ciri "
"yang dispesiifikasikan oleh UD untuk versi yang akan digambarkan untuk versi"
" selanjutnya:"

#: src/ch08-01-generic-data-types.md:317
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl`"
" declaration. Then we do the same for `T2` and `U2`, this time as part of "
"`mixup` signature. We can now try the `mixup` function:"
msgstr ""
"Kami menambahkan persyaratan untuk T1 dan U1 yang dapat diturunkan pada "
"deklarasi WalletMixmplpl."

#: src/ch08-01-generic-data-types.md:331
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, "
"u8>` instance."
msgstr ""
"Kami pertama kali membuat dua contoh: salah satu dari Walllet<bool, u128> "
"dan yang lain dari Wallet<felt2, u8>. Kemudian, kita sebut thoseixup. dan "
"membuat sebuah ▪Walllet<bool baru, u8> contoh."

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"A trait defines a set of methods that can be implemented by a type. These "
"methods can be called on instances of the type when this trait is "
"implemented. A trait combined with a generic type defines functionality a "
"particular type has and can share with other types. We can use traits to "
"define shared behavior in an abstract way. We can use _trait bounds_ to "
"specify that a generic type can be any type that has certain behavior."
msgstr ""
"Sebuah sifat mendefinisikan satu set metode yang dapat diimplementasikan "
"dengan sebuah tipe. Metode ini dapat disebut pada contoh dari tipe ketika "
"sifat ini diimplementasikan. Sebuah sifat yang dikombinasikan dengan tipe "
"umum mendefinisikan fungsionalitas tipe tertentu dan dapat dibagi dengan "
"tipe lain. Kita dapat menggunakan sifat yang sama untuk mendefinisikan "
"perilaku bersama secara abstrak. Kita dapat menggunakan _trait terikat_ "
"untuk menentukan bahwa tipe umum dapat menjadi tipe apapun yang memiliki "
"perilaku tertentu."

#: src/ch08-02-traits-in-cairo.md:7
msgid ""
"Note: Traits are similar to a feature often called interfaces in other "
"languages, although with some differences."
msgstr ""
"Catatan: Sifat mirip dengan fitur yang sering disebut antarmuka dalam bahasa"
" - bahasa lain, meskipun dengan beberapa perbedaan."

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"While traits can be written to not accept generic types, they are most "
"useful when used with generic types. We already covered generics in the "
"[previous chapter](./ch08-01-generic-data-types.md), and we will use them in"
" this chapter to demonstrate how traits can be used to define shared "
"behavior for generic types."
msgstr ""
"Sementara sifat-sifat dapat ditulis untuk tidak menerima tipe generik, "
"mereka paling berguna ketika digunakan dengan tipe generik. Kami telah "
"menutupi generik dalam [ bab sebelumnya] Allahbapron./ch08-01-generic-data-"
"types.md), dan kami akan menggunakannya di bab ini untuk menunjukkan "
"bagaimana sifat-sifat dapat digunakan untuk mendefinisikan perilaku bersama "
"untuk tipe umum."

#: src/ch08-02-traits-in-cairo.md:13
msgid "Defining a Trait"
msgstr "Mendefinisikan Sifat - Sifatnya"

#: src/ch08-02-traits-in-cairo.md:15
msgid ""
"A type’s behavior consists of the methods we can call on that type. "
"Different types share the same behavior if we can call the same methods on "
"all of those types. Trait definitions are a way to group method signatures "
"together to define a set of behaviors necessary to accomplish some purpose."
msgstr ""
"Perilaku yang berbeda terdiri dari metode yang dapat kita gunakan untuk "
"menentukan jenis perilaku yang sama jika kita dapat menghubungi metode yang "
"sama pada semua jenis tersebut. definisi Trait adalah cara untuk "
"mengelompokkan metode bersama-sama untuk menentukan seperangkat perilaku "
"yang diperlukan untuk mencapai suatu tujuan."

#: src/ch08-02-traits-in-cairo.md:17
msgid ""
"For example, let’s say we have a struct `NewsArticle` that holds a news "
"story in a particular location. We can define a trait `Summary` that "
"describes the behavior of something that can summarize the `NewsArticle` "
"type."
msgstr ""
"Sebagai contoh, mari kita katakan kita memiliki sebuah struktur yang "
"memegang berita di lokasi tertentu. kita dapat menentukan sebuah sifat yang "
"menggambarkan perilaku dari sesuatu yang dapat meringkaskan tipe "
"NewsArticle."

#: src/ch08-02-traits-in-cairo.md:34
msgid "\"{:?} by {:?} ({:?})\""
msgstr "\"{:?\" oleh {:?} ({:})\""

#: src/ch08-02-traits-in-cairo.md:41
msgid ""
"Here, we declare a trait using the `trait` keyword and then the trait’s "
"name, which is `Summary` in this case. We’ve also declared the trait as "
"`pub` so that crates depending on this crate can make use of this trait too,"
" as we’ll see in a few examples."
msgstr ""
"Di sini, kita menyatakan sebuah sifat menggunakan kata kunci dan kemudian "
"sifat itu, yang juga dapat digunakan dalam hal ini, seperti yang kita lihat "
"dalam beberapa contoh."

#: src/ch08-02-traits-in-cairo.md:44
msgid ""
"Inside the curly brackets, we declare the method signatures that describe "
"the behaviors of the types that implement this trait, which in this case is "
"`fn summarize(self: @NewsArticle) -> ByteArray;`. After the method "
"signature, instead of providing an implementation within curly brackets, we "
"use a semicolon."
msgstr ""
"Di dalam kurung keriting, kami menyatakan tanda tangan metode yang "
"menggambarkan perilaku dari jenis yang menerapkan sifat ini, yang dalam hal "
"ini adalah ▪fn merangkumkan diri: @NewsArtikle) -> ByteArray;-- setelah "
"tanda tangan metode, alih-alih menyediakan implementasi dalam kurung "
"keriting, kami menggunakan semikolon."

#: src/ch08-02-traits-in-cairo.md:46
msgid ""
"Note: the `ByteArray` type is the type used to represent strings in Cairo."
msgstr ""
"Catatan: tipe byteArray adalah tipe yang digunakan untuk mewakili string di "
"Cairo."

#: src/ch08-02-traits-in-cairo.md:48
msgid ""
"As the trait is not generic, the `self` parameter is not generic either and "
"is of type `@NewsArticle`. This means that the `summarize` method can only "
"be called on instances of `NewsArticle`."
msgstr ""
"Karena sifat ini tidak generik, parameter diri sendiri juga tidak umum dan "
"bertipe umum. Ini berarti metode yang disummarisasi hanya dapat disebut pada"
" contoh-contoh dari NewsArticle."

#: src/ch08-02-traits-in-cairo.md:50
msgid ""
"Now, consider that we want to make a media aggregator library crate named "
"_aggregator_ that can display summaries of data that might be stored in a "
"`NewsArticle` or `Tweet` instance. To do this, we need a summary from each "
"type, and we’ll request that summary by calling a summarize method on an "
"instance of that type. By defining the `Summary` trait on generic type `T`, "
"we can implement the `summarize` method on any type we want to be able to "
"summarize."
msgstr ""
"Sekarang, pertimbangkan bahwa kita ingin membuat sebuah media aggregator "
"perpustakaan peti bernama _aggregator_ yang dapat menampilkan rangkuman data"
" yang mungkin disimpan dalam sebuah åNewsArticle atau åTweetáne. Untuk "
"melakukan hal ini, kita perlu ringkasan dari setiap tipe, dan kami akan "
"meminta ringkasan bahwa dengan memanggil metoda tambahan pada contoh tipe "
"itu. Dengan mendefinisikan sifat sumary pada tipe generik åT, kita dapat "
"mengimplementasikan metode  memberikan tipe mana pun kita ingin mampu untuk "
"meringkas."

#: src/ch08-02-traits-in-cairo.md:68 src/ch08-02-traits-in-cairo.md:145
#: src/ch08-02-traits-in-cairo.md:222
msgid "\"{} by {} ({})\""
msgstr "\"{} by {} ({})\""

#: src/ch08-02-traits-in-cairo.md:82 src/ch08-02-traits-in-cairo.md:159
#: src/ch08-02-traits-in-cairo.md:236
msgid "\"{}: {}\""
msgstr "\"{}: {}\""

#: src/ch08-02-traits-in-cairo.md:91 src/ch08-02-traits-in-cairo.md:168
#: src/ch08-02-traits-in-cairo.md:245
msgid "\"Cairo has become the most popular language for developers\""
msgstr "\"Cairo telah menjadi bahasa yang paling populer bagi pengembang\""

#: src/ch08-02-traits-in-cairo.md:92 src/ch08-02-traits-in-cairo.md:169
#: src/ch08-02-traits-in-cairo.md:246
msgid "\"Worldwide\""
msgstr "\"Worldwide\""

#: src/ch08-02-traits-in-cairo.md:93 src/ch08-02-traits-in-cairo.md:170
#: src/ch08-02-traits-in-cairo.md:247
msgid "\"Cairo Digger\""
msgstr "\"Cairo Digger\""

#: src/ch08-02-traits-in-cairo.md:94 src/ch08-02-traits-in-cairo.md:171
#: src/ch08-02-traits-in-cairo.md:248
msgid "\"Cairo is a new programming language for zero-knowledge proofs\""
msgstr "\"Cairo adalah bahasa pemrograman baru untuk bukti pengetahuan kosong \""

#: src/ch08-02-traits-in-cairo.md:98 src/ch08-02-traits-in-cairo.md:175
#: src/ch08-02-traits-in-cairo.md:252
msgid "\"EliBenSasson\""
msgstr "\"EliBenSasson\""

#: src/ch08-02-traits-in-cairo.md:99 src/ch08-02-traits-in-cairo.md:176
#: src/ch08-02-traits-in-cairo.md:253
msgid ""
"\"Crypto is full of short-term maximizing projects. \\n @Starknet and "
"@StarkWareLtd are about long-term vision maximization.\""
msgstr ""
"\"Crypto penuh dengan proyek maksimum jangka pendek. \\n @Starknet dan "
"@StarkWareLtd adalah tentang maksimalisasi visi jangka panjang.\""

#: src/ch08-02-traits-in-cairo.md:102 src/ch08-02-traits-in-cairo.md:179
#: src/ch08-02-traits-in-cairo.md:256
msgid "// Tweet instantiation\n"
msgstr "//Tweet instantiation\n"

#: src/ch08-02-traits-in-cairo.md:104 src/ch08-02-traits-in-cairo.md:181
#: src/ch08-02-traits-in-cairo.md:258
msgid "\"New article available! {}\""
msgstr "\"Koran baru tersedia! []\""

#: src/ch08-02-traits-in-cairo.md:105 src/ch08-02-traits-in-cairo.md:182
#: src/ch08-02-traits-in-cairo.md:259
msgid "\"New tweet! {}\""
msgstr "\"New tweet! []\""

#: src/ch08-02-traits-in-cairo.md:111
msgid ""
"<span class=\"caption\">A `Summary` trait that consists of the behavior "
"provided by a `summarize` method</span>"
msgstr ""
"<span class=\"caption\">A ÁSummary sifat yang terdiri dari perilaku yang "
"disediakan oleh sebuah metode </span>"

#: src/ch08-02-traits-in-cairo.md:113
msgid ""
"Each type implementing this trait must provide its own custom behavior for "
"the body of the method. The compiler will enforce that any type that "
"implements the `Summary` trait will have the method `summarize` defined with"
" this signature exactly."
msgstr ""
"Setiap tipe yang menerapkan sifat ini harus menyediakan kebiasaannya sendiri"
" untuk tubuh metode tersebut. Komiler akan memaksakan jenis apa pun yang "
"mengimplementasikan sifat slumary akan memiliki metode ·summarizeå "
"didefinisikan dengan tanda tangan ini persis."

#: src/ch08-02-traits-in-cairo.md:115
msgid ""
"A trait can have multiple methods in its body: the method signatures are "
"listed one per line and each line ends in a semicolon."
msgstr ""
"Sebuah sifat dapat memiliki berbagai metode dalam tubuhnya: tanda tangan "
"metodenya terdaftar satu per baris dan setiap baris berakhir pada titik "
"koma."

#: src/ch08-02-traits-in-cairo.md:117
msgid "Implementing a Trait on a Type"
msgstr "Menimplementasikan Sifat pada Suatu Tipe"

#: src/ch08-02-traits-in-cairo.md:119
msgid ""
"Now that we’ve defined the desired signatures of the `Summary` trait’s "
"methods, we can implement it on the types in our media aggregator. The "
"following code shows an implementation of the `Summary` trait on the "
"`NewsArticle` struct that uses the headline, the author, and the location to"
" create the return value of `summarize`. For the `Tweet` struct, we define "
"`summarize` as the username followed by the entire text of the tweet, "
"assuming that tweet content is already limited to 280 characters."
msgstr ""
"Sekarang kita telah mendefinisikan tanda tangan yang diinginkan dari metode-"
"metria Summary, kita dapat mengimplementasikannya pada tipe-tipe di media "
"kita. Kode berikut ini menunjukkan implementasi dari sifat yang diinginkan "
"pada struktur ÁSUMmarary di dalam bentuk yang menggunakan headline, penulis,"
" dan lokasi untuk membuat nilai kembali ÁTweetán, kita mendefinisikan nama "
"pengguna yang diikuti oleh seluruh teks, dengan tafsiran yang sudah terbatas"
" pada 280 karakter."

#: src/ch08-02-traits-in-cairo.md:188
msgid ""
"Implementing a trait on a type is similar to implementing regular methods. "
"The difference is that after `impl`, we put a name for the implementation, "
"then use the `of` keyword, and then specify the name of the trait we are "
"writing the implementation for. If the implementation is for a generic type,"
" we place the generic type name in the angle brackets after the trait name."
msgstr ""
"Menimplementasikan sifat pada tipe mirip dengan menerapkan metode biasa. "
"Perbedaannya adalah bahwa setelah melakukan implementasi adalah untuk tipe "
"umum, kita menaruh nama umum untuk implementasi, lalu menggunakan kata "
"kunci, dan kemudian menentukan nama sifat yang kita tulis untuk "
"implementasi. Jika penerapan adalah untuk tipe umum, kita menempatkan nama "
"umum dalam kurung sudut setelah nama sifat."

#: src/ch08-02-traits-in-cairo.md:193
msgid ""
"Note that for the trait method to be accessible, there must be an "
"implementation of that trait visible from the scope where the method is "
"called. If the trait is `pub` and the implementation is not, and the "
"implementation is not visible in the scope where the trait method is called,"
" this will cause a compilation error."
msgstr ""
"Perhatikan bahwa agar metode perangai dapat diakses, harus ada penerapan "
"sifat tersebut yang terlihat dari ruang lingkup di mana metode ini disebut. "
"Jika sifat tersebut adalah ·pubå dan implementasi tidak, dan implementasi "
"tidak terlihat dalam lingkup di mana metode sifat disebut, ini akan "
"menyebabkan kesalahan kompilasi."

#: src/ch08-02-traits-in-cairo.md:195
msgid ""
"Within the `impl` block, we put the method signatures that the trait "
"definition has defined. Instead of adding a semicolon after each signature, "
"we use curly brackets and fill in the method body with the specific behavior"
" that we want the methods of the trait to have for the particular type."
msgstr ""
"Daripada menambahkan setengah koma setelah setiap tanda tangan, kami "
"menggunakan kurung keriting dan mengisi metode tubuh dengan perilaku "
"spesifik yang kami inginkan dari metode sifat yang kami miliki untuk jenis "
"tertentu."

#: src/ch08-02-traits-in-cairo.md:200
msgid ""
"Now that the library has implemented the `Summary` trait on `NewsArticle` "
"and `Tweet`, users of the crate can call the trait methods on instances of "
"`NewsArticle` and `Tweet` in the same way we call regular methods. The only "
"difference is that the user must bring the trait into scope as well as the "
"types. Here’s an example of how a crate could use our `aggregator` crate:"
msgstr ""
"Sekarang perpustakaan telah mengimplementasikan sifat Summary pada "
"'NewsArticle' dan 'Tweet', pengguna dari peti itu dapat menyebut metode-"
"metode khas pada contohnya dari 'NewsArticle' dan 'Tweet' dengan cara yang "
"sama kita sebut metode reguler. Satu-satunya perbedaan adalah bahwa pengguna"
" harus membawa sifat-sifat ke dalam lingkup serta jenis-jenisnya."

#: src/ch08-02-traits-in-cairo.md:265
msgid "This code prints the following:"
msgstr "Kode ini mencetak hal berikut:"

#: src/ch08-02-traits-in-cairo.md:279
msgid ""
"Other crates that depend on the _aggregator_ crate can also bring the "
"`Summary` trait into scope to implement `Summary` on their own types."
msgstr ""
"Peti lain yang tergantung pada peti _aggregator_ dapat juga membawa sifat-"
"sifat yang ada dalam lingkup untuk mengimplementasikan sistemer pada tipe "
"mereka sendiri."

#: src/ch08-02-traits-in-cairo.md:304
msgid "Managing and Using External Trait"
msgstr "Mengelola dan Menggunakan Sifat Eksternal"

#: src/ch08-02-traits-in-cairo.md:306
msgid ""
"To use traits methods, you need to make sure the correct "
"traits/implementation(s) are imported. In some cases you might need to "
"import not only the trait but also the implementation if they are declared "
"in separate modules. If `CircleGeometry` implementation was in a separate "
"module/file named _circle_, then to define `boundary` method on `Circle` "
"struct, we'd need to import `ShapeGeometry` trait in the _circle_ module."
msgstr ""
"Untuk menggunakan metode perangai, Anda perlu memastikan bahwa "
"perangai/implementasi yang benar (ircleGeometri) diimpor. Dalam beberapa "
"kasus Anda mungkin perlu mengimpor tidak hanya sifat tetapi juga impletasi "
"jika mereka dinyatakan dalam modul terpisah. Jika implementasi cirkelry "
"dalam modul terpisah/berkas bernama _circle_, kemudian untuk mendefinisikan "
"metode Árcleá strucle struct, kita perlu mengimpor sifat auxpeometri dalam "
"modul _circle_."

#: src/ch08-02-traits-in-cairo.md:309
msgid ""
"If the code was organized into modules like this, where the implementation "
"of a trait was defined in a different module than the trait itself, "
"explicitly importing the relevant trait or implementation is required."
msgstr ""
"Jika kode terorganisir dalam modul seperti ini, di mana implementasi sebuah "
"sifat didefinisikan dalam modul yang berbeda daripada sifat itu sendiri, "
"secara eksplisit mengimpor sifat atau implementasi yang relevan diperlukan."

#: src/ch08-02-traits-in-cairo.md:312
msgid ""
"// Here T is an alias type which will be provided during implementation\n"
msgstr ""
"//Di sini T adalah sebuah tipe alias yang akan disediakan selama "
"implementasi\n"

#: src/ch08-02-traits-in-cairo.md:319
msgid ""
"// Importing ShapeGeometry is required to implement this trait for "
"Rectangle\n"
msgstr ""
"// Mengimpor ShapeGeometri diperlukan untuk mengimplementasikan sifat ini "
"untuk persegi panjang\n"

#: src/ch08-02-traits-in-cairo.md:328
msgid ""
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"    // to implement the trait for that type\n"
msgstr ""
"//Implementasi RectgleGeometri melewati <Rectangle> // untuk "
"mengimplementasikan sifat untuk tipe itu\n"

#: src/ch08-02-traits-in-cairo.md:341
msgid ""
"// Importing ShapeGeometry is required to implement this trait for Circle\n"
msgstr ""
"// Mengimpor ShapeGeometri diperlukan untuk mengimplementasikan sifat ini "
"untuk Lingkaran\n"

#: src/ch08-02-traits-in-cairo.md:349
msgid ""
"// Implementation CircleGeometry passes in <Circle>\n"
"    // to implement the imported trait for that type\n"
msgstr ""
"//Implementasi CircleGeometri lewat dalam <Circle> // untuk "
"mengimplementasikan sifat impor untuk tipe itu\n"

#: src/ch08-02-traits-in-cairo.md:366
msgid "\"Rectangle area: {}\""
msgstr "\"Area Rectangle: {}\""

#: src/ch08-02-traits-in-cairo.md:366
msgid "//35\n"
msgstr "///35\n"

#: src/ch08-02-traits-in-cairo.md:367
msgid "\"Rectangle boundary: {}\""
msgstr "Batas Rectangle: {}\""

#: src/ch08-02-traits-in-cairo.md:367
msgid "//24\n"
msgstr "//24\n"

#: src/ch08-02-traits-in-cairo.md:370
msgid "\"Circle area: {}\""
msgstr "\"Area lingkaran: {}\""

#: src/ch08-02-traits-in-cairo.md:370
msgid "//78\n"
msgstr "//78\n"

#: src/ch08-02-traits-in-cairo.md:371
msgid "\"Circle boundary: {}\""
msgstr "Batas lingkaran: {}\""

#: src/ch08-02-traits-in-cairo.md:371
msgid "//31\n"
msgstr "//31\n"

#: src/ch08-02-traits-in-cairo.md:375
msgid ""
"Note that in this example, `CircleGeometry` and `RectangleGeometry` "
"implementations don't need to be declared as `pub`. Indeed, `ShapeGeometry` "
"trait, which is public, is used to print the result in the `main` function. "
"The compiler will find the appropriate implementation for the "
"`ShapeGeometry` public trait, regardless of the implementation visibility."
msgstr ""
"Perhatikan bahwa dalam contoh ini, \"CircleGeometry\" dan "
"\"RectangleGeometry,\" implementations\" tidak perlu dideklarasikan sebagai "
"\"CircleGeometry.\" Memang, sifat umum, yang digunakan untuk mencetak hasil "
"dari fungsi thosemain.\" Komiler akan menemukan implementasi yang sesuai "
"untuk sifat publik, terlepas dari penerapan visibilitas."

#: src/ch08-02-traits-in-cairo.md:377
msgid "Impl Aliases"
msgstr "Aliase Impl"

#: src/ch08-02-traits-in-cairo.md:379
msgid ""
"Implementations can be aliased when imported. This is most useful when you "
"want to instantiate generic implementations with concrete types. For "
"example, let's say we define a trait `Two` that is used to return the value "
"`2` for a type `T`. We can write a trivial generic implementation of `Two` "
"for all types that implement the `One` trait, simply by adding twice the "
"value of `one` and returning it. However, in our public API, we may only "
"want to expose the `Two` implementation for the `u8` and `u128` types."
msgstr ""
"Implementasi dapat dilafalkan ketika diimpor. Ini paling berguna bila Anda "
"ingin mengimplementasi umum instantasi dengan tipe beton. Sebagai contoh, "
"katakanlah kita mendefinisikan sifat yang digunakan untuk mengembalikan "
"nilai tersebut. Namun, di API umum kita, kita mungkin hanya ingin mengungkap"
" penerapan umum yang sepele untuk semua tipe yang mengimplementasi ▪8 dan "
"tipe."

#: src/ch08-02-traits-in-cairo.md:400
msgid ""
"<span class=\"caption\"> Listing 8-1: Using impl aliases to instantiate "
"generic impls with concrete types</span>"
msgstr ""
"<span class=\"caption\"> Listing 8-1: Menggunakan alias impl ke impls "
"generik instantate dengan tipe beton</span>"

#: src/ch08-02-traits-in-cairo.md:402
msgid ""
"We can define the generic implementation in a private module, use an impl "
"alias to instantiate the generic implementation for these two concrete "
"types, and make these two implementations public, while keeping the generic "
"implementation private and unexposed. This way, we can avoid code "
"duplication using the generic implementation, while keeping the public API "
"clean and simple."
msgstr ""
"Kita dapat mendefinisikan implementasi generik dalam modul privat, "
"menggunakan impl alias untuk mempercepat implementasi generik untuk dua tipe"
" beton ini, dan membuat kedua implementasi ini untuk umum, sementara menjaga"
" implementasi umum privat dan tidak terafeksi. Dengan cara ini, kita dapat "
"menghindari duplikasi kode menggunakan implementasi umum, sementara menjaga "
"API publik tetap bersih dan sederhana."

#: src/ch08-02-traits-in-cairo.md:404
msgid "Negative Impls"
msgstr "Impl Negatif"

#: src/ch08-02-traits-in-cairo.md:406
msgid ""
"Note: This is still an experimental feature and can only be used if "
"`experimental-features = [\"negative_impls\"]` is enabled in your "
"_Scarb.toml_ file, under the `[package]` section."
msgstr ""
"Catatan: Ini masih merupakan fitur eksperimental dan hanya dapat digunakan "
"jika ·experimental-features = [\"negatitive_impls\"]]"

#: src/ch08-02-traits-in-cairo.md:408
msgid ""
"Negative implementations, also known as negative traits or negative bounds, "
"are a mechanism that allows you to express that a type does not implement a "
"certain trait when defining the implementation of a trait over a generic "
"type. Negative impls enable you to write implementations that are applicable"
" only when another implementation does not exist in the current scope."
msgstr ""
"In implementasi negatif, juga dikenal sebagai sifat negatif atau batas "
"negatif, adalah mekanisme yang memungkinkan Anda untuk mengekspresikan bahwa"
" tipe tidak mengimplementasikan suatu sifat tertentu ketika mendefinisikan "
"implementasi dari sifat atas tipe umum. Impls negatif memungkinkan Anda "
"untuk menulis implementasi yang hanya berlaku ketika implementasi lain tidak"
" ada dalam lingkup saat ini."

#: src/ch08-02-traits-in-cairo.md:410
msgid ""
"For example, let's say we have a trait `Producer` and a trait `Consumer`, "
"and we want to define a generic behavior where all types implement the "
"`Consumer` trait by default. However, we want to ensure that no type can be "
"both a `Consumer` and a `Producer`. We can use negative impls to express "
"this restriction."
msgstr ""
"Sebagai contoh, katakanlah kita memiliki sifat producer dan sifat konsuer, "
"dan kita ingin mendefinisikan perilaku umum di mana semua tipe menerapkan "
"sifat konsumen secara default. Namun, kita ingin memastikan bahwa tidak ada "
"tipe yang dapat keduanya adalah sebuah ▪Consumer atau producer. kita dapat "
"menggunakan laknat negatif untuk mengekspresikan pembatasan ini."

#: src/ch08-02-traits-in-cairo.md:412
msgid ""
"In Listing 8-2, we define a `ProducerType` that implements the `Producer` "
"trait, and two other types, `AnotherType` and `AThirdType`, which do not "
"implement the `Producer` trait. We then use negative impls to create a "
"default implementation of the `Consumer` trait for all types that do not "
"implement the `Producer` trait."
msgstr ""
"Di Listing 8-2, kami mendefinisikan sebuah ·AthirdType yang "
"mengimplementasikan sifat-sifat producer (producer), dan dua tipe lainnya, "
"dan dua tipe lainnya, ▪AnotherType) dan ·AThirdType-- yang tidak menerapkan "
"sifat producer."

#: src/ch08-02-traits-in-cairo.md:440
msgid "\"{:?} consumed value: {}\""
msgstr "\"{:?} nilai yang dikonsumsi: {}\""

#: src/ch08-02-traits-in-cairo.md:450
msgid ""
"// producer.consumer(production); Invalid: ProducerType does not implement "
"Consumer\n"
msgstr ""
"//produser.consumer[production]; Tidak valid: ProducerType tidak "
"mengimplementasikan Konsumer\n"

#: src/ch08-02-traits-in-cairo.md:456
msgid ""
"<span class=\"caption\"> Listing 8-2: Using negative impls to enforce that a"
" type cannot implement both `Producer` and `Consumer` traits "
"simultaneously</span>"
msgstr ""
"<span class=\"caption\"> Listing 8-2: Menggunakan impls negatif untuk "
"memaksakan bahwa sebuah tipe tidak dapat mengimplementasi baik producer "
"maupun karakter Konsumer secara simultan</span>"

#: src/ch08-02-traits-in-cairo.md:458
msgid ""
"In the `main` function, we create instances of `ProducerType`, "
"`AnotherType`, and `AThirdType`. We then call the `produce` method on the "
"`producer` instance and pass the result to the `consume` method on the "
"`another_type` and `third_type` instances. Finally, we try to call the "
"`consume` method on the `producer` instance, which results in a compile-time"
" error because `ProducerType` does not implement the `Consumer` trait."
msgstr ""
"Dalam fungsinya, kita membuat contoh-contoh dari producerType, dan lain-lain"
" yang digunakan dan kita mencoba untuk membuat metode producer pada contoh "
"producer (producerType), yang menghasilkan kesalahan karena producer "
"(producer) producer (producer) muncul karena producer) producer (producer) "
"yang tidak menerapkan sifat-sifat tersebut."

#: src/ch08-02-traits-in-cairo.md:460
msgid "{{#quiz ../quizzes/ch08-02-traits.toml}}"
msgstr "{{#quiz../quizzes/ch08-02-traits.toml}}}"

#: src/ch09-00-error-handling.md
msgid "Error handling"
msgstr "Kesalahan penanganan"

#: src/ch09-00-error-handling.md
msgid ""
"In this chapter, we will explore various error handling techniques provided "
"by Cairo, which not only allow you to address potential issues in your code,"
" but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as "
"pattern matching with the `Result` enum, using the `?` operator for more "
"ergonomic error propagation, and employing the `unwrap` or `expect` methods "
"for handling recoverable errors, you'll gain a deeper understanding of "
"Cairo's error handling features. These concepts are crucial for building "
"robust applications that can effectively handle unexpected situations, "
"ensuring your code is ready for production."
msgstr ""
"Dalam bab ini, kita akan menjelajahi berbagai teknik penanganan kesalahan "
"yang disediakan oleh Cairo, yang tidak hanya memungkinkan Anda untuk "
"mengatasi masalah potensial dalam kode Anda, tetapi juga membuatnya lebih "
"mudah untuk membuat program yang dapat disesuaikan dan dapat dipertahankan. "
"Dengan memeriksa pendekatan yang berbeda untuk mengelola kesalahan, seperti "
"pola yang cocok dengan enum resultic resolve, menggunakan årgentic operator "
"untuk propagasi kesalahan ergonotic, dan menggunakan metode Áun wrave atau "
"auxexpectánust untuk menangani kesalahan-kesalahan yang dapat diperbaiki, "
"Anda akan memperoleh pemahaman lebih dalam fitur penanganan error Cairo. "
"Konsep ini sangat penting untuk aplikasi bangunan yang dapat ditangani "
"secara efektif, yang tidak terduga dapat ditangani oleh kode Anda untuk "
"produksi secara tidak terduga."

#: src/ch09-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with `panic`"
msgstr "Kesalahan Tak Dapat Dipulihkan dengan åpanic)"

#: src/ch09-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in"
" runtime errors. While the `panic` function from the core library doesn't "
"provide a resolution for these errors, it does acknowledge their occurrence "
"and terminates the program. There are two primary ways that a panic can be "
"triggered in Cairo: inadvertently, through actions causing the code to panic"
" (e.g., accessing an array beyond its bounds), or deliberately, by invoking "
"the `panic` function."
msgstr ""
"Di Cairo, masalah yang tak terduga mungkin muncul selama eksekusi program, "
"yang mengakibatkan kesalahan dalam runtime. sementara fungsi Épanicå dari "
"perpustakaan inti tidak memberikan resolusi untuk kesalahan ini, ia mengakui"
" kejadian mereka dan mengakhiri program. ada dua cara utama agar kepanikan "
"dapat dipicu di Cairo: secara tidak sengaja, melalui tindakan yang "
"menyebabkan kode panik (misalnya, mengakses array di luar batas-batasnya), "
"atau sengaja, dengan melibatkan fungsi progenik."

#: src/ch09-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The "
"`panic` function takes an array as an argument, which can be used to provide"
" an error message and performs an unwind process where all variables are "
"dropped and dictionaries squashed to ensure the soundness of the program to "
"safely terminate the execution."
msgstr ""
"Ketika kepanikan terjadi, hal itu mengarah ke penghentian program secara "
"tiba-tiba. Fungsi ·panicáne mengambil sebuah array sebagai argumen, yang "
"dapat digunakan untuk memberikan pesan kesalahan dan melakukan sebuah proses"
" unwind di mana semua variabel dijatuhkan dan kamus terjepit untuk "
"memastikan soundness dari program untuk dengan aman mengakhiri eksekusi."

#: src/ch09-01-unrecoverable-errors-with-panic.md:7
msgid ""
"Here is how we can call `panic` from inside a program and return the error "
"code `2`:"
msgstr ""
"Berikut adalah bagaimana kita dapat memanggil æpanicé dari dalam program dan"
" mengembalikan kode kesalahan:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:18
#: src/ch09-01-unrecoverable-errors-with-panic.md:58
msgid "\"This line isn't reached\""
msgstr "\"Garis ini tidak mencapai\""

#: src/ch09-01-unrecoverable-errors-with-panic.md:22
msgid "Running the program will produce the following output:"
msgstr "Menjalankan program akan menghasilkan keluaran berikut:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:33
msgid ""
"As you can notice in the output, the call to `println!` macro is never "
"reached, as the program terminates after encountering the `panic` statement."
msgstr ""
"Seperti yang dapat Anda lihat di output, panggilan ke åprintln! makro tidak "
"pernah dicapai, karena program berakhir setelah menghadapi pernyataan "
"·panicáne."

#: src/ch09-01-unrecoverable-errors-with-panic.md:35
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use"
" the `panic_with_felt252` function. This function serves as an abstraction "
"of the array-defining process and is often preferred due to its clearer and "
"more concise expression of intent. By using `panic_with_felt252`, developers"
" can panic in a one-liner by providing a `felt252` error message as an "
"argument, making the code more readable and maintainable."
msgstr ""
"Sebuah pendekatan alternatif dan lebih terdiomatitik untuk panik di Cairo "
"akan menggunakan ekspresi yang lebih jelas dan lebih ringkas dari maksud. "
"Dengan menggunakan fungsi_felt252. Fungsi ini berfungsi sebagai abstraksi "
"dari proses penyelenggara array dan sering kali lebih disukai karena lebih "
"jelas dan lebih ringkas ekspresi maksud. Dengan menggunakan ▪panic_felt2523,"
" pengembang dapat panik dalam satu-liner dengan memberikan sebuah pesan "
"felt25 sesaat sebagai argumen, membuat kode yang dapat dibaca dan "
"dipertahankan."

#: src/ch09-01-unrecoverable-errors-with-panic.md:37
msgid "Let's consider an example:"
msgstr "Mari kita perhatikan sebuah contoh:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:47
msgid ""
"Executing this program will yield the same error message as before. In that "
"case, if there is no need for an array and multiple values to be returned "
"within the error, `panic_with_felt252` is a more succinct alternative."
msgstr ""
"Menjalankan program ini akan menghasilkan pesan galat yang sama seperti "
"sebelumnya. Dalam hal ini, jika tidak ada kebutuhan untuk sebuah array dan "
"beberapa nilai yang akan dikembalikan dalam kesalahan, ·panic_with_felt252 "
"TM adalah alternatif yang lebih singkat."

#: src/ch09-01-unrecoverable-errors-with-panic.md:49 src/ch11-05-macros.md:29
msgid "`panic!` Macro"
msgstr "Makro"

#: src/ch09-01-unrecoverable-errors-with-panic.md:51
msgid ""
"`panic!` macro can be really helpful. The previous example returning the "
"error code `2` shows how convenient `panic!` macro is. There is no need to "
"create an array and pass it as an argument like with the `panic` function."
msgstr ""
"makro dapat sangat membantu. Contoh sebelumnya mengembalikan kode kesalahan "
"menunjukkan betapa nyamannya makro."

#: src/ch09-01-unrecoverable-errors-with-panic.md:56
msgid "\"2\""
msgstr "\"2\""

#: src/ch09-01-unrecoverable-errors-with-panic.md:62
msgid ""
"Unlike the `panic_with_felt252` function, using `panic!` allows the input, "
"which is ultimately the panic error, to be a literal longer than 31 bytes. "
"This is because `panic!` takes a string as a parameter. For example, the "
"following line of code will successfully compile:"
msgstr ""
"Tidak seperti \"panic_with_felt252,\" menggunakan åpanic! Ijinkan masukan, "
"yang pada akhirnya kesalahan panik, untuk menjadi literal lebih lama dari 31"
" byte. Ini karena åpanic! Ambil string sebagai parameter. Sebagai contoh, "
"baris berikut kode akan berhasil dikompilasi:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:65
msgid "\"the error for panic! macro is not limited to 31 characters anymore\""
msgstr "\"kesalahan untuk panik! makro tidak terbatas pada 31 karakter lagi\""

#: src/ch09-01-unrecoverable-errors-with-panic.md:68
msgid "`nopanic` Notation"
msgstr "Notasi ·nopanicé"

#: src/ch09-01-unrecoverable-errors-with-panic.md:70
msgid ""
"You can use the `nopanic` notation to indicate that a function will never "
"panic. Only `nopanic` functions can be called in a function annotated as "
"`nopanic`."
msgstr ""
"Anda dapat menggunakan notasi gnopanic untuk menunjukkan bahwa sebuah fungsi"
" tidak akan pernah panik."

#: src/ch09-01-unrecoverable-errors-with-panic.md:80
msgid ""
"This function will always return `42` and is guaranteed to never panic. "
"Conversely, the following function is not guaranteed to never panic:"
msgstr "Fungsi ini akan selalu kembali, dan dijamin tidak akan pernah panik."

#: src/ch09-01-unrecoverable-errors-with-panic.md:88
msgid ""
"If you try to compile this function that includes code that may panic, you "
"will get the following error:"
msgstr ""
"Jika Anda mencoba mengkompilasi fungsi ini yang mencakup kode yang mungkin "
"panik, Anda akan mendapat kesalahan berikut:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:108
msgid ""
"Note that there are two functions that may panic here, `assert` and equality"
" with `==`. We usually don't use `assert` function in practice and use "
"`assert!` macro instead. We will discuss `assert!` macro in more detail in "
"the [Testing Cairo Programs](./ch10-01-how-to-write-tests.md#checking-"
"results-with-the-assert-macro) chapter."
msgstr ""
"Perhatikan bahwa ada dua fungsi yang mungkin panik di sini, misro sebagai "
"gantinya. kita akan membahas makro yang lebih detail di bab [Program "
"Cairo]./ch10-01-how-to-tests.md# checking-reult-with-esert-macro)."

#: src/ch09-01-unrecoverable-errors-with-panic.md:112
msgid "`panic_with` Attribute"
msgstr "Panik_dengan Atribut"

#: src/ch09-01-unrecoverable-errors-with-panic.md:114
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an "
"`Option` or `Result`. This attribute takes two arguments, which are the data"
" that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will "
"panic if the function returns `None` or `Err`, with the given data as the "
"panic error."
msgstr ""
"Anda dapat menggunakan atribut åpanic_with sekelompok fungsi untuk menandai "
"fungsi yang kembali ke fungsi awal atau result. Atribut ini membutuhkan dua "
"argumen, yang adalah data yang lewat sebagai alasan panik serta nama untuk "
"fungsi pembungkus. akan menciptakan pembungkus untuk fungsi yang telah "
"dienotasikan Anda yang akan panik jika fungsi kembali atau tidak ada lagi "
"argumen, dengan data yang diberikan sebagai kesalahan panik."

#: src/ch09-01-unrecoverable-errors-with-panic.md:116
#: src/appendix-03-derivable-traits.md:38
msgid "Example:"
msgstr "Contoh:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:129
msgid "// this returns None\n"
msgstr "# # This return None\n"

#: src/ch09-01-unrecoverable-errors-with-panic.md:130
msgid "// this panics with 'value is 0'\n"
msgstr "/Ini panik dengan 'nilai adalah 0'\n"

#: src/ch09-01-unrecoverable-errors-with-panic.md:134
msgid "{{#quiz ../quizzes/ch09-01-unrecoverable-errors-with-panic.toml}}"
msgstr "{{#quiz../quizzes/ch09-01-uncoverable-errors-with-panic.toml}} ]"

#: src/ch09-02-recoverable-errors.md:1
msgid "Recoverable Errors with `Result`"
msgstr "Kesalahan Yang Dapat Dipulihkan dengan CERINTA"

#: src/ch09-02-recoverable-errors.md:3
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to add two large integers "
"and the operation overflows because the sum exceeds the maximum "
"representable value, you might want to return an error or a wrapped result "
"instead of causing undefined behavior or terminating the process."
msgstr ""
"Kebanyakan kesalahan tidak cukup serius untuk menghentikan program ini. "
"Kadang-kadang, ketika sebuah fungsi gagal, itu karena alasan bahwa Anda "
"dapat dengan mudah menafsirkan dan merespon. Sebagai contoh, jika Anda "
"mencoba untuk menambahkan dua bilangan bulat besar dan operasi overflows "
"karena jumlah melampaui nilai yang mewakili maksimum, Anda mungkin ingin "
"mengembalikan kesalahan atau hasil yang dibungkus daripada menyebabkan "
"perilaku yang tidak jelas atau mengakhiri proses."

#: src/ch09-02-recoverable-errors.md:5
msgid "The `Result` Enum"
msgstr "Enum (Enam)."

#: src/ch09-02-recoverable-errors.md:7
msgid ""
"Recall from [Generic data types](./ch08-01-generic-data-types.md#enums) "
"section in Chapter 8 that the `Result` enum is defined as having two "
"variants, `Ok` and `Err`, as follows:"
msgstr ""
"Recall from [Genic tipe data]. /ch08-01-generic-data-types.ms.md#enums) "
"dalam Bab 8 bahwa enum enum resolte didefinisikan sebagai memiliki dua "
"varians, ▪Ok Chewier, sebagai berikut:"

#: src/ch09-02-recoverable-errors.md:20
msgid "The `ResultTrait`"
msgstr "The ResultTrait"

#: src/ch09-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>`"
" enum, such as unwrapping values, checking whether the `Result` is `Ok` or "
"`Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr ""
"Sifat ResultTrait menyediakan metode-metode untuk bekerja dengan result<T, "
"E>, seperti nilai-nilai unwraping, memeriksa apakah implementasi resolult "
"adalah oká atau err, dan panik dengan pesan kustom."

#: src/ch09-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to "
"extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` "
"variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior "
"when the `Result` is in the `Err` variant. The `expect` method allows you to"
" provide a custom error message (as a `felt252` value) that will be used "
"when panicking, giving you more control and context over the panic. On the "
"other hand, the `unwrap` method panics with a default error message, "
"providing less information about the cause of the panic."
msgstr ""
"Metode-metode ini mirip dengan metode-metode yang mereka berdua coba "
"mengekstrak nilai dari tipe tersebut, dari sebuah result <T, E> ketika "
"berada dalam varian åok. Jika metode yang mereka berdua coba ekstrak adalah "
"åOkánax), kedua metode itu mengembalikan nilai tersebut. Namun, perbedaan "
"kunci di antara dua metode tersebut terletak pada perilaku mereka ketika "
"bencana berada dalam variabel tersebut."

#: src/ch09-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` methods have the exact opposite behavior. "
"If the `Result` is `Err(x)`, both methods return the value `x`. However, the"
" key difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control "
"and context over the panic. On the other hand, the `unwrap_err` method "
"panics with a default error message, providing less information about the "
"cause of the panic."
msgstr ""
"Metode khusus ini memiliki perilaku yang berbeda. Jika metode ini memiliki "
"perilaku yang benar-benar berbeda, kedua metode tersebut akan mengembalikan "
"nilai  (misal 25). Namun, perbedaan kunci antara dua metode tersebut adalah "
"dalam kasus ▪Reult:::Oktal). Metode pengungkapan ini memungkinkan Anda untuk"
" memberikan pesan custom (sebagai nilai felt2523) yang akan digunakan ketika"
" panik, memberi Anda kontrol lebih banyak dan konteks atas panik. Pada sisi "
"lain, metode versuser). Metode yang memungkinkan Anda untuk memberikan pesan"
" default, menyebabkan lebih sedikit tentang kepanikan."

#: src/ch09-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the "
"first four methods signatures. This syntax represents generic type "
"constraints in the Cairo language, as seen in the previous chapter. These "
"constraints indicate that the associated functions require an implementation"
" of the `Drop` trait for the generic types `T` and `E`, respectively."
msgstr ""
"Seorang pembaca yang berhati - hati mungkin memperhatikan <+Drop<T> dan "
"<+Drop<E> dalam empat metode tanda tangan pertama. Sintak ini merupakan "
"kendala umum dalam bahasa Cairo, seperti yang terlihat di bab sebelumnya. "
"Keterbatasan ini menunjukkan bahwa fungsi yang terkait membutuhkan "
"implementasi dari sifat umum untuk tipe umum ÉTÉ dan ÉE, masing-masing."

#: src/ch09-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by "
"the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr ""
"Yang terakhir, metode-metode yang digunakan oleh fungsi ▪ResultTrait untuk "
"memeriksa varian dari sebuah nilai enum resol."

#: src/ch09-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the"
" `Result` is the `Ok` variant, meaning the operation was successful. If the "
"`Result` is the `Err` variant, it returns `false`."
msgstr ""
"Nilai dan nilai E> adalah jika result adalah varian yang sama, berarti "
"operasi itu sukses."

#: src/ch09-02-recoverable-errors.md:49
msgid ""
"`is_err` takes a snapshot of a `Result<T, E>` value and returns `true` if "
"the `Result` is the `Err` variant, meaning the operation encountered an "
"error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr ""
"Nilai dan nilai E> adalah jika reserult adalah varian, berarti operasi "
"mengalami kesalahan. Jika resolt adalah varian thoseok, ia akan kembali."

#: src/ch09-02-recoverable-errors.md:51
msgid ""
"These methods are helpful when you want to check the success or failure of "
"an operation without consuming the `Result` value, allowing you to perform "
"additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr ""
"Metode - metode ini sangat membantu apabila Anda ingin memeriksa "
"keberhasilan atau kegagalan suatu operasi tanpa mengkonsumsi nilai ÁResulté,"
" memungkinkan Anda melakukan operasi tambahan atau membuat keputusan - "
"keputusan berdasarkan varian tanpa perlu membungkusnya."

#: src/ch09-02-recoverable-errors.md:53
msgid ""
"You can find the implementation of the `ResultTrait` "
"[here](https://github.com/starkware-"
"libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr ""
"Anda dapat menemukan implementasi dari 'ResultTrait' "
"[disini][https://gitub.com/starkware-"
"libs/cairo/blob/main/corelib/src/result.cairo#L20)."

#: src/ch09-02-recoverable-errors.md:55
msgid ""
"It is always easier to understand with examples. Have a look at this "
"function signature:"
msgstr ""
"Selalu lebih mudah untuk dipahami dengan contoh. Lihatlah tanda tangan "
"fungsi ini:"

#: src/ch09-02-recoverable-errors.md:61
msgid ""
"It takes two `u128` integers, `a` and `b`, and returns a `Result<u128, "
"u128>` where the `Ok` variant holds the sum if the addition does not "
"overflow, and the `Err` variant holds the overflowed value if the addition "
"does overflow."
msgstr ""
"Perlu dua integer, atau integer, dan variannya tidak meluap, dan variannya "
"mengandung nilai yang meluap - luap bila penjumlahan itu meluap."

#: src/ch09-02-recoverable-errors.md:63
msgid "Now, we can use this function elsewhere. For instance:"
msgstr "Sekarang, kita dapat menggunakan fungsi ini di tempat lain."

#: src/ch09-02-recoverable-errors.md:75
msgid ""
"Here, it accepts two `u128` integers, `a` and `b`, and returns an "
"`Option<u128>`. It uses the `Result` returned by `u128_overflowing_add` to "
"determine the success or failure of the addition operation. The `match` "
"expression checks the `Result` from `u128_overflowing_add`. If the result is"
" `Ok(r)`, it returns `Option::Some(r)` containing the sum. If the result is "
"`Err(r)`, it returns `Option::None` to indicate that the operation has "
"failed due to overflow. The function does not panic in case of an overflow."
msgstr ""
"Di sini, ia menerima dua bilangan 1228 integer, dan kembali ke sini untuk "
"menentukan keberhasilan atau kegagalan operasi penambahan. Ekspresi yang "
"tidak cocok memeriksa ekspresi <u128>. Ia menggunakan ▪Resolting_d. Jika "
"hasilnya adalah ▪128_overflowing_ad), ia kembali option: Ada yang berisi. "
"Jika hasilnya adalah Ár), ia kembali ke operasi yang telah gagal."

#: src/ch09-02-recoverable-errors.md:77
msgid "Let's take another example:"
msgstr "Mari kita ambil contoh lain:"

#: src/ch09-02-recoverable-errors.md:88
msgid ""
"In this example, the `parse_u8` function takes a `felt252` and tries to "
"convert it into a `u8` integer using the `try_into` method. If successful, "
"it returns `Result::Ok(value)`, otherwise it returns `Result::Err('Invalid "
"integer')`."
msgstr ""
"Dalam contoh ini, fungsi åparse_u8 mengambil sebuah °252) dan mencoba "
"mengubahnya menjadi integer (integer = integer = integer). jika berhasil, ia"
" akan kembali lagi:: Okórze), jika tidak, ia akan kembali ▪Resolult::::Err "
"(Err (Err harta karun) integer)."

#: src/ch09-02-recoverable-errors.md:90
msgid "Our two test cases are:"
msgstr "Dua kasus percobaan kami adalah:"

#: src/ch09-02-recoverable-errors.md:107
msgid "// should not panic\n"
msgstr "/ //seharusnya tidak panik\n"

#: src/ch09-02-recoverable-errors.md:115
msgid "// should panic\n"
msgstr "//harus panik\n"

#: src/ch09-02-recoverable-errors.md:123
msgid ""
"Don't worry about the `#[cfg(test)]` attribute for now. We'll explain in "
"more detail its meaning in the next [Testing Cairo Programs](./ch10-01-how-"
"to-write-tests.md) chapter."
msgstr ""
"Jangan khawatir tentang atribut untuk saat ini. Kami akan menjelaskan secara"
" lebih rinci artinya dalam bab berikutnya [Program Tes Cairo]./ch10-01-how-"
"to-writes-test.md)."

#: src/ch09-02-recoverable-errors.md:125
msgid ""
"`#[test]` attribute means the function is a test function, and "
"`#[should_panic]` attribute means this test will pass if the test execution "
"panics."
msgstr ""
"atribut ini berarti fungsi adalah fungsi tes, dan atribut [seharusnya_panik]"
" berarti tes ini akan lulus jika percobaan panik."

#: src/ch09-02-recoverable-errors.md:127
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the"
" `unwrap` method not to panic. The second test function attempts to convert "
"a value that is out of the `u8` range, expecting the `unwrap` method to "
"panic with the error message `Invalid integer`."
msgstr ""
"Yang pertama menguji konversi yang valid dari nomor 252 sampai ·u8, "
"mengharapkan metode pertama untuk tidak panik. Percobaan fungsi kedua untuk "
"mengubah nilai yang berada di luar jangkauan ·u8, mengharapkan metode åun "
"wrapping yang panik dengan pesan galat integer yang tidak valid."

#: src/ch09-02-recoverable-errors.md:132
msgid "The `?` Operator"
msgstr "Operator."

#: src/ch09-02-recoverable-errors.md:134
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator "
"is used for more idiomatic and concise error handling. When you use the `?` "
"operator on a `Result` or `Option` type, it will do the following:"
msgstr ""
"Operator terakhir yang akan kita bicarakan adalah operatornya. operatornya "
"digunakan untuk tipe yang lebih sederhana dan ringkas. ketika Anda "
"menggunakan operator pada jenis resolte atau opsi, ia akan melakukan hal "
"berikut:"

#: src/ch09-02-recoverable-errors.md:136
msgid ""
"If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the "
"inner value `x` directly."
msgstr ""
"Jika nilainya adalah \"Result:: Okłx\" atau \"Option\": \"Some Allahx,\" "
"maka nilai dalam akan dikembalikan langsung."

#: src/ch09-02-recoverable-errors.md:137
msgid ""
"If the value is `Result::Err(e)` or `Option::None`, it will propagate the "
"error or `None` by immediately returning from the function."
msgstr ""
"Jika nilainya adalah \"Result::Erróe\" atau \"Opsi\": \"None,\" maka ia akan"
" menyebarkan kesalahan atau tidak.\" dengan segera kembali dari fungsinya."

#: src/ch09-02-recoverable-errors.md:139
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let"
" the calling function deal with them."
msgstr ""
"Operator sangat berguna ketika Anda ingin menangani kesalahan secara "
"implisit dan membiarkan fungsi panggilan berurusan dengan mereka."

#: src/ch09-02-recoverable-errors.md:146 src/ch09-02-recoverable-errors.md:166
msgid "// DO SOMETHING\n"
msgstr "//Lakukan SESUATU\n"

#: src/ch09-02-recoverable-errors.md:152
msgid ""
"We can see that `do_something_with_parse_u8` function takes a `felt252` "
"value as input and calls `parse_u8` function. The `?` operator is used to "
"propagate the error, if any, or unwrap the successful value."
msgstr ""
"Kita dapat melihat bahwa 'do' sesuatu' dengan 'parse_u8' fungsi mengambil "
"nilai ▪felt252) sebagai masukan dan panggilan fungsi 'parse_u8'. Operator "
"digunakan untuk menyebarkan kesalahan, jika ada, atau membuka nilai sukses."

#: src/ch09-02-recoverable-errors.md:154
msgid "And with a little test case:"
msgstr "Dan dengan kasus kecil:"

#: src/ch09-02-recoverable-errors.md:178
msgid "\"Result: {}\""
msgstr "\"Hasil: [}\""

#: src/ch09-02-recoverable-errors.md:179
msgid "\"Error: {}\""
msgstr "\"Error: {}\""

#: src/ch09-02-recoverable-errors.md:186
msgid "The console will print the error `Invalid Integer`."
msgstr "Konsol akan mencetak kesalahan yang tidak sah."

#: src/ch09-02-recoverable-errors.md:190
msgid ""
"We saw that recoverable errors can be handled in Cairo using the `Result` "
"enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is "
"generic, with types `T` and `E` representing the successful and error "
"values, respectively. The `ResultTrait` provides methods for working with "
"`Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or"
" `Err`, and panicking with custom messages."
msgstr ""
"Kami melihat bahwa kesalahan yang dapat dipulihkan dapat ditangani di Cairo "
"menggunakan enum generic, yang memiliki dua varian, yang masing-masing "
"mewakili nilai yang sukses dan galat."

#: src/ch09-02-recoverable-errors.md:192
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use "
"pattern matching to handle the success or failure of an operation. The `?` "
"operator can be used to implicitly handle errors by propagating the error or"
" unwrapping the successful value. This allows for more concise and clear "
"error handling, where the caller is responsible for managing errors raised "
"by the called function."
msgstr ""
"Untuk menangani kesalahan yang dapat dipulihkan, sebuah fungsi dapat "
"mengembalikan jenis ÁResulté dan menggunakan pencocokan pola untuk menangani"
" keberhasilan atau kegagalan suatu operasi. Operator dapat digunakan secara "
"implisit untuk menangani kesalahan dengan menyebarkan kesalahan atau "
"mengurai nilai yang sukses. Hal ini memungkinkan untuk lebih ringkas dan "
"jelas penanganan galat, di mana penelepon bertanggung jawab untuk menangani "
"kesalahan yang dibangkitkan oleh fungsi yang disebut."

#: src/ch09-02-recoverable-errors.md:194
msgid "{{#quiz ../quizzes/ch09-02-error-handling-result.toml}}"
msgstr "{{#quiz../quizzes/ch09-02-error-handling-result.toml}}"

#: src/ch10-00-testing-cairo-programs.md
msgid ""
"Correctness in our programs is the extent to which our code does what we "
"intend it to do. Cairo is designed with a high degree of concern about the "
"correctness of programs, but correctness is complex and not easy to prove. "
"Cairo's linear type system shoulders a huge part of this burden, but the "
"type system cannot catch everything. As such, Cairo includes support for "
"writing tests."
msgstr ""
"Kebenaran dalam program kita adalah sejauh mana kode kita melakukan apa yang"
" kita berniat untuk melakukannya. Cairo dirancang dengan tingkat tinggi "
"keprihatinan tentang kebenaran program, tetapi kebenaran itu rumit dan tidak"
" mudah untuk membuktikan. Sistem linear Cairo bahu bagian besar dari beban "
"ini, tetapi sistem tipe tidak bisa menangkap segalanya. Karena demikian, "
"Cairo termasuk dukungan untuk tes menulis."

#: src/ch10-00-testing-cairo-programs.md
msgid ""
"Testing is a complex skill: although we can’t cover every detail about how "
"to write good tests in one chapter, we’ll discuss the mechanics of Cairo's "
"testing facilities. We’ll talk about the annotations and macros available to"
" you when writing your tests, the default behavior and options provided for "
"running your tests, and how to organize tests into unit tests and "
"integration tests."
msgstr ""
"Tes adalah keterampilan yang rumit: meskipun kita tidak dapat menutupi "
"setiap detail tentang bagaimana menulis tes yang baik dalam satu bab, kita "
"akan membahas mekanisme fasilitas pengujian Cairo. kita akan berbicara "
"tentang anotasi dan macros yang tersedia untuk Anda ketika menulis tes Anda,"
" perilaku baku dan pilihan yang disediakan untuk menjalankan tes Anda, dan "
"bagaimana mengatur tes ke tes unit dan integrasi tes."

#: src/ch10-01-how-to-write-tests.md:3 src/ch10-01-how-to-write-tests.md:17
msgid "The Anatomy of a Test Function"
msgstr "Anatomi Suatu Fungsi Ujian"

#: src/ch10-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these"
" three actions:"
msgstr ""
"Uji coba adalah fungsi Cairo yang memverifikasi bahwa kode bukan tes "
"berfungsi dengan cara yang diharapkan. Tubuh dari fungsi tes biasanya "
"melakukan tiga aksi ini:"

#: src/ch10-01-how-to-write-tests.md:7
msgid "Set up any needed data or state."
msgstr "Atur data atau keadaan yang diperlukan."

#: src/ch10-01-how-to-write-tests.md:8
msgid "Run the code you want to test."
msgstr "Jalankan kode yang ingin kau uji."

#: src/ch10-01-how-to-write-tests.md:9
msgid "Assert the results are what you expect."
msgstr "Membantu hasil adalah apa yang Anda harapkan."

#: src/ch10-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides for writing tests that take these "
"actions, which include:"
msgstr ""
"Mari kita lihat fitur-fitur yang disediakan Cairo untuk tes penulisan yang "
"mengambil tindakan ini, termasuk:"

#: src/ch10-01-how-to-write-tests.md:13
msgid "`#[test]` attribute."
msgstr "atribut."

#: src/ch10-01-how-to-write-tests.md:14
msgid ""
"`assert!`, `assert_eq!`, `assert_ne!`, `assert_lt!`, `assert_le!`, "
"`assert_gt!` and `assert_ge!` macros."
msgstr "Assert!, assert_eq!, assert_ne!, essert!, macros!"

#: src/ch10-01-how-to-write-tests.md:15
msgid "`#[should_panic]` attribute."
msgstr "Atribut."

#: src/ch10-01-how-to-write-tests.md:19
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the "
"`#[test]` attribute. Attributes are metadata about pieces of Cairo code; one"
" example is the `#[derive()]` attribute we used with structs in [Chapter "
"5](ch05-01-defining-and-instantiating-structs.md). To change a function into"
" a test function, add `#[test]` on the line before `fn`. When you run your "
"tests with the `scarb cairo-test` command, Scarb runs Cairo's test runner "
"binary that runs the annotated functions and reports on whether each test "
"function passes or fails."
msgstr ""
"Pada dasarnya, sebuah tes di Cairo adalah fungsi yang dianotasi dengan "
"atribut yang kita gunakan dengan struktur di [Chapter 5]-01-dening-and-"
"instenting-structs.m). Untuk mengubah fungsi menjadi fungsi tes, tambahkan "
"[#[test] di baris sebelum. Ketika Anda menjalankan tes Anda dengan kartiro-"
"cart Scarb, jalankan tes biner yang berjalan pada setiap fungsi, atau gagal "
"pada setiap fungsi yang dijalankan pada setiap fungsi."

#: src/ch10-01-how-to-write-tests.md:21
msgid ""
"Let's create a new project called _adder_ using Scarb with the command "
"`scarb new adder`:"
msgstr ""
"Mari kita buat sebuah proyek baru yang disebut _adder_ menggunakan Scarb "
"dengan perintah thosecarb new adder.:"

#: src/ch10-01-how-to-write-tests.md:30
msgid ""
"In _lib.cairo_, let's remove the existing content and add a `tests` module "
"containing the first test, as shown in Listing 10-1."
msgstr ""
"Dalam _lib.cairo_, mari kita hapus konten yang ada dan tambahkan modul "
"åtestá berisi tes pertama, seperti yang ditunjukkan dalam Daftar 10-1."

#: src/ch10-01-how-to-write-tests.md:40 src/ch10-01-how-to-write-tests.md:73
#: src/ch10-01-how-to-write-tests.md:97 src/ch10-01-how-to-write-tests.md:749
#: src/ch10-01-how-to-write-tests.md:786 src/ch10-02-test-organization.md:25
msgid "\"result is not 4\""
msgstr "\"Hasil bukanlah 4\""

#: src/ch10-01-how-to-write-tests.md:45
msgid "<span class=\"caption\">Listing 10-1: A simple test function</span>"
msgstr "<span class=\"caption\">Listing 10-1: Sebuah fungsi tes sederhana</span>"

#: src/ch10-01-how-to-write-tests.md:47
msgid ""
"Note the `#[test]` annotation: this attribute indicates this is a test "
"function, so the test runner knows to treat this function as a test. We "
"might also have non-test functions to help set up common scenarios or "
"perform common operations, so we always need to indicate which functions are"
" tests."
msgstr ""
"Perhatikan anotasi (stest): atribut ini menunjukkan fungsi tes, jadi pelari "
"uji tahu untuk memperlakukan fungsi ini sebagai tes. kita mungkin juga "
"memiliki fungsi non-test untuk membantu mengatur skenario umum atau "
"melakukan operasi umum, jadi kita selalu perlu mengindikasi fungsi yang mana"
" adalah tes."

#: src/ch10-01-how-to-write-tests.md:49
msgid ""
"We use the `#[cfg(test)]` attribute for the `tests` module, so that the "
"compiler knows the code it contains needs to be compiled only when running "
"tests. This is actually not an option: if you put a simple test with the "
"`#[test]` attribute in a _lib.cairo_ file, it will not compile. We will talk"
" more about the `#[cfg(test)]` attribute in the next [Testing "
"Organization](ch10-02-test-organization.md) section."
msgstr ""
"Kami menggunakan atribut untuk modul estimasi, sehingga kompiler tahu kode "
"yang ada perlu dikompilasi hanya ketika menjalankan tes. Ini sebenarnya "
"bukan pilihan: jika Anda menempatkan tes sederhana dengan atribut "
"_lib.cairo_, ini tidak akan dikompilasi. Kita akan berbicara lebih banyak "
"tentang atribut Á dalam bagian selanjutnya [Tg[Test Organization-02-est.m)."

#: src/ch10-01-how-to-write-tests.md:51
msgid ""
"The example function body uses the `assert!` macro, which contains the "
"result of adding 2 and 2, which equals 4. This assertion serves as an "
"example of the format for a typical test. We'll explain in more detail how "
"`assert!` works later in this chapter. Let’s run it to see that this test "
"passes."
msgstr ""
"Contoh tubuh fungsi menggunakan makro! yang berisi hasil penambahan 2 dan 2,"
" yang sama dengan 4. pernyataan ini berfungsi sebagai contoh dari format "
"untuk tes khas. kita akan menjelaskan secara lebih detail bagaimana assert! "
"bekerja kemudian di bab ini."

#: src/ch10-01-how-to-write-tests.md:53
msgid ""
"The `scarb cairo-test` command runs all tests found in our project, and "
"shows the following output:"
msgstr ""
"Perintah Cairo-test-timbun menjalankan semua tes yang ditemukan dalam proyek"
" kami, dan menunjukkan output berikut:"

#: src/ch10-01-how-to-write-tests.md:63
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 "
"test`. The next line shows the name of the test function, called `it_works`,"
" and that the result of running that test is `ok`. The test runner also "
"provides an estimation of the gas consumption. The overall summary `test "
"result: ok.` means that all the tests passed, and the portion that reads `1 "
"passed; 0 failed` totals the number of tests that passed or failed."
msgstr ""
"baris berikutnya menunjukkan nama dari fungsi tes, yang disebut "
"æit_worksést, dan bahwa hasil dari menjalankan tes tersebut adalah ook. "
"pelari yang juga memberikan estimasi dari konsumsi gas."

#: src/ch10-01-how-to-write-tests.md:65
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically "
"Requested](#ignoring-some-tests-unless-specifically-requested) section later"
" in this chapter. Because we haven’t done that here, the summary shows `0 "
"ignored`. We can also pass an argument to the `scarb cairo-test` command to "
"run only a test whose name matches a string; this is called filtering and "
"we’ll cover that in the [Running Single Tests](#running-single-tests) "
"section. Since we haven’t filtered the tests being run, the end of the "
"summary shows `0 filtered out`."
msgstr ""
"Ini memungkinkan untuk menandai sebuah tes yang diabaikan sehingga tidak "
"berjalan dalam hal tertentu; kita akan menutupi bahwa dalam [Ignore Beberapa"
" Tes Kecuali Khusus Dimohonkan] Kami juga dapat melewati argumen untuk "
"Ásbiro-test-terkecuali-spesifikasi) bagian kemudian dalam bab ini. Karena "
"kita belum melakukan itu di sini, ringkasan menunjukkan ·0 diabaikan."

#: src/ch10-01-how-to-write-tests.md:67
msgid ""
"Let’s start to customize the test to our own needs. First change the name of"
" the `it_works` function to a different name, such as `exploration`, like "
"so:"
msgstr ""
"Mari kita ubah nama fungsinya menjadi nama yang berbeda, seperti "
"'exploration'."

#: src/ch10-01-how-to-write-tests.md:77
msgid ""
"Then run `scarb cairo-test` again. The output now shows `exploration` "
"instead of `it_works`:"
msgstr ""
"Kemudian jalankan lagi. keluaran sekarang menunjukkan eksplorasi, bukan "
"æit_works:"

#: src/ch10-01-how-to-write-tests.md:87
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a"
" new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. Enter the new test as a function named `another`, "
"so your _src/lib.cairo_ file looks like in Listing 10-2."
msgstr ""
"Sekarang kita akan menambahkan tes yang lain, tapi kali ini kita akan "
"membuat tes yang gagal! tes gagal ketika sesuatu dalam uji coba panik "
"fungsi. dan ketika benang utama melihat bahwa benang tes telah mati, tes "
"ditandai sebagai gagal. masukkan tes baru sebagai fungsi lain bernama Á, "
"sehingga file Anda _src/.cairo_ tampak seperti Listing 10-2."

#: src/ch10-01-how-to-write-tests.md:103
msgid "\"Make this test fail\""
msgstr "\"Membuat tes ini gagal\""

#: src/ch10-01-how-to-write-tests.md:109
msgid ""
"<span class=\"caption\">Listing 10-2: Adding a second test in _lib.cairo_ "
"that will fail</span>"
msgstr ""
"<span class=\"caption\">Listing 10-2: Menambahkan tes kedua dalam "
"_lib.cairo_ yang akan gagal</span>"

#: src/ch10-01-how-to-write-tests.md:111
msgid "Run `scarb cairo-test` and you will see the following output:"
msgstr "Jalankan Cairo-test kareb dan Anda akan melihat keluaran berikut:"

#: src/ch10-01-how-to-write-tests.md:113
msgid ""
"```shell\n"
"$ scarb cairo-test \n"
"     Running cairo-test listing_08_03\n"
"   Compiling test(listings/ch10-testing-cairo-programs/listing_10_02/Scarb.toml)\n"
"    Finished release target(s) in 1 second\n"
"testing listing_08_03 ...\n"
"running 2 tests\n"
"test listing_08_03::tests::exploration ... ok (gas usage est.: 22540)\n"
"test listing_08_03::tests::another ... fail (gas usage est.: 24810)\n"
"failures:\n"
"   listing_08_03::tests::another - Panicked with \"Make this test fail\".\n"
"\n"
"\n"
"```"
msgstr "Font color = \"# e2a5\" }Diterjemahkan oleh:"

#: src/ch10-01-how-to-write-tests.md:128
msgid ""
"Instead of `ok`, the line `adder::another` shows `fail`. A new section "
"appears between the individual results and the summary. It displays the "
"detailed reason for each test failure. In this case, we get the details that"
" `another` failed because it panicked with `\"Make this test fail\"` error."
msgstr ""
"Alih-alih dari ikhtisar, baris ini menunjukkan bahwa bagian baru muncul "
"antara hasil individu dan ringkasannya. menunjukkan alasan rinci untuk "
"setiap kegagalan tes. dalam hal ini, kita mendapatkan rincian yang lain "
"gagal karena panik dengan \"Membuat tes ini gagal\" gagal."

#: src/ch10-01-how-to-write-tests.md:130
msgid ""
"The summary line is displayed at the end: overall, our test result is "
"`FAILED`. We had one test pass and one test fail."
msgstr "Secara keseluruhan, hasil tes kami gagal dan satu tes gagal."

#: src/ch10-01-how-to-write-tests.md:132
msgid ""
"Now that you’ve seen what the test results look like in different scenarios,"
" let’s look at some functions that are useful in tests."
msgstr ""
"Sekarang Anda telah melihat apa hasil tes terlihat dalam skenario yang "
"berbeda, mari kita lihat beberapa fungsi yang berguna dalam tes."

#: src/ch10-01-how-to-write-tests.md:134
msgid "Checking Results with the `assert!` Macro"
msgstr "Memeriksa Hasil dengan Macro"

#: src/ch10-01-how-to-write-tests.md:136
msgid ""
"The `assert!` macro, provided by Cairo, is useful when you want to ensure "
"that some condition in a test evaluates to `true`. We give the `assert!` "
"macro the first argument that evaluates to a boolean. If the value is "
"`true`, nothing happens and the test passes. If the value is `false`, the "
"`assert!` macro calls `panic()` to cause the test to fail with a message we "
"defined as the second argument. Using the `assert!` macro helps us check "
"that our code is functioning in the way we intended."
msgstr ""
"Makro pertama yang dievaluasi ke boolean. jika nilainya benar-benar tidak "
"ada yang terjadi dan tes tidak ada yang terjadi."

#: src/ch10-01-how-to-write-tests.md:138
msgid ""
"Remember in [Chapter 5](./ch05-03-method-syntax.md), we used a `Rectangle` "
"struct and a `can_hold` method, which are repeated here in Listing 10-3. "
"Let’s put this code in the _src/lib.cairo_ file, then write some tests for "
"it using the `assert!` macro."
msgstr ""
"Ingat di [Chapter 5] Helsing./ch05-03-method-syntax.md), kami menggunakan "
"▪Rectangle struct dan sebuah metode ▪can_holdå, yang diulangi di sini dalam "
"Listing 10-3."

#: src/ch10-01-how-to-write-tests.md:160
msgid ""
"<span class=\"caption\">Listing 10-3: Using the `Rectangle` struct and its "
"`can_hold` method from Chapter 5</span>"
msgstr ""
"<span class=\"caption\">Listing 10-3: Menggunakan ▪Rectangleå struct dan "
"metode åcan_hold predict 5</span>"

#: src/ch10-01-how-to-write-tests.md:162
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case "
"for the `assert!` macro. We can write a test that exercises the `can_hold` "
"method by creating a `Rectangle` instance that has a width of `8` and a "
"height of `7` and asserting that it can hold another `Rectangle` instance "
"that has a width of `5` and a height of `1`."
msgstr ""
"Metode tersebut dapat digunakan kembali, yang berarti ini merupakan contoh "
"penggunaan yang sempurna untuk makro. kita dapat menulis sebuah tes yang "
"melatih metode tersebut dengan menciptakan sebuah ·Rectengle yang memiliki "
"lebar 5 dan tinggi 0;1."

#: src/ch10-01-how-to-write-tests.md:191 src/ch10-01-how-to-write-tests.md:204
#: src/ch10-01-how-to-write-tests.md:251 src/ch10-01-how-to-write-tests.md:264
msgid "\"rectangle cannot hold\""
msgstr "\"Rektangle cannot hold\""

#: src/ch10-01-how-to-write-tests.md:210
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the `assert!` macro and "
"passed it the result of calling `larger.can_hold(@smaller)`. This expression"
" is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr "Kami telah menamai tes kami dengan nama yang kami butuhkan."

#: src/ch10-01-how-to-write-tests.md:220
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr ""
"Ini tidak lulus! kali ini menyatakan bahwa persegi panjang yang lebih kecil "
"tidak dapat menahan persegi panjang yang lebih besar:"

#: src/ch10-01-how-to-write-tests.md:270
msgid ""
"<span class=\"caption\">Listing 10-4: Adding another test in _lib.cairo_ "
"that will pass</span>"
msgstr ""
"<span class=\"caption\">Listing 10-4: Menambahkan tes lain dalam _lib.cairo_"
" yang akan melewati</span>"

#: src/ch10-01-how-to-write-tests.md:272
msgid ""
"Because the correct result of the `can_hold` method, in this case, is "
"`false`, we need to negate that result before we pass it to the `assert!` "
"macro. As a result, our test will pass if `can_hold` returns `false`:"
msgstr ""
"Karena hasil yang benar dari metode tersebut, dalam hal ini, adalah false, "
"kita perlu meniadakan hasilnya sebelum kita lulus ke makro."

#: src/ch10-01-how-to-write-tests.md:288
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the `>` sign with a `<` sign when it compares"
" the widths:"
msgstr ""
"Dua tes yang lulus! Sekarang mari kita lihat apa yang terjadi pada hasil tes"
" kita ketika kita memperkenalkan bug dalam kode kita."

#: src/ch10-01-how-to-write-tests.md:298
msgid "Running the tests now produces the following:"
msgstr "Menjalankan tes sekarang menghasilkan hal berikut:"

#: src/ch10-01-how-to-write-tests.md:300
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 2 tests\n"
"test adder::tests::larger_can_hold_smaller ... fail (gas usage est.: 57610)\n"
"test adder::tests::smaller_cannot_hold_larger ... ok (gas usage est.: 55140)\n"
"failures:\n"
"   adder::larger_can_hold_smaller - Panicked with \"rectangle cannot hold\".\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"Uji adder:: test adder:::: bigster_can_hold_smaller... gagal penggunaan: "
"larger_smaller: bigger_s_hold_shold_shold_shold_maller -panked dengan "
"\"rectangle::: Error: test hasil: FAILED. 1; 1; 0; diabaikan"

#: src/ch10-01-how-to-write-tests.md:312
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false` (`8` "
"is not less than `5`) in the `larger_can_hold_smaller` test. Notice that the"
" `smaller_cannot_hold_larger` test still passes: to make this test fail, the"
" height comparison should also be modified in `can_hold` method, replacing "
"the `>` sign with a `<` sign."
msgstr ""
"Tes kami menangkap bug! Karena lebih besar lagi.width adalah kurang dari 8 "
"dan tidak lebih kecil dari 5 di dalam tes phaser_canhold_smaller. perhatikan"
" bahwa tes Ásmaller_not_hold_faller masih dapat melewati: untuk membuat tes "
"ini gagal, perbandingan tinggi harus dimodifikasi dalam metode \\01}"

#: src/ch10-01-how-to-write-tests.md:316
msgid "Testing Equality and Comparisons with the `assert_xx!` Macros"
msgstr "Menguji Kesetaraan dan Perbandingan dengan Macros"

#: src/ch10-01-how-to-write-tests.md:318
msgid "`assert_eq!` and `assert_ne!` Macros"
msgstr "Macros"

#: src/ch10-01-how-to-write-tests.md:320
msgid ""
"A common way to verify functionality is to test for equality between the "
"result of the code under test and the value you expect the code to return. "
"You could do this using the `assert!` macro and passing it an expression "
"using the `==` operator. However, this is such a common test that the "
"standard library provides a pair of macros — `assert_eq!` and `assert_ne!` —"
" to perform this test more conveniently. These macros compare two arguments "
"for equality or inequality, respectively. They’ll also print the two values "
"if the assertion fails, which makes it easier to see _why_ the test failed; "
"conversely, the `assert!` macro only indicates that it got a `false` value "
"for the `==` expression, without printing the values that led to the `false`"
" value."
msgstr ""
"Sebuah cara umum untuk menguji fungsinya adalah dengan menguji kesetaraan "
"antara hasil kode yang ada di bawah uji dan nilai yang Anda harapkan kode "
"tersebut. Anda dapat melakukan ini dengan menggunakan makro dan melewatinya "
"dengan ekspresi yang menggunakan operator. Namun, ini adalah tes yang umum "
"bahwa perpustakaan standar menyediakan sepasang macros {asert_eq! dan "
"Áassert_ne! untuk melakukan tes ini dengan lebih mudah."

#: src/ch10-01-how-to-write-tests.md:331
msgid ""
"In Listing 10-5, we write a function named `add_two` that adds `2` to its "
"parameter, then we test this function using `assert_eq!` and `assert_ne!` "
"macros."
msgstr ""
"Di Listing 10-5, kami menulis sebuah fungsi bernama ·add_woad_wor yang "
"menambah parameternya, lalu kami menguji fungsi ini menggunakan macros!"

#: src/ch10-01-how-to-write-tests.md:357
msgid ""
"<span class=\"caption\">Listing 10-5: Testing the function `add_two` using "
"`assert_eq!` and `assert_ne!` macros</span>"
msgstr ""
"<span class=\"caption\">Listing 10-5: Menguji fungsi <add_dua; menggunakan "
"·assert_eq!"

#: src/ch10-01-how-to-write-tests.md:359
msgid "Let’s check that it passes!"
msgstr "Mari kita periksa lewat!"

#: src/ch10-01-how-to-write-tests.md:370
msgid ""
"In the `it_adds_two` test, we pass `4` as argument to `assert_eq!` macro, "
"which is equal to the result of calling `add_two(2)`. The line for this test"
" is `test adder::tests::it_adds_two ... ok`, and the `ok` text indicates "
"that our test passed."
msgstr ""
"Dalam tes ini, kami melewati 4% sebagai argumen untuk ·assert_eq! makro, "
"yang sama dengan panggilan ·ok_add_dua). Barisan untuk tes ini adalah "
"adderest::::::it_adds_t_two... ok, dan teks oroglic menunjukkan bahwa tes "
"kami lulus."

#: src/ch10-01-how-to-write-tests.md:373
msgid ""
"In the `wrong_check` test, we pass `0` as argument to `assert_ne!` macro, "
"which is not equal to the result of calling `add_two(2)`. Tests that use the"
" `assert_ne!` macro will pass if the two values we give it are _not_ equal "
"and fail if they’re equal. This macro is most useful for cases when we’re "
"not sure what a value _will_ be, but we know what the value definitely "
"_shouldn’t_ be. For example, if we’re testing a function that is guaranteed "
"to change its input in some way, but how the input is changed depends on the"
" day of the week that we run our tests, the best thing to assert might be "
"that the output of the function is not equal to the input."
msgstr ""
"Dalam tes salah_check, kami lulus sebagai argumen untuk ·assert_ne! makro, "
"yang tidak sama dengan hasil dari memanggil ·add_t2). Ujilah yang "
"menggunakan nilai _will_ne! macro akan lulus jika dua nilai yang kami "
"berikan adalah _not_ equal dan gagal jika mereka sama. makro ini paling "
"berguna untuk kasus ketika kita tidak yakin apa nilai _will_ne_, tapi kita "
"tahu apa nilai yang pasti _posten_t_t. Sebagai contoh, jika kita memberikan "
"fungsi yang dijamin perubahan dalam beberapa masukan, bagaimana cara ini "
"tergantung pada minggu kita untuk menjalankan hal yang sama dengan fungsi "
"terbaik."

#: src/ch10-01-how-to-write-tests.md:382
msgid ""
"Let’s introduce a bug into our code to see what `assert_eq!` looks like when"
" it fails. Change the implementation of the `add_two` function to instead "
"add `3`:"
msgstr ""
"Mari kita perkenalkan bug ke dalam kode kita untuk melihat apa yang terjadi "
"ketika gagal."

#: src/ch10-01-how-to-write-tests.md:391
msgid "Run the tests again:"
msgstr "Jalankan tes lagi:"

#: src/ch10-01-how-to-write-tests.md:393
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 2 tests\n"
"test adder::tests::wrong_check ... ok (gas usage est.: 132000)\n"
"test adder::tests::it_adds_two ... fail (gas usage est.: 166800)\n"
"failures:\n"
"   adder::tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` failed.\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"·shell $ scarb cairo-test test adder... menjalankan 2 test adder::: test::: "
"salah_check... ok (gunakan gas est.: 132000) uji adder::::::it_adds_t_dua..."
" gagal (gas penggunaan est.: 1668) gagal: adests:::::::: it_ds_t_t_two - "
"exactioned dengan \"astion ·2) gagal."

#: src/ch10-01-how-to-write-tests.md:407
msgid ""
"Our test caught the bug! The `it_adds_two` test failed with the following "
"message: ``Panicked with \"assertion `4 == add_two(2)` failed``. It tells us"
" that the assertion that failed was `` \"assertion `left == right` failed`` "
"and the `left` and `right` values are printed on the next lines as `left: "
"left_value` and `right: right_value`. This helps us start debugging: the "
"`left` argument was `4` but the `right` argument, where we had `add_two(2)`,"
" was `5`. You can imagine that this would be especially helpful when we have"
" a lot of tests going on."
msgstr ""
"Uji coba kami menangkap bug! Tes ini gagal dengan pesan berikut: \"Panicked "
"dengan \"assertion ·4 == add_t_woe2). Ini memberitahu kita bahwa pernyataan "
"yang gagal adalah \"assertion ıleft (kiri) == kanan dan kanan kiri dan "
"kanan, di mana kita telah mencetak dua baris berikutnya: kiri dan kanan; "
"kanan; ini membantu kita memulai pengawaungan: argumen yang tersisa adalah "
"benar-benar dapat kita bayangkan ketika kita akan memiliki banyak hasil yang"
" baik."

#: src/ch10-01-how-to-write-tests.md:415
msgid ""
"Note that in some languages and test frameworks, the parameters for equality"
" assertion functions are called `expected` and `actual`, and the order in "
"which we specify the arguments matters. However, in Cairo, they’re called "
"`left` and `right`, and the order in which we specify the value we expect "
"and the value the code produces doesn’t matter. We could write the assertion"
" in this test as `assert_eq!(add_two(2), 4)`, which would result in the same"
" failure message that displays `` assertion failed: `(left == right)` ``."
msgstr ""
"Perhatikan bahwa dalam beberapa bahasa dan kerangka kerja tes, parameter "
"untuk penilaian kesetaraan disebut sebagai fungsi yang kita harapkan, dan "
"urutan di mana kita menyatakan nilai yang kita harapkan dan nilai yang "
"dihasilkan kode tidak penting."

#: src/ch10-01-how-to-write-tests.md:423
msgid ""
"Here is a simple example comparing two structs, showing how to use "
"`assert_eq!` and `assert_ne!` macros:"
msgstr ""
"Berikut ini adalah contoh sederhana membandingkan dua struktur, menunjukkan "
"bagaimana menggunakan macro:"

#: src/ch10-01-how-to-write-tests.md:440
msgid "\"{:?},{:?} should be equal\""
msgstr "\"{:?,\"{:?} seharusnya sama\""

#: src/ch10-01-how-to-write-tests.md:442
msgid "\"{:?},{:?} should not be equal\""
msgstr "\"{:?},{:?} tidak boleh sama\""

#: src/ch10-01-how-to-write-tests.md:446
msgid ""
"Under the surface, `assert_eq!` and `assert_ne!` macros use the operators "
"`==` and `!=`, respectively. They both take snapshots of values as "
"arguments. When the assertions fail, these macros print their arguments "
"using debug formatting (`{:?}` syntax), which means the values being "
"compared must implement `PartialEq` and `Debug` traits. All primitive types "
"and most of the core library types implement these traits. For structs and "
"enums that you define yourself, you’ll need to implement `PartialEq` to "
"assert equality of those types. You’ll also need to implement `Debug` to "
"print the values when the assertion fails. Because both traits are "
"derivable, this is usually as straightforward as adding the `#[derive(Drop, "
"Debug, PartialEq)]` annotation to your struct or enum definition. See "
"[Appendix C](./appendix-03-derivable-traits.md) for more details about these"
" and other derivable traits."
msgstr ""
"Di bawah permukaan, misasert_eq! dan macros menampilkan argumen mereka "
"dengan formattasi debug ({:}, yang berarti nilai-nilai yang sedang "
"dibandingkan harus mengimplementasikan ÁPartialEq dan <debug sifat-sifat "
"dasar dan sebagian besar tipe perpustakaan dasar yang mengimplementasikan "
"sifat-sifat ini. Untuk struktur dan enums bahwa anda perlu untuk "
"mengimplementasikan nilai-nilai tersebut. Anda juga perlu untuk "
"mengimplementasikan nilai-nilai tersebut."

#: src/ch10-01-how-to-write-tests.md:457
msgid "`assert_lt!`, `assert_le!`, `assert_gt!` and `assert_ge!` Macros"
msgstr "Asosert_lt!, sassert_le!, sacsert_gt! dan scarsert_ge!"

#: src/ch10-01-how-to-write-tests.md:459
msgid "Comparisons in tests can be done using the `assert_xx!` macros:"
msgstr ""
"Pembandingan dalam tes dapat dilakukan dengan menggunakan makro ·assert_xx!"

#: src/ch10-01-how-to-write-tests.md:461
msgid ""
"`assert_lt!` checks if a given value is lower than another value, and "
"reverts otherwise."
msgstr ""
"Periksa apakah nilai yang diberikan lebih rendah dari nilai lain, dan "
"kembali sebaliknya."

#: src/ch10-01-how-to-write-tests.md:462
msgid ""
"`assert_le!` checks if a given value is lower or equal than another value, "
"and reverts otherwise."
msgstr ""
"Periksa apakah nilai yang diberikan lebih rendah atau sama dengan nilai "
"lain, dan kembali sebaliknya."

#: src/ch10-01-how-to-write-tests.md:463
msgid ""
"`assert_gt!` checks if a given value is greater than another value, and "
"reverts otherwise."
msgstr ""
"pemeriksaan jika nilai yang diberikan lebih besar dari nilai lain, dan "
"kembali sebaliknya."

#: src/ch10-01-how-to-write-tests.md:464
msgid ""
"`assert_ge!` checks if a given value is greater or equal than another value,"
" and reverts otherwise."
msgstr ""
"Periksa apakah nilai yang diberikan lebih besar atau sama dengan nilai lain,"
" dan kembali sebaliknya."

#: src/ch10-01-how-to-write-tests.md:466
msgid "Listing 10-6 demonstrates how to use these macros:"
msgstr "Daftar 10-6 menunjukkan bagaimana menggunakan macro ini:"

#: src/ch10-01-how-to-write-tests.md:504
msgid "\"{:?},{:?} should be lower or equal\""
msgstr "\"{:?},{:?} seharusnya lebih rendah atau sama\""

#: src/ch10-01-how-to-write-tests.md:509
msgid ""
"<span class=\"caption\">Listing 10-6: Example of tests that use the "
"`assert_xx!` macros for comparisons</span>"
msgstr ""
"<span class=\"caption\">Listing 10-6: Contoh dari tes yang menggunakan "
"<assert_xx! macros untuk perbandingan</span>"

#: src/ch10-01-how-to-write-tests.md:511
msgid ""
"In this example, we roll a `Dice` struct multiple times and compare the "
"results. We need to manually implement the `PartialOrd` trait for our struct"
" so that we can compare `Dice` instances with `lt`, `le`, `gt` and `ge` "
"functions, which are used by `assert_lt!`, `assert_le!`, `assert_gt!` and "
"`assert_ge!` macros, respectively. We also need to derive the `Copy` trait "
"on our `Dice` struct to use the instantiated structs multiple times, as the "
"comparison functions take ownership of the variables."
msgstr ""
"Dalam contoh ini, kita dapat membanding-bandingkannya berulang kali dan "
"membandingkan hasilnya. kita perlu mengimplementasikannya secara manual, "
"yang digunakan secara manual oleh ·aster_lt!, scuasert_le!, assert_gt! dan "
"assert_ge! kita juga perlu mendapatkan fungsi-fungsi yang kita butuhkan "
"untuk mengoplabeli dalam kondisi yang lebih cepat, untuk menggunakan fungsi "
"pengumpamaan yang berbeda, sebagai variabel pembanding."

#: src/ch10-01-how-to-write-tests.md:513
msgid "Adding Custom Failure Messages"
msgstr "Menambahkan Pesan Kegagalan Kustom"

#: src/ch10-01-how-to-write-tests.md:515
msgid ""
"You can also add a custom message to be printed with the failure message as "
"optional arguments to `assert!`, `assert_eq!`, and `assert_ne!` macros. Any "
"arguments specified after the required arguments are passed along to the "
"`format!` macro (discussed in the "
"[Printing](./ch11-08-printing.md#formatting) chapter), so you can pass a "
"format string that contains `{}` placeholders and values to go in those "
"placeholders. Custom messages are useful for documenting what an assertion "
"means; when a test fails, you’ll have a better idea of what the problem is "
"with the code."
msgstr ""
"Anda juga dapat menambahkan pesan kustom untuk dicetak dengan pesan "
"kegagalan sebagai argumen opsional untuk ·assert!, ·assert_eq!, dan macros. "
"Argumen apa pun yang ditentukan setelah argumen yang diperlukan diteruskan "
"ke ▪format! makro (mengalami di [Prinsi]dian] Valentina. "
"/ch11-08-printing.mdformatting), sehingga Anda dapat melewatkan format "
"string yang berisi pemegang dan nilai-nilai yang ada di tempat tersebut."

#: src/ch10-01-how-to-write-tests.md:523
msgid ""
"Let’s add a custom failure message composed of a format string with a "
"placeholder filled in with the actual value we got from the `add_two` "
"function:"
msgstr ""
"Mari kita tambahkan pesan kegagalan gubahan yang terdiri dari sebuah string "
"format dengan pemegang tempat yang diisi dengan nilai sebenarnya yang kita "
"dapatkan dari fungsi ·add_two:"

#: src/ch10-01-how-to-write-tests.md:530
msgid "\"Expected {}, got add_two(2)={}\""
msgstr "\"Diduga {}, diperoleh add_two Nabina2)={}\""

#: src/ch10-01-how-to-write-tests.md:534
msgid "Now when we run the test, we’ll get a more informative error message:"
msgstr ""
"Sekarang ketika kita menjalankan tes, kita akan mendapatkan pesan kesalahan "
"yang lebih informatif:"

#: src/ch10-01-how-to-write-tests.md:536
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 1 test\n"
"test adder::tests::it_adds_two ... fail (gas usage est.: 590230)\n"
"failures:\n"
"   adder::tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` failed: Expected 4, got add_two(2)=5\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"·shell $ scarbs cairo-test test adder... berjalan 1 test "
"adder::::it_adds_t_wo... gagal (gas penggunaan est.: 590230) kegagalan: "
"adder::::test::: it_adds_t_dua -paniked dengan \"assertion {2) == "
"added_t_t2): Diduga 4, gott_two_2)=5. Error: hasil test: FAIED. 0; 0; 0; "
"diabaikan 0; 0;"

#: src/ch10-01-how-to-write-tests.md:549
msgid ""
"We can see the value we actually got in the test output, which would help us"
" debug what happened instead of what we were expecting to happen."
msgstr ""
"Kita dapat melihat nilai yang sebenarnya kita dapatkan di output tes, yang "
"akan membantu kita men-debug apa yang terjadi bukan apa yang kita harapkan "
"akan terjadi."

#: src/ch10-01-how-to-write-tests.md:554
msgid "Checking for panics with `should_panic`"
msgstr "Memeriksa kepanikan dengan seharusnya_panik"

#: src/ch10-01-how-to-write-tests.md:556
msgid ""
"In addition to checking return values, it’s important to check that our code"
" handles error conditions as we expect. For example, consider the `Guess` "
"type in Listing 10-7:"
msgstr ""
"Selain memeriksa nilai kembali, penting untuk memeriksa kode kami menangani "
"kondisi kesalahan seperti yang kita harapkan."

#: src/ch10-01-how-to-write-tests.md:573 src/ch10-01-how-to-write-tests.md:625
msgid "\"Guess must be >= 1 and <= 100\""
msgstr "\"Tebak harus >= 1 dan <= 100\""

#: src/ch10-01-how-to-write-tests.md:581
msgid ""
"<span class=\"caption\">Listing 10-7: `Guess` struct and its `new` "
"method</span>"
msgstr ""
"<span class=\"caption\">Listing 10-7: \"Guess,\" struct dan metode baru "
"</span>"

#: src/ch10-01-how-to-write-tests.md:583
msgid ""
"Other code that uses `Guess` depends on the guarantee that `Guess` instances"
" will contain only values between `1` and `100`. We can write a test that "
"ensures that attempting to create a `Guess` instance with a value outside "
"that range panics."
msgstr ""
"Kita dapat menulis tes yang menjamin bahwa upaya untuk membuat sebuah kasus "
"hanya akan mengandung nilai-nilai antara 100 dan 100 orang."

#: src/ch10-01-how-to-write-tests.md:585
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr ""
"Kami melakukan ini dengan menambahkan atribut yang seharusnya_panik untuk "
"fungsi tes kami. tes ini akan lulus jika kode dalam panik fungsi; tes gagal "
"jika kode di dalam fungsi tidak panik."

#: src/ch10-01-how-to-write-tests.md:600
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result to see that"
" this test passes:"
msgstr ""
"Kami menempatkan atribut ı should_panic] setelah atribut (stest) dan sebelum"
" fungsi tes itu berlaku untuk. Mari kita lihat hasilnya untuk melihat apakah"
" tes ini lulus:"

#: src/ch10-01-how-to-write-tests.md:610
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the `new` function will panic if the value is greater than `100`:"
msgstr ""
"Sekarang mari kita perkenalkan bug dalam kode kita dengan menghapus kondisi "
"bahwa fungsi baru akan panik jika nilainya lebih besar dari 100 °:"

#: src/ch10-01-how-to-write-tests.md:635
msgid "When we run the test, it will fail:"
msgstr "Ketika kita menjalankan tes, itu akan gagal."

#: src/ch10-01-how-to-write-tests.md:648
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]` attribute. "
"The failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""
"Kita tidak mendapatkan pesan yang sangat berguna dalam kasus ini, tetapi "
"ketika kita melihat fungsi tes, kita melihat bahwa hal itu menunjukkan "
"dengan atribut [seharusnya_panik]. Kegagalan yang kita dapatkan berarti "
"bahwa kode dalam fungsi tes tidak menyebabkan kepanikan."

#: src/ch10-01-how-to-write-tests.md:650
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional"
" `expected` parameter to the `#[should_panic]` attribute. The test harness "
"will make sure that the failure message contains the provided text. For "
"example, consider the modified code for `GuessImpl` in Listing 10-8 where "
"the `new` function panics with different messages depending on whether the "
"value is too small or too large:"
msgstr ""
"Uji coba yang menggunakan seharusnya_panik dapat kurang tepat. Sebuah uji "
"coba yang seharusnya dapat melewati bahkan jika panik tes untuk alasan yang "
"berbeda dari yang kita harapkan. Untuk membuat tes yang seharusnya lebih "
"tepat, kita dapat menambahkan sebuah parameter opsional yang dieksplorasikan"
" ke atribut optional ke \\# [seharusnya_panic]. Harnes tes akan memastikan "
"bahwa kegagalan berisi teks yang disediakan. Sebagai contoh, pertimbangkan "
"kode yang dimodifikasi untuk guesslpl dalam Daftar 10-8 fungsi baru dengan "
"pesan yang berbeda apakah terlalu besar atau terlalu besar:"

#: src/ch10-01-how-to-write-tests.md:667 src/ch10-01-how-to-write-tests.md:702
msgid "\"Guess must be >= 1\""
msgstr "\"Tebak harus >= 1\""

#: src/ch10-01-how-to-write-tests.md:669 src/ch10-01-how-to-write-tests.md:681
#: src/ch10-01-how-to-write-tests.md:700 src/ch10-01-how-to-write-tests.md:714
msgid "\"Guess must be <= 100\""
msgstr "\"Tebak harus <= 100\""

#: src/ch10-01-how-to-write-tests.md:690
msgid ""
"<span class=\"caption\">Listing 10-8: `new` implementation that panics with "
"different error messages</span>"
msgstr ""
"<span class=\"caption\">Listing 10-8: implementasi baru yang panik dengan "
"pesan kesalahan yang berbeda</span>"

#: src/ch10-01-how-to-write-tests.md:692
msgid ""
"The test will pass because the value we put in the `should_panic` "
"attribute’s `expected` parameter is the string that the `Guess::new` method "
"panics with. We need to specify the entire panic message that we expect."
msgstr ""
"Tes ini akan lulus karena nilai yang kami masukkan ke dalam atribut "
"oposid_panic ·exspected parameter adalah string yang kita harapkan::: metode"
" baru panik dengan."

#: src/ch10-01-how-to-write-tests.md:694
msgid ""
"To see what happens when a `should_panic` test with an expected message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the `if value < 1` and the `else if value > 100` blocks:"
msgstr ""
"Untuk melihat apa yang terjadi ketika sebuah tes seharusnya_panik dengan "
"pesan yang diharapkan gagal, biarkan lagi memperkenalkan bug ke dalam kode "
"kami dengan menukar tubuh dari nilai < 1) dan nilai > 100 blok:"

#: src/ch10-01-how-to-write-tests.md:721
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr ""
"Kali ini ketika kita menjalankan tes seharusnya_panik, itu akan gagal:"

#: src/ch10-01-how-to-write-tests.md:723
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing guess ...\n"
"running 1 test\n"
"test guess::tests::greater_than_100 ... fail (gas usage est.: 26690)\n"
"failures:\n"
"   guess::tests::greater_than_100 - Panicked with \"Guess must be >= 1\".\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"▪shell $ scarb cairo-test tes menebak... berjalan 1 tes menebak:::: "
"greater_than_100... gagal (gunakan gas est.: 26690) kegagalan: dugaan:::::: "
"besar_than_100 -panik dengan \"Guess harus >= 1\". Error: hasil tes: gagal; "
"0; 0 diabaikan; 0 diabaikan"

#: src/ch10-01-how-to-write-tests.md:733
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string. The "
"panic message that we did get in this case was `Guess must be >= 1`. Now we "
"can start figuring out where our bug is!"
msgstr ""
"Pesan kegagalan menunjukkan bahwa tes ini memang panik seperti yang kita "
"harapkan, tetapi pesan panik tidak termasuk string yang diharapkan. Pesan "
"panik yang kita dapatkan dalam kasus ini adalah ▪Guess harus >= 1ltu "
"sekarang kita bisa mulai mencari tahu di mana bug kita berada!"

#: src/ch10-01-how-to-write-tests.md:735
msgid "Running Single Tests"
msgstr "Menjalankan Tes Tunggal"

#: src/ch10-01-how-to-write-tests.md:737
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working"
" on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing `scarb"
" cairo-test` an option `-f` (for \"filter\"), followed by the name of the "
"test you want to run as an argument."
msgstr ""
"Kadang-kadang, menjalankan tes suite secara penuh dapat memakan waktu lama. "
"jika anda mengerjakan kode dalam area tertentu, anda mungkin hanya ingin "
"menjalankan tes yang berkaitan dengan kode tersebut. anda dapat memilih tes "
"mana yang dapat dijalankan dengan melewati ▪scarb cairo-test. sebuah pilihan"
" ▪-f ▪ (untuk \"filter\"), diikuti dengan nama tes yang ingin anda jalankan "
"sebagai argumen."

#: src/ch10-01-how-to-write-tests.md:739
msgid ""
"To demonstrate how to run a single test, we’ll first create two test "
"functions, as shown in Listing 10-9, and choose which ones to run."
msgstr ""
"Untuk menunjukkan bagaimana menjalankan tes tunggal, kita pertama akan "
"membuat dua fungsi tes, seperti yang ditunjukkan dalam daftar 10-9, dan "
"memilih yang mana untuk dijalankan."

#: src/ch10-01-how-to-write-tests.md:755
msgid "\"result is not 5\""
msgstr "\"Hasil bukan 5\""

#: src/ch10-01-how-to-write-tests.md:760
msgid ""
"<span class=\"caption\">Listing 10-9: Two tests with two different "
"names</span>"
msgstr ""
"<span class=\"caption\">Listing 10-9: Dua tes dengan dua nama yang "
"berbeda</span>"

#: src/ch10-01-how-to-write-tests.md:762
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that "
"test using the `-f` flag:"
msgstr ""
"Kita dapat melewati nama dari fungsi tes apapun untuk tes-timur untuk "
"menjalankan tes hanya dengan menggunakan bendera."

#: src/ch10-01-how-to-write-tests.md:772
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t "
"match that name. The test output lets us know we had one more test that "
"didn’t run by displaying `1 filtered out;` at the end."
msgstr ""
"Hanya tes dengan nama ·add_t_and_wo ran; tes lainnya tidak cocok dengan nama"
" itu. Hasil tes memungkinkan kita tahu bahwa kita memiliki satu tes lagi "
"yang tidak berjalan dengan menampilkan ▪1 disaring; pada akhirnya."

#: src/ch10-01-how-to-write-tests.md:774
msgid ""
"We can also specify part of a test name, and any test whose name contains "
"that value will be run."
msgstr ""
"Kita juga dapat menentukan bagian dari nama tes, dan setiap tes yang namanya"
" berisi nilai tersebut akan dijalankan."

#: src/ch10-01-how-to-write-tests.md:776
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr "Mengabaikan Beberapa Ujian Kecuali secara Khusus Diminta"

#: src/ch10-01-how-to-write-tests.md:778
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you"
" might want to exclude them during most runs of `scarb cairo-test`. Rather "
"than listing as arguments all tests you do want to run, you can instead "
"annotate the time-consuming tests using the `#[ignore]` attribute to exclude"
" them, as shown here:"
msgstr ""
"Kadang-kadang beberapa tes spesifik dapat sangat memakan waktu untuk "
"dijalankan, sehingga Anda mungkin ingin mengecualikan mereka selama sebagian"
" besar berjalan dari cairo-test. Daripada daftar sebagai argumen semua tes "
"yang Anda lakukan ingin jalankan, Anda dapat menganotasi tes yang memakan "
"waktu menggunakan atribut cairo, sebagaimana ditunjukkan di sini:"

#: src/ch10-01-how-to-write-tests.md:791
msgid "// code that takes an hour to run\n"
msgstr "#/ code that takes an hour to run\n"

#: src/ch10-01-how-to-write-tests.md:796
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""
"Setelah kami melakukan tes, kami menambahkan baris untuk tes yang ingin kami"
" abaikan."

#: src/ch10-01-how-to-write-tests.md:807
msgid "The `expensive_test` function is listed as ignored."
msgstr ""
"Fungsi yang paling bergantung pada fungsi terdaftar sebagai diabaikan."

#: src/ch10-01-how-to-write-tests.md:809
msgid ""
"When you’re at a point where it makes sense to check the results of the "
"ignored tests and you have time to wait for the results, you can run `scarb "
"cairo-test --include-ignored` to run all tests, whether they’re ignored or "
"not."
msgstr ""
"Ketika Anda berada pada titik di mana masuk akal untuk memeriksa hasil tes "
"yang diabaikan dan Anda punya waktu untuk menunggu hasilnya, Anda dapat "
"menjalankan cairo-test --include-ignored, apakah mereka diabaikan atau "
"tidak."

#: src/ch10-01-how-to-write-tests.md:811
msgid "Testing Recursive Functions or Loops"
msgstr "Menguji Fungsi atau Loop Rekursif"

#: src/ch10-01-how-to-write-tests.md:813
msgid ""
"When testing recursive functions or loops, the test is instantiated by "
"default with a maximum amount of gas that it can consume. This prevents "
"running infinite loops or consuming too much gas, and can help you benchmark"
" the efficiency of your implementations. This value is assumed reasonably "
"large enough, but you can override it by adding the "
"`#[available_gas(<Number>)]` attribute to the test function. The following "
"example shows how to use it:"
msgstr ""
"Ketika pengujian fungsi rekursif atau loops, tes ini instansiated secara "
"baku dengan jumlah maksimum gas yang dapat dikonsumsi. Hal ini mencegah "
"berjalan loop tak terbatas atau mengkonsumsi terlalu banyak gas, dan dapat "
"membantu Anda memposisikan efisiensi implementasi Anda. Nilai ini "
"diasumsikan cukup besar, tetapi Anda dapat menimpanya dengan menambahkannya "
"\"#[available_gas<Number>)] atribut untuk tes fungsi. Contoh berikut "
"menunjukkan bagaimana menggunakannya:"

#: src/ch10-01-how-to-write-tests.md:834
msgid "\"result is not 55\""
msgstr "\"Hasil bukan 55\""

#: src/ch10-01-how-to-write-tests.md:839
msgid "Benchmarking the Gas Usage of a Specific Operation"
msgstr "Benchmarking the Gas Usage of a Spesifik Operation"

#: src/ch10-01-how-to-write-tests.md:841
msgid ""
"When you want to benchmark the gas usage of a specific operation, you can "
"use the following pattern in your test function."
msgstr ""
"Bila Anda ingin menandai penggunaan gas dari suatu operasi spesifik, Anda "
"dapat menggunakan pola berikut dalam fungsi tes Anda."

#: src/ch10-01-how-to-write-tests.md:846 src/ch10-01-how-to-write-tests.md:873
msgid "/// code we want to bench.\n"
msgstr "/ /Kode kami ingin bangku.\n"

#: src/ch10-01-how-to-write-tests.md:847
msgid "\"{}\\n\""
msgstr "\"{}\\n\""

#: src/ch10-01-how-to-write-tests.md:850
msgid ""
"The following example shows how to use it to test the gas function of the "
"`sum_n` function above."
msgstr ""
"Contoh berikut menunjukkan bagaimana menggunakannya untuk menguji fungsi gas"
" dari fungsi Ásum_n di atas."

#: src/ch10-01-how-to-write-tests.md:875
msgid "\"consumed gas: {}\\n\""
msgstr "\"gas yang dikonsumsi: [}\\n\""

#: src/ch10-01-how-to-write-tests.md:880
msgid ""
"The value printed when running `scarb cairo-test` is the amount of gas that "
"was consumed by the benchmarked operation."
msgstr ""
"Nilai yang dicetak ketika menjalankan cairo-test adalah jumlah gas yang "
"dikonsumsi oleh operasi benchmarked."

#: src/ch10-01-how-to-write-tests.md:892
msgid ""
"Here, the gas usage of the `sum_n` function is `80690` (decimal "
"representation of the hex number). The total amount consumed by the test is "
"slightly higher at `140100`, due to some extra steps required to run the "
"entire test function."
msgstr ""
"Di sini, penggunaan gas dari fungsi ısum_n adalah 80690 representasi dari "
"nomor hex (jumlah total yang dikonsumsi oleh tes sedikit lebih tinggi pada "
"140100, karena beberapa langkah ekstra yang diperlukan untuk menjalankan "
"seluruh fungsi tes."

#: src/ch10-01-how-to-write-tests.md:894
msgid "{{#quiz ../quizzes/ch10-01-how_to_write_tests.toml}}"
msgstr "{{#quiz../quizzes/ch10-01-how_to_write_test.toml}}}"

#: src/ch10-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and "
"integration tests. Unit tests are small and more focused, testing one module"
" in isolation at a time, and can test private functions. Integration tests "
"use your code in the same way any other external code would, using only the "
"public interface and potentially exercising multiple modules per test."
msgstr ""
"Kita akan berpikir tentang tes dalam dua kategori utama: tes unit dan tes "
"integrasi. Tes unit kecil dan lebih fokus, pengujian satu modul dalam "
"isolasi pada satu waktu, dan dapat menguji fungsi pribadi. Uji integrasi "
"menggunakan kode Anda dengan cara yang sama dengan kode eksternal lainnya "
"akan, hanya menggunakan antarmuka publik dan berpotensi berolahraga beberapa"
" modul per tes."

#: src/ch10-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr ""
"Menulis kedua jenis tes penting untuk memastikan bahwa potongan-potongan "
"dari perpustakaan Anda melakukan apa yang Anda harapkan, secara terpisah dan"
" bersama-sama."

#: src/ch10-02-test-organization.md:7
msgid "Unit Tests"
msgstr "Unit Test"

#: src/ch10-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the"
" rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the `src` directory in each file with the"
" code that they’re testing."
msgstr ""
"Tujuan tes unit adalah untuk menguji setiap unit kode dalam isolasi dari "
"sisa kode untuk dengan cepat menentukan di mana kode dan tidak bekerja "
"seperti yang diharapkan."

#: src/ch10-02-test-organization.md:11
msgid ""
"The convention is to create a module named `tests` in each file to contain "
"the test functions and to annotate the module with `#[cfg(test)]` attribute."
msgstr ""
"Konvensi ini untuk membuat sebuah modul bernama åtest dalam setiap berkas "
"untuk memuat fungsi tes dan untuk mengulangi modul dengan atribut "
"\"#[cfgresslertest]."

#: src/ch10-02-test-organization.md:13
msgid "The Tests Module and `#[cfg(test)]`"
msgstr "Modul Penguji dan C# [cfginskytest]]"

#: src/ch10-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and"
" run the test code only when you run `scarb cairo-test`, not when you run "
"`scarb cairo-run`. This saves compile time when you only want to build the "
"library and saves space in the resulting compiled artifact because the tests"
" are not included. You’ll see that because integration tests go in a "
"different directory, they don’t need the `#[cfg(test)]` annotation. However,"
" because unit tests go in the same files as the code, you’ll use "
"`#[cfg(test)]` to specify that they shouldn’t be included in the compiled "
"result."
msgstr ""
"Anotasi pada modul tes memberitahu Cairo untuk menyusun dan menjalankan kode"
" uji hanya ketika Anda menjalankan Cairo-test, bukan ketika Anda menjalankan"
" agnostik, bukan ketika Anda menjalankan sebuah direktori cairocarb-run. Hal"
" ini menghemat waktu ketika Anda hanya ingin membangun perpustakaan dan "
"menghemat ruang dalam artefak hasil yang dikompilasi karena tes tersebut "
"tidak termasuk. Anda akan melihat bahwa karena integrasi tes pergi dalam "
"direktori yang berbeda, mereka tidak perlu yang benar-benar dikompilasikan."

#: src/ch10-02-test-organization.md:17
msgid ""
"Recall that when we created the new _adder_ project in the first section of "
"this chapter, we wrote this first test:"
msgstr ""
"Ingat bahwa ketika kita menciptakan proyek baru _adder_ di bagian pertama "
"bab ini, kami menulis tes pertama ini:"

#: src/ch10-02-test-organization.md:30
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the "
"following item should only be included given a certain configuration option."
" In this case, the configuration option is `test`, which is provided by "
"Cairo for compiling and running tests. By using the `cfg` attribute, Cairo "
"compiles our test code only if we actively run the tests with `scarb cairo-"
"test`. This includes any helper functions that might be within this module, "
"in addition to the functions annotated with `#[test]`."
msgstr ""
"Atributnya adalah konfigurasi dan memberitahu Cairo bahwa item berikut hanya"
" harus dimasukkan ke dalam opsi konfigurasi tertentu. Dalam hal ini, pilihan"
" konfigurasi adalah Écarbiro-testà, yang disediakan oleh Cairo untuk "
"kompilasi dan menjalankan tes. Dengan menggunakan atribut thosefgotic, Cairo"
" mengkompilasi kode uji coba kita hanya jika kita secara aktif menjalankan "
"tes dengan Écarbiro-testà. Ini termasuk setiap fungsi pembantu yang mungkin "
"berada di dalam modul ini, dalam penambahan fungsi yang dianotasi dengan "
"\\[test]."

#: src/ch10-02-test-organization.md:32
msgid "Integration Tests"
msgstr "Tes Integrasi"

#: src/ch10-02-test-organization.md:34
msgid ""
"Integration tests use your library in the same way any other code would. "
"Their purpose is to test whether many parts of your library work together "
"correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is "
"important as well. To create integration tests, you first need a `tests` "
"directory."
msgstr ""
"Uji integrasi menggunakan perpustakaan Anda dengan cara yang sama dengan "
"kode lain. Tujuan mereka adalah untuk menguji apakah banyak bagian dari "
"perpustakaan Anda bekerja sama dengan benar. Satuan kode yang bekerja dengan"
" benar dapat memiliki masalah ketika terintegrasi, sehingga cakupan tes kode"
" terpadu juga penting. Untuk membuat tes integrasi, Anda terlebih dahulu "
"membutuhkan direktori Átestá."

#: src/ch10-02-test-organization.md:36
msgid "The _tests_ Directory"
msgstr "_Direktori Tes_t"

#: src/ch10-02-test-organization.md:48
msgid "First of all, add the following code in your _lib.cairo_ file:"
msgstr "Pertama-tama, tambahkan kode berikut dalam berkas _lib.cairo_ Anda:"

#: src/ch10-02-test-organization.md:50
msgid "<span class=\"caption\">Filename: src/lib.cairo</span>"
msgstr "<span class=\"caption\"> Filename: src/lib.cairo</span>"

#: src/ch10-02-test-organization.md:61
msgid ""
"Note that we still need to use the `#[cfg(test)]` attribute here, because we"
" are in the _lib.cairo_ file of the _src_ directory. Then, create a "
"_tests.cairo_ file and fill it as follows:"
msgstr ""
"Perhatikan bahwa kita masih perlu menggunakan direktori _src_. Kemudian, "
"buat _tests.cairo_ dan isi sebagai berikut:"

#: src/ch10-02-test-organization.md:64
msgid "<span class=\"caption\">Filename: src/tests.cairo</span>"
msgstr "<span class=\"caption\"> Filename: src/tess.cairo</span>"

#: src/ch10-02-test-organization.md:70
msgid ""
"Finally, enter this code into the _src/tests/integration_tests.cairo_ file:"
msgstr ""
"Terakhir, masukkan kode ini ke dalam berkas _src/tes/integrasi_test.cairo_:"

#: src/ch10-02-test-organization.md:72
msgid "<span class=\"caption\">Filename: src/tests/integration_tests.cairo</span>"
msgstr ""
"Kelas <span=\"caption\"> Nama berkas: src/tess/integrasi_test.cairo</span>"

#: src/ch10-02-test-organization.md:79
msgid "\"internal_adder failed\""
msgstr "\"internal_adder gagal\""

#: src/ch10-02-test-organization.md:83
msgid ""
"We need to bring our tested functions into each test file scope. For that "
"reason we add `use adder::it_adds_two` at the top of the code, which we "
"didn’t need in the unit tests."
msgstr ""
"Kita perlu membawa fungsi kami yang diuji ke dalam setiap lingkup berkas "
"tes. yang tidak kita butuhkan dalam tes unit."

#: src/ch10-02-test-organization.md:85
msgid ""
"Then, to run all of our integration tests, we can just add a filter to only "
"run tests whose path contains \"integration_tests\"."
msgstr ""
"Kemudian, untuk menjalankan semua tes integrasi kami, kami hanya dapat "
"menambahkan filter untuk hanya menjalankan tes yang jalurnya berisi "
"\"integrasi-tes\""

#: src/ch10-02-test-organization.md:100
msgid ""
"The result of the tests is the same as what we've been seeing: one line for "
"each test."
msgstr ""
"Hasil tesnya sama seperti yang kita lihat: satu baris untuk setiap tes."

#: src/ch10-02-test-organization.md:102
msgid "{{#quiz ../quizzes/ch10-02-testing-organization.toml}}"
msgstr "{{#quiz../quizzes/ch10-02-testing-organisasi.toml}}}"

#: src/ch11-00-advanced-features.md
msgid "Advanced Features"
msgstr "Fitur Lanjutan"

#: src/ch11-00-advanced-features.md
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr ""
"Sekarang, mari kita belajar tentang fitur yang lebih maju ditawarkan oleh "
"Cairo."

#: src/ch11-01-custom-data-structures.md:3
msgid ""
"When you first start programming in Cairo, you'll likely want to use arrays "
"(`Array<T>`) to store collections of data. However, you will quickly realize"
" that arrays have one big limitation - the data stored in them is immutable."
" Once you append a value to an array, you can't modify it."
msgstr ""
"Ketika Anda pertama kali memulai pemrograman di Cairo, Anda mungkin ingin "
"menggunakan array (Array<T>) untuk menyimpan koleksi data. Namun, Anda akan "
"segera menyadari bahwa array memiliki satu pembatasan besar - data yang "
"tersimpan di dalamnya dapat berubah. Setelah Anda menambahkan nilai ke "
"array, Anda tidak dapat memodifikasinya."

#: src/ch11-01-custom-data-structures.md:8
msgid ""
"This can be frustrating when you want to use a mutable data structure. For "
"example, say you're making a game where the players have a level, and they "
"can level up. You might try to store the level of the players in an array:"
msgstr ""
"Hal ini dapat membuat frustasi ketika Anda ingin menggunakan struktur data "
"yang dapat berubah-ubah. Sebagai contoh, katakanlah Anda membuat permainan "
"di mana para pemain memiliki tingkat, dan mereka dapat menaikkan level. Anda"
" mungkin mencoba untuk menyimpan tingkat pemain dalam sebuah array:"

#: src/ch11-01-custom-data-structures.md:16
msgid ""
"But then you realize you can't increase the level at a specific index once "
"it's set. If a player dies, you cannot remove it from the array unless he "
"happens to be in the first position."
msgstr ""
"Tapi kemudian Anda menyadari bahwa Anda tidak dapat meningkatkan tingkat "
"pada indeks tertentu setelah diatur. Jika seorang pemain meninggal, Anda "
"tidak dapat menghapusnya dari array kecuali dia kebetulan berada di posisi "
"pertama."

#: src/ch11-01-custom-data-structures.md:20
msgid ""
"Fortunately, Cairo provides a handy built-in [dictionary "
"type](./ch03-02-dictionaries.md) called `Felt252Dict<T>` that allows us to "
"simulate the behavior of mutable data structures. Let's first explore how to"
" create a struct that contains, among others, a `Felt252Dict<T>`."
msgstr ""
"Untungnya, Cairo menyediakan built-in yang berguna [tipe dialog][kiamat. "
"/ch03-02-dictionary.md) yang disebut <T 252 Dict> yang memungkinkan kita "
"untuk mensimulasikan perilaku struktur data yang dapat dimutasi. Mari kita "
"pertama-tama mencari cara membuat struktur yang berisi, antara lain, sebuah "
"{Felt252Dict<T>."

#: src/ch11-01-custom-data-structures.md:23
msgid ""
"Note: Several concepts used in this chapter were already presented earlier "
"in the book. We recommend checking out the following chapters if you need to"
" revise them: [Structs](ch05-00-using-structs-to-structure-related-data.md),"
" [Methods](./ch05-03-method-syntax.md), [Generic types](./ch08-00-generic-"
"types-and-traits.md), [Traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"Catatan: Beberapa konsep yang digunakan dalam bab ini telah disajikan "
"sebelumnya dalam buku. kami menyarankan bab-bab berikut jika Anda perlu "
"merevisinya: [Struktur05-00-structs-to-structural-data.md), [Meto-"
"traods]tunik./ch03-method-syntax.md], [Generic types/08-generic-types-and-"
"trats.ms.m],/Tra-tra-in-ird.2."

#: src/ch11-01-custom-data-structures.md:29
msgid "Dictionaries as Struct Members"
msgstr "Kamus sebagai Anggota Struktur"

#: src/ch11-01-custom-data-structures.md:31
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly "
"interacting with them may not be entirely seamless. Let's try implementing a"
" custom _user database_ that will allow us to add users and query them. We "
"will need to define a struct to represent the new type and a trait to define"
" its functionality:"
msgstr ""
"Menentukan dictionary sebagai anggota struktur mungkin di Cairo tetapi "
"benar-benar berinteraksi dengan mereka mungkin tidak sepenuhnya mulus. Mari "
"kita coba menerapkan basis data _user_ khusus yang akan memungkinkan kita "
"untuk menambahkan pengguna dan query mereka. Kita perlu mendefinisikan "
"sebuah struktur untuk mewakili tipe baru dan sebuah sifat untuk "
"mendefinisikan fungsinya:"

#: src/ch11-01-custom-data-structures.md:46
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic"
" over the balances of the users, giving major flexibility to whoever uses "
"our data type. Its two members are:"
msgstr ""
"Tipe baru kita, UserDatabase<T> mewakili basis data pengguna. Ini generik "
"atas keseimbangan pengguna, memberikan fleksibilitas utama kepada siapa pun "
"yang menggunakan tipe data kita."

#: src/ch11-01-custom-data-structures.md:48
msgid "`users_updates`, the number of users updates in the dictionary."
msgstr "Jumlah pengguna baru di kamus."

#: src/ch11-01-custom-data-structures.md:49
msgid "`balances`, a mapping of each user to its balance."
msgstr "Keseimbangan, pemetaan setiap pengguna terhadap keseimbangannya."

#: src/ch11-01-custom-data-structures.md:51
msgid ""
"The database core functionality is defined by `UserDatabaseTrait`. The "
"following methods are defined:"
msgstr ""
"Fungsi fungsi inti basis data didefinisikan oleh UserDatabaseTrait. Metode "
"berikut didefinisikan:"

#: src/ch11-01-custom-data-structures.md:53
msgid "`new` for easily creating new `UserDatabase` types."
msgstr "Untuk dengan mudah menciptakan jenis-jenis baru UserDatabase."

#: src/ch11-01-custom-data-structures.md:54
msgid "`update_user` to update the balance of users in the database."
msgstr "Untuk memperbarui keseimbangan pengguna dalam basis data."

#: src/ch11-01-custom-data-structures.md:55
msgid "`get_balance` to find user's balance in the database."
msgstr "Untuk menemukan keseimbangan pengguna di database."

#: src/ch11-01-custom-data-structures.md:57
msgid ""
"The only remaining step is to implement each of the methods in "
"`UserDatabaseTrait`, but since we are working with [Generic "
"types](./ch08-00-generic-types-and-traits.md) we also need to correctly "
"establish the requirements of `T` so it can be a valid `Felt252Dict<T>` "
"value type:"
msgstr ""
"Satu-satunya langkah yang tersisa adalah mengimplementasikan setiap metode "
"di UserDatabaseTrait, tetapi karena kita bekerja dengan [tipe "
"Generik]./ch08-00-generic-types-and-traits.md) kita juga perlu menetapkan "
"dengan benar persyaratan dari <T) sehingga dapat menjadi tipe nilai yang "
"valid Felt252Dict<T>:"

#: src/ch11-01-custom-data-structures.md:59
msgid ""
"`T` should implement the `Copy<T>` since it's required for getting values "
"from a `Felt252Dict<T>`."
msgstr ""
"Anda harus mengimplementasikan <T> karena diperlukan untuk mendapatkan nilai"
" dari sebuah ▪Felt252Dict<T>."

#: src/ch11-01-custom-data-structures.md:60
msgid ""
"All value types of a dictionary implement the `Felt252DictValue<T>`, our "
"generic type should do as well."
msgstr ""
"Semua tipe nilai dari sebuah kamus yang menerapkan Felt252DictValue<T>, tipe"
" umum kita juga harus melakukannya."

#: src/ch11-01-custom-data-structures.md:61
msgid ""
"To insert values, `Felt252DictTrait<T>` requires all value types to be "
"droppable (implement the `Drop<T>` trait)."
msgstr ""
"Untuk memasukkan nilai, diperlukan semua tipe nilai untuk dapat diturunkan "
"(menimplementasi sifat <T> Ddroppable)."

#: src/ch11-01-custom-data-structures.md:63
msgid ""
"The implementation, with all restrictions in place, would be as follows:"
msgstr ""
"In implementasi, dengan semua pembatasan di tempat, akan sebagai berikut:"

#: src/ch11-01-custom-data-structures.md:67
#: src/ch11-01-custom-data-structures.md:112
msgid "// Creates a database\n"
msgstr "//Membuat suatu basis data\n"

#: src/ch11-01-custom-data-structures.md:72
#: src/ch11-01-custom-data-structures.md:117
msgid "// Get the user's balance\n"
msgstr "#/ Get the user's balance\n"

#: src/ch11-01-custom-data-structures.md:77
#: src/ch11-01-custom-data-structures.md:122
msgid "// Add a user\n"
msgstr "//Tambahkan pengguna\n"

#: src/ch11-01-custom-data-structures.md:85
msgid ""
"Our database implementation is almost complete, except for one thing: the "
"compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since"
" it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait. "
"Since it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are"
" forced to implement the `Destruct<T>` trait manually (refer to the "
"[Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for more "
"information). Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` "
"definition won't work because of the use of [Generic "
"types](./ch08-00-generic-types-and-traits.md) in the struct definition. We "
"need to code the `Destruct<T>` trait implementation by ourselves:"
msgstr ""
"In implementasi basis data kami hampir selesai, kecuali satu hal: kompiler "
"tidak tahu bagaimana membuat sebuah karakter ▪UserDatabase<T> pergi keluar "
"dari jangkauan, karena tidak dapat diimplementasikan, jadi kita dipaksa "
"untuk mengimplementasi karakter <T> secara manual, atau destruct<T>. Karena "
"ia memiliki karakter ÁFelt252Dict> sebagai anggota, ia tidak dapat "
"diturunkan, sehingga kita dipaksa untuk mengimplementasikan karakter <T> "
"(refer ke [Ownership]01-isnizeder-thest.Tdrop-it) definisi "
"<Trachigensigensigenik] [."

#: src/ch11-01-custom-data-structures.md:97
msgid ""
"Implementing `Destruct<T>` for `UserDatabase` was our last step to get a "
"fully functional database. We can now try it out:"
msgstr ""
"Meniru Destruct<T> untuk UserDatabase adalah langkah terakhir kita untuk "
"mendapatkan basis data yang berfungsi penuh."

#: src/ch11-01-custom-data-structures.md:147
msgid "\"Expected 40\""
msgstr "\"Diduga 40\""

#: src/ch11-01-custom-data-structures.md:148
msgid "\"Expected 0\""
msgstr "\"Diduga 0\""

#: src/ch11-01-custom-data-structures.md:156
msgid "Simulating a Dynamic Array with Dicts"
msgstr "Simulasikan Array Dinamis dengan Dicts"

#: src/ch11-01-custom-data-structures.md:158
msgid ""
"First, let's think about how we want our mutable dynamic array to behave. "
"What operations should it support?"
msgstr ""
"Pertama, mari kita berpikir tentang bagaimana kita ingin kita bermutasi "
"dinamika array untuk berperilaku. operasi apa yang harus mendukung?"

#: src/ch11-01-custom-data-structures.md:161
msgid "It should:"
msgstr "Seharusnya:"

#: src/ch11-01-custom-data-structures.md:163
msgid "Allow us to append items at the end."
msgstr "Izinkan kami untuk menambahkan item di akhir."

#: src/ch11-01-custom-data-structures.md:164
msgid "Let us access any item by index."
msgstr "Mari kita akses setiap item dengan indeks."

#: src/ch11-01-custom-data-structures.md:165
msgid "Allow setting the value of an item at a specific index."
msgstr "Ijinkan menata nilai butir pada indeks tertentu."

#: src/ch11-01-custom-data-structures.md:166
msgid "Return the current length."
msgstr "Kembalikan panjang saat ini."

#: src/ch11-01-custom-data-structures.md:168
msgid "We can define this interface in Cairo like:"
msgstr "Kita dapat menentukan antarmuka ini di Cairo seperti:"

#: src/ch11-01-custom-data-structures.md:181
msgid ""
"This provides a blueprint for the implementation of our dynamic array. We "
"named it _Vec_ as it is similar to the `Vec<T>` data structure in Rust."
msgstr ""
"Ini menyediakan cetak biru untuk implementasi array dinamis kami. Kami "
"menamainya _Vec_ karena mirip dengan struktur data åVec<T>."

#: src/ch11-01-custom-data-structures.md:184
msgid "Implementing a Dynamic Array in Cairo"
msgstr "Mengimplementasi Array Dynamic di Cairo"

#: src/ch11-01-custom-data-structures.md:186
msgid ""
"To store our data, we'll use a `Felt252Dict<T>` which maps index numbers "
"(felts) to values. We'll also store a separate `len` field to track the "
"length."
msgstr ""
"Untuk menyimpan data kita, kita akan menggunakan medan terpisah "
"Felt252Dict<T> yang memetakan nomor indeks (merasa) ke nilai-nilai."

#: src/ch11-01-custom-data-structures.md:189
msgid ""
"Here is what our struct looks like. We wrap the type `T` inside `Nullable` "
"pointer to allow using any type `T` in our data structure, as explained in "
"the [Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-"
"supported-natively) section:"
msgstr ""
"Ini yang terlihat seperti struktur kita. kita membungkus tipenya. "
"/ch03-02-dictionaries.md#dictionary-of-types-not-supported-natively):"

#: src/ch11-01-custom-data-structures.md:200
msgid ""
"Since we again have `Felt252Dict<T>` as a struct member, we need to "
"implement the `Destruct<T>` trait to tell the compiler how to make "
"`NullableVec<T>` go out of scope."
msgstr ""
"Karena kita memiliki lagi Felt252Dict<T> sebagai anggota struct, kita perlu "
"mengimplementasikan destruct <T> sifat untuk memberitahu kompiler bagaimana "
"membuat NOullableVec<T> keluar dari jangkauan."

#: src/ch11-01-custom-data-structures.md:210
msgid ""
"The key thing that makes this vector mutable is that we can insert values "
"into the dictionary to set or update values in our data structure. For "
"example, to update a value at a specific index, we do:"
msgstr ""
"Kunci yang membuat vektor ini dapat bermutasi adalah kita dapat memasukkan "
"nilai ke dalam kamus untuk mengatur atau memperbarui nilai-nilai dalam "
"struktur data kita. Sebagai contoh, untuk memperbarui suatu nilai pada "
"indeks tertentu, kita lakukan:"

#: src/ch11-01-custom-data-structures.md:216
#: src/ch11-01-custom-data-structures.md:245
#: src/ch11-01-custom-data-structures.md:254
msgid "\"Index out of bounds\""
msgstr "\"Indeks out of bounds\""

#: src/ch11-01-custom-data-structures.md:221
msgid ""
"This overwrites the previously existing value at that index in the "
"dictionary."
msgstr "Ini menimpa nilai sebelumnya yang ada pada indeks dalam kamus."

#: src/ch11-01-custom-data-structures.md:223
msgid ""
"While arrays are immutable, dictionaries provide the flexibility we need for"
" modifiable data structures like vectors."
msgstr ""
"Sementara array tidak dapat berubah, kamus menyediakan fleksibilitas yang "
"kita butuhkan untuk struktur data yang dapat diubah seperti vektor."

#: src/ch11-01-custom-data-structures.md:226
msgid ""
"The implementation of the rest of the interface is straightforward. The "
"implementation of all the methods defined in our interface can be done as "
"follow :"
msgstr ""
"In implementasi dari seluruh antar muka langsung. implementasi dari semua "
"metoda yang didefinisikan dalam antar muka kita dapat dilakukan sebagai "
"berikut:"

#: src/ch11-01-custom-data-structures.md:263
msgid ""
"The full implementation of the `Vec` structure can be found in the "
"community-maintained library [Alexandria](https://github.com/keep-starknet-"
"strange/alexandria/tree/main/packages/data_structures/src)."
msgstr ""
"In implementasi penuh dari struktur åVecé dapat ditemukan di perpustakaan "
"yang dijaga masyarakat "
"[Alexandria][Alexandria][Alexantria]://github.com/keep-starknet-"
"strange/alandria/tree/main/packages/data_structs/src)."

#: src/ch11-01-custom-data-structures.md:268
msgid "Simulating a Stack with Dicts"
msgstr "Menasimulasi Stack dengan Dicts"

#: src/ch11-01-custom-data-structures.md:270
msgid ""
"We will now look at a second example and its implementation details: a "
"Stack."
msgstr ""
"Sekarang kita akan melihat contoh kedua dan rincian implementasinya: sebuah "
"Stack."

#: src/ch11-01-custom-data-structures.md:272
msgid ""
"A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new "
"element and removal of an existing element takes place at the same end, "
"represented as the top of the stack."
msgstr ""
"Stack adalah sebuah koleksi LIFO (Last-In, First-Out). Pemasukan dari elemen"
" baru dan penghapusan dari elemen yang ada terjadi pada bagian yang sama, "
"yang diwakili sebagai puncak stack."

#: src/ch11-01-custom-data-structures.md:276
msgid "Let us define what operations we need to create a stack:"
msgstr ""
"Mari kita mendefinisikan operasi apa yang kita butuhkan untuk membuat sebuah"
" stack:"

#: src/ch11-01-custom-data-structures.md:278
msgid "Push an item to the top of the stack."
msgstr "Push item ke puncak stack."

#: src/ch11-01-custom-data-structures.md:279
msgid "Pop an item from the top of the stack."
msgstr "Pop item dari atas tumpukan."

#: src/ch11-01-custom-data-structures.md:280
msgid "Check whether there are still any elements in the stack."
msgstr "Periksa apakah masih ada elemen dalam stack."

#: src/ch11-01-custom-data-structures.md:282
msgid "From these specifications we can define the following interface :"
msgstr "Dari spesifikasi ini kita dapat menentukan antarmuka berikut:"

#: src/ch11-01-custom-data-structures.md:292
msgid "Implementing a Mutable Stack in Cairo"
msgstr "Mengimplementasi Stack yang Dapat Dimutasi di Cairo"

#: src/ch11-01-custom-data-structures.md:294
msgid ""
"To create a stack data structure in Cairo, we can again use a "
"`Felt252Dict<T>` to store the values of the stack along with a `usize` field"
" to keep track of the length of the stack to iterate over it."
msgstr ""
"Untuk membuat struktur data stack di Cairo, kita dapat menggunakan lagi "
"sebuah ▪Felt252Dict<T> untuk menyimpan nilai-nilai stack bersama dengan "
"sebuah ruas Ãusizé untuk melacak panjang stack ke itaring di atasnya."

#: src/ch11-01-custom-data-structures.md:298
msgid "The Stack struct is defined as:"
msgstr "Struktur Stack didefinisikan sebagai:"

#: src/ch11-01-custom-data-structures.md:307
msgid ""
"Next, let's see how our main functions `push` and `pop` are implemented."
msgstr ""
"Selanjutnya, mari kita lihat bagaimana fungsi utama kita diimplementasikan."

#: src/ch11-01-custom-data-structures.md:330
msgid ""
"The code uses the `insert` and `get` methods to access the values in the "
"`Felt252Dict<T>`. To push an element to the top of the stack, the `push` "
"function inserts the element in the dict at index `len` and increases the "
"`len` field of the stack to keep track of the position of the stack top. To "
"remove a value, the `pop` function decreases the value of `len` to update "
"the position of the stack top and then retrieves the last value at position "
"`len`."
msgstr ""
"Kode ini menggunakan metode-metode ini dan mendapatkan akses masuk nilai-"
"nilai di dalam kotak itu. Untuk mendorong elemen ke puncak stack, fungsi pop"
" menurunkan nilai elemen dalam didict dan kemudian mengambil kembali posisi "
"terakhir dari stack top."

#: src/ch11-01-custom-data-structures.md:337
msgid ""
"The full implementation of the Stack, along with more data structures that "
"you can use in your code, can be found in the community-maintained "
"[Alexandria](https://github.com/keep-starknet-"
"strange/alexandria/tree/main/packages/data_structures/src) library, in the "
"\"data_structures\" crate."
msgstr ""
"In implementasi penuh dari Stack, bersama dengan lebih banyak struktur data "
"yang dapat Anda gunakan dalam kode Anda, dapat ditemukan di perpustakaan "
"[Alexandria]://github.com/keep-starknet-"
"strange/alandria/tree/main/packages/data_structs/src), dalam kotak "
"\"data_strucs.\""

#: src/ch11-01-custom-data-structures.md:343
msgid "{{#quiz ../quizzes/ch11-01-custom-structs.toml}}"
msgstr "{{#quiz../quizzes/ch11-01-custom-structs.toml}}"

#: src/ch11-01-custom-data-structures.md:347
msgid ""
"Well done! Now you have knowledge of arrays, dictionaries and even custom "
"data structures. While Cairo's memory model is immutable and can make it "
"difficult to implement mutable data structures, we can fortunately use the "
"`Felt252Dict<T>` type to simulate mutable data structures. This allows us to"
" implement a wide range of data structures that are useful for many "
"applications, effectively hiding the complexity of the underlying memory "
"model."
msgstr ""
"Sekarang Anda memiliki pengetahuan tentang array, dictionary, dan bahkan "
"struktur data gubahan. Sementara model memori Cairo tidak dapat diubah dan "
"dapat membuatnya sulit untuk mengimplementasikan struktur data yang dapat "
"bermutasi, kita dapat dengan senang hati menggunakan struktur data "
"▪Felt252Dict<T>T. Tipe simulasi struktur data yang dapat disimulasikan. Hal "
"ini memungkinkan kita untuk mengimplementasikan berbagai struktur data yang "
"berguna bagi banyak aplikasi, secara efektif menyembunyikan kompleksitas "
"model memori yang mendasari."

#: src/ch11-02-smart-pointers.md:3
msgid ""
"A pointer is a general concept for a variable that contains a memory "
"address. This address refers to, or “points at,” some other data. While "
"pointers are a powerful feature, they can also be a source of bugs and "
"security vulnerabilities. For example, a pointer can reference an unassigned"
" memory cell, which means that attempting to access the data at that address"
" would cause the program to crash, making it unprovable. To prevent such "
"issues, Cairo uses _Smart Pointers_."
msgstr ""
"Sebuah penunjuk adalah sebuah konsep umum untuk sebuah variabel yang berisi "
"sebuah alamat memori. Alamat ini mengacu pada, atau titik di, beberapa data "
"lainnya. sementara penunjuk adalah fitur yang kuat, mereka juga dapat "
"menjadi sumber dari kerentanan bug dan keamanan. Sebagai contoh, penunjuk "
"dapat mereferensikan sebuah sel memori yang tidak terssigned, yang berarti "
"bahwa mencoba mengakses data pada alamat tersebut akan menyebabkan program "
"mengalami crash, membuatnya tidak provable. Untuk mencegah isu tersebut, "
"Cairo menggunakan _Smart Pointers."

#: src/ch11-02-smart-pointers.md:5
msgid ""
"Smart pointers are data structures that act like a pointer, but also have "
"additional metadata and capabilities. The concept of smart pointers isn’t "
"unique to Cairo: smart pointers originated in C++ and exist in other "
"languages like Rust as well. In the specific case of Cairo, smart pointers "
"ensure that memory is not addressed in an unsafe way that could cause a "
"program to be unprovable, by providing a safe way to access memory through "
"strict type checking and ownership rules."
msgstr ""
"Penunjuk cerdas adalah struktur data yang bertindak seperti penunjuk, tetapi"
" juga memiliki metadata dan kemampuan tambahan. Konsep dari penunjuk cerdas "
"tidak unik bagi Cairo: penunjuk cerdas berasal dari C++ dan ada dalam bahasa"
" lain seperti Rust juga. Dalam kasus spesifik Cairo, penunjuk cerdas "
"memastikan bahwa memori tidak ditujukan dengan cara yang tidak aman yang "
"dapat menyebabkan program tidak provabel, dengan menyediakan cara yang aman "
"untuk mengakses memori melalui aturan pemeriksaan dan kepemilikan ketat."

#: src/ch11-02-smart-pointers.md:7
msgid ""
"Though we didn’t call them as such at the time, we’ve already encountered a "
"few smart pointers in this book, including `Felt252Dict<T>` and `Array<T>` "
"in Chapter 3. Both these types count as smart pointers because they own a "
"memory segment and allow you to manipulate it. They also have metadata and "
"extra capabilities or guarantees. Arrays keep track of their current length "
"to ensure that existing elements are not overwritten, and that new elements "
"are only appended to the end."
msgstr ""
"Meskipun kami tidak memanggil mereka seperti pada saat itu, kami telah "
"menemukan beberapa pointer cerdas dalam buku ini, termasuk ▪Felt252Dict<T> "
"dan ÉArray<T> dalam Bab 3. Kedua tipe ini sudah ditemukan sebagai penunjuk "
"cerdas karena mereka memiliki segmen memori dan memungkinkan Anda untuk "
"memanipulasinya. Mereka juga memiliki metadata dan kemampuan ekstra atau "
"jaminan. Array menyimpan panjang mereka saat ini untuk memastikan bahwa "
"elemen yang ada tidak overwrittented, dan bahwa elemen baru hanya "
"appendedededed sampai akhir."

#: src/ch11-02-smart-pointers.md:9
msgid ""
"The Cairo VM memory is composed by multiple segments that can store data, "
"each identified by a unique index. When you create an array, you allocate a "
"new segment in the memory to store the future elements. The array itself is "
"just a pointer to that segment where the elements are stored."
msgstr ""
"Memori VM Cairo disusun oleh beberapa segmen yang dapat menyimpan data, "
"masing-masing diidentifikasi oleh indeks unik. Ketika Anda membuat sebuah "
"array, Anda mengalokasikan segmen baru dalam memori untuk menyimpan elemen "
"di masa depan. Array itu sendiri hanya sebuah penunjuk ke segmen di mana "
"elemen disimpan."

#: src/ch11-02-smart-pointers.md:11
msgid "The `Box<T>` Type to Manipulate Pointers"
msgstr "Tipe Pengunjuk Manipulasi Kotak<T>"

#: src/ch11-02-smart-pointers.md:13
msgid ""
"The principal smart pointer type in Cairo is a _box_, denoted as `Box<T>`. "
"Manually defining boxes allow you to store data in a specific memory segment"
" of the Cairo VM called the _boxed segment_. This segment is dedicated to "
"store all boxed values, and what remains in the execution segment is only a "
"pointer to the boxed segment. Whenever you instantiate a new pointer "
"variable of type `Box<T>`, you append the data of type `T` to the boxed "
"segment."
msgstr ""
"Tipe penunjuk cerdas utama di Cairo adalah sebuah _boxed segmen_. Segmen ini"
" didedikasikan untuk menyimpan semua nilai kotak<T>. Secara manual "
"mendefinisikan kotak-kotak untuk menyimpan data dalam segmen memori spesifik"
" dari Cairo VM yang disebut segmen _boxed_. segmen ini didedikasikan untuk "
"menyimpan semua nilai kotak, dan apa yang tersisa dalam segmen eksekusi "
"hanya pointer ke segmen boxed. Ketika Anda instantiate sebuah variabel "
"poiner tipe baru --Box<T>, Anda menambahkan data tipe °T ke segmen box."

#: src/ch11-02-smart-pointers.md:15
msgid ""
"Boxes have very little performance overhead, other than writing their inner "
"values to the boxed segment. But they don’t have many extra capabilities "
"either. You’ll use them most often in these situations:"
msgstr ""
"Kotak memiliki kinerja yang sangat sedikit di atas kepala, selain menulis "
"nilai-nilai batin mereka ke segmen kotak. tapi mereka tidak memiliki banyak "
"kemampuan ekstra baik. kamu akan menggunakannya paling sering dalam situasi "
"ini:"

#: src/ch11-02-smart-pointers.md:17
msgid ""
"When you have a type whose size can’t be known at compile time and you want "
"to use a value of that type in a context that requires an exact size"
msgstr ""
"Bila Anda memiliki tipe yang ukurannya tidak dapat diketahui pada waktu "
"kompilasi dan Anda ingin menggunakan nilai dari jenis itu dalam konteks yang"
" memerlukan ukuran yang tepat"

#: src/ch11-02-smart-pointers.md:18
msgid ""
"When you have a large amount of data and you want to transfer ownership but "
"ensure the data won’t be copied when you do so"
msgstr ""
"Bila Anda memiliki sejumlah besar data dan Anda ingin mentransfer "
"kepemilikan tapi pastikan data tersebut tidak akan disalin ketika Anda "
"melakukannya"

#: src/ch11-02-smart-pointers.md:20
msgid ""
"We’ll demonstrate the first situation in the [“Enabling Recursive Types with"
" Boxes”](./ch11-02-smart-pointers.md#enabling-recursive-types-with-nullable-"
"boxes) section. In the second case, transferring ownership of a large amount"
" of data can take a long time because the data is copied around in memory. "
"To improve performance in this situation, we can store the large amount of "
"data in the boxed segment using a box type. Then, only the small amount of "
"pointer data is copied around in memory, while the data it references stays "
"in one place on the boxed segment."
msgstr ""
"Kami akan mendemonstrasikan situasi pertama dalam bagian \"Recursive Types\""
" dengan Boxes]--ch11-02-smart-pointers.md#nabling-recursive-types-with-"
"nullable-boxes). Dalam kasus kedua, mentransfer kepemilikan sejumlah besar "
"data dapat memakan waktu lama karena data disalin di sekitar memori. Untuk "
"memperbaiki kinerja dalam situasi ini, kita dapat menyimpan banyak data "
"dalam kotak menggunakan tipe kotak. Kemudian, hanya jumlah kecil poin data "
"yang disalin di sekitar memori, sementara data tetap di satu tempat di "
"kotak."

#: src/ch11-02-smart-pointers.md:25
msgid "Using a `Box<T>` to Store Data in the Boxed Segment"
msgstr "Menggunakan <T> Kotak ke Simpan Data dalam Segmen Berkotak"

#: src/ch11-02-smart-pointers.md:27
msgid ""
"Before we discuss the boxed segment storage use cases for `Box<T>`, we’ll "
"cover the syntax and how to interact with values stored within a `Box<T>`."
msgstr ""
"Sebelum kita membahas kotak penyimpanan menggunakan kasus-kasus untuk "
"menggunakan kotak untuk kotak<T>, kita akan menutupi sintaks dan bagaimana "
"berinteraksi dengan nilai-nilai yang tersimpan dalam sebuah kotak<T>."

#: src/ch11-02-smart-pointers.md:29
msgid ""
"Listing 11-1 shows how to use a box to store a value in the boxed segment:"
msgstr ""
"Daftar 11-1 menunjukkan bagaimana menggunakan kotak untuk menyimpan nilai "
"dalam segmen kotak:"

#: src/ch11-02-smart-pointers.md:34
msgid "\"b = {}\""
msgstr "\"b = {}\""

#: src/ch11-02-smart-pointers.md:38
msgid ""
"<span class=\"caption\">Listing 11-1: Storing a `u128` value in the boxed "
"segment using a box</span>"
msgstr ""
"<span class=\"caption\">Listing 11-1: Menyimpan sebuah nilai ▪u128) dalam "
"segmen boxed menggunakan kotak</span>"

#: src/ch11-02-smart-pointers.md:40
msgid ""
"We define the variable `b` to have the value of a `Box` that points to the "
"value `5`, which is stored in the boxed segment. This program will print `b "
"= 5`; in this case, we can access the data in the box similar to how we "
"would if this data was simply in the execution memory. Putting a single "
"value in a box isn’t very useful, so you won’t use boxes by themselves in "
"this way very often. Having values like a single `u128` in the execution "
"memory, where they’re stored by default, is more appropriate in the majority"
" of situations. Let’s look at a case where boxes allow us to define types "
"that we wouldn’t be allowed to if we didn’t have boxes."
msgstr ""
"Kami mendefinisikan variabel ini untuk memiliki nilai dari sebuah kotak yang"
" menunjuk pada nilai yang tersimpan dalam segmen kotak. program ini akan "
"mencetaknya dengan cara ini, kita dapat mengakses data di dalam kotak yang "
"mirip dengan bagaimana kita akan jika data ini hanya ada dalam memori "
"eksekusi."

#: src/ch11-02-smart-pointers.md:42
msgid "Enabling Recursive Types with Nullable Boxes"
msgstr "Mengaktifkan Tipe Rekursif dengan Kotak Nullable"

#: src/ch11-02-smart-pointers.md:46
msgid "Using Boxes to Improve Performance"
msgstr "Menggunakan Kotak untuk Meningkatkan Kinerja"

#: src/ch11-02-smart-pointers.md:48
msgid ""
"Passing pointers between functions allows you to reference data without "
"copying the data itself. Using boxes can improve performance as it allows "
"you to pass a pointer to some data from one function to another, without the"
" need to copy the entire data in memory before performing the function call."
" Instead of having to write `n` values into memory before calling a "
"function, only a single value is written, corresponding to the pointer to "
"the data. If the data stored in the box is very large, the performance "
"improvement can be significant, as you would save `n-1` memory operations "
"before each function call."
msgstr ""
"Melewati penunjuk antar fungsi memungkinkan Anda untuk mereferensikan data "
"tanpa menyalin data itu sendiri. Menggunakan kotak dapat meningkatkan "
"kinerja sebagaimana hal itu memungkinkan Anda untuk melewatkan suatu "
"penunjuk ke beberapa data dari satu fungsi ke fungsi lain, tanpa perlu "
"menyalin seluruh data dalam memori sebelum melakukan panggilan fungsi. "
"Daripada harus menulis nilai ▪n ▪ nilai ke dalam memori sebelum memanggil "
"sebuah fungsi, hanya satu nilai ditulis, sesuai dengan penunjuk ke data. "
"Jika data yang tersimpan dalam kotak sangat besar, peningkatan kinerja dapat"
" signifikan, karena Anda akan menyimpan operasi memori sebelum setiap "
"panggilan."

#: src/ch11-02-smart-pointers.md:50
msgid ""
"Let's take a look at the code in Listing 11-2, which shows two ways of "
"passing data to a function: by value and by pointer."
msgstr ""
"Mari kita lihat kode di Listing 11-2, yang menunjukkan dua cara mengirim "
"data ke sebuah fungsi: dengan nilai dan penunjuk."

#: src/ch11-02-smart-pointers.md:61 src/ch11-02-smart-pointers.md:66
msgid "\"{} is shopping today and bought {} items\""
msgstr "\"{} adalah belanja hari ini dan membeli {} item\""

#: src/ch11-02-smart-pointers.md:70
msgid "\"Eli\""
msgstr "\"Eli\""

#: src/ch11-02-smart-pointers.md:73
msgid "\"Uri\""
msgstr "\"Uri\""

#: src/ch11-02-smart-pointers.md:78
msgid ""
"<span class=\"caption\">Listing 11-2: Storing large amounts of data in a box"
" for performance.</span>"
msgstr ""
"<span class=\"caption\">Listing 11-2: Menyimpan sejumlah besar data dalam "
"sebuah kotak untuk kinerja.</span>"

#: src/ch11-02-smart-pointers.md:80
msgid "The `main` function includes 2 function calls:"
msgstr "Fungsi utama mencakup 2 fungsi panggilan:"

#: src/ch11-02-smart-pointers.md:82
msgid "`pass_data` that takes a variable of type `Cart`."
msgstr "Pass_data yang membutuhkan variabel tipe kart."

#: src/ch11-02-smart-pointers.md:83
msgid "`pass_pointer` that takes a pointer of type `Box<Cart>`."
msgstr "Penunjuk yang membutuhkan sebuah penunjuk tipe. Kotak<Cart>."

#: src/ch11-02-smart-pointers.md:85
msgid ""
"When passing data to a function, the entire data is copied into the last "
"available memory cells right before the function call. Calling `pass_data` "
"will copy all 3 fields of `Cart` to memory, while `pass_pointer` only "
"requires the copy of the `new_box` pointer which is of size 1."
msgstr ""
"Ketika mengirim data ke sebuah fungsi, seluruh data disalin ke dalam sel "
"memori terakhir yang tersedia tepat sebelum panggilan fungsi. Memanggil "
"spass_data akan menyalin semua 3 ▪Cartá ke memori, sementara åpass_pointer "
"hanya membutuhkan salinan dari pointer baru_box yang berukuran 1."

#: src/ch11-02-smart-pointers.md:94
msgid ""
"The illustration above demonstrates how the memory behaves in both cases. "
"The first instance of `Cart` is stored in the execution segment, and we need"
" to copy all its fields to memory before calling the `pass_data` function. "
"The second instance of `Cart` is stored in the boxed segment, and the "
"pointer to it is stored in the execution segment. When calling the "
"`pass_pointer` function, only the pointer to the struct is copied to memory "
"right before the function call. In both cases, however, instantiating the "
"struct will store all its values in the execution segment: the boxed segment"
" can only be filled with data taken from the execution segment."
msgstr ""
"Perumpamaan di atas menunjukkan bagaimana cara kerja memori dalam kedua "
"kasus. Contoh pertama dari segmen yang disimpan dalam kotak, dan pointer "
"untuk itu disimpan dalam segmen eksekusi. Ketika memanggil semua medan "
"memori sebelum memanggil fungsi Ápass_data."

#: src/ch11-02-smart-pointers.md:96
msgid "The `Nullable<T>` Type for Dictionaries"
msgstr "Jenis untuk Kamus (Dictionaries)"

#: src/ch11-02-smart-pointers.md:98
msgid ""
"`Nullable<T>` is another type of smart pointer that can either point to a "
"value or be `null` in the absence of value. It is defined at the Sierra "
"level. This type is mainly used in dictionaries that contain types that "
"don't implement the `zero_default` method of the `Felt252DictValue<T>` trait"
" (i.e., arrays and structs)."
msgstr ""
"Ini didefinisikan pada tingkat Sierra. Tipe ini terutama digunakan dalam "
"dictionaries yang tidak menerapkan metode thoseol_default asal-asalan dari "
"font <T.e., array dan structs)."

#: src/ch11-02-smart-pointers.md:100
msgid ""
"If we try to access an element that does not exist in a dictionary, the code"
" will fail if the `zero_default` method cannot be called."
msgstr ""
"Jika kita mencoba untuk mengakses elemen yang tidak ada dalam kamus, kode "
"akan gagal jika metode ·zero_defaulté tidak dapat disebut."

#: src/ch11-02-smart-pointers.md:102
msgid ""
"[Chapter 3.2](/ch03-02-dictionaries.md#dictionaries-of-types-not-supported-"
"natively) about dictionaries thoroughly explains how to store a "
"`Span<felt252>` variable inside a dictionary using the `Nullable<T>` type. "
"Please refer to it for further information."
msgstr ""
"[Chapter 3.2) Tentang dictionary dijelaskan secara menyeluruh bagaimana "
"menyimpan sebuah ÁSpan<felt252> variabel di dalam kamus menggunakan tipe <T>"
" yang tidak didukung. Silakan merujuk ke sana untuk informasi lebih lanjut."

#: src/ch11-02-smart-pointers.md:106
msgid "{{#quiz ../quizzes/ch11-02-smart_pointers.toml}}"
msgstr "{{#quiz../quizzes/ch11-02-smart_pointers.toml}}}"

#: src/ch11-03-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows "
"the redefinition of standard operators, such as addition (`+`), subtraction "
"(`-`), multiplication (`*`), and division (`/`), to work with user-defined "
"types. This can make the syntax of the code more intuitive, by enabling "
"operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr ""
"Operator overloading adalah fitur dalam beberapa bahasa pemrograman yang "
"memungkinkan redefinisi operator standar, seperti penambahan (Negeri), "
"pengurangan, perkalian, dan pembagian (Negeri), untuk bekerja dengan tipe "
"yang terdefinisi pengguna. Hal ini dapat membuat sintaks kode lebih "
"intuitif, dengan mengaktifkan operasi pada tipe user-defined untuk "
"diekspresikan dengan cara yang sama seperti operasi pada tipe primitif."

#: src/ch11-03-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of "
"specific traits. Each operator has an associated trait, and overloading that"
" operator involves providing an implementation of that trait for a custom "
"type. However, it's essential to use operator overloading judiciously. "
"Misuse can lead to confusion, making the code more difficult to maintain, "
"for example when there is no semantic meaning to the operator being "
"overloaded."
msgstr ""
"Di Cairo, operator overloading dicapai melalui implementasi sifat-sifat "
"tertentu. Setiap operator memiliki sifat terkait, dan overloading operator "
"termasuk menyediakan implementasi sifat itu untuk tipe kustom. Namun, sangat"
" penting untuk menggunakan operator overloading sewenang-wenang. Misuse "
"dapat menyebabkan kebingungan, membuat kode lebih sulit untuk "
"mempertahankan, misalnya ketika tidak ada makna semantik untuk operator yang"
" kelebihan beban."

#: src/ch11-03-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have "
"two data fields, mana and health. Combining two `Potions` should add their "
"respective fields."
msgstr "Perhatikan contoh di mana dua sumber daya perlu dikombinasikan."

#: src/ch11-03-operator-overloading.md:26
msgid "// Both potions were combined with the `+` operator.\n"
msgstr "//Kedua ramuan itu dikombinasikan dengan operator.\n"

#: src/ch11-03-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type."
" The add function takes two arguments: `lhs` and `rhs` (left and right-hand "
"side). The function body returns a new `Potion` instance, its field values "
"being a combination of `lhs` and `rhs`."
msgstr ""
"Dalam kode di atas, kami menerapkan sifat yang sama untuk jenis 'Potion' "
"ditambah fungsinya membutuhkan dua argumen: 'lhs' dan 'rhs' (kiri dan kanan-"
"tangan)."

#: src/ch11-03-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires "
"specification of the concrete type being overloaded. The overloaded generic "
"trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr ""
"Sebagaimana diilustrasikan dalam contoh ini, membebani operator memerlukan "
"spesifikasi dari tipe beton yang kelebihan beban. Sifat umum yang berlebihan"
" adalah Tambahkan<T>, dan kami mendefinisikan implementasi beton untuk tipe "
"▪Potionà dengan <Potion>."

#: src/ch11-03-operator-overloading.md:36
msgid "{{#quiz ../quizzes/ch11-03-operator-overloading.toml}}"
msgstr "{{#quiz../quizzes/ch11-03-operator-overloading.toml}}}"

#: src/ch11-04-hash.md:1
msgid "Hashes"
msgstr "Hashes"

#: src/ch11-04-hash.md:3
msgid ""
"At its essence, hashing is a process of converting input data (often called "
"a message) of any length into a fixed-size value, typically referred to as a"
" \"hash.\" This transformation is deterministic, meaning that the same input"
" will always produce the same hash value. Hash functions are a fundamental "
"component in various fields, including data storage, cryptography and data "
"integrity verification. They are very often used when developing smart "
"contracts, especially when working with [Merkle "
"trees](https://en.wikipedia.org/wiki/Merkle_tree#Uses)."
msgstr ""
"Pada esensinya, hashing adalah proses mengubah data masukan (yang sering "
"disebut pesan) dari panjang apa pun menjadi nilai ukuran tetap, biasanya "
"disebut sebagai \"hash.\" Transformasi ini adalah deterministik, berarti "
"bahwa masukan yang sama akan selalu menghasilkan nilai hash. Fungsi hash "
"adalah komponen fundamental dalam berbagai bidang, termasuk penyimpanan "
"data, kriptografi dan identifikasi data. Mereka sering digunakan ketika "
"mengembangkan kontrak cerdas, terutama ketika bekerja dengan [Merkle trees] "
"whtps.wikipedia.org/wi/wiki/Mlepedia_trees)."

#: src/ch11-04-hash.md:5
msgid ""
"In this chapter, we will present the two hash functions implemented natively"
" in the Cairo core library: `Poseidon` and `Pedersen`. We will discuss when "
"and how to use them, and see examples with Cairo programs."
msgstr ""
"Di bab ini, kami akan menyajikan kedua fungsi hash yang diimplementasikan "
"secara asli di perpustakaan inti Cairo:"

#: src/ch11-04-hash.md:9
msgid "Hash Functions in Cairo"
msgstr "Fungsi Hash di Cairo"

#: src/ch11-04-hash.md:11
msgid ""
"The Cairo core library provides two hash functions: Pedersen and Poseidon."
msgstr ""
"Perpustakaan inti Cairo menyediakan dua fungsi hash: Pedersen dan Poseidon."

#: src/ch11-04-hash.md:13
msgid ""
"Pedersen hash functions are cryptographic algorithms that rely on [elliptic "
"curve cryptography](https://en.wikipedia.org/wiki/Elliptic-"
"curve_cryptography). These functions perform operations on points along an "
"elliptic curve — essentially, doing math with the locations of these points "
"— which are easy to do in one direction and hard to undo. This one-way "
"difficulty is based on the Elliptic Curve Discrete Logarithm Problem "
"(ECDLP), which is a problem so hard to solve that it ensures the security of"
" the hash function. The difficulty of reversing these operations is what "
"makes the Pedersen hash function secure and reliable for cryptographic "
"purposes."
msgstr ""
"Fungsi ini bekerja pada titik-titik sepanjang kurva elliptik kriptografis] "
"pada dasarnya, melakukan matematika dengan lokasi-lokasi titik-titik ini "
"<wiki.org/wilipptic-curve_cryptography) yang mudah dilakukan dalam satu arah"
" dan sulit untuk membatalkan. Kesulitan satu arah ini didasarkan pada "
"Elliptic Discarrim Problem Logarim (ECDLP), yang merupakan masalah yang "
"sangat sulit untuk menyelesaikan fungsi keamanan tersebut."

#: src/ch11-04-hash.md:15
msgid ""
"Poseidon is a family of hash functions designed to be very efficient as "
"algebraic circuits. Its design is particularly efficient for Zero-Knowledge "
"proof systems, including STARKs (so, Cairo). Poseidon uses a method called a"
" 'sponge construction,' which soaks up data and transforms it securely using"
" a process known as the Hades permutation. Cairo's version of Poseidon is "
"based on a three-element state permutation with [specific "
"parameters](https://github.com/starkware-"
"industries/poseidon/blob/main/poseidon3.txt)."
msgstr ""
"Poseidon adalah sebuah keluarga dari fungsi hash yang dirancang untuk "
"menjadi sangat efisien sebagai sirkuit aljabar. desainnya sangat efisien "
"untuk sistem bukti pengetahuan-Zero, termasuk STARKs (So, Cairo). Poseidon "
"menggunakan metode yang disebut 'konstruksi ponge', yang menyerap data dan "
"mengubahnya dengan aman menggunakan proses yang dikenal sebagai permutasi "
"Hades. Versi Poseidon Cairo didasarkan pada tiga-elmen negara pertumen "
"pertasi dengan [speficicficic "
"parameter]://ghttps.com/startwrib/feaperries/pose/bdon/bdon/depose/dont)."

#: src/ch11-04-hash.md:20
msgid "When to Use Them?"
msgstr "Kapan Menggunakannya?"

#: src/ch11-04-hash.md:22
msgid ""
"Pedersen was the first hash function used on Starknet, and is still used to "
"compute the addresses of variables in storage (for example, `LegacyMap` uses"
" Pedersen to hash the keys of a storage mapping on Starknet). However, as "
"Poseidon is cheaper and faster than Pedersen when working with STARK proofs "
"system, it's now the recommended hash function to use in Cairo programs."
msgstr ""
"Pederen adalah fungsi hash pertama yang digunakan di Starknet, dan masih "
"digunakan untuk menghitung alamat dari variabel dalam penyimpanan (misalnya,"
" legacyMap) menggunakan Pederen untuk hash kunci pemetaan penyimpanan di "
"Starknet). Namun, Poseidon lebih murah dan lebih cepat daripada Pedersen "
"ketika bekerja dengan sistem bukti STARK, sekarang fungsi hash dianjurkan "
"untuk digunakan dalam program Cairo."

#: src/ch11-04-hash.md:26
msgid ""
"The core library makes it easy to work with hashes. The `Hash` trait is "
"implemented for all types that can be converted to `felt252`, including "
"`felt252` itself. For more complex types like structs, deriving `Hash` "
"allows them to be hashed easily using the hash function of your choice - "
"given that all of the struct's fields are themselves hashable. You cannot "
"derive the `Hash` trait on a struct that contains un-hashable values, such "
"as `Array<T>` or `Felt252Dict<T>`, even if `T` itself is hashable."
msgstr ""
"Perpustakaan inti membuatnya mudah untuk bekerja dengan hashhes. sifat yang "
"diimplementasikan untuk semua jenis yang dapat diubah menjadi 252, termasuk "
"TINGGAL 252. Untuk jenis yang lebih kompleks seperti struktur, "
"menghambatnya, memungkinkan mereka untuk menjadi terhimpit dengan mudah "
"menggunakan fungsi hash pilihan Anda - mengingat bahwa semua bidang struc's "
"sendiri dapat dimiliki."

#: src/ch11-04-hash.md:28
msgid ""
"The `Hash` trait is accompanied by the `HashStateTrait` and "
"`HashStateExTrait` that define the basic methods to work with hashes. They "
"allow you to initialize a hash state that will contain the temporary values "
"of the hash after each application of the hash function, update the hash "
"state and finalize it when the computation is completed. `HashStateTrait` "
"and `HashStateExTrait` are defined as follows:"
msgstr ""
"Sifat HasyTrait disertai dengan hastateTrait sementara dan setelah setiap "
"aplikasi dari fungsi hashstateExrait, mendefinisikan metode dasar untuk "
"bekerja dengan hashes. Mereka memungkinkan Anda untuk menginisialisasi "
"sebuah negara hashtrate yang akan berisi nilai-nilai sementara dari hash "
"setelah setiap aplikasi dari fungsi hash, memperbarui keadaan hash dan "
"menyelesaikannya ketika komputasi selesai."

#: src/ch11-04-hash.md:31
msgid "/// A trait for hash state accumulators.\n"
msgstr "/ Sebuah sifat untuk hash state akumulator.\n"

#: src/ch11-04-hash.md:36
msgid "/// Extension trait for hash state accumulators.\n"
msgstr "/ /Tekstensi sifat untuk hash state akumulator.\n"

#: src/ch11-04-hash.md:39 src/ch11-04-hash.md:45
msgid "/// Updates the hash state with the given value.\n"
msgstr "//Perbarui keadaan hash dengan nilai yang diberikan.\n"

#: src/ch11-04-hash.md:42
msgid "/// A trait for values that can be hashed.\n"
msgstr "/ Sebuah sifat untuk nilai-nilai yang dapat dihancurkan.\n"

#: src/ch11-04-hash.md:50
msgid ""
"To use hashes in your code, you must first import the relevant traits and "
"functions. In the following example, we will demonstrate how to hash a "
"struct using both the Pedersen and Poseidon hash functions."
msgstr ""
"Untuk menggunakan hash dalam kode Anda, pertama-tama Anda harus mengimpor "
"sifat dan fungsi yang relevan. dalam contoh berikut, kita akan menunjukkan "
"bagaimana hash struktur menggunakan baik fungsi Pederen dan Poseidon."

#: src/ch11-04-hash.md:52
msgid ""
"The first step is to initialize the hash with either `PoseidonTrait::new() "
"-> HashState` or `PedersenTrait::new(base: felt252) -> HashState` depending "
"on which hash function we want to work with. Then the hash state can be "
"updated with the `update(self: HashState, value: felt252) -> HashState` or "
"`update_with(self: S, value: T) -> S` functions as many times as required. "
"Then the function `finalize(self: HashState) -> felt252` is called on the "
"hash state and it returns the value of the hash as a `felt252`."
msgstr ""
"Langkah pertama adalah menginisialisasi hash dengan baik poseidonTrait:: new"
" Allah) -> Hashstate atau ▪PedersenTrait: baru: felt252) -> Hastate_Untate "
"bergantung pada fungsi hash yang ingin kita kerjakan. Kemudian status hash "
"dapat diperbarui dengan sendirinya: Hastlatate, feltate:252) -> Hashatate "
"atau ãwate_Uzateself: S, nilai T,> S,> S,> S,> S, sebagai fungsi yang "
"diperlukan."

#: src/ch11-04-hash.md:74
msgid ""
"Pedersen is different from Poseidon, as it starts with a base state. This "
"base state must be of `felt252` type, which forces us to either hash the "
"struct with an arbitrary base state using the `update_with` method, or "
"serialize the struct into an array to loop through all of its fields and "
"hash its elements together."
msgstr ""
"Pederen berbeda dari Poseidon, karena dimulai dengan sebuah kondisi dasar. "
"Kondisi dasar ini harus berupa tipe ▪felt252, yang memaksa kita untuk "
"membuat struktur dengan keadaan dasar yang sewenang-wenang menggunakan "
"metode ·update_with--, atau serialkan struktur ke dalam array untuk memutar "
"melalui semua bidang dan hash elemen bersama-sama."

#: src/ch11-04-hash.md:76
msgid "Here is a short example of Pedersen hashing:"
msgstr "Berikut adalah contoh pendek dari hasing Pedersen:"

#: src/ch11-04-hash.md:93
msgid "// hash1 is the result of hashing a struct with a base state of 0\n"
msgstr "//Hash1 adalah hasil hashing sebuah struktur dengan keadaan dasar 0\n"

#: src/ch11-04-hash.md:105
msgid "// hash2 is the result of hashing only the fields of the struct\n"
msgstr "//Hash2 adalah hasil dari hashing hanya bidang dari struktur\n"

#: src/ch11-04-hash.md:114
msgid "Advanced Hashing: Hashing Arrays with Poseidon"
msgstr "Advanced Hashing: Hashing Arrays with Poseidon"

#: src/ch11-04-hash.md:116
msgid ""
"Let us look at an example of hashing a struct that contains a "
"`Span<felt252>`. To hash a `Span<felt252>` or a struct that contains a "
"`Span<felt252>` you can use the built-in function `poseidon_hash_span(mut "
"span: Span<felt252>) -> felt252`. Similarly, you can hash `Array<felt252>` "
"by calling `poseidon_hash_span` on its span."
msgstr ""
"Mari kita lihat sebuah contoh dari hashing sebuah struktur yang berisi "
"sebuah struktur yang berisi sebuah batang yang memiliki fungsi bawaan "
"<rasat2> -> merasa 2525. Demikian pula, Anda dapat memiliki array<felt252> "
"dengan memanggil posidon_hash_span_sh_spanmut pada rentangnya."

#: src/ch11-04-hash.md:119
msgid "First, let us import the following traits and function:"
msgstr "Pertama, mari kita impor sifat dan fungsi berikut:"

#: src/ch11-04-hash.md:127
msgid ""
"Now we define the struct. As you might have noticed, we didn't derive the "
"`Hash` trait. If you attempt to derive the `Hash` trait for this struct, it "
"will result in an error because the structure contains a field that is not "
"hashable."
msgstr ""
"Sekarang kita definisikan strukturnya seperti yang mungkin anda perhatikan, "
"kita tidak mendapatkan sifat hash. jika anda mencoba untuk memperoleh sifat "
"dari struktur ini, itu akan mengakibatkan kesalahan karena strukturnya "
"mengandung medan yang tidak dapat dilewati."

#: src/ch11-04-hash.md:138
msgid ""
"In this example, we initialized a `HashState` (`hash`), updated it and then "
"called the function `finalize()` on the `HashState` to get the computed hash"
" `hash_felt252`. We used `poseidon_hash_span` on the `Span` of the "
"`Array<felt252>` to compute its hash."
msgstr ""
"Dalam contoh ini, kami menginisialisasi sebuah hashstate (rasa 252), "
"memperbaruinya dan kemudian disebut fungsinya pada ·finalisasiá) untuk "
"mendapatkan hashstate atau hashed hash_felt252."

#: src/ch11-05-macros.md:3
msgid ""
"The Cairo language has some plugins that allow developers to simplify their "
"code. They are called `inline_macros` and are a way of writing code that "
"generates other code."
msgstr ""
"Bahasa Cairo memiliki beberapa pengaya yang memungkinkan pengembang "
"menyederhanakan kode mereka."

#: src/ch11-05-macros.md:5
msgid "`consteval_int!` Macro"
msgstr "Makro"

#: src/ch11-05-macros.md:7
msgid ""
"In some situations, a developer might need to declare a constant that is the"
" result of a computation of integers. To compute a constant expression and "
"use its result at compile time, it is required to use the `consteval_int!` "
"macro."
msgstr ""
"Dalam beberapa situasi, seorang pengembang mungkin perlu menyatakan konstan "
"yang merupakan hasil dari komputasi integer. Untuk menghitung ekspresi "
"konstan dan menggunakan hasilnya pada waktu yang dikompilasi, dibutuhkan "
"untuk menggunakan ▪consteval_int! makro."

#: src/ch11-05-macros.md:9
msgid "Here is an example of `consteval_int!`:"
msgstr "Berikut ini adalah contoh dari iconsteval_int!:"

#: src/ch11-05-macros.md:15
msgid "This will be interpreted as `const a: felt252 = 8;` by the compiler."
msgstr "Ini akan ditafsirkan sebagai åconst a: felt252 = 8;-- oleh kompiler."

#: src/ch11-05-macros.md:17
msgid "`selector!` Macro"
msgstr "Pembeku! Macro"

#: src/ch11-05-macros.md:19
msgid ""
"See [Entry Point Selector](./ch15-02-contract-dispatchers-library-"
"dispatchers-and-system-calls.md#entry-point-selector)."
msgstr ""
"Lihat [Entertry Point Selektor]./ch15-02-contract-dispatchers-library-"
"dispatchers-and-system-calls.md#entry-point-sector)."

#: src/ch11-05-macros.md:21
msgid "`print!` and `println!` Macros"
msgstr "Cetakan! Macros"

#: src/ch11-05-macros.md:23
msgid "Please refer to the [Printing](./ch11-08-printing.md) page."
msgstr "Silakan merujuk ke halaman [Printing]. /ch11-08-printing.md)."

#: src/ch11-05-macros.md:27
msgid "Please refer to the [Arrays](./ch03-01-arrays.md) page."
msgstr "Silakan merujuk ke halaman [Arrays]. /ch03-01-arrays.md)."

#: src/ch11-05-macros.md:31
msgid ""
"See [Unrecoverable Errors with panic](./ch09-01-unrecoverable-errors-with-"
"panic.html#panic-macro) page."
msgstr ""
"Lihat [ Error Tak Tercover dengan panik]. /ch09-01-uncoverable-errors-with-"
"panic.html#panic-macro) halaman."

#: src/ch11-05-macros.md:33
msgid "`assert!` and `assert_xx!` Macros"
msgstr "Dan Macrossert_xx!"

#: src/ch11-05-macros.md:35
msgid "See [How to Write Tests](./ch10-01-how-to-write-tests.md) page."
msgstr ""
"Lihat [Bagaimana Menulis Tests]. /ch10-01-how-to- write-tests.md) halaman."

#: src/ch11-05-macros.md:37
msgid "`format!` Macro"
msgstr "Macro"

#: src/ch11-05-macros.md:39
msgid "See [Printing](./ch11-08-printing.html#formatting) page."
msgstr "Lihat halaman.html#formatting). /ch11-08-printing.html#formatting)."

#: src/ch11-05-macros.md:41
msgid "`write!` and `writeln!` Macros"
msgstr "Tulis! Dan tulislah! Macros"

#: src/ch11-05-macros.md:43
msgid ""
"See [Printing](./ch11-08-printing.html#printing-custom-data-types) page."
msgstr "Lihat halaman.html#printing-custom-data-types)."

#: src/ch11-05-macros.md:45
msgid "`get_dep_component!`, `get_dep_component_mut` and `component!` Macros"
msgstr "Get_dep_component!, misal_dep_component_mut_component dan komponent!"

#: src/ch11-05-macros.md:47
msgid ""
"Please refer to the [Composability and "
"Components](./ch16-02-00-composability-and-components.md) chapter."
msgstr ""
"Mohon merujuk ke bab [Komputasi dan Komponen]./ch16-02-00-kompetisi-dan-"
"komponen.md)."

#: src/ch11-06-inlining-in-cairo.md:3
msgid ""
"Inlining is a common code optimization technique supported by most "
"compilers. It involves replacing a function call at the call site with the "
"actual code of the called function, eliminating the overhead associated with"
" the function call itself. This can improve performance by reducing the "
"number of instructions executed, but may increase the total size of the "
"program. When you're thinking about whether to inline a function, take into "
"account things like how big it is, what parameters it has, how often it gets"
" called, and how it might affect the size of your compiled code."
msgstr ""
"Inlining adalah teknik optimasi kode umum yang didukung oleh kebanyakan "
"kompiler. Ini mencakup mengganti panggilan fungsi pada situs panggilan yang "
"sebenarnya dengan kode yang disebut fungsi, menghilangkan overhead yang "
"terkait dengan panggilan fungsi itu sendiri. Hal ini dapat meningkatkan "
"kinerja dengan mengurangi jumlah instruksi yang dijalankan, tetapi dapat "
"meningkatkan total ukuran program. Ketika Anda berpikir tentang apakah untuk"
" inline fungsi, memperhitungkan hal-hal seperti besar itu, apa parameter "
"itu, seberapa sering disebut, dan bagaimana mungkin mempengaruhi ukuran kode"
" yang dikompile Anda."

#: src/ch11-06-inlining-in-cairo.md:5
msgid "The `inline` Attribute"
msgstr "Atribut dalam bahasa Inggris"

#: src/ch11-06-inlining-in-cairo.md:7
msgid ""
"In Cairo, the `inline` attribute suggests whether or not the Sierra code "
"corresponding to the attributed function should be directly injected in the "
"caller function's context, rather than using a `function_call` libfunc to "
"execute that code."
msgstr ""
"Di Cairo, atribut æinlineé menunjukkan apakah kode Sierra berhubungan dengan"
" fungsi atribut yang harus disuntikkan langsung dalam konteks fungsi "
"pemanggil, daripada menggunakan sebuah libfunc thosefunction_call untuk "
"menjalankan kode tersebut."

#: src/ch11-06-inlining-in-cairo.md:9
msgid "There are three variants of the `inline` attribute that one can use:"
msgstr "Ada tiga varian dari atribut åinline-- yang dapat digunakan:"

#: src/ch11-06-inlining-in-cairo.md:11
msgid "`#[inline]` suggests performing an inline expansion."
msgstr "___[inline]*** menyarankan untuk melakukan ekspansi inline."

#: src/ch11-06-inlining-in-cairo.md:12
msgid ""
"`#[inline(always)]` suggests that an inline expansion should always be "
"performed."
msgstr ""
"▪#[inlinemeisteralways]] menunjukkan bahwa ekspansi inline harus selalu "
"dilakukan."

#: src/ch11-06-inlining-in-cairo.md:13
msgid ""
"`#[inline(never)]` suggests that an inline expansion should never be "
"performed."
msgstr ""
"▪#[inline Allah tidak pernah) menunjukkan bahwa ekspansi inline tidak boleh "
"dilakukan."

#: src/ch11-06-inlining-in-cairo.md:15
msgid ""
"Note: the `inline` attribute in every form is a hint, with no requirements "
"on the language to place a copy of the attributed function in the caller. "
"This means that the attribute may be ignored by the compiler. In practice, "
"`#[inline(always)]` will cause inlining in all but the most exceptional "
"cases."
msgstr ""
"Catatan: atribut dalam setiap bentuk adalah petunjuk, tanpa persyaratan pada"
" bahasa untuk menempatkan salinan fungsi atribut pada pemanggil. Ini berarti"
" atribut tersebut dapat diabaikan oleh kompiler. Dalam praktek, \"#[inline "
"kalians)] akan menyebabkan inlining dalam semua kecuali kasus yang paling "
"luar biasa."

#: src/ch11-06-inlining-in-cairo.md:17
msgid ""
"Many of the Cairo corelib functions are inlined. User-defined functions may "
"also be annotated with the `inline` attribute. Annoting functions with the "
"`#[inline(always)]` attribute reduces the total number of steps required "
"when calling these attributed functions. Indeed, injecting the Sierra code "
"at the caller site avoids the step-cost involved in calling functions and "
"obtaining their arguments."
msgstr ""
"Banyak fungsi corelib Cairo tidak terinline. Fungsi terdefinisi pengguna "
"mungkin juga dapat dinotasi dengan atribut ▪inlineå[inlinalways]. Atribut "
"mengurangi jumlah langkah yang diperlukan ketika memanggil fungsi-fungsi "
"yang atribut ini. Memang, menyuntikkan kode penelepon Sierra di situs "
"tersebut menghindari fungsi panggilan langkah dan mendapatkan argumen "
"mereka."

#: src/ch11-06-inlining-in-cairo.md:19
msgid ""
"However, inlining can also lead to increased code size. Whenever a function "
"is inlined, the call site contains a copy of the function's Sierra code, "
"potentially leading to duplication of code across the compiled code."
msgstr ""
"Namun, inlining juga dapat menyebabkan peningkatan ukuran kode. Setiap kali "
"sebuah fungsi diinline, situs panggilan berisi salinan dari kode Sierra "
"fungsi, berpotensi menyebabkan duplikasi kode melalui kode yang dikompilasi."

#: src/ch11-06-inlining-in-cairo.md:21
msgid ""
"Therefore, inlining should be applied with caution. Using `#[inline]` or "
"`#[inline(always)]` indiscriminately will lead to increased compile time. It"
" is particularly useful to inline small functions, ideally with many "
"arguments. This is because inlining large functions will increase the code "
"length of the program, and handling many arguments will increase the number "
"of steps to execute these functions."
msgstr ""
"Oleh karena itu, inlining harus diterapkan dengan hati-hati. Menggunakan "
"fungsi kecil, idealnya dengan banyak argumen. Hal ini karena inlining fungsi"
" besar akan meningkatkan panjang kode program, dan menangani banyak argumen "
"akan meningkatkan jumlah langkah untuk melaksanakan fungsi ini."

#: src/ch11-06-inlining-in-cairo.md:23
msgid ""
"The more frequently a function is called, the more beneficial inlining "
"becomes in terms of performance. By doing so, the number of steps for the "
"execution will be lower, while the code length will not grow that much or "
"might even decrease in terms of total number of instructions."
msgstr ""
"Semakin sering sebuah fungsi disebut, semakin bermanfaat inlining dalam hal "
"kinerja. Dengan melakukannya, jumlah langkah untuk eksekusi akan lebih "
"rendah, sementara panjang kode tidak akan tumbuh sebanyak itu atau bahkan "
"mungkin menurun dalam hal jumlah total instruksi."

#: src/ch11-06-inlining-in-cairo.md:25
msgid ""
"Inlining is often a tradeoff between number of steps and code length. Use "
"the `inline` attribute cautiously where it is appropriate."
msgstr ""
"Inlining sering kali merupakan tradeoff antara sejumlah langkah dan panjang "
"kode."

#: src/ch11-06-inlining-in-cairo.md:27
msgid "Inlining Example"
msgstr "Contoh yang Mendesak"

#: src/ch11-06-inlining-in-cairo.md:29
msgid ""
"Let's introduce a short example to illustrate the mechanisms of inlining in "
"Cairo. Listing 11-3 shows a basic program allowing comparison between "
"inlined and non-inlined functions."
msgstr ""
"Mari kita perkenalkan contoh singkat untuk menggambarkan mekanisme inlining "
"di Cairo. Daftar 11-3 menunjukkan program dasar memungkinkan perbandingan "
"antara fungsi inline dan non-inline."

#: src/ch11-06-inlining-in-cairo.md:47
msgid ""
"<span class=\"caption\">Listing 11-3: A small Cairo program that adds the "
"return value of 2 functions, with one of them being inlined</span>"
msgstr ""
"<span class=\"caption\">Listing 11-3: Sebuah program Cairo kecil yang "
"menambahkan nilai kembali dari 2 fungsi, dengan salah satu dari mereka "
"sedang diinline</span>"

#: src/ch11-06-inlining-in-cairo.md:49
msgid ""
"Let's take a look at the corresponding Sierra code to see how inlining works"
" under the hood:"
msgstr ""
"Mari kita lihat pada kode Sierra yang sesuai untuk melihat bagaimana "
"inlining bekerja di bawah tenda:"

#: src/ch11-06-inlining-in-cairo.md:52 src/ch11-06-inlining-in-cairo.md:215
msgid "// type declarations\n"
msgstr "//jenis deklarasi\n"

#: src/ch11-06-inlining-in-cairo.md:54 src/ch11-06-inlining-in-cairo.md:218
msgid "// libfunc declarations\n"
msgstr "// deklarasi libfunc\n"

#: src/ch11-06-inlining-in-cairo.md:61 src/ch11-06-inlining-in-cairo.md:226
msgid "// statements\n"
msgstr "//pernyataan\n"

#: src/ch11-06-inlining-in-cairo.md:75 src/ch11-06-inlining-in-cairo.md:238
msgid "// funcs\n"
msgstr "#/ funcs\n"

#: src/ch11-06-inlining-in-cairo.md:82
msgid "The Sierra file is structured in three parts:"
msgstr "Berkas Sierra terstruktur dalam tiga bagian:"

#: src/ch11-06-inlining-in-cairo.md:84
msgid "Type and libfunc declarations."
msgstr "Tipe dan deklarasi libfunc."

#: src/ch11-06-inlining-in-cairo.md:85
msgid "Statements that constitute the program."
msgstr "Pernyataan yang membentuk program."

#: src/ch11-06-inlining-in-cairo.md:86
msgid "Declaration of the functions of the program."
msgstr "Deklarasi fungsi program."

#: src/ch11-06-inlining-in-cairo.md:88
msgid ""
"The Sierra code statements always match the order of function declarations "
"in the Cairo program. Indeed, the declaration of the functions of the "
"program tells us that:"
msgstr ""
"Pernyataan kode Sierra selalu cocok dengan urutan deklarasi fungsi dalam "
"program Cairo."

#: src/ch11-06-inlining-in-cairo.md:90
msgid "`main` function starts at line 0, and returns a `felt252` on line 5."
msgstr "Fungsi utama dimulai pada baris 0, dan kembali ke saluran 252."

#: src/ch11-06-inlining-in-cairo.md:91
msgid ""
"`inlined` function starts at line 6, and returns a `felt252` on line 8."
msgstr ""
"Fungsi dibariskan di baris 6, dan mengembalikan sebuah ± 252 di baris 8."

#: src/ch11-06-inlining-in-cairo.md:92
msgid ""
"`not_inlined` function starts at line 9, and returns a `felt252` on line 11."
msgstr ""
"Fungsi tidak_dibariskan dimulai di baris 9, dan mengembalikan sebuah "
"irfelt252 di baris 11."

#: src/ch11-06-inlining-in-cairo.md:94
msgid ""
"All statements corresponding to the `main` function are located between "
"lines 0 and 5:"
msgstr ""
"Semua laporan yang berhubungan dengan fungsi ımain yang terletak di antara "
"garis 0 dan 5:"

#: src/ch11-06-inlining-in-cairo.md:105
msgid ""
"The `function_call` libfunc is called on line 0 to execute the `not_inlined`"
" function. This will execute the code from lines 9 to 10 and store the "
"return value in the variable with id `0`."
msgstr ""
"Fungsi fungsinya adalah libfunc disebut di baris 0 untuk menjalankan fungsi "
"ænot_inlined. Ini akan mengeksekusi kode dari baris 9 sampai 10 dan "
"menyimpan nilai kembali dalam variabel dengan id 0."

#: src/ch11-06-inlining-in-cairo.md:112
msgid ""
"This code uses a single data type, `felt252`. It uses two library functions "
"- `felt_const<2>`, which returns the constant `felt252` 2, "
"and `store_temp<felt252>`, which pushes a constant value to memory. The "
"first line calls the `felt_const<2>` libfunc to create a variable with "
"id `0`. Then, the second line pushes this variable to memory for later use."
msgstr ""
"Kode ini menggunakan sebuah tipe data tunggal, yang menggunakan dua fungsi "
"perpustakaan - ▪felt_const<2>, yang mengembalikan tipe konstan TINGGAL2, dan"
" Ástore_temp<felt252>, yang mendorong nilai konstan ke memori. Baris pertama"
" memanggil baris pertama yang disebut <2> libfunc untuk membuat variabel "
"dengan É0. Kemudian, baris kedua mendorong variabel ini untuk digunakan "
"nanti."

#: src/ch11-06-inlining-in-cairo.md:114
msgid ""
"After that, Sierra statements from line 1 to 2 are the actual body of the "
"`inlined` function:"
msgstr ""
"Setelah itu, pernyataan Sierra dari baris 1 sampai 2 adalah tubuh yang "
"sebenarnya dari fungsi æinlined:"

#: src/ch11-06-inlining-in-cairo.md:121
msgid ""
"The only difference is that the inlined code will store the `felt252_const` "
"value in a variable with id `1`, because `[0]` refers to a variable "
"previously assigned:"
msgstr ""
"Satu-satunya perbedaan adalah bahwa kode inline akan menyimpan nilai "
"▪felt252_consté dalam variabel dengan id ·1,\" karena [0] reference ke "
"variabel sebelumnya ditugaskan:"

#: src/ch11-06-inlining-in-cairo.md:128
msgid ""
"Note: in both cases (inlined or not), the `return` instruction of the "
"function being called is not executed, as this would lead to prematurely end"
" the execution of the `main` function. Instead, return values of `inlined` "
"and `not_inlined` will be added and the result will be returned."
msgstr ""
"Catatan: dalam kedua kasus ini (dibariskan atau tidak), instruksi dari "
"fungsi yang disebut tidak dijalankan, karena hal ini akan menyebabkan "
"eksekusi dini dari fungsi ·returné. Sebaliknya, kembali nilai-nilai  "
"(inlined) dan tidak_inlined) akan ditambahkan dan hasilnya akan "
"dikembalikan."

#: src/ch11-06-inlining-in-cairo.md:130
msgid ""
"Lines 3 to 5 contain the Sierra statements that will add the values "
"contained in variables with ids `0` and `1`, store the result in memory and "
"return it:"
msgstr ""
"Baris 3 sampai 5 berisi pernyataan Sierra yang akan menambahkan nilai-nilai "
"yang terkandung dalam variabel dengan ids ·0 dan ·1), menyimpan hasilnya "
"dalam memori dan mengembalikannya:"

#: src/ch11-06-inlining-in-cairo.md:138
msgid ""
"Now, let's take a look at the Casm code corresponding to this program to "
"really understand the benefits of inlining."
msgstr ""
"Sekarang, mari kita lihat kode Casm yang berhubungan dengan program ini "
"untuk benar-benar memahami manfaat inlining."

#: src/ch11-06-inlining-in-cairo.md:140
msgid "Casm Code Explanations"
msgstr "Penjelasan Kode Casm"

#: src/ch11-06-inlining-in-cairo.md:142
msgid "Here is the Casm code for our previous program example:"
msgstr "Berikut adalah kode Casm untuk contoh program kami sebelumnya:"

#: src/ch11-06-inlining-in-cairo.md:158
msgid ""
"Don't hesitate to use [cairovm.codes](https://cairovm.codes/) playground to "
"follow along and see all the execution trace."
msgstr ""
"Jangan ragu untuk menggunakan [cairovm.codes][https://cairovm.codes/) taman "
"bermain untuk mengikuti sepanjang dan melihat semua jejak eksekusi."

#: src/ch11-06-inlining-in-cairo.md:160
msgid ""
"Each instruction and each argument for any instruction increment the Program"
" Counter (known as PC) by 1. This means that `ret` on line 2 is actually the"
" instruction at `PC = 3`, as the argument `3` corresponds to `PC = 2`."
msgstr ""
"Setiap instruksi dan setiap argumen untuk peningkatan setiap Program Kontra "
"(dikenal sebagai PC) oleh 1. Ini berarti bahwa året di baris 2 sebenarnya "
"adalah instruksi di ÉPC = 3), sebagai argumen yang berkorespondensi dengan "
"▪3."

#: src/ch11-06-inlining-in-cairo.md:162
msgid ""
"The `call` and `ret` instructions allow implementation of a function stack:"
msgstr ""
"Instruksi yang diberikan memungkinkan implementasi dari sebuah stack fungsi:"

#: src/ch11-06-inlining-in-cairo.md:164
msgid ""
"`call` instruction acts like a jump instruction, updating the PC to a given "
"value, whether relatively to the current value using `rel` or absolutely "
"using `abs`."
msgstr ""
"Instruksi seperti melompat, meng-update komputer ke suatu nilai tertentu, "
"apakah relatif terhadap nilai yang digunakan saat ini atau benar-benar "
"menggunakan komputer."

#: src/ch11-06-inlining-in-cairo.md:165
msgid ""
"`ret` instruction jumps back right after the `call` instruction and "
"continues the execution of the code."
msgstr ""
"Instruksinya melompat kembali tepat setelah instruksinya dan melanjutkan "
"eksekusi kodenya."

#: src/ch11-06-inlining-in-cairo.md:167
msgid ""
"We can now decompose how these instructions are executed to understand what "
"this code does:"
msgstr ""
"Sekarang kita bisa menguraikan bagaimana instruksi ini dijalankan untuk "
"memahami apa kode ini lakukan:"

#: src/ch11-06-inlining-in-cairo.md:169
msgid ""
"`call rel 3`: this instruction increments the PC by 3 and executes the "
"instruction at this location, which is `call rel 9` at `PC = 4`."
msgstr ""
"Panggilan rel 3: instruksi ini meningkatkan PC dengan 3 dan mengeksekusi "
"instruksi di lokasi ini, yang adalah ·call rel 9 TM di åPC = 4."

#: src/ch11-06-inlining-in-cairo.md:170
msgid ""
"`call rel 9` increments the PC by 9 and executes the instruction at `PC = "
"13`, which is actually line 9."
msgstr ""
"Hubungi rel 9Ul untuk meningkatkan PC pada 9 dan jalankan instruksi di ▪PC ="
" 13, yang sebenarnya adalah baris 9."

#: src/ch11-06-inlining-in-cairo.md:171
msgid ""
"`[ap + 0] = 2, ap++`: `ap` stands for Allocation Pointer, which points to "
"the first memory cell that has not been used by the program so far. This "
"means we store the value `2` in the next free memory cell indicated by the "
"current value of `ap`, after which we increment `ap` by 1. Then, we go to "
"the next line which is `ret`."
msgstr ""
"Ini berarti kita menyimpan nilai tersebut di sel memori bebas berikutnya "
"yang ditunjukkan oleh nilai saat ini dari Alokasi Pointer, setelah itu kita "
"naik 1."

#: src/ch11-06-inlining-in-cairo.md:172
msgid "`ret`: jumps back to the line after `call rel 9`, so we go to line 4."
msgstr ""
"Kembali ke garis setelah panggilan ulang ke 9 jadi kita pergi ke baris 4."

#: src/ch11-06-inlining-in-cairo.md:173
msgid ""
"`[ap + 0] = 1, ap++` : we store the value `1` in `[ap]` and we apply `ap++` "
"so that `[ap - 1] = 1`. This means we now have `[ap-1] = 1, [ap-2] = 2` and "
"we go to the next line."
msgstr ""
"Jadi kita akan pergi ke baris berikutnya. ini berarti kita memiliki [ap-1] ="
" 1, [ap-2] dan kita pergi ke baris berikutnya."

#: src/ch11-06-inlining-in-cairo.md:174
msgid ""
"`[ap + 0] = [ap + -1] + [ap + -2], ap++`: we sum the values `1` and `2` and "
"store the result in `[ap]`, and we apply `ap++` so the result is `[ap-1] = "
"3, [ap-2] = 1, [ap-3]=2`."
msgstr ""
"[ap + -1] + [ap + -2], ap++: kita jumlahkan nilai-nilainya, dan 2] dan "
"simpan hasilnya dalam å[ap], dan kita terapkan ▪ap++ (ap-1] = 3, [ap] = 1, "
"[ap-3]=2."

#: src/ch11-06-inlining-in-cairo.md:175
msgid "`ret`: jumps back to the line after `call rel 3`, so we go to line 2."
msgstr "Kembali ke garis setelah panggilan rel 3, jadi kita pergi ke baris 2."

#: src/ch11-06-inlining-in-cairo.md:176
msgid ""
"`ret`: last instruction executed as there is no more `call` instruction "
"where to jump right after. This is the actual return instruction of the "
"Cairo `main` function."
msgstr "Ini adalah instruksi kembali yang sebenarnya dari fungsi Cairo."

#: src/ch11-06-inlining-in-cairo.md:178
msgid "To summarize:"
msgstr "Untuk meringkas:"

#: src/ch11-06-inlining-in-cairo.md:180
msgid ""
"`call rel 3` corresponds to the `main` function, which is obviously not "
"inlined."
msgstr ""
"Hubungi rel 3 dan sesuai dengan fungsinya, yang jelas-jelas tidak terinline."

#: src/ch11-06-inlining-in-cairo.md:181
msgid ""
"`call rel 9` triggers the call the `not_inlined` function, which returns `2`"
" and stores it at the final location `[ap-3]`."
msgstr ""
"Teleponlah Rel 9 reli memicu panggilan fungsi yang tidak terinline, yang "
"kembali dan menyimpannya di lokasi akhir [ap-3]."

#: src/ch11-06-inlining-in-cairo.md:182
msgid ""
"The line 4 is the inlined code of the `inlined` function, which returns `1` "
"and stores it at the final location `[ap-2]`. We clearly see that there is "
"no `call` instruction in this case, because the body of the function is "
"inserted and directly executed."
msgstr ""
"Garis 4 adalah kode yang diinline dari fungsi ·inlined, yang kembali ke "
"nomor 1 dan menyimpannya di lokasi akhir [ap-2]. kita melihat dengan jelas "
"bahwa tidak ada instruksi ·callé dalam kasus ini, karena badan fungsi "
"dimasukkan dan langsung dieksekusi."

#: src/ch11-06-inlining-in-cairo.md:183
msgid ""
"After that, the sum is computed and we ultimately go back to the line 2 "
"which contains the final `ret` instruction that returns the sum, "
"corresponding to the return value of the `main` function."
msgstr ""
"Setelah itu, jumlahnya dihitung dan kami akhirnya kembali ke baris 2 yang "
"berisi instruksi terakhir yang mengembalikan jumlah tersebut, sesuai dengan "
"nilai kembali fungsinya."

#: src/ch11-06-inlining-in-cairo.md:185
msgid ""
"It is interesting to note that in both Sierra code and Casm code, the "
"`not_inlined` function will be called and executed before the body of the "
"`inlined` function, even though the Cairo program executes `inlined() + "
"not_inlined()`."
msgstr ""
"Sangat menarik untuk dicatat bahwa dalam kode Sierra maupun kode Casm, "
"fungsi ·not_inlined) akan disebut dan dieksekusi sebelum tubuh fungsi "
"Áinlined, meskipun program Cairo mengeksekusi Áinlined®) + bukan_inlined "
"Allah."

#: src/ch11-06-inlining-in-cairo.md:187
msgid ""
"The Casm code of our program clearly shows that there is a function call for"
" the `not_inlined` function, while the `inlined` function is correctly "
"inlined."
msgstr ""
"Kode Casm dari program kami dengan jelas menunjukkan bahwa ada panggilan "
"fungsi untuk fungsi ånot_inlinedé, sementara fungsi ·inlinedé benar-benar "
"diinline."

#: src/ch11-06-inlining-in-cairo.md:189
msgid "Additional Optimizations"
msgstr "Optimasi Tambahan"

#: src/ch11-06-inlining-in-cairo.md:191
msgid ""
"Let's study another program that shows other benefits that inlining may "
"sometimes provide. Listing 11-4 shows a Cairo program that calls 2 functions"
" and doesn't return anything:"
msgstr ""
"Mari kita mempelajari program lain yang menunjukkan manfaat lain bahwa "
"inlining kadang-kadang dapat menyediakan."

#: src/ch11-06-inlining-in-cairo.md:210
msgid ""
"<span class=\"caption\">Listing 11-4: A small Cairo program that calls "
"`inlined` and `not_inlined` and doesn't return any value.</span>"
msgstr ""
"<span class=\"caption\">Listing 11-4: Sebuah program Cairo kecil yang "
"memanggil [inlined] dan tidak_inlinedán dan tidak mengembalikan nilai "
"apapun.</span>"

#: src/ch11-06-inlining-in-cairo.md:212
msgid "Here is the corresponding Sierra code:"
msgstr "Berikut ini adalah kode Sierra yang sesuai:"

#: src/ch11-06-inlining-in-cairo.md:245
msgid ""
"In this specific case, we can observe that the compiler has applied "
"additional optimizations to the `main` function of our code : the code of "
"the `inlined` function, which is annotated with the `#[inline(always)]` "
"attribute, is actually not copied in the `main` function. Instead, the "
"`main` function starts with the `function_call` libfunc to call the "
"`not_inlined` function, entirely omitting the code of the `inlined` "
"function."
msgstr ""
"Dalam kasus spesifik ini, kita dapat mengamati bahwa kompiler telah "
"menerapkan optimasi tambahan untuk fungsi kode kita: kode dari fungsi "
"·inlined, yang telah dianotasi dengan fungsi ▪#[inline kalians] atribut "
"tambahan, sebenarnya tidak disalin dalam fungsi thosemain. Sebaliknya, "
"fungsi ·mainía dimulai dengan fungsi fungsi fungsi fungsi fungsi "
"ófunction_call libfunc untuk memanggil fungsi åno_inlined, seluruhnya "
"menghilangkan kode fungsi ıinlined."

#: src/ch11-06-inlining-in-cairo.md:247
msgid ""
"Because `inlined` return value is never used, the compiler optimizes the "
"`main` function by skipping the `inlined` function code. This will actually "
"reduce the code length while reducing the number of steps required to "
"execute `main`."
msgstr ""
"Karena nilai kembali yang diinline tidak pernah digunakan, kompiler "
"mengoptimalkan fungsi ımain dengan melewatkan kode fungsi ·inlined. Ini akan"
" benar-benar mengurangi panjang kode ketika mengurangi jumlah langkah yang "
"diperlukan untuk mengeksekusi ·main."

#: src/ch11-06-inlining-in-cairo.md:249
msgid ""
"In contrast, line 0 uses the `function_call` libfunc to execute the "
"`not_inlined` function normally. This means that all the code from lines 7 "
"to 8 will be executed:"
msgstr ""
"Sebagai kontras, baris 0 menggunakan fungsi dari libfunc untuk menjalankan "
"fungsi yang tidak terinline secara normal. Ini berarti bahwa semua kode dari"
" baris 7 sampai 8 akan dijalankan:"

#: src/ch11-06-inlining-in-cairo.md:256
msgid ""
"This value stored in the variable with id `0` is then dropped on line 1, as "
"it is not used in the `main` function:"
msgstr ""
"Nilai ini disimpan dalam variabel dengan id those0 kemudian didrop di baris "
"1, karena tidak digunakan dalam fungsi åmain:"

#: src/ch11-06-inlining-in-cairo.md:262
msgid ""
"Finally, as the `main` function doesn't return any value, a variable of unit"
" type `()` is created and returned:"
msgstr ""
"Akhirnya, karena fungsi ımain tidak mengembalikan nilai apapun, sebuah "
"variabel dari tipe satuan diciptakan dan dikembalikan:"

#: src/ch11-06-inlining-in-cairo.md:271
msgid ""
"Inlining is a compiler optimization technique that can be very useful in "
"various situations. Inlining a function allows to get rid of the overhead of"
" calling a function with the `function_call` libfunc by injecting the Sierra"
" code directly in the caller function's context, while potentially "
"optimizing the Sierra code executed to reduce the number of steps. If used "
"effectively, inlining can even reduce code length as shown in the previous "
"example."
msgstr ""
"Inlining adalah teknik compiler optimasi yang dapat sangat berguna dalam "
"berbagai situasi. Menginlining sebuah fungsi memungkinkan untuk menghapus "
"overhead dari memanggil sebuah fungsi dengan libfunc æui dengan menyuntikkan"
" kode Sierra langsung dalam konteks fungsi pemanggil, sementara berpotensi "
"mengoptimalisasi kode Sierra dieksekusi untuk mengurangi jumlah langkah. "
"Jika digunakan secara efektif, inlining bahkan dapat mengurangi panjang kode"
" seperti yang ditunjukkan dalam contoh sebelumnya."

#: src/ch11-06-inlining-in-cairo.md:273
msgid ""
"Nevertheless, applying the `inline` attribute to a function with a lot of "
"code and few parameters might result in an increased code size, especially "
"if the inlined function is used many times in the codebase. Use inlining "
"only where it makes sense, and be aware that the compiler handles inlining "
"by default. Therefore, manually applying inlining is not recommended in most"
" situations, but can help improve and fine-tune your code's behavior."
msgstr ""
"Namun demikian, menerapkan atribut æinline (inline) pada sebuah fungsi "
"dengan banyak kode dan beberapa parameter mungkin menghasilkan peningkatan "
"ukuran kode, terutama jika fungsi inline digunakan berkali-kali dalam basis "
"kode. Gunakan inlining hanya di mana ia masuk akal, dan menyadari bahwa "
"kompiler menangani inlining secara baku. Oleh karena itu, secara manual "
"menerapkan inlining tidak disarankan dalam banyak situasi, tetapi dapat "
"membantu meningkatkan dan menyempurnakan perilaku kode Anda."

#: src/ch11-08-printing.md:3
msgid ""
"When writing a program, it is quite common to print some data to the "
"console, either for the normal process of the program or for debugging "
"purpose. In this chapter, we describe the options you have to print simple "
"and complex data types."
msgstr ""
"Ketika menulis sebuah program, cukup umum untuk mencetak beberapa data ke "
"konsol, baik untuk proses normal dari program atau untuk tujuan debugging. "
"Dalam bab ini, kami menjelaskan pilihan yang harus Anda tampilkan tipe data "
"yang sederhana dan kompleks."

#: src/ch11-08-printing.md:5
msgid "Printing Standard Data Types"
msgstr "Tipe Data Standar Pencetakan"

#: src/ch11-08-printing.md:7
msgid "Cairo provides two macros to print standard data types:"
msgstr "Cairo menyediakan dua makro untuk mencetak tipe data standar:"

#: src/ch11-08-printing.md:9
msgid "`println!` which prints on a new line"
msgstr "Sidik jari yang mana di jalur yang baru."

#: src/ch11-08-printing.md:10
msgid "`print!` with inline printing"
msgstr "Cetak! Dengan pencetakan inline"

#: src/ch11-08-printing.md:12
msgid ""
"Both take a `ByteArray` string as first parameter (see [Data "
"Types](./ch02-02-data-types.md#byte-array-strings)), which can be a simple "
"string to print a message or a string with placeholders to format the way "
"values are printed."
msgstr ""
"Keduanya mengambil string ·ByteArray) sebagai parameter pertama (lihat [Data"
" Types]↑./ch02-02-data-types.md#byte-array-strings), yang dapat berupa "
"string sederhana untuk mencetak pesan atau string dengan pemegang tempat "
"untuk memformat nilai yang dicetak."

#: src/ch11-08-printing.md:14
msgid "There are two ways to use these placeholders and both can be mixed:"
msgstr ""
"Ada dua cara untuk menggunakan pemegang tempat ini dan keduanya dapat "
"dicampur:"

#: src/ch11-08-printing.md:16
msgid ""
"empty curly brackets `{}` are replaced by values given as parameters to the "
"`print!` macro, in the same order."
msgstr ""
"braket keriting kosong {}diganti dengan nilai yang diberikan sebagai "
"parameter untuk cetak! makro, dalam urutan yang sama."

#: src/ch11-08-printing.md:17
msgid ""
"curly brackets with variable names are directly replaced by the variable "
"value."
msgstr ""
"braket keriting dengan nama variabel langsung digantikan oleh nilai "
"variabel."

#: src/ch11-08-printing.md:19
msgid "Here are some examples:"
msgstr "Berikut beberapa contohnya:"

#: src/ch11-08-printing.md:27
msgid "\"Hello world!\""
msgstr "\"Halo dunia!\""

#: src/ch11-08-printing.md:28
msgid "\"{} {} {}\""
msgstr "[{] [] [}]\""

#: src/ch11-08-printing.md:28
msgid "// 10 20 30\n"
msgstr "/ 10 20 30\n"

#: src/ch11-08-printing.md:29
msgid "\"{c} {a} {}\""
msgstr "\"{c} {a} {}\""

#: src/ch11-08-printing.md:29
msgid "// 30 10 20\n"
msgstr "/ / 30 10 20\n"

#: src/ch11-08-printing.md:33
msgid ""
"`print!` and `println!` macros use the `Display` trait under the hood, and "
"are therefore used to print the value of types that implement it. This is "
"the case for basic data types, but not for more complex ones. If you try to "
"print complex data type values with these macros, e.g. for debugging "
"purposes, you will get an error. In that case, you can either [manually "
"implement](./ch11-08-printing.md#printing-custom-data-types) the `Display` "
"trait for your type or use the `Debug` trait (see "
"[below](./ch11-08-printing.md#print-debug-traces))."
msgstr ""
"Karena itu digunakan untuk mencetak nilai dari tipe yang menerapkannya. Ini "
"adalah kasus untuk tipe data dasar, tapi bukan untuk yang lebih kompleks. "
"Jika Anda mencoba untuk mencetak nilai data kompleks dengan makro ini, "
"misalnya. Untuk tujuan debugging, Anda akan mendapat kesalahan. Dalam hal "
"ini, Anda dapat [biasanya mengimplementasikan] atau menirukan atau "
"menirunya."

#: src/ch11-08-printing.md:39
msgid "Formatting"
msgstr "Pemformatan"

#: src/ch11-08-printing.md:41
msgid ""
"Cairo also provides a useful macro to handle string formatting: `format!`. "
"This macro works like `println!`, but instead of printing the output to the "
"screen, it returns a `ByteArray` with the contents. In the following "
"example, we perform string concatenation using either the `+` operator or "
"the `format!` macro. The version of the code using `format!` is much easier "
"to read, and the code generated by the `format!` macro uses snapshots, so "
"that this call doesn’t take ownership of any of its parameters."
msgstr ""
"Cairo juga menyediakan sebuah makro yang berguna untuk menangani format "
"string: ·format!. Makro ini bekerja seperti ·println!, tapi daripada "
"mencetak keluaran ke layar, ia mengembalikan sebuah string formating: dengan"
" isinya. Dalam contoh berikut, kita melakukan konkatensi string menggunakan "
"operator \\ atau formatat!"

#: src/ch11-08-printing.md:46 src/ch11-08-printing.md:52
msgid "\"tic\""
msgstr "\"tic\""

#: src/ch11-08-printing.md:47 src/ch11-08-printing.md:53
msgid "\"tac\""
msgstr "\"tac\""

#: src/ch11-08-printing.md:48 src/ch11-08-printing.md:54
msgid "\"toe\""
msgstr "\"Toe\""

#: src/ch11-08-printing.md:49
msgid "\"-\""
msgstr "\"-\""

#: src/ch11-08-printing.md:50
msgid "// using + operator consumes the strings, so they can't be used again!\n"
msgstr ""
"//menggunakan + operator mengkonsumsi string, sehingga mereka tidak dapat "
"digunakan lagi!\n"

#: src/ch11-08-printing.md:55
msgid "\"{s1}-{s2}-{s3}\""
msgstr "\"{s1}-{s2}-{s3}\""

#: src/ch11-08-printing.md:55
msgid ""
"// s1, s2, s3 are not consumed by format!\n"
"    // or\n"
msgstr "// s1, s2, s3 tidak dikonsumsi oleh format! // atau\n"

#: src/ch11-08-printing.md:57
msgid "\"{}-{}-{}\""
msgstr "\"{}-{}-{}\""

#: src/ch11-08-printing.md:63
msgid "Printing Custom Data Types"
msgstr "Mencetak Tipe Data Gubahan"

#: src/ch11-08-printing.md:65
msgid ""
"As previously explained, if you try to print the value of a custom data type"
" with `print!` or `println!` macros, you'll get an error telling you that "
"the `Display` trait is not implemented for your custom type:"
msgstr ""
"Seperti yang telah dijelaskan sebelumnya, jika Anda mencoba untuk mencetak "
"nilai dari tipe data kustom dengan cetak! atau pprintln! Anda akan mendapat "
"kesalahan dengan mengatakan bahwa sifat åDisplay tidak diimplementasikan "
"untuk tipe custom Anda:"

#: src/ch11-08-printing.md:71
msgid ""
"The `println!` macro can do many kinds of formatting, and by default, the "
"curly brackets tell `println!` to use formatting known as `Display` - output"
" intended for direct end user consumption. The primitive types we’ve seen so"
" far implement `Display` by default because there’s only one way you’d want "
"to show a `1` or any other primitive type to a user. But with structs, the "
"way `println!` should format the output is less clear because there are more"
" display possibilities: Do we want commas or not? Do we want to print the "
"curly brackets? Should all the fields be shown? Due to this ambiguity, Cairo"
" doesn’t try to guess what we want, and structs don’t have a provided "
"implementation of `Display` to use with `println!` and the `{}` placeholder."
msgstr ""
"makro dapat melakukan berbagai bentuk format, dan secara baku, tanda kurung "
"keriting mengatakan bahwa hanya ada satu cara untuk menampilkan format yang "
"dikenal sebagai display atau tipe primitif lainnya yang ditujukan untuk "
"konsumsi pengguna langsung. Tipe primitif yang kita lihat sejauh ini "
"seharusnya kurang menerapkannya karena ada lebih banyak kemungkinan: Apakah "
"kita ingin mencetak ▪1 jenis sederhana lainnya pada pengguna. tetapi dengan "
"struktur °L:"

#: src/ch11-08-printing.md:73
msgid "Here is the `Display` trait to implement:"
msgstr "Berikut adalah sifat display untuk diterapkan:"

#: src/ch11-08-printing.md:81
msgid ""
"The second parameter `f` is of type `Formatter`, which is just a struct "
"containing a `ByteArray`, representing the pending result of formatting:"
msgstr ""
"Parameter kedua adalah tipe dari formatter, yang hanya struct berisi sebuah "
"▪ByteArray, mewakili hasil tertunda dari format:"

#: src/ch11-08-printing.md:86
msgid "/// The pending result of formatting.\n"
msgstr "/ Hasil tertunda dari pemformatan.\n"

#: src/ch11-08-printing.md:91
msgid ""
"Knowing this, here is an example of how to implement the `Display` trait for"
" a custom `Point` struct:"
msgstr ""
"Mengetahui hal ini, ini adalah contoh bagaimana menerapkan sifat display "
"untuk sebuah struktur kustom:"

#: src/ch11-08-printing.md:104
msgid "\"Point ({}, {})\""
msgstr "\"Point ({}, {})\""

#: src/ch11-08-printing.md:112 src/ch11-08-printing.md:156
msgid "// Point: (1, 3)\n"
msgstr "#/ Point: (1, 3)\n"

#: src/ch11-08-printing.md:116
msgid ""
"Cairo also provides the `write!` and `writeln!` macros to write formatted "
"strings in a formatter. Here is a short example using `write!` macro to "
"concatenate multiple strings on the same line and then print the result:"
msgstr ""
"Cairo juga menyediakan tulisan! dan menulis! macro untuk menulis string "
"terformat dalam sebuah formateri. ini adalah contoh singkat menggunakan "
"tulisan! makro untuk mengkatenasi beberapa string pada baris yang sama dan "
"kemudian mencetak hasilnya:"

#: src/ch11-08-printing.md:126
msgid "\"hello\""
msgstr "\"Halo\""

#: src/ch11-08-printing.md:127
msgid "\"world\""
msgstr "\"Dunia\""

#: src/ch11-08-printing.md:128
msgid "\" {a} {b}\""
msgstr "\" {a} [b}\""

#: src/ch11-08-printing.md:130
msgid "// helloworld 10 20\n"
msgstr "//haloworld 10 20\n"

#: src/ch11-08-printing.md:134
msgid ""
"It is also possible to implement the `Display` trait for the `Point` struct "
"using these macros, as shown here:"
msgstr ""
"Hal ini juga dimungkinkan untuk mengimplementasikan sifat display yang untuk"
" struktur ·Pointe_BAR_ menggunakan makro ini, sebagaimana ditunjukkan di "
"sini:"

#: src/ch11-08-printing.md:150
msgid "\"Point ({x}, {y})\""
msgstr "\"Point ({x}, {y})\""

#: src/ch11-08-printing.md:160
msgid ""
"Printing complex data types this way might not be ideal as it requires "
"additional steps to use the `print!` and `println!` macros. If you need to "
"print complex data types, especially when debugging, use the `Debug` trait "
"described below instead."
msgstr ""
"Mencetak tipe data yang rumit dengan cara ini mungkin tidak ideal karena "
"memerlukan langkah tambahan untuk menggunakan sidik jari! dan makro jika "
"Anda perlu mencetak tipe data kompleks, terutama ketika debug, gunakan sifat"
" debug yang digambarkan di bawah sebagai gantinya."

#: src/ch11-08-printing.md:162
msgid "Print Debug Traces"
msgstr "Cetak Telusuri Debug"

#: src/ch11-08-printing.md:164
msgid ""
"Cairo provides the `Debug` trait, which can be derived to print the value of"
" variables when debugging. Simply add `:?` within the curly brackets `{}` "
"placeholders in a `print!` or `println!` macro string."
msgstr ""
"Cairo menyediakan sifat debug, yang dapat diperoleh untuk mencetak nilai "
"variabel ketika debug. Cukup tambahkan ·gt;??"

#: src/ch11-08-printing.md:166
msgid ""
"This trait is very useful and is implemented by default for basic data "
"types. It can also be simply derived for complex data types using the "
"`#[derive(Debug)]` attribute, as long as all types they contain implement "
"it. This eliminates the need to manually implement extra code to print "
"complex data types."
msgstr ""
"Sifat ini sangat berguna dan diimplementasikan secara default untuk tipe "
"data dasar. Ini juga dapat hanya diturunkan untuk tipe data kompleks "
"menggunakan atribut åDebug \"# [derive]], asalkan semua tipe mengandungnya "
"yang mengimplementasikannya. Ini menghilangkan kebutuhan secara manual untuk"
" mengimplementasikan kode ekstra untuk menampilkan tipe data kompleks."

#: src/ch11-08-printing.md:168
msgid ""
"Note that `assert_xx!` macros used in tests require the provided values to "
"implement the `Debug` trait, as they also print the result in case of "
"assertion failure."
msgstr ""
"Perhatikan bahwa makro yang digunakan dalam tes itu membutuhkan nilai - "
"nilai yang disediakan untuk mengimplementasikan sifat åDebug, karena mereka "
"juga mencetak hasilnya dalam kasus kegagalan pernyataan."

#: src/ch11-08-printing.md:170
msgid ""
"For more details about the `Debug` trait and its usage for printing values "
"when debugging, please refer to the [Derivable "
"Traits](./appendix-03-derivable-traits.md#debug-trait-for-printing-and-"
"debugging) appendix."
msgstr ""
"Untuk rincian lebih lanjut tentang sifat åDebug dan penggunaannya untuk "
"mencetak nilai ketika debugging, silakan merujuk ke apendiks [Barat Dapat "
"Diizinkan]./apendix-03-derivable-traits.md#debug-trait-for-printing-and-"
"debuging)."

#: src/appendix-00.md
msgid ""
"The following sections contain reference material you may find useful in "
"your Cairo journey."
msgstr ""
"Bagian - bagian berikut memuat bahan referensi yang mungkin berguna bagi "
"perjalanan Anda di Cairo."

#: src/appendix-01-keywords.md:1
msgid "Appendix A - Keywords"
msgstr "Lampiran A - Kata Kunci"

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or future"
" use by the Cairo language."
msgstr ""
"Daftar berikut berisi kata kunci yang dikhususkan untuk penggunaan bahasa "
"Cairo saat ini atau di masa depan."

#: src/appendix-01-keywords.md:5
msgid "There are three keyword categories:"
msgstr "Ada tiga kategori kata kunci:"

#: src/appendix-01-keywords.md:7
msgid "strict"
msgstr "ketat"

#: src/appendix-01-keywords.md:8
msgid "loose"
msgstr "lepas"

#: src/appendix-01-keywords.md:9
msgid "reserved"
msgstr "Terresered"

#: src/appendix-01-keywords.md:11
msgid ""
"There is a fourth category, which are functions from the core library. While"
" their names are not reserved, they are not recommended to be used as names "
"of any items to follow good practices."
msgstr ""
"Ada kategori keempat, yang merupakan fungsi dari perpustakaan inti. "
"sedangkan nama mereka tidak dipesan, mereka tidak disarankan untuk digunakan"
" sebagai nama dari setiap item untuk mengikuti praktek yang baik."

#: src/appendix-01-keywords.md:16
msgid "Strict keywords"
msgstr "Kata kunci ketat"

#: src/appendix-01-keywords.md:18
msgid ""
"These keywords can only be used in their correct contexts. They cannot be "
"used as names of any items."
msgstr ""
"Kata kunci ini hanya dapat digunakan dalam konteks yang benar. Mereka tidak "
"dapat digunakan sebagai nama dari setiap butir."

#: src/appendix-01-keywords.md:21
msgid "`as` - Rename import"
msgstr "Mengimpor ganti nama"

#: src/appendix-01-keywords.md:22
msgid "`break` - Exit a loop immediately"
msgstr "- Keluar dari loop segera"

#: src/appendix-01-keywords.md:23
msgid "`const` - Define constant items"
msgstr "- Definisikan konstanta item"

#: src/appendix-01-keywords.md:24
msgid "`continue` - Continue to the next loop iteration"
msgstr "Lanjutkan ke iterasi loop berikutnya"

#: src/appendix-01-keywords.md:25
msgid "`else` - Fallback for `if` and `if let` control flow constructs"
msgstr ""
"Jika Anda membiarkan kontrol struktur aliran, Anda akan mendapatkan kembali."

#: src/appendix-01-keywords.md:26
msgid "`enum` - Define an enumeration"
msgstr "- Definisikan sebuah enumerasi"

#: src/appendix-01-keywords.md:27
msgid ""
"`extern` - Function defined at the compiler level that can be compiled to "
"CASM"
msgstr ""
"- Fungsi terdefinisi pada tingkat kompiler yang dapat dikompilasi ke CASM"

#: src/appendix-01-keywords.md:28
msgid "`false` - Boolean false literal"
msgstr "- Boolean palsu literal"

#: src/appendix-01-keywords.md:29
msgid "`fn` - Define a function"
msgstr "- Definisikan sebuah fungsi"

#: src/appendix-01-keywords.md:30
msgid "`if` - Branch based on the result of a conditional expression"
msgstr "- Cabang berdasarkan hasil dari ekspresi kondisional"

#: src/appendix-01-keywords.md:31
msgid "`impl` - Implement inherent or trait functionality"
msgstr "Implementasi bawaan atau sifat fungsionalitas"

#: src/appendix-01-keywords.md:32
msgid ""
"`implicits` - Special kind of function parameters that are required to "
"perform certain actions"
msgstr ""
"- Jenis khusus parameter fungsi yang diperlukan untuk melakukan tindakan "
"tertentu"

#: src/appendix-01-keywords.md:33
msgid "`let` - Bind a variable"
msgstr "- Bind a variabel"

#: src/appendix-01-keywords.md:34
msgid "`loop` - Loop unconditionally"
msgstr "- Loop tanpa syarat."

#: src/appendix-01-keywords.md:35
msgid "`match` - Match a value to patterns"
msgstr "- Cocokkan dengan pola"

#: src/appendix-01-keywords.md:36
msgid "`mod` - Define a module"
msgstr "- Definisikan sebuah modul"

#: src/appendix-01-keywords.md:37
msgid "`mut` - Denote variable mutability"
msgstr "- Variabel Kemunafikan Denote"

#: src/appendix-01-keywords.md:38
msgid ""
"`nopanic` - Functions marked with this notation mean that the function will "
"never panic."
msgstr ""
"▪nopanic å - Fungsi yang ditandai dengan notasi ini berarti bahwa fungsi "
"tersebut tidak akan pernah panik."

#: src/appendix-01-keywords.md:39
msgid "`of` - Implement a trait"
msgstr "- Menimplementasi sebuah sifat"

#: src/appendix-01-keywords.md:40
msgid ""
"`pub` - Denote public visibility in items, such as struct and struct fields,"
" enums, consts, traits and impl blocks, or modules"
msgstr ""
"▪pubé - Memberikan visibilitas publik pada barang, seperti struct and struct"
" fields, enums, consts, ciri dan impl blocks, atau modul"

#: src/appendix-01-keywords.md:41
msgid "`ref` - Parameter passed implicitly returned at the end of a function"
msgstr ""
"- Parameter dilewatkan secara implisit kembali pada akhir sebuah fungsi"

#: src/appendix-01-keywords.md:42
msgid "`return` - Return from function"
msgstr "Kembali dari fungsi"

#: src/appendix-01-keywords.md:43
msgid "`struct` - Define a structure"
msgstr "- Definisikan struktur"

#: src/appendix-01-keywords.md:44
msgid "`trait` - Define a trait"
msgstr "- Tentukan sifat."

#: src/appendix-01-keywords.md:45
msgid "`true` - Boolean true literal"
msgstr "- Boolean benar-benar literal"

#: src/appendix-01-keywords.md:46
msgid "`type` - Define a type alias"
msgstr "- Definisikan sebuah tipe alias"

#: src/appendix-01-keywords.md:47
msgid "`use` - Bring symbols into scope"
msgstr "- Bawa simbol ke dalam ruang lingkup"

#: src/appendix-01-keywords.md:48
msgid "`while` - loop conditionally based on the result of an expression"
msgstr ""
"Sementara itu - loop secara kondisional berdasarkan hasil dari sebuah "
"ekspresi"

#: src/appendix-01-keywords.md:52
msgid "Loose Keywords"
msgstr "Kata Kunci Loose"

#: src/appendix-01-keywords.md:54
msgid ""
"These keywords are associated with a specific behaviour, but can also be "
"used to define items."
msgstr ""
"Kata kunci ini dikaitkan dengan perilaku tertentu, tetapi juga dapat "
"digunakan untuk mendefinisikan item."

#: src/appendix-01-keywords.md:56
msgid "`self` - Method subject"
msgstr "- Masalah metode"

#: src/appendix-01-keywords.md:57
msgid "`super` - Parent module of the current module"
msgstr "- Modul induk modul modul saat ini"

#: src/appendix-01-keywords.md:61
msgid "Reserved Keywords"
msgstr "Kata Kunci Yang Dicadangkan"

#: src/appendix-01-keywords.md:63
msgid ""
"These keywords aren't used yet, but they are reserved for future use. For "
"now, it is possible to use them to define items, although it is highly "
"recommended not to do so. The reasoning behind this recommendation is to "
"make current programs forward compatible with future versions of Cairo by "
"forbidding them to use these keywords."
msgstr ""
"Kata kunci ini belum digunakan, tetapi dikhususkan untuk penggunaan di masa "
"depan. Untuk sekarang, mungkin untuk menggunakannya untuk mendefinisikan "
"item, walaupun sangat dianjurkan untuk tidak melakukannya. Alasan di balik "
"rekomendasi ini adalah untuk membuat program saat ini sesuai dengan versi "
"berikutnya Cairo dengan melarang mereka menggunakan kata kunci ini."

#: src/appendix-01-keywords.md:68
msgid "`Self`"
msgstr "Selfé"

#: src/appendix-01-keywords.md:69
msgid "`do`"
msgstr "Jadi, apa yang harus kita lakukan?"

#: src/appendix-01-keywords.md:70
msgid "`dyn`"
msgstr "[ Gambar di hlm."

#: src/appendix-01-keywords.md:71
msgid "`for`"
msgstr "Untuk itu."

#: src/appendix-01-keywords.md:72
msgid "`hint`"
msgstr "Oh, tidak."

#: src/appendix-01-keywords.md:73
msgid "`in`"
msgstr "Dalam hal tertentu."

#: src/appendix-01-keywords.md:74
msgid "`macro`"
msgstr "(Naikro)"

#: src/appendix-01-keywords.md:75
msgid "`move`"
msgstr "Pergi dari sini."

#: src/appendix-01-keywords.md:76
msgid "`static_assert`"
msgstr "S_asser_statis"

#: src/appendix-01-keywords.md:77
msgid "`static`"
msgstr "Aku tidak tahu apa-apa."

#: src/appendix-01-keywords.md:78
msgid "`try`"
msgstr "Coba saja."

#: src/appendix-01-keywords.md:79
msgid "`typeof`"
msgstr "Seperti itulah."

#: src/appendix-01-keywords.md:80
msgid "`unsafe`"
msgstr "Aku tidak tahu apa yang harus dilakukan."

#: src/appendix-01-keywords.md:81
msgid "`where`"
msgstr "Di mana aku berada?"

#: src/appendix-01-keywords.md:82
msgid "`with`"
msgstr "Dengan apa?"

#: src/appendix-01-keywords.md:83
msgid "`yield`"
msgstr "[ Gambar di hlm."

#: src/appendix-01-keywords.md:87
msgid "Built-in Functions"
msgstr "Fungsi Bawaan"

#: src/appendix-01-keywords.md:89
msgid ""
"The Cairo programming language provides several specific functions that "
"serve a special purpose. We will not cover all of them in this book, but "
"using the names of these functions as names of other items is not "
"recommended."
msgstr ""
"Bahasa pemrograman Cairo menyediakan beberapa fungsi spesifik yang memiliki "
"tujuan khusus. kami tidak akan menutup semuanya dalam buku ini, tetapi "
"menggunakan nama fungsi ini sebagai nama dari item lain tidak dianjurkan."

#: src/appendix-01-keywords.md:91
msgid ""
"`assert` - This function checks a boolean expression, and if it evaluates to"
" false, it triggers the panic function."
msgstr ""
"- Fungsi ini memeriksa ekspresi boolean, dan jika dievaluasi untuk palsu, "
"itu memicu fungsi panik."

#: src/appendix-01-keywords.md:92
msgid ""
"`panic` - This function acknowledges the occurrence of an error and "
"terminates the program."
msgstr "- Fungsi ini mengakui terjadinya kesalahan dan mengakhiri program."

#: src/appendix-02-operators-and-symbols.md:1
msgid "Appendix B - Operators and Symbols"
msgstr "Lampiran B - Operator dan Simbol"

#: src/appendix-02-operators-and-symbols.md:3
msgid ""
"This appendix contains a glossary of Cairo's syntax, including operators and"
" other symbols that appear by themselves or in the context of paths, "
"generics, macros, attributes, comments, tuples, and brackets."
msgstr ""
"Apendiks ini berisi glossary sintaks Cairo, termasuk operator dan simbol "
"lain yang muncul sendiri atau dalam konteks jalur, generik, makro, atribut, "
"komentar, tuples, dan kurung."

#: src/appendix-02-operators-and-symbols.md:5
msgid "Operators"
msgstr "Operator"

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr ""
"Tabel B-1 berisi operator di Cairo, contoh bagaimana operator akan muncul "
"dalam konteks, penjelasan singkat, dan apakah operator yang overloadable. "
"Jika operator kelebihan beban, sifat relevan untuk digunakan untuk overload "
"operator yang terdaftar."

#: src/appendix-02-operators-and-symbols.md:9
msgid "Operator"
msgstr "Operator"

#: src/appendix-02-operators-and-symbols.md:9
#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:66
#: src/appendix-02-operators-and-symbols.md:76
#: src/appendix-02-operators-and-symbols.md:89
#: src/appendix-02-operators-and-symbols.md:120
#: src/appendix-02-operators-and-symbols.md:146
#: src/appendix-02-operators-and-symbols.md:154
#: src/appendix-02-operators-and-symbols.md:168
msgid "Explanation"
msgstr "Penjelasan"

#: src/appendix-02-operators-and-symbols.md:9
msgid "Overloadable?"
msgstr "Berlebihan?"

#: src/appendix-02-operators-and-symbols.md:11
msgid "`!`"
msgstr "Oh, Tuhan."

#: src/appendix-02-operators-and-symbols.md:11
msgid "`!expr`"
msgstr "! Expré!"

#: src/appendix-02-operators-and-symbols.md:11
msgid "Logical complement"
msgstr "komplemen Logis"

#: src/appendix-02-operators-and-symbols.md:11
msgid "`Not`"
msgstr "Tidak ada."

#: src/appendix-02-operators-and-symbols.md:12
msgid "`~`"
msgstr "Aku tidak tahu apa-apa."

#: src/appendix-02-operators-and-symbols.md:12
msgid "`~expr`"
msgstr "Aku tidak tahu apa yang akan terjadi."

#: src/appendix-02-operators-and-symbols.md:12
msgid "Bitwise NOT"
msgstr "Jangan Bitwise"

#: src/appendix-02-operators-and-symbols.md:12
msgid "`BitNot`"
msgstr "BitNoté"

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!=`"
msgstr "Aku tidak tahu apa-apa."

#: src/appendix-02-operators-and-symbols.md:13
msgid "`expr != expr`"
msgstr "Expr!= expré"

#: src/appendix-02-operators-and-symbols.md:13
msgid "Non-equality comparison"
msgstr "Pembandingan bukan kualitas"

#: src/appendix-02-operators-and-symbols.md:13
#: src/appendix-02-operators-and-symbols.md:38
msgid "`PartialEq`"
msgstr "PartialEq"

#: src/appendix-02-operators-and-symbols.md:14
msgid "`%`"
msgstr "Jadi, apa yang akan kau lakukan?"

#: src/appendix-02-operators-and-symbols.md:14
msgid "`expr % expr`"
msgstr "expr % exprå"

#: src/appendix-02-operators-and-symbols.md:14
msgid "Arithmetic remainder"
msgstr "Sisa Aritmatika"

#: src/appendix-02-operators-and-symbols.md:14
msgid "`Rem`"
msgstr "Remé."

#: src/appendix-02-operators-and-symbols.md:15
msgid "`%=`"
msgstr "0) \\k20}fs-type"

#: src/appendix-02-operators-and-symbols.md:15
msgid "`var %= expr`"
msgstr "▪var %= exprNeal"

#: src/appendix-02-operators-and-symbols.md:15
msgid "Arithmetic remainder and assignment"
msgstr "Sisa dan tugas Aritmatika"

#: src/appendix-02-operators-and-symbols.md:15
msgid "`RemEq`"
msgstr "RemEq"

#: src/appendix-02-operators-and-symbols.md:16
msgid "`&`"
msgstr ""
"&lt;br /&gt;Oh, Tuhan!&lt;/font&gt; &lt;font color=\"#ffff00\"&gt;Apa yang "
"kau lakukan?&lt;/font&gt; &lt;font color=\"#ffff00\"&gt;Apa yang kau "
"lakukan?&lt;/font&gt; &lt;font color=\"#ffff00\"&gt;Apa yang kau "
"lakukan?&lt;/font&gt; &lt;font color=\"#ffff00\"&gt;Apa?&lt;/font&gt; "
"&lt;font color=\"#ffff00\"&gt;Apa?"

#: src/appendix-02-operators-and-symbols.md:16
msgid "`expr & expr`"
msgstr "▪expr & exprå"

#: src/appendix-02-operators-and-symbols.md:16
msgid "Bitwise AND"
msgstr "\"Addwise AND\""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`BitAnd`"
msgstr "BitAndrofs-type"

#: src/appendix-02-operators-and-symbols.md:17
msgid "`&&`"
msgstr ""
"&lt;/font&gt; &lt;font color=\"#ffff00\"&gt;- Ya.&lt;/font&gt; &lt;font "
"color=\"#ffff00\"&gt;Apa yang kau lakukan?&lt;/font&gt; &lt;font "
"color=\"#ffff00\"&gt;Apa yang kau lakukan?&lt;/font&gt; &lt;font "
"color=\"#ffff00\"&gt;Apa?"

#: src/appendix-02-operators-and-symbols.md:17
msgid "`expr && expr`"
msgstr "expr && expré"

#: src/appendix-02-operators-and-symbols.md:17
msgid "Short-circuiting logical AND"
msgstr "Short-cirching logical AND"

#: src/appendix-02-operators-and-symbols.md:18
#: src/appendix-02-operators-and-symbols.md:21
msgid "`*`"
msgstr "Oh, Tuhan."

#: src/appendix-02-operators-and-symbols.md:18
msgid "`expr * expr`"
msgstr "Expr * expré"

#: src/appendix-02-operators-and-symbols.md:18
msgid "Arithmetic multiplication"
msgstr "Perkalian Aritmatika"

#: src/appendix-02-operators-and-symbols.md:18
msgid "`Mul`"
msgstr "Mol."

#: src/appendix-02-operators-and-symbols.md:19
msgid "`*=`"
msgstr "Ah, ya."

#: src/appendix-02-operators-and-symbols.md:19
msgid "`var *= expr`"
msgstr "Árvar *= expré"

#: src/appendix-02-operators-and-symbols.md:19
msgid "Arithmetic multiplication and assignment"
msgstr "Perkalian dan tugas Aritmetik"

#: src/appendix-02-operators-and-symbols.md:19
msgid "`MulEq`"
msgstr "MolEq"

#: src/appendix-02-operators-and-symbols.md:20
msgid "`@`"
msgstr "Jadi, saya akan pergi ke suatu tempat di sini."

#: src/appendix-02-operators-and-symbols.md:20
msgid "`@var`"
msgstr "."

#: src/appendix-02-operators-and-symbols.md:20
msgid "Snapshot"
msgstr "Snapshot"

#: src/appendix-02-operators-and-symbols.md:21
msgid "`*var`"
msgstr "*var*"

#: src/appendix-02-operators-and-symbols.md:21
msgid "Desnap"
msgstr "Desnap"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`+`"
msgstr "Aku tidak tahu apa-apa tentang hal itu."

#: src/appendix-02-operators-and-symbols.md:22
msgid "`expr + expr`"
msgstr "- Expr + expr--"

#: src/appendix-02-operators-and-symbols.md:22
msgid "Arithmetic addition"
msgstr "Tambahan Aritmatika"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`Add`"
msgstr "Tambahkan"

#: src/appendix-02-operators-and-symbols.md:23
msgid "`+=`"
msgstr "Aku tidak tahu apa yang akan terjadi."

#: src/appendix-02-operators-and-symbols.md:23
msgid "`var += expr`"
msgstr "▪var += exprå"

#: src/appendix-02-operators-and-symbols.md:23
msgid "Arithmetic addition and assignment"
msgstr "Tambahan dan tugas Aritmatika"

#: src/appendix-02-operators-and-symbols.md:23
msgid "`AddEq`"
msgstr "TINGGALKAN SIFAT"

#: src/appendix-02-operators-and-symbols.md:24
msgid "`,`"
msgstr "Ya, ya."

#: src/appendix-02-operators-and-symbols.md:24
msgid "`expr, expr`"
msgstr "Expr, expré"

#: src/appendix-02-operators-and-symbols.md:24
msgid "Argument and element separator"
msgstr "Argumen dan pemisah elemen"

#: src/appendix-02-operators-and-symbols.md:25
#: src/appendix-02-operators-and-symbols.md:26
msgid "`-`"
msgstr "Aku tidak tahu apa-apa tentang hal itu."

#: src/appendix-02-operators-and-symbols.md:25
msgid "`-expr`"
msgstr "- Expré."

#: src/appendix-02-operators-and-symbols.md:25
msgid "Arithmetic negation"
msgstr "Negatif Aritmetik"

#: src/appendix-02-operators-and-symbols.md:25
msgid "`Neg`"
msgstr "Tidak."

#: src/appendix-02-operators-and-symbols.md:26
msgid "`expr - expr`"
msgstr "[ Gambar di hlm."

#: src/appendix-02-operators-and-symbols.md:26
msgid "Arithmetic subtraction"
msgstr "pengurangan Aritmetik"

#: src/appendix-02-operators-and-symbols.md:26
msgid "`Sub`"
msgstr "Jadi, mari kita lihat apa yang akan kita lakukan."

#: src/appendix-02-operators-and-symbols.md:27
msgid "`-=`"
msgstr "Aku tidak tahu apa yang akan terjadi."

#: src/appendix-02-operators-and-symbols.md:27
msgid "`var -= expr`"
msgstr "▪var -= exprå"

#: src/appendix-02-operators-and-symbols.md:27
msgid "Arithmetic subtraction and assignment"
msgstr "pengurangan dan tugas Aritmetik"

#: src/appendix-02-operators-and-symbols.md:27
msgid "`SubEq`"
msgstr "[SubEq]"

#: src/appendix-02-operators-and-symbols.md:28
msgid "`->`"
msgstr "Aku tidak tahu apa-apa tentang hal itu."

#: src/appendix-02-operators-and-symbols.md:28
msgid "`fn(...) -> type`, <code>\\|...\\| -> type</code>"
msgstr "-> tipe, <kode>\\Negara -> tipe</kode>"

#: src/appendix-02-operators-and-symbols.md:28
msgid "Function and closure return type"
msgstr "Fungsi dan tipe kembali penutupan"

#: src/appendix-02-operators-and-symbols.md:29
msgid "`.`"
msgstr "Aku tidak tahu apa-apa tentang hal itu."

#: src/appendix-02-operators-and-symbols.md:29
msgid "`expr.ident`"
msgstr "Expr.ident those.expr.ident"

#: src/appendix-02-operators-and-symbols.md:29
msgid "Member access"
msgstr "Akses anggota"

#: src/appendix-02-operators-and-symbols.md:30
msgid "`/`"
msgstr "Jadi, apa yang akan Anda lakukan?"

#: src/appendix-02-operators-and-symbols.md:30
msgid "`expr / expr`"
msgstr "- Expr - Expr--"

#: src/appendix-02-operators-and-symbols.md:30
msgid "Arithmetic division"
msgstr "Pembagian Aritmatika"

#: src/appendix-02-operators-and-symbols.md:30
msgid "`Div`"
msgstr "(Divé)"

#: src/appendix-02-operators-and-symbols.md:31
msgid "`/=`"
msgstr "Aku tidak tahu apa yang akan terjadi."

#: src/appendix-02-operators-and-symbols.md:31
msgid "`var /= expr`"
msgstr "▪var /= exprå"

#: src/appendix-02-operators-and-symbols.md:31
msgid "Arithmetic division and assignment"
msgstr "Divisi Aritmetik dan tugas"

#: src/appendix-02-operators-and-symbols.md:31
msgid "`DivEq`"
msgstr "[DivEq]"

#: src/appendix-02-operators-and-symbols.md:32
#: src/appendix-02-operators-and-symbols.md:33
msgid "`:`"
msgstr "Jadi, apa yang akan Anda lakukan?"

#: src/appendix-02-operators-and-symbols.md:32
msgid "`pat: type`, `ident: type`"
msgstr "±pat: tipe ±, ±ident: tipe"

#: src/appendix-02-operators-and-symbols.md:32
msgid "Constraints"
msgstr "Kendala"

#: src/appendix-02-operators-and-symbols.md:33
msgid "`ident: expr`"
msgstr "- Expré."

#: src/appendix-02-operators-and-symbols.md:33
msgid "Struct field initializer"
msgstr "Penginisialisasi ruas struktur"

#: src/appendix-02-operators-and-symbols.md:34
msgid "`;`"
msgstr "Jadi, kita akan pergi ke suatu tempat di mana kita akan pergi."

#: src/appendix-02-operators-and-symbols.md:34
msgid "`expr;`"
msgstr "Ekspr; mereka tidak tahu apa-apa tentang hal itu."

#: src/appendix-02-operators-and-symbols.md:34
msgid "Statement and item terminator"
msgstr "Pengakhir pernyataan dan butir"

#: src/appendix-02-operators-and-symbols.md:35
msgid "`<`"
msgstr "Aku tidak tahu."

#: src/appendix-02-operators-and-symbols.md:35
msgid "`expr < expr`"
msgstr "Expr < exprNeal"

#: src/appendix-02-operators-and-symbols.md:35
msgid "Less than comparison"
msgstr "Kurang dari perbandingan"

#: src/appendix-02-operators-and-symbols.md:35
#: src/appendix-02-operators-and-symbols.md:36
#: src/appendix-02-operators-and-symbols.md:40
#: src/appendix-02-operators-and-symbols.md:41
msgid "`PartialOrd`"
msgstr "Partial Ord"

#: src/appendix-02-operators-and-symbols.md:36
msgid "`<=`"
msgstr "Aku tidak tahu apa yang akan terjadi."

#: src/appendix-02-operators-and-symbols.md:36
msgid "`expr <= expr`"
msgstr "Expr <= exprNeal"

#: src/appendix-02-operators-and-symbols.md:36
msgid "Less than or equal to comparison"
msgstr "Kurang dari atau sama dengan perbandingan"

#: src/appendix-02-operators-and-symbols.md:37
msgid "`=`"
msgstr "Aku tidak tahu apa-apa."

#: src/appendix-02-operators-and-symbols.md:37
msgid "`var = expr`"
msgstr "▪var = exprå"

#: src/appendix-02-operators-and-symbols.md:37
msgid "Assignment"
msgstr "Penugasan"

#: src/appendix-02-operators-and-symbols.md:38
msgid "`==`"
msgstr "-=Syukurlah.=-"

#: src/appendix-02-operators-and-symbols.md:38
msgid "`expr == expr`"
msgstr "Expr == Expré"

#: src/appendix-02-operators-and-symbols.md:38
msgid "Equality comparison"
msgstr "Perbandingan kualitas"

#: src/appendix-02-operators-and-symbols.md:39
msgid "`=>`"
msgstr "-=>Negro=-"

#: src/appendix-02-operators-and-symbols.md:39
msgid "`pat => expr`"
msgstr "åpat => exprNeal"

#: src/appendix-02-operators-and-symbols.md:39
msgid "Part of match arm syntax"
msgstr "Bagian dari sintaks lengan yang cocok"

#: src/appendix-02-operators-and-symbols.md:40
msgid "`>`"
msgstr "Aku tidak tahu apa-apa."

#: src/appendix-02-operators-and-symbols.md:40
msgid "`expr > expr`"
msgstr "[ Gambar di hlm."

#: src/appendix-02-operators-and-symbols.md:40
msgid "Greater than comparison"
msgstr "Lebih besar dari perbandingan"

#: src/appendix-02-operators-and-symbols.md:41
msgid "`>=`"
msgstr "-=Syukurlah.=-"

#: src/appendix-02-operators-and-symbols.md:41
msgid "`expr >= expr`"
msgstr "ESPPR >= exprNeal"

#: src/appendix-02-operators-and-symbols.md:41
msgid "Greater than or equal to comparison"
msgstr "Lebih besar dari atau sama dengan perbandingan"

#: src/appendix-02-operators-and-symbols.md:42
msgid "`^`"
msgstr "Jadi, mari kita lihat apa yang terjadi."

#: src/appendix-02-operators-and-symbols.md:42
msgid "`expr ^ expr`"
msgstr "ESPPR ^ exprNeal"

#: src/appendix-02-operators-and-symbols.md:42
msgid "Bitwise exclusive OR"
msgstr "Eksklusif Bitwise OR"

#: src/appendix-02-operators-and-symbols.md:42
msgid "`BitXor`"
msgstr "(BitXor)"

#: src/appendix-02-operators-and-symbols.md:43
msgid "<code>\\|</code>"
msgstr "<kode>\\æu</kode>"

#: src/appendix-02-operators-and-symbols.md:43
msgid "<code>expr \\| expr</code>"
msgstr "<kode>expr \\pr</kode>"

#: src/appendix-02-operators-and-symbols.md:43
msgid "Bitwise OR"
msgstr "Bitwise OR"

#: src/appendix-02-operators-and-symbols.md:43
msgid "`BitOr`"
msgstr "BitOr"

#: src/appendix-02-operators-and-symbols.md:44
msgid "<code>\\|\\|</code>"
msgstr "<kode>\\Neal\\Neal</kode>"

#: src/appendix-02-operators-and-symbols.md:44
msgid "<code>expr \\|\\| expr</code>"
msgstr "<kode>expr \\___\\pr</kode>"

#: src/appendix-02-operators-and-symbols.md:44
msgid "Short-circuiting logical OR"
msgstr "Sirkuit pendek OR"

#: src/appendix-02-operators-and-symbols.md:45
msgid "`?`"
msgstr "Apa?"

#: src/appendix-02-operators-and-symbols.md:45
msgid "expr?"
msgstr "expr?"

#: src/appendix-02-operators-and-symbols.md:45
msgid "Error propagation"
msgstr "Propagasi galat"

#: src/appendix-02-operators-and-symbols.md:47
msgid "<span class=\"caption\">Table B-1: Operators</span>"
msgstr "<span class=\"caption\">Tabel B-1: Operator</span>"

#: src/appendix-02-operators-and-symbols.md:49
msgid "Non Operator Symbols"
msgstr "Simbol Non Operator"

#: src/appendix-02-operators-and-symbols.md:51
msgid ""
"The following list contains all symbols that are not used as operators; that"
" is, they do not have the same behavior as a function or method call."
msgstr ""
"Daftar berikut berisi semua simbol yang tidak digunakan sebagai operator; "
"yaitu, mereka tidak memiliki perilaku yang sama sebagai fungsi atau "
"panggilan metode."

#: src/appendix-02-operators-and-symbols.md:53
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr ""
"Tabel B-2 menunjukkan simbol yang muncul sendiri dan valid di berbagai "
"lokasi."

#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:66
#: src/appendix-02-operators-and-symbols.md:76
#: src/appendix-02-operators-and-symbols.md:89
#: src/appendix-02-operators-and-symbols.md:120
#: src/appendix-02-operators-and-symbols.md:146
#: src/appendix-02-operators-and-symbols.md:154
msgid "Symbol"
msgstr "Simbol"

#: src/appendix-02-operators-and-symbols.md:57
msgid "`..._u8`, `..._usize`, `..._bool`, etc."
msgstr "..._u8, °C..._Musiasi, ±..._bool, dll."

#: src/appendix-02-operators-and-symbols.md:57
msgid "Numeric literal of specific type"
msgstr "Literal numerik dari tipe spesifik"

#: src/appendix-02-operators-and-symbols.md:58
msgid "`\"...\"`"
msgstr "\"....\""

#: src/appendix-02-operators-and-symbols.md:58
msgid "String literal"
msgstr "String literal"

#: src/appendix-02-operators-and-symbols.md:59
msgid "`'...'`"
msgstr "'...'"

#: src/appendix-02-operators-and-symbols.md:59
msgid "Short string, 31 ASCII characters maximum"
msgstr "String pendek, 31 karakter ASCII maksimum"

#: src/appendix-02-operators-and-symbols.md:60
msgid "`_`"
msgstr "Aku tidak tahu apa-apa."

#: src/appendix-02-operators-and-symbols.md:60
msgid "“Ignored” pattern binding"
msgstr "Pembatas pola"

#: src/appendix-02-operators-and-symbols.md:62
msgid "<span class=\"caption\">Table B-2: Stand-Alone Syntax</span>"
msgstr "<span class=\"caption\">Tabel B-2: Stand-Alone Sintaks</span>"

#: src/appendix-02-operators-and-symbols.md:64
msgid ""
"Table B-3 shows symbols that are used within the context of a module "
"hierarchy path to access an item."
msgstr ""
"Tabel B-3 menampilkan simbol yang digunakan dalam konteks dari suatu path "
"hirarki modul untuk mengakses suatu butir."

#: src/appendix-02-operators-and-symbols.md:68
msgid "`ident::ident`"
msgstr "Insiden:: teridentifikasi"

#: src/appendix-02-operators-and-symbols.md:68
msgid "Namespace path"
msgstr "Path Namespace"

#: src/appendix-02-operators-and-symbols.md:69
msgid "`super::path`"
msgstr "Aku tak tahu harus berkata apa."

#: src/appendix-02-operators-and-symbols.md:69
msgid "Path relative to the parent of the current module"
msgstr "Path relatif terhadap induk modul kini"

#: src/appendix-02-operators-and-symbols.md:70
msgid "`trait::method(...)`"
msgstr "▪trait::method↑...]"

#: src/appendix-02-operators-and-symbols.md:70
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr ""
"Menyalurkan sebuah metode panggilan dengan menyebutkan sifat yang "
"mendefinisikannya"

#: src/appendix-02-operators-and-symbols.md:72
msgid "<span class=\"caption\">Table B-3: Path-Related Syntax</span>"
msgstr "<span class=\"caption\">Tabel B-3: Path-Related Sintaks</span>"

#: src/appendix-02-operators-and-symbols.md:74
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr ""
"Tabel B-4 menampilkan simbol yang muncul dalam konteks menggunakan parameter"
" tipe generik."

#: src/appendix-02-operators-and-symbols.md:78
msgid "`path<...>`"
msgstr "Jalan <...>"

#: src/appendix-02-operators-and-symbols.md:78
msgid "Specifies parameters to generic type in a type (e.g., `Array<u8>`)"
msgstr ""
"Spesifikasikan parameter ke tipe generik dalam sebuah tipe (misalnya, "
"ARray<u8>)"

#: src/appendix-02-operators-and-symbols.md:79
msgid "`path::<...>`, `method::<...>`"
msgstr "Path:<...>, method::<...>"

#: src/appendix-02-operators-and-symbols.md:79
msgid ""
"Specifies parameters to a generic type, function, or method in an "
"expression; often referred to as turbofish"
msgstr ""
"Tentukan parameter ke jenis umum, fungsi, atau metode dalam sebuah ekspresi;"
" sering disebut sebagai turbofish"

#: src/appendix-02-operators-and-symbols.md:80
msgid "`fn ident<...> ...`"
msgstr "Jadi identitas<...>..."

#: src/appendix-02-operators-and-symbols.md:80
msgid "Define generic function"
msgstr "Definisikan fungsi generik"

#: src/appendix-02-operators-and-symbols.md:81
msgid "`struct ident<...> ...`"
msgstr "Mengidentifikasi identitas<...>..."

#: src/appendix-02-operators-and-symbols.md:81
msgid "Define generic structure"
msgstr "Definisikan struktur generik"

#: src/appendix-02-operators-and-symbols.md:82
msgid "`enum ident<...> ...`"
msgstr "Enimum terident <...>..."

#: src/appendix-02-operators-and-symbols.md:82
msgid "Define generic enumeration"
msgstr "Definisikan enumerasi generik"

#: src/appendix-02-operators-and-symbols.md:83
msgid "`impl<...> ...`"
msgstr "åimpl<...>..."

#: src/appendix-02-operators-and-symbols.md:83
msgid "Define generic implementation"
msgstr "Definisikan implementasi generik"

#: src/appendix-02-operators-and-symbols.md:85
msgid "<span class=\"caption\">Table B-4: Generics</span>"
msgstr "<span class=\"caption\">Tabel B-4: Generik</span>"

#: src/appendix-02-operators-and-symbols.md:87
msgid ""
"Table B-5 shows symbols that appear in the context of specifying attributes "
"on an item."
msgstr ""
"Tabel B-5 menampilkan simbol yang muncul dalam konteks dari spesifikasikan "
"atribut pada suatu item."

#: src/appendix-02-operators-and-symbols.md:91
msgid "`#[derive(...)]`"
msgstr "# # [derive[...]"

#: src/appendix-02-operators-and-symbols.md:91
msgid "Automatically implements a trait for a type"
msgstr "Otomatis mengimplementasikan suatu sifat bagi suatu tipe"

#: src/appendix-02-operators-and-symbols.md:92
msgid "`#[inline]`"
msgstr "# [inline]"

#: src/appendix-02-operators-and-symbols.md:92
msgid "Hint to the compiler to allow inlining of annotated function"
msgstr "Petunjuk ke kompiler untuk mengijinkan inlining dari fungsi ternotasi"

#: src/appendix-02-operators-and-symbols.md:93
msgid "`#[inline(always)]`"
msgstr "# #[inline[always)]"

#: src/appendix-02-operators-and-symbols.md:93
msgid "Hint to the compiler to systematically inline annotated function"
msgstr "Petunjuk ke kompiler untuk secara sistematis inline fungsi ternotasi"

#: src/appendix-02-operators-and-symbols.md:94
msgid "`#[inline(never)]`"
msgstr "# # [inline Allah tidak pernah]]"

#: src/appendix-02-operators-and-symbols.md:94
msgid "Hint to the compiler to never inline annotated function"
msgstr "Petunjuk ke kompiler untuk tidak pernah inline fungsi ternotasi"

#: src/appendix-02-operators-and-symbols.md:95
msgid "`#[must_use]`"
msgstr "# # [must_use]"

#: src/appendix-02-operators-and-symbols.md:95
msgid ""
"Hint to the compiler that the return value of a function or a specific "
"returned type must be used"
msgstr ""
"Petunjuk ke kompiler bahwa nilai kembali dari sebuah fungsi atau tipe yang "
"dikembalikan spesifik harus digunakan"

#: src/appendix-02-operators-and-symbols.md:96
msgid "`#[generate_trait]`"
msgstr "# # [generate_trait]"

#: src/appendix-02-operators-and-symbols.md:96
msgid "Automatically generates a trait for an impl"
msgstr "Otomatis menghasilkan suatu sifat untuk sebuah impl"

#: src/appendix-02-operators-and-symbols.md:97
msgid "`#[available_gas(...)]`"
msgstr "##[available_gas↑...]"

#: src/appendix-02-operators-and-symbols.md:97
msgid "Set the maximum amount of gas available to execute a function"
msgstr ""
"Mengatur maksimum jumlah gas yang tersedia untuk mengeksekusi suatu fungsi"

#: src/appendix-02-operators-and-symbols.md:98
msgid "`#[panic_with('...', wrapper_name)]`"
msgstr "# # [panic_with--'...', wrapper_name)]"

#: src/appendix-02-operators-and-symbols.md:98
msgid ""
"Creates a wrapper for the annotated function which will panic if the "
"function returns `None` or `Err`, with the given data as the panic error"
msgstr ""
"Membuat pembungkus untuk fungsi anotasi yang akan panik jika fungsinya "
"kembali atau dengan data yang diberikan sebagai kesalahan panik"

#: src/appendix-02-operators-and-symbols.md:99
msgid "`#[test]`"
msgstr "# [test]"

#: src/appendix-02-operators-and-symbols.md:99
msgid "Describe a function as a test function"
msgstr "Gambarkan sebuah fungsi sebagai sebuah fungsi tes"

#: src/appendix-02-operators-and-symbols.md:100
msgid "`#[cfg(...)]`"
msgstr "# # [cfg↑...]]"

#: src/appendix-02-operators-and-symbols.md:100
msgid ""
"Configuration attribute, especially used to configure a `tests` module with "
"`#[cfg(test)]`"
msgstr ""
"Atribut konfigurasi, khususnya digunakan untuk menata sebuah modul åtestó "
"dengan \"#[cfgresslertest)]"

#: src/appendix-02-operators-and-symbols.md:101
msgid "`#[should_panic]`"
msgstr "¶ [seharusnya_panik]"

#: src/appendix-02-operators-and-symbols.md:101
msgid "Specifies that a test function should necessarily panic"
msgstr "Tentukan bahwa fungsi tes harus selalu panik"

#: src/appendix-02-operators-and-symbols.md:102
msgid "`#[starknet::contract]`"
msgstr "# # [Starknet::contract]"

#: src/appendix-02-operators-and-symbols.md:102
msgid "Defines a Starknet smart contract"
msgstr "Mendefinisikan kontrak cerdas Starknet"

#: src/appendix-02-operators-and-symbols.md:103
msgid "`#[starknet::interface]`"
msgstr "?? [starknet:: antar muka]?"

#: src/appendix-02-operators-and-symbols.md:103
msgid "Defines a Starknet interface"
msgstr "Mendefinisikan antarmuka Starknet"

#: src/appendix-02-operators-and-symbols.md:104
msgid "`#[starknet::component]`"
msgstr "# # [Starknet::component]"

#: src/appendix-02-operators-and-symbols.md:104
msgid "Defines a Starknet component"
msgstr "Mendefinisikan komponen Starknet"

#: src/appendix-02-operators-and-symbols.md:105
msgid "`#[starknet::embeddable]`"
msgstr "?? [starknet::terbenamkan]"

#: src/appendix-02-operators-and-symbols.md:105
msgid ""
"Defines an isolated embeddable implementation that can be injected in any "
"smart contract"
msgstr ""
"Mendefinisikan sebuah implementasi yang dapat dibenamkan yang dapat "
"disuntikkan dalam kontrak pintar apapun"

#: src/appendix-02-operators-and-symbols.md:106
msgid "`#[embeddable_as(...)]`"
msgstr "# # [embeddable_as Allahn...]]"

#: src/appendix-02-operators-and-symbols.md:106
msgid "Defines an embeddable implementation inside a component"
msgstr ""
"Mendefinisikan sebuah implementasi yang dapat dibenamkan di dalam sebuah "
"komponen"

#: src/appendix-02-operators-and-symbols.md:107
msgid "`#[storage]`"
msgstr "# [storage]"

#: src/appendix-02-operators-and-symbols.md:107
msgid "Defines the storage of a smart contract"
msgstr "Mendefinisikan penyimpanan kontrak cerdas"

#: src/appendix-02-operators-and-symbols.md:108
msgid "`#[event]`"
msgstr "# [devent]"

#: src/appendix-02-operators-and-symbols.md:108
msgid "Defines an event in a smart contract"
msgstr "Mendefinisikan suatu kejadian dalam sebuah kontrak cerdas"

#: src/appendix-02-operators-and-symbols.md:109
msgid "`#[constructor]`"
msgstr "# [constructor]"

#: src/appendix-02-operators-and-symbols.md:109
msgid "Defines the constructor in a smart contract"
msgstr "Mendefinisikan konstruktor dalam kontrak pintar"

#: src/appendix-02-operators-and-symbols.md:110
msgid "`#[abi(embed_v0)]`"
msgstr "S.T.A.R.A.R.D."

#: src/appendix-02-operators-and-symbols.md:110
msgid ""
"Defines an implementation of a trait, exposing the functions of the impl as "
"entrypoints of a contract"
msgstr ""
"Mendefinisikan implementasi sebuah sifat, mengekspos fungsi impl sebagai "
"titik masuk sebuah kontrak"

#: src/appendix-02-operators-and-symbols.md:111
msgid "`#[abi(per_item)]`"
msgstr "▪#[abi[abiper_item)]]"

#: src/appendix-02-operators-and-symbols.md:111
msgid ""
"Allows individual definition of the entrypoint type of functions inside an "
"impl"
msgstr ""
"Memungkinkan definisi individu dari tipe titik masuk fungsi dalam sebuah "
"impl"

#: src/appendix-02-operators-and-symbols.md:112
msgid "`#[external(v0)]`"
msgstr "S.E.L.D.A.R.A.R.D."

#: src/appendix-02-operators-and-symbols.md:112
msgid "Defines an external function when `#[abi(per_item)]` is used"
msgstr "Mendefinisikan fungsi eksternal ketika \"#[abi[abiper_item)] digunakan"

#: src/appendix-02-operators-and-symbols.md:113
msgid "`#[flat]`"
msgstr "# [flat]"

#: src/appendix-02-operators-and-symbols.md:113
msgid ""
"Defines a enum variant of the `Event` enum that is not nested, ignoring the "
"variant name in the serialization process, very useful for composability "
"when using Starknet components"
msgstr ""
"Mendefinisikan varian enum dari enum yang tidak bersarang, mengabaikan nama "
"varian dalam proses seri, sangat berguna untuk komposabilitas ketika "
"menggunakan komponen Starknet"

#: src/appendix-02-operators-and-symbols.md:114
msgid "`#[key]`"
msgstr "# [kunci]"

#: src/appendix-02-operators-and-symbols.md:114
msgid ""
"Defines an indexed `Event` enum field, allowing for more efficient queries "
"and filtering of events"
msgstr ""
"Mendefinisikan medan enum indeks, memungkinkan pencarian yang lebih efisien "
"dan penyaringan peristiwa"

#: src/appendix-02-operators-and-symbols.md:116
msgid "<span class=\"caption\">Table B-5: Attributes</span>"
msgstr "<span class=\"caption\">Tabel B-5: Atribut</span>"

#: src/appendix-02-operators-and-symbols.md:118
msgid ""
"Table B-6 shows symbols that appear in the context of calling or defining "
"macros."
msgstr ""
"Tabel B-6 menunjukkan simbol yang muncul dalam konteks panggilan atau "
"mendefinisikan makro."

#: src/appendix-02-operators-and-symbols.md:122
msgid "`print!`"
msgstr "Sidik jari!"

#: src/appendix-02-operators-and-symbols.md:122
msgid "Inline printing"
msgstr "Pencetakan inline"

#: src/appendix-02-operators-and-symbols.md:123
msgid "`println!`"
msgstr "Cetakan!"

#: src/appendix-02-operators-and-symbols.md:123
msgid "Print on a new line"
msgstr "Cetak pada baris baru"

#: src/appendix-02-operators-and-symbols.md:124
msgid "`consteval_int!`"
msgstr "Consteval_int!"

#: src/appendix-02-operators-and-symbols.md:124
msgid "Declare a constant that is the result of a computation of integers"
msgstr "Menyatakan konstanta yang merupakan hasil dari komputasi integer"

#: src/appendix-02-operators-and-symbols.md:125
msgid "`array!`"
msgstr "Anarray!"

#: src/appendix-02-operators-and-symbols.md:125
msgid "Instantiate and fill arrays"
msgstr "Seketika dan isi array"

#: src/appendix-02-operators-and-symbols.md:126
msgid "`panic!`"
msgstr "Panic!"

#: src/appendix-02-operators-and-symbols.md:126
msgid ""
"Calls `panic` function and allows to provide a message error longer than 31 "
"characters"
msgstr ""
"Memanggil fungsi åpanicáne dan memungkinkan untuk memberikan pesan error "
"lebih dari 31 karakter"

#: src/appendix-02-operators-and-symbols.md:127
msgid "`assert!`"
msgstr "Sosert!"

#: src/appendix-02-operators-and-symbols.md:127
msgid "Evaluates a Boolean and panics if `false`"
msgstr "Mengevaluasi Boolean dan panik jika false"

#: src/appendix-02-operators-and-symbols.md:128
msgid "`assert_eq!`"
msgstr "S_assert_eq!"

#: src/appendix-02-operators-and-symbols.md:128
msgid "Evaluates an equality, and panics if not equal"
msgstr "Mengevaluasi kesetaraan, dan panik jika tidak sama"

#: src/appendix-02-operators-and-symbols.md:129
msgid "`assert_ne!`"
msgstr "Sosert_ne!"

#: src/appendix-02-operators-and-symbols.md:129
msgid "Evaluates an equality, and panics if equal"
msgstr "Mengevaluasi kesetaraan, dan panik jika sama"

#: src/appendix-02-operators-and-symbols.md:130
msgid "`assert_lt!`"
msgstr "S_lT!"

#: src/appendix-02-operators-and-symbols.md:130
msgid "Evaluates a comparison, and panics if greater or equal"
msgstr "Mengevaluasi perbandingan, dan panik jika lebih besar atau sama"

#: src/appendix-02-operators-and-symbols.md:131
msgid "`assert_le!`"
msgstr "assert_le!"

#: src/appendix-02-operators-and-symbols.md:131
msgid "Evaluates a comparison, and panics if greater"
msgstr "Mengevaluasi perbandingan, dan panik jika lebih besar"

#: src/appendix-02-operators-and-symbols.md:132
msgid "`assert_gt!`"
msgstr "\"Asseert_gt!\""

#: src/appendix-02-operators-and-symbols.md:132
msgid "Evaluates a comparison, and panics if lower or equal"
msgstr "Mengevaluasi perbandingan, dan panik jika lebih rendah atau sama"

#: src/appendix-02-operators-and-symbols.md:133
msgid "`assert_ge!`"
msgstr "assert_ge!"

#: src/appendix-02-operators-and-symbols.md:133
msgid "Evaluates a comparison, and panics if lower"
msgstr "Mengevaluasi perbandingan, dan panik jika lebih rendah"

#: src/appendix-02-operators-and-symbols.md:134
msgid "`format!`"
msgstr "Format!"

#: src/appendix-02-operators-and-symbols.md:134
msgid "Format a string and returns a `ByteArray` with the contents"
msgstr "Memformat string dan mengembalikan sebuah byteArray dengan isi"

#: src/appendix-02-operators-and-symbols.md:135
msgid "`write!`"
msgstr "Tulis!"

#: src/appendix-02-operators-and-symbols.md:135
msgid "Write formatted strings in a formatter"
msgstr "Tulis string keterangan dalam sebuah formateri"

#: src/appendix-02-operators-and-symbols.md:136
msgid "`writeln!`"
msgstr "Penulisan!"

#: src/appendix-02-operators-and-symbols.md:136
msgid "Write formatted strings in a formatter on a new line"
msgstr "Tulis string terformat dalam sebuah formatter pada baris baru"

#: src/appendix-02-operators-and-symbols.md:137
msgid "`get_dep_component!`"
msgstr "Get_dep_component!"

#: src/appendix-02-operators-and-symbols.md:137
msgid ""
"Returns the requested component state from a snapshot of the state inside a "
"component"
msgstr ""
"Mengembalikan keadaan komponen yang diminta dari snapshot dari keadaan di "
"dalam suatu komponen"

#: src/appendix-02-operators-and-symbols.md:138
msgid "`get_dep_component_mut!`"
msgstr "Get_dep_component_mut!"

#: src/appendix-02-operators-and-symbols.md:138
msgid ""
"Returns the requested component state from a reference of the state inside a"
" component"
msgstr ""
"Mengembalikan keadaan komponen yang diminta dari referensi keadaan di dalam "
"komponen"

#: src/appendix-02-operators-and-symbols.md:139
msgid "`component!`"
msgstr "Komponen!"

#: src/appendix-02-operators-and-symbols.md:139
msgid ""
"Macro used in Starknet contracts to embed a component inside a contract"
msgstr ""
"Makro digunakan dalam kontrak Starknet untuk menanamkan komponen di dalam "
"kontrak"

#: src/appendix-02-operators-and-symbols.md:142
msgid "<span class=\"caption\">Table B-6: Macros</span>"
msgstr "<span class=\"caption\">Tabel B-6: Macros</span>"

#: src/appendix-02-operators-and-symbols.md:144
msgid "Table B-7 shows symbols that create comments."
msgstr "Tabel B-7 menunjukkan simbol yang membuat komentar."

#: src/appendix-02-operators-and-symbols.md:148
msgid "`//`"
msgstr "Aku tidak tahu apa-apa."

#: src/appendix-02-operators-and-symbols.md:148
msgid "Line comment"
msgstr "Komentar baris"

#: src/appendix-02-operators-and-symbols.md:150
msgid "<span class=\"caption\">Table B-7: Comments</span>"
msgstr "<span class=\"caption\">Tabel B-7: Komentar</span>"

#: src/appendix-02-operators-and-symbols.md:152
msgid "Table B-8 shows symbols that appear in the context of using tuples."
msgstr ""
"Tabel B-8 menampilkan simbol yang muncul dalam konteks menggunakan tuples."

#: src/appendix-02-operators-and-symbols.md:156
msgid "`()`"
msgstr "Aku tidak tahu apa-apa tentang hal itu."

#: src/appendix-02-operators-and-symbols.md:156
msgid "Empty tuple (aka unit), both literal and type"
msgstr "Tuple kosong (satuanaka), baik literal maupun tipe"

#: src/appendix-02-operators-and-symbols.md:157
msgid "`(expr)`"
msgstr "▪EXPR)"

#: src/appendix-02-operators-and-symbols.md:157
msgid "Parenthesized expression"
msgstr "Ekspresi kurung"

#: src/appendix-02-operators-and-symbols.md:158
msgid "`(expr,)`"
msgstr "(Ekspr)"

#: src/appendix-02-operators-and-symbols.md:158
msgid "Single-element tuple expression"
msgstr "Ekspresi tuplemen-tunggal"

#: src/appendix-02-operators-and-symbols.md:159
msgid "`(type,)`"
msgstr "Aku tidak tahu apa-apa tentang hal ini."

#: src/appendix-02-operators-and-symbols.md:159
msgid "Single-element tuple type"
msgstr "Tipe tuplemen-tunggal"

#: src/appendix-02-operators-and-symbols.md:160
msgid "`(expr, ...)`"
msgstr "▪expr,...)"

#: src/appendix-02-operators-and-symbols.md:160
msgid "Tuple expression"
msgstr "Ekspresi umum"

#: src/appendix-02-operators-and-symbols.md:161
msgid "`(type, ...)`"
msgstr "Seperti,...)"

#: src/appendix-02-operators-and-symbols.md:161
msgid "Tuple type"
msgstr "Tipe Tuple"

#: src/appendix-02-operators-and-symbols.md:162
msgid "`expr(expr, ...)`"
msgstr "Exprłexpr,...)"

#: src/appendix-02-operators-and-symbols.md:162
msgid ""
"Function call expression; also used to initialize tuple `struct`s and tuple "
"`enum` variants"
msgstr ""
"Panggilan ekspresi fungsi; juga digunakan untuk menginisialisasi tuple "
"åstructs dan tuple (varian tuple)"

#: src/appendix-02-operators-and-symbols.md:164
msgid "<span class=\"caption\">Table B-8: Tuples</span>"
msgstr "<span class=\"caption\">Tabel B-8: Tuples</span>"

#: src/appendix-02-operators-and-symbols.md:166
msgid "Table B-9 shows the contexts in which curly braces are used."
msgstr "Tabel B-9 menunjukkan konteks di mana kawat gigi keriting digunakan."

#: src/appendix-02-operators-and-symbols.md:168
msgid "Context"
msgstr "Konteks"

#: src/appendix-02-operators-and-symbols.md:170
msgid "`{...}`"
msgstr "Ya, ya, ya, ya, ya, ya, ya, ya, ya, ya, ya, ya, ya, ya, ya, ya, ya."

#: src/appendix-02-operators-and-symbols.md:170
msgid "Block expression"
msgstr "Ekspresi blok"

#: src/appendix-02-operators-and-symbols.md:171
msgid "`Type {...}`"
msgstr "Type {...}"

#: src/appendix-02-operators-and-symbols.md:171
msgid "`struct` literal"
msgstr "Rangkaian literal"

#: src/appendix-02-operators-and-symbols.md:173
msgid "<span class=\"caption\">Table B-9: Curly Braces</span>"
msgstr "<span class=\"caption\">Tabel B-9: Curly Braces</span>"

#: src/appendix-03-derivable-traits.md:1
msgid "Appendix C - Derivable Traits"
msgstr "Lampiran C - Sifat yang Dapat Diturunkan"

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which"
" you can apply to a struct or enum definition. The `derive` attribute "
"generates code to implement a default trait on the type you’ve annotated "
"with the `derive` syntax."
msgstr ""
"Di berbagai tempat dalam buku ini, kita telah membahas atribut éderive, yang"
" dapat Anda terapkan pada definisi struct atau enum."

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the "
"traits in the standard library compatible with the `derive` attribute."
msgstr ""
"Dalam apendiks ini, kami menyediakan referensi komprehensif yang merinci "
"semua sifat di perpustakaan standar yang sesuai dengan atribut åderiveé."

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that "
"can be implemented on your types using `derive`. Other traits defined in the"
" standard library don’t have sensible default behavior, so it’s up to you to"
" implement them in a way that makes sense for what you’re trying to "
"accomplish."
msgstr ""
"Sifat-sifat ini dicantumkan di sini adalah satu-satunya yang didefinisikan "
"oleh perpustakaan inti yang dapat diterapkan pada tipe Anda dengan "
"menggunakan sifat-sifat lain yang didefinisikan di perpustakaan standar "
"tidak memiliki perilaku baku yang masuk akal, sehingga terserah Anda untuk "
"menerapkannya dengan cara yang masuk akal untuk apa yang Anda coba capai."

#: src/appendix-03-derivable-traits.md:9
msgid "Drop and Destruct"
msgstr "Drop and Destruct"

#: src/appendix-03-derivable-traits.md:11
msgid ""
"When moving out of scope, variables need to be moved first. This is where "
"the `Drop` trait intervenes. You can find more details about its usage "
"[here](ch04-01-what-is-ownership.md#no-op-destruction-the-drop-trait)."
msgstr ""
"Ketika bergerak keluar dari ruang lingkup, variabel perlu dipindahkan "
"terlebih dahulu. Ini adalah di mana sifat yang turun tangan. Anda dapat "
"menemukan lebih banyak rincian tentang penggunaan [di sini][di "
"sini]bah04-01-apa-adalah-pemilik.md#no-op-destruction-the-drop-trait)."

#: src/appendix-03-derivable-traits.md:13
msgid ""
"Moreover, Dictionaries need to be squashed before going out of scope. "
"Calling the `squash` method on each of them manually can quickly become "
"redundant. `Destruct` trait allows Dictionaries to be automatically squashed"
" when they get out of scope. You can also find more information about "
"`Destruct` [here](ch04-01-what-is-ownership.md#destruction-with-a-side-"
"effect-the-destruct-trait)."
msgstr ""
"Selain itu, Dictionary perlu dihancurkan sebelum keluar dari jangkauan. "
"memanggil metode ·squash-- pada masing-masing dari mereka secara manual "
"dapat segera menjadi berlebihan."

#: src/appendix-03-derivable-traits.md:15
msgid "`Clone` and `Copy` for Duplicating Values"
msgstr "SERBA - SERBI DAN TUBUH UNTUK Gandakan Nilai - Nilai"

#: src/appendix-03-derivable-traits.md:17
msgid ""
"The `Clone` trait provides the functionality to explicitly create a deep "
"copy of a value."
msgstr ""
"Sifat Cloneé memberikan fungsionalitas untuk secara eksplisit membuat "
"salinan mendalam nilai."

#: src/appendix-03-derivable-traits.md:19
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone "
"on each of the type's components. This means all the fields or values in the"
" type must also implement `Clone` to derive `Clone`."
msgstr ""
"Yang kemudian disebut klon pada setiap komponen tipe. ini berarti semua "
"bidang atau nilai-nilai dalam tipe harus juga mengimplementasikan Clone."

#: src/appendix-03-derivable-traits.md:21
msgid "Here is a simple example:"
msgstr "Ini adalah contoh sederhana:"

#: src/appendix-03-derivable-traits.md:32
#: src/appendix-03-derivable-traits.md:50
msgid "\"Not equal\""
msgstr "\"Tidak sama\""

#: src/appendix-03-derivable-traits.md:36
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy`"
" on any type whose parts all implement `Copy`."
msgstr ""
"Sifat yang memungkinkan untuk duplikasi nilai-nilai Anda dapat diperoleh "
"pada jenis apa pun yang semua bagiannya mengimplementasikan."

#: src/appendix-03-derivable-traits.md:49
msgid "// Copy Trait prevents first_struct from moving into second_struct\n"
msgstr "//Salin Trait mencegah m_struct pertama dari pindah ke m_struct kedua\n"

#: src/appendix-03-derivable-traits.md:51
msgid "\"Not Equal\""
msgstr "\"Tidak Sama\""

#: src/appendix-03-derivable-traits.md:55
msgid "`Debug` for Printing and Debugging"
msgstr "\"Debug\" untuk Pencetakan dan Pengawakutuan"

#: src/appendix-03-derivable-traits.md:57
msgid ""
"The `Debug` trait enables debug formatting in format strings, which you "
"indicate by adding `:?` within `{}` placeholders."
msgstr ""
"Sifat debug memungkinkan pemformatan debug dalam format string, yang Anda "
"indikasikan dengan menambahkan:?"

#: src/appendix-03-derivable-traits.md:59
msgid ""
"It allows you to print instances of a type for debugging purposes, so you "
"and other programmers using this type can inspect an instance at a "
"particular point in a program’s execution."
msgstr ""
"Hal ini memungkinkan Anda untuk mencetak contoh jenis untuk tujuan debug, "
"sehingga Anda dan programmer lain menggunakan jenis ini dapat memeriksa "
"suatu contoh pada titik tertentu dalam program eksekusi."

#: src/appendix-03-derivable-traits.md:61
msgid ""
"For example, if you want to print the value of a variable of type `Point`, "
"you can do it as follows:"
msgstr ""
"Misalnya, jika Anda ingin mencetak nilai dari variabel tipe årecté, Anda "
"dapat melakukannya sebagai berikut:"

#: src/appendix-03-derivable-traits.md:72
msgid "\"{:?}\""
msgstr "\"{:?\""

#: src/appendix-03-derivable-traits.md:81
msgid ""
"The `Debug` trait is required, for example, when using the `assert_xx!` "
"macros in tests. Theses macros print the values of instances given as "
"arguments if the equality or comparison assertion fails so programmers can "
"see why the two instances weren’t equal."
msgstr ""
"Sebagai contoh, sifat ini diperlukan ketika menggunakan macros dalam tes. "
"Ini makro mencetak nilai dari contoh yang diberikan sebagai argumen jika "
"pernyataan kesetaraan atau perbandingan gagal sehingga programer dapat "
"melihat mengapa kedua contoh tersebut tidak sama."

#: src/appendix-03-derivable-traits.md:83
msgid "`Default` for Default Values"
msgstr "Standar untuk Nilai Baku"

#: src/appendix-03-derivable-traits.md:85
msgid ""
"The `Default` trait allows creation of a default value of a type. The most "
"common default value is zero. All primitive types in the standard library "
"implement `Default`."
msgstr ""
"Sifat 'Default' memungkinkan terciptanya nilai baku dari sebuah tipe. Nilai "
"baku yang paling umum adalah nol. Semua tipe primitif di perpustakaan "
"standar mengimplementasikan 'Default."

#: src/appendix-03-derivable-traits.md:87
msgid ""
"If you want to derive `Default` on a composite type, each of its elements "
"must already implement `Default`. If you have an [`enum`](ch06-01-enums.md) "
"type, you must declare its default value by using the `#[default]` attribute"
" on one of its variants."
msgstr ""
"Jika Anda ingin memperolehnya pada tipe majemuk, masing-masing elemennya "
"harus mengimplementasikannya dengan menggunakan atribut default (baku). Jika"
" Anda memiliki atribut [enum][enum] Allahk06-01-enums.md), Anda harus "
"menyatakan nilai bakunya dengan menggunakan atributnya pada salah satu "
"variannya."

#: src/appendix-03-derivable-traits.md:89
msgid "An example:"
msgstr "Contoh:"

#: src/appendix-03-derivable-traits.md:108
msgid "\"item1 mismatch\""
msgstr "\"item1 tidak cocok\""

#: src/appendix-03-derivable-traits.md:109
msgid "\"item2 mismatch\""
msgstr "\"item2 tidak cocok\""

#: src/appendix-03-derivable-traits.md:112
msgid "\"case mismatch\""
msgstr "\"Kasus tidak cocok\""

#: src/appendix-03-derivable-traits.md:116
msgid "`PartialEq` for Equality Comparisons"
msgstr "▪PartialEqå untuk Perbandingan Kesetaraan"

#: src/appendix-03-derivable-traits.md:118
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for "
"equality, thereby enabling the `==` and `!=` operators."
msgstr ""
"Sifat \"PartialEq\" memungkinkan perbandingan antara contoh dari tipe "
"kesetaraan, yang memungkinkan terjadinya operator."

#: src/appendix-03-derivable-traits.md:120
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all "
"their fields are equal; they are not equal if any field is different. When "
"derived for enums, each variant is equal to itself and not equal to the "
"other variants."
msgstr ""
"Ketika ada daerah yang berbeda. ketika berasal dari enum, setiap varian sama"
" dengan dirinya sendiri dan tidak sama dengan varian lainnya."

#: src/appendix-03-derivable-traits.md:122
msgid ""
"You can write your own implementation of the `PartialEq` trait for your "
"type, if you can't derive it or if you want to implement your custom rules. "
"In the following example, we write an implementation for `PartialEq` in "
"which we consider that two rectangles are equal if they have the same area:"
msgstr ""
"Anda dapat menulis implementasi anda sendiri dari sifat åPartialEqé untuk "
"tipe anda, jika anda tidak dapat memperolehnya atau jika anda ingin "
"mengimplementasikan aturan anda sendiri. Dalam contoh berikut, kami menulis "
"implementasi untuk thosePartialEq di mana kita menganggap bahwa dua persegi "
"panjang sama jika mereka memiliki area yang sama:"

#: src/appendix-03-derivable-traits.md:145
msgid "\"Are rect1 and rect2 equal? {}\""
msgstr "\"Apakah rect1 dan rect2 sama? [}\""

#: src/appendix-03-derivable-traits.md:149
msgid ""
"The `PartialEq` trait is required when using the `assert_eq!` macro in "
"tests, which needs to be able to compare two instances of a type for "
"equality."
msgstr ""
"Sifat yang diperlukan untuk menggunakan makro dalam tes, yang perlu dapat "
"membandingkan dua contoh dari jenis persamaan hak."

#: src/appendix-03-derivable-traits.md:162
msgid "\"Structs are different\""
msgstr "\"Structs are different\""

#: src/appendix-03-derivable-traits.md:166
msgid "Serializing with `Serde`"
msgstr "Serialisasi dengan Serde"

#: src/appendix-03-derivable-traits.md:168
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` "
"functions for data structures defined in your crate. It allows you to "
"transform your structure into an array (or the opposite)."
msgstr ""
"Ini memungkinkan Anda mengubah struktur Anda menjadi sebuah array (atau "
"sebaliknya)."

#: src/appendix-03-derivable-traits.md:170
msgid ""
"**[Serialization](https://en.wikipedia.org/wiki/Serialization)** is a "
"process of transforming data structures into a format that can be easily "
"stored or transmitted. Let's say you are running a program and would like to"
" persist its state to be able to resume it later. To do this, you could take"
" each of the objects your program is using and save their information, for "
"example in a file. This is a simplified version of serialization. Now if you"
" want to resume your program with this saved state, you would perform "
"**deserialization**, which means loading the state of the objects from the "
"saved source."
msgstr ""
"**[Serialization][Serialization]://en.wikipedia.org/wiki/Serialization)** "
"adalah proses transformasi struktur data menjadi sebuah format yang dapat "
"dengan mudah disimpan atau ditransmisikan. Anggaplah Anda menjalankan sebuah"
" program dan ingin mempertahankan kondisinya agar dapat melanjutkan lagi "
"nanti. Untuk melakukan ini, Anda dapat mengambil setiap objek yang digunakan"
" dan menyimpan informasi mereka, sebagai contoh. Ini adalah versi "
"serialisasi yang disederhanakan. Sekarang jika Anda ingin melanjutkan "
"program Anda dengan keadaan ini, Anda akan melakukan *desertialisasi, yang "
"berarti memuat objek dari sumber yang disimpan."

#: src/appendix-03-derivable-traits.md:172
msgid "For example:"
msgstr "Misalnya:"

#: src/appendix-03-derivable-traits.md:190
msgid "If you run the `main` function, the output will be:"
msgstr "Jika Anda menjalankan fungsi åmain, keluaran akan:"

#: src/appendix-03-derivable-traits.md:196
msgid ""
"We can see here that our struct `A` has been serialized into the output "
"array. Note that the `serialize` function takes as argument a snapshot of "
"the type you want to convert into an array. This is why deriving `Drop` for "
"`A` is required here, as the `main` function keeps ownership of the "
"`first_struct` struct."
msgstr ""
"Kita dapat melihat di sini bahwa struct kita telah serial ke dalam array "
"output. Perhatikan bahwa fungsi ·serializeé mengambil sebagai argumen "
"sebagai snapshot dari tipe yang ingin Anda ubah menjadi sebuah array. Inilah"
" sebabnya mengapa turunan untuk Apropose diperlukan di sini, sebagai fungsi "
"thosemainmain tetap kepemilikan dari struktur pertama_struct."

#: src/appendix-03-derivable-traits.md:198
msgid ""
"Also, we can use the `deserialize` function to convert the serialized array "
"back into our `A` struct."
msgstr ""
"Juga, kita dapat menggunakan fungsi yang berdeserialisasi untuk mengubah "
"array serial kembali ke struktur kita."

#: src/appendix-03-derivable-traits.md:218
msgid ""
"Here we are converting a serialized array span back to the struct `A`. "
"`deserialize` returns an `Option` so we need to unwrap it. When using "
"`deserialize` we also need to specify the type we want to deserialize into."
msgstr ""
"Di sini kita mengubah rentang array serial kembali ke struct A. Kita juga "
"perlu menspesifikasikan tipe yang ingin kita deserialisasikan ke dalam."

#: src/appendix-03-derivable-traits.md:220
msgid "Hashing with `Hash`"
msgstr "Hashing with those Hash--"

#: src/appendix-03-derivable-traits.md:222
msgid ""
"It is possible to derive the `Hash` trait on structs and enums. This allows "
"them to be hashed easily using any available hash function. For a struct or "
"an enum to derive the `Hash` attribute, all fields or variants need to be "
"hashable themselves."
msgstr ""
"Dapat diperoleh sifat pada struktur dan enum. Hal ini memungkinkan mereka "
"untuk diratakan dengan mudah menggunakan fungsi hash yang tersedia. Untuk "
"sebuah struktur atau enum untuk memperoleh atribut ·Hash--, semua bidang "
"atau varian perlu diawetkan sendiri."

#: src/appendix-03-derivable-traits.md:224
msgid ""
"You can refer to the [Hashes section](ch11-04-hash.md) to get more "
"information about how to hash complex data types."
msgstr ""
"Anda dapat mengacu pada bagian [Hashes] (Hashes section) 139ch11-04-hash.md)"
" untuk mendapatkan lebih banyak informasi tentang bagaimana untuk tipe data "
"kompleks hash."

#: src/appendix-03-derivable-traits.md:226
msgid "Starknet Storage with `starknet::Store`"
msgstr "Penyimpanan Starknet dengan Éstarknet::Store"

#: src/appendix-03-derivable-traits.md:228
msgid ""
"The `starknet::Store` trait is relevant only when building on "
"[Starknet](ch13-00-introduction-to-starknet-smart-contracts.md). It allows "
"for a type to be used in smart contract storage by automatically "
"implementing the necessary read and write functions."
msgstr ""
"The åstarknet: Sifat yang berkaitan hanya ketika membangun di "
"[Starknet][Starknet][1300-introduction-to-starknet-smart-contracts.md). Hal "
"ini memungkinkan sebuah tipe untuk digunakan dalam penyimpanan kontrak "
"pintar dengan secara otomatis menerapkan fungsi baca dan tulis."

#: src/appendix-03-derivable-traits.md:230
msgid ""
"You can find detailed information about the inner workings of Starknet "
"storage in the [Contract storage section](ch14-01-contract-storage.md)."
msgstr ""
"Anda dapat menemukan informasi rinci tentang bagian dalam penyimpanan "
"Starknet di bagian penyimpanan [Kontract][14-01-contract-storage.md)."

#: src/appendix-04-cairo-prelude.md:1
msgid "Appendix D - The Cairo Prelude"
msgstr "Lampiran D - Prelude Cairo"

#: src/appendix-04-cairo-prelude.md:3
msgid "Prelude"
msgstr "Prelude"

#: src/appendix-04-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data "
"types, and traits that are automatically brought into scope of every module "
"in a Cairo crate without needing explicit import statements. Cairo's prelude"
" provides the basic building blocks developers need to start Cairo programs "
"and writing smart contracts."
msgstr ""
"Praluda Cairo adalah koleksi modul, fungsi, tipe data, dan ciri-ciri yang "
"secara otomatis dibawa ke ruang lingkup setiap modul di peti Cairo tanpa "
"memerlukan pernyataan impor eksplisit. Pembuka blok bangunan dasar perlu "
"memulai program Cairo dan menulis kontrak cerdas."

#: src/appendix-04-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the "
"_[lib.cairo](https://github.com/starkware-"
"libs/cairo/blob/main/corelib/src/lib.cairo)_ file of the corelib crate and "
"contains Cairo's primitive data types, traits, operators, and utility "
"functions. This includes:"
msgstr ""
"Perpustakaan inti prelude didefinisikan dalam "
"_[lib.cairo][lib.cairo][ghttps://github.com/starkware-"
"libs/cairo/cairo/main/core/src/lib.cairo)_ berkas dari peti intilib dan "
"berisi tipe data primitif Cairo, sifat, operator, dan fungsi utilitas. Ini "
"termasuk:"

#: src/appendix-04-cairo-prelude.md:15
msgid "Data types: integers, bools, arrays, dicts, etc."
msgstr "Tipe data: integer, bools, array, dicts, dsb."

#: src/appendix-04-cairo-prelude.md:16
msgid ""
"Traits: behaviors for arithmetic, comparison, and serialization operations"
msgstr ""
"Traits: perilaku untuk operasi aritmetik, perbandingan, dan serialisasi"

#: src/appendix-04-cairo-prelude.md:17
msgid "Operators: arithmetic, logical, bitwise"
msgstr "Operator: aritmatika, logis, bitwise"

#: src/appendix-04-cairo-prelude.md:18
msgid "Utility functions - helpers for arrays, maps, boxing, etc."
msgstr "Utilitas fungsi - pembantu untuk array, peta, tinju, dll."

#: src/appendix-04-cairo-prelude.md:20
msgid ""
"The core library prelude delivers the fundamental programming constructs and"
" operations needed for basic Cairo programs, without requiring the explicit "
"import of elements. Since the core library prelude is automatically "
"imported, its contents are available for use in any Cairo crate without "
"explicit imports. This prevents repetition and provides a better devX. This "
"is what allows you to use `ArrayTrait::append()` or the `Default` trait "
"without bringing them explicitly into scope."
msgstr ""
"Perpustakaan inti prelude memberikan konstruksi pemrograman dasar dan "
"operasi yang diperlukan untuk program-program dasar Cairo, tanpa memerlukan "
"impor elemen yang eksplisit. Karena perpustakaan inti prelude secara "
"otomatis diimpor, isinya tersedia untuk digunakan di setiap peti Cairo tanpa"
" impor eksplisit. Hal ini mencegah pengulangan dan menyediakan devX yang "
"lebih baik. Ini adalah apa yang memungkinkan Anda untuk menggunakan "
"▪ArrayTrait:apend 1964) atau sifat ÁDafán tanpa membawa mereka secara "
"eksplisit ke ruang lingkup."

#: src/appendix-04-cairo-prelude.md:28
msgid ""
"You can choose which prelude to use. For example, adding `edition = "
"\"2023_11\"` in the _Scarb.toml_ configuration file will load the prelude "
"from November 2023. Note that when you create a new project using `scarb "
"new` command, the _Scarb.toml_ file will automatically include `edition = "
"\"2023_11\"`."
msgstr ""
"Anda dapat memilih prelude mana yang akan digunakan. Sebagai contoh, "
"menambahkan roodisi = \"2023_11\" dalam berkas konfigurasi _Scarb.toml_ akan"
" memuat preludesi dari November 2023. Perlu dicatat bahwa ketika Anda "
"membuat proyek baru menggunakan perintah baru ▪scarb baru, berkas "
"_Scarb.toml_ secara otomatis akan memuat fusition = \"2023_11\""

#: src/appendix-04-cairo-prelude.md:30
msgid "The compiler currently exposes 2 different versions of the prelude:"
msgstr "kompiler saat ini mengekspos 2 versi berbeda dari prelude:"

#: src/appendix-04-cairo-prelude.md:32
msgid ""
"A general version, with a lot of traits that are made available, "
"corresponding to `edition = \"2023_01\"`."
msgstr ""
"Sebuah versi umum, dengan banyak sifat yang tersedia, sesuai dengan åedition"
" = \"2023_01.\""

#: src/appendix-04-cairo-prelude.md:33
msgid ""
"A restricted version, including the most essential traits needed for general"
" Cairo programming, corresponding to `edition = 2023_11`."
msgstr ""
"Versi yang terbatas, termasuk sifat yang paling penting yang diperlukan "
"untuk pemrograman umum Cairo, yang berhubungan dengan edisi = 2023_11."

#: src/appendix-05-common-error-messages.md:1
msgid "Appendix E - Common Error Messages"
msgstr "Lampiran E - Common Error Pesan"

#: src/appendix-05-common-error-messages.md:3
msgid ""
"You might encounter error messages when writing Cairo code. Some of them "
"occur very frequently, which is why we will be listing the most common error"
" messages in this appendix to help you resolve common issues."
msgstr ""
"Anda mungkin menemukan pesan kesalahan ketika menulis kode Cairo. Beberapa "
"dari mereka terjadi sangat sering, itulah sebabnya kita akan mendaftarkan "
"pesan kesalahan yang paling umum dalam apendiks ini untuk membantu Anda "
"menyelesaikan masalah umum."

#: src/appendix-05-common-error-messages.md:5
msgid ""
"`Variable not dropped.`: this error message means that you are trying to "
"make a variable with a type that do not implement the `Drop` trait go out of"
" scope, withtout destroying it. Make sure that variables that need to be "
"dropped at the end of the execution of a function implement the `Drop` trait"
" or the `Destruct` trait. See [Ownership](ch04-01-what-is-"
"ownership.md#destroying-values---example-with-feltdict) section."
msgstr ""
"Pesan galat ini berarti Anda mencoba membuat variabel dengan tipe yang tidak"
" mengimplementasikan sifat ÉDropán. Lihat [Ownership]. "
"(Ownership].Anch04-is-ownership.m#destroyering-value--exple-with-fectivet) "
"bagian."

#: src/appendix-05-common-error-messages.md:7
msgid ""
"`Variable was previously moved.`: this error message means that you are "
"trying to use a variable whose ownership has already been transferred to "
"another function. When a variable doesn't implement the `Copy` trait, it is "
"passed by value to functions, and ownership of the variable is transferred "
"to the function. Such a variable cannot be used anymore in the current "
"context after its ownership has been transferred. It is often useful to use "
"the `clone` method in this situation."
msgstr ""
"Sebelumnya dapat diubah. Pesan kesalahan ini berarti anda mencoba "
"menggunakan variabel yang kepemilikannya telah ditransfer ke fungsi lain. "
"ketika variabel tidak mengimplementasikan sifat  (COP), ia diteruskan oleh "
"nilai ke fungsi, dan kepemilikan variabel tersebut dipindahkan ke fungsi. "
"Variabel tersebut tidak dapat digunakan lagi dalam konteks saat ini setelah "
"kepemilikannya dipindahkan. Sering berguna untuk menggunakan metode Áclone "
"dalam situasi ini."

#: src/appendix-05-common-error-messages.md:9
msgid ""
"`error: Trait has no implementation in context: "
"core::fmt::Display::<package_name::struct_name>`: this error message is "
"encountered if you try to print an instance of a custom data type with `{}` "
"placeholders in a `print!` or `println!` macro. To mitigate this issue, you "
"need to either manually implement the `Display` trait for your type, or use "
"the `Debug` trait by applying `derive(Debug)` to your type, allowing to "
"print your instance by adding `:?` in `{}` placeholders."
msgstr ""
"RIGRATOR: Trait tidak memiliki implementasi dalam konteks: core:fmt: "
"Display::<package_name::::struct_name>: pesan kesalahan ini ditemui jika "
"Anda mencoba untuk mencetak suatu contoh dari tipe data kustom dengan "
"pemegang tempat dalam sebuah Áprint! atau ÁprintInln!"

#: src/appendix-05-common-error-messages.md:11
msgid ""
"`Got an exception while executing a hint: Hint Error: Failed to deserialize "
"param #x.`: this error means that the execution failed because an entrypoint"
" was called without the expected arguments. Make sure that the arguments you"
" provide when calling an entrypoint are correct. There is a classic issue "
"with `u256` variables, which are actually structs of 2 `u128`. Therefore, "
"when calling a function that takes a `u256` as argument, you need to pass 2 "
"values."
msgstr ""
"GOT exception while excepting a hint Error: Gagal untuk deserialize param "
"#x."

#: src/appendix-05-common-error-messages.md:13
msgid ""
"`Item path::item is not visible in this context.`: this error message lets "
"us know that the path to bring an item into scope is correct, but there is a"
" vibility issue. In cairo, all items are private to parent modules by "
"default. To resolve this issue, make sure that all the modules on the path "
"to items and items themselves are declared with `pub(crate)` or `pub` to "
"have access to them."
msgstr ""
"Jalur ltitem:: tidak terlihat dalam konteks ini. Pesan kesalahan ini "
"memungkinkan kita tahu bahwa jalan untuk membawa item ke ruang lingkup "
"benar, tetapi ada masalah dengan kemampuan. Dalam cairo, semua benda "
"bersifat pribadi ke modul induk secara default. Untuk menyelesaikan masalah "
"ini, pastikan bahwa semua modul pada jalur ke item dan benda-benda itu "
"sendiri dinyatakan dengan ▪pubáncrate) atau Ábábé untuk mengaksesnya."

#: src/appendix-05-common-error-messages.md:15
msgid ""
"`Identifier not found.`: this error message is a bit aspecific but might "
"indicate that:"
msgstr ""
"Pengidentifikasi tidak ditemukan. Pesan kesalahan ini sedikit spesifik tapi "
"mungkin menunjukkan bahwa:"

#: src/appendix-05-common-error-messages.md:16
msgid ""
"A variable is being used before it has been declared. Make sure to declare "
"variables with the `let` keyword."
msgstr ""
"Variabel sedang digunakan sebelum dideklarasikan. Pastikan untuk "
"mendeklarasikan variabel dengan kata kuncinya."

#: src/appendix-05-common-error-messages.md:17
msgid ""
"The path to bring an item into scope is wrongly defined. Make sure to use "
"valid paths."
msgstr ""
"Path untuk membawa suatu butir ke dalam ruang lingkup salah didefinisikan. "
"Pastikan untuk menggunakan path yang valid."

#: src/appendix-05-common-error-messages.md:19
msgid "Starknet Components Related Error Messages"
msgstr "Komponen Starknet Terkait Pesan Galat"

#: src/appendix-05-common-error-messages.md:21
msgid ""
"You might encounter some errors when trying to implement components. "
"Unfortunately, some of them lack meaningful error messages to help debug. "
"This section aims to provide you with some pointers to help you debug your "
"code."
msgstr ""
"Anda mungkin menemui beberapa kesalahan ketika mencoba mengimplementasikan "
"komponen. Sayangnya, beberapa dari mereka tidak memiliki pesan galat yang "
"berarti untuk membantu debug. Bagian ini bertujuan untuk menyediakan "
"beberapa penunjuk untuk membantu anda men-debug kode."

#: src/appendix-05-common-error-messages.md:25
msgid ""
"`Trait not found. Not a trait.`: this error can occur when you're not "
"importing the component's impl block correctly in your contract. Make sure "
"to respect the following syntax:"
msgstr ""
"Tidak ditemukan. Tidak ada sifat. Kesalahan ini dapat terjadi ketika Anda "
"tidak mengimpor blok impl komponen dengan benar dalam kontrak Anda. Pastikan"
" untuk menghormati sintaks berikut:"

#: src/appendix-05-common-error-messages.md:33
msgid ""
"`Plugin diagnostic: name is not a substorage member in the contract's "
"Storage. Consider adding to Storage: (...)`: the compiler helps you a lot "
"debugging this by giving you recommendation on the action to take. "
"Basically, you forgot to add the component's storage to your contract's "
"storage. Make sure to add the path to the component's storage annotated with"
" the `#[substorage(v0)]` attribute to your contract's storage."
msgstr ""
"Nama bukan substorage anggota dalam penyimpanan kontrak. Pertimbangkan untuk"
" menambahkan ke Penyimpanan: (): compiler membantu Anda banyak debugging ini"
" dengan memberikan Anda rekomendasi pada tindakan untuk mengambil. Pada "
"dasarnya, Anda lupa untuk menambahkan komponen penyimpanan kontrak Anda. "
"Pastikan untuk menambahkan jalan ke penyimpanan komponen yang diberi nama "
"dengan \"# [substorauxv0] atribut ke penyimpanan kontrak Anda."

#: src/appendix-05-common-error-messages.md:35
msgid ""
"`Plugin diagnostic: name is not a nested event in the contract's Event enum."
" Consider adding to the Event enum:` similar to the previous error, the "
"compiler tells you that you forgot to add the component's events to your "
"contract's events. Make sure to add the path to the component's events to "
"your contract's events."
msgstr ""
"Pertimbangkan untuk menambahkannya ke Event Enum: yang mirip dengan "
"kesalahan sebelumnya, kompiler memberitahu Anda bahwa Anda lupa untuk "
"menambahkan peristiwa komponen pada acara kontrak Anda."

#: src/appendix-06-useful-development-tools.md:1
msgid "Appendix F - Useful Development Tools"
msgstr "Lampiran Alat Pengembangan F - Berguna"

#: src/appendix-06-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo"
" project provides. We’ll look at automatic formatting, quick ways to apply "
"warning fixes, a linter, and integrating with IDEs."
msgstr ""
"Dalam apendiks ini, kita berbicara tentang beberapa alat pengembangan "
"berguna yang disediakan proyek Cairo. kita akan melihat formatting otomatis,"
" cara cepat untuk menerapkan perbaikan peringatan, liter, dan "
"mengintegrasikan dengan IDE."

#: src/appendix-06-useful-development-tools.md:7
msgid "Automatic Formatting with `scarb fmt`"
msgstr "Pemformatan otomatis dengan fmt åscarb"

#: src/appendix-06-useful-development-tools.md:9
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command. If you're "
"using the Cairo binaries directly, you can run `cairo-format` instead. Many "
"collaborative projects use `scarb fmt` to prevent arguments about which "
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""
"Proyek-proyek scarb dapat diformat dengan menggunakan perintah fmt. Jika "
"Anda menggunakan binaries Cairo secara langsung, Anda dapat menjalankan "
"åcairo-formatán. Banyak proyek kolaboratif menggunakan thosecarb fmt. untuk "
"mencegah argumen tentang gaya mana yang digunakan ketika menulis Cairo: "
"semua orang format kode mereka menggunakan alat tersebut."

#: src/appendix-06-useful-development-tools.md:14
msgid ""
"To format any Cairo project, enter the following inside the project "
"directory:"
msgstr ""
"Untuk memformat projek Cairo mana pun, masukkan berikut di dalam direktori "
"projek:"

#: src/appendix-06-useful-development-tools.md:20
msgid "IDE Integration Using `cairo-language-server`"
msgstr "IDE Integration Uring ▪cairo-language-server)"

#: src/appendix-06-useful-development-tools.md:22
msgid ""
"To help IDE integration, the Cairo community recommends using the [`cairo-language-server`](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-language-server)<!-- ignore -->. This tool is a set of compiler-centric utilities that speaks the [Language Server Protocol](http://langserver.org/)<!--\n"
"ignore -->, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use `cairo-language-server`, such as [the Cairo extension for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)."
msgstr ""
"Untuk membantu integrasi IDE, komunitas Cairo merekomendasikan penggunaan "
"[Negara-Lang-server] -->. Alat ini adalah perangkat dari utilitas kompiler-"
"entris yang menggunakan Protokol Server-"
"Starkware/cairo/tree/main/crates/cairo-lang-lang-server)< --> yang khusus "
"untuk program dan bahasa untuk setiap klien lain. Yang berbeda dapat "
"menggunakan protilitas yang menggunakan protokol server-sayogira, seperti "
"penghidupan Visual.org/ -->, yang khusus untuk programing dan pemograman "
"dengan setiap klien lain."

#: src/appendix-06-useful-development-tools.md:32
msgid ""
"Visit the `vscode-cairo` "
"[page](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)<!--"
" ignore --> to install it on VSCode. You will get abilities such as "
"autocompletion, jump to definition, and inline errors."
msgstr ""
"Kunjungi åvscode-cairo--iro [page][page] "
"1964https://marketplace.vistudio.com/items?item=starkware.cairo1)<-- abaikan"
" --> untuk memasangnya di VSCode. Anda akan memperoleh kemampuan seperti "
"pelengkapan otomatis, melompat ke definisi, dan kesalahan inline."

#: src/appendix-06-useful-development-tools.md:38
msgid ""
"Note: If you have Scarb installed, it should work out of the box with the "
"Cairo VSCode extension, without a manual installation of the language "
"server."
msgstr ""
"Catatan: Jika Anda memasang Scarb, kotak itu harus bekerja di luar kotak "
"dengan ekstensi VSCode Cairo, tanpa instalasi manual server bahasa."

#: src/appendix-07-cairo-binaries.md:1
msgid "Appendix G - Installing the Cairo Binaries"
msgstr "Lampiran G - Memasang Binary Cairo"

#: src/appendix-07-cairo-binaries.md:3
msgid ""
"If you want to have access to the Cairo binaries, for anything that you "
"could not achieve by purely using Scarb you can install them by following "
"the instructions below."
msgstr ""
"Jika Anda ingin memiliki akses ke binaries Cairo, untuk apa pun yang Anda "
"tidak bisa mencapai hanya dengan menggunakan Scarb Anda dapat menginstal "
"mereka dengan mengikuti instruksi di bawah ini."

#: src/appendix-07-cairo-binaries.md:5
msgid "Prerequisites"
msgstr "Prasyarat"

#: src/appendix-07-cairo-binaries.md:7
msgid ""
"You will need to have [Rust](https://www.rust-lang.org) and "
"[Git](https://git-scm.com/) installed."
msgstr ""
"Anda akan memerlukan [Rut][Rust][https://www.rust-lang.org) dan [Git] "
"althttps://git-scm.com/) terpasang."

#: src/appendix-07-cairo-binaries.md:9
msgid ""
"To install Rust, you first need the [`rustup`](https://www.rust-"
"lang.org/tools/install) tool. It allows you to install Rust using the "
"following command:"
msgstr ""
"Untuk memasang Rust, pertama - tama Anda membutuhkan alat [artistup] "
"mereka://www.rust-lang.org/tool/install). Anda dapat memasang Rust "
"menggunakan perintah berikut:"

#: src/appendix-07-cairo-binaries.md:11
msgid "# Install stable Rust\n"
msgstr "# Pasang stabil Rust\n"

#: src/appendix-07-cairo-binaries.md:15
msgid ""
"Follow the link for information on how to install [Git](https://git-"
"scm.com/downloads)."
msgstr ""
"Ikuti link untuk informasi tentang cara menginstal [Git][Git]https://git-"
"scm.com/downloads)."

#: src/appendix-07-cairo-binaries.md:17
msgid ""
"The next step is to install Cairo. We will download Cairo manually, using "
"Cairo repository or with an installation script. You’ll need an internet "
"connection for the download."
msgstr ""
"Langkah berikutnya adalah memasang Cairo. kita akan mengunduh Cairo secara "
"manual, menggunakan repositori Cairo atau dengan skrip instalasi. anda akan "
"membutuhkan koneksi internet untuk mengunduh."

#: src/appendix-07-cairo-binaries.md:19
msgid ""
"Installing Cairo with a Script "
"([Installer](https://github.com/franalgaba/cairo-installer) by "
"[Fran](https://github.com/franalgaba))"
msgstr ""
"Menginstal Cairo dengan Skrip "
"(Installer)[Installer][Https://gitub.com/franalgaba/cairo-installer) oleh "
"[Fran]bahttps://github.com/franalgaba)))"

#: src/appendix-07-cairo-binaries.md:21
msgid "Install"
msgstr "Pasang"

#: src/appendix-07-cairo-binaries.md:23
msgid ""
"If you wish to install a specific release of Cairo rather than the latest "
"head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export "
"CAIRO_GIT_TAG=v2.5.1`)."
msgstr ""
"Jika Anda ingin menginstal rilis spesifik Cairo daripada kepala terbaru, "
"atur variabel lingkungan ▪CAIRO_GIT_TAGG Rasulé (mis. ▪export "
"CAIRO_GIT_TAG=v2,1)."

#: src/appendix-07-cairo-binaries.md:29
msgid ""
"After installing, follow [these instructions](#set-up-your-shell-"
"environment-for-cairo) to set up your shell environment."
msgstr ""
"Setelah memasang, ikuti [intruksi ini][#set-up-your-shell-environment-for-"
"cairo) untuk mengatur lingkungan shell Anda."

#: src/appendix-07-cairo-binaries.md:31
msgid "Update"
msgstr "Perbarui"

#: src/appendix-07-cairo-binaries.md:33
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | bash\n"
"```"
msgstr ""
"rm -fr ~/.cairo curl -L https://github.com/franalgaba/cairo-"
"installer/raw/main/bin/cairo-installer ▪"

#: src/appendix-07-cairo-binaries.md:38
msgid "Uninstall"
msgstr "Hapus"

#: src/appendix-07-cairo-binaries.md:40
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, "
"just remove it:"
msgstr ""
"Cairo dipasang di dalam ÁCAIRO_ROOTå (baku: ~/.cairo). Untuk melepaskan, "
"hapus saja:"

#: src/appendix-07-cairo-binaries.md:46
msgid "then remove these three lines from .bashrc:"
msgstr "lalu hapus ketiga baris ini dari.bassrc:"

#: src/appendix-07-cairo-binaries.md:49
msgid "\"$HOME/.cairo/target/release:$PATH\""
msgstr "\"$HOME/.cairo/target/release: $PATH\""

#: src/appendix-07-cairo-binaries.md:52
msgid "and finally, restart your shell:"
msgstr "dan akhirnya, start ulang shell Anda:"

#: src/appendix-07-cairo-binaries.md:58
msgid "Set Up your Shell Environment for Cairo"
msgstr "Mengatur Lingkungan Shell Anda untuk Cairo"

#: src/appendix-07-cairo-binaries.md:60
msgid ""
"Define environment variable `CAIRO_ROOT` to point to the path where Cairo "
"will store its data. `$HOME/.cairo` is the default. If you installed Cairo "
"via Git checkout, we recommend to set it to the same location as where you "
"cloned it."
msgstr ""
"Definisikan variabel lingkungan ▪CAIRO_ROOTé untuk menunjuk ke lokasi di "
"mana Cairo akan menyimpan datanya.."

#: src/appendix-07-cairo-binaries.md:64
msgid "Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr "Tambahkan alat executables-*cairo ke åPATH-mu jika belum ada"

#: src/appendix-07-cairo-binaries.md:66
msgid ""
"The below setup should work for the vast majority of users for common use "
"cases."
msgstr ""
"Pengaturan di bawah ini harus bekerja untuk mayoritas pengguna untuk kasus "
"penggunaan umum."

#: src/appendix-07-cairo-binaries.md:68
msgid "For **bash**:"
msgstr "Untuk ** bash**:"

#: src/appendix-07-cairo-binaries.md:70
msgid ""
"Stock Bash startup files vary widely between distributions in which of them "
"source which, under what circumstances, in what order and what additional "
"configuration they perform. As such, the most reliable way to get Cairo in "
"all environments is to append Cairo configuration commands to both `.bashrc`"
" (for interactive shells) and the profile file that Bash would use (for "
"login shells)."
msgstr ""
"Stock Bash startup file bervariasi secara luas antara distribusi di mana, "
"dalam keadaan apa, dalam urutan apa dan apa konfigurasi tambahan yang mereka"
" lakukan. Seperti itu, cara yang paling dapat diandalkan untuk mendapatkan "
"Cairo di semua lingkungan adalah untuk menambahkan konfigurasi Cairo "
"perintah untuk baik ▪.bassrcáne (untuk shell interaktif) dan berkas profil "
"Bash yang akan menggunakan (untuk login kerang)."

#: src/appendix-07-cairo-binaries.md:76
msgid ""
"First, add the commands to `~/.bashrc` by running the following in your "
"terminal:"
msgstr ""
"Pertama, tambahkan perintah untuk ~/.bassrcé dengan menjalankan berikut di "
"terminal Anda:"

#: src/appendix-07-cairo-binaries.md:79 src/appendix-07-cairo-binaries.md:89
#: src/appendix-07-cairo-binaries.md:95 src/appendix-07-cairo-binaries.md:102
msgid "'export CAIRO_ROOT=\"$HOME/.cairo\"'"
msgstr "'export CAIRO_ROOT=\"$HOME/.cairo\"'"

#: src/appendix-07-cairo-binaries.md:80 src/appendix-07-cairo-binaries.md:90
#: src/appendix-07-cairo-binaries.md:96 src/appendix-07-cairo-binaries.md:103
msgid ""
"'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"'"
msgstr ""
"'command -v cairo-compile >/dev/null-nall expor "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"'"

#: src/appendix-07-cairo-binaries.md:83
msgid ""
"Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add "
"the commands there as well. If you have none of these, add them to "
"`~/.profile`."
msgstr ""
"Kemudian, jika Anda memiliki ~/.profileé, ~/.bash_profileé atau "
"~/.bash_login, tambahkan perintah di sana juga. Jika Anda tidak memiliki "
"satupun dari ini, tambahkan mereka ke ~/.profile..profile."

#: src/appendix-07-cairo-binaries.md:86
msgid "to add to `~/.profile`:"
msgstr "untuk menambah ke ~/.profile:"

#: src/appendix-07-cairo-binaries.md:93
msgid "to add to `~/.bash_profile`:"
msgstr "untuk menambah ke ~/.bash_profile:"

#: src/appendix-07-cairo-binaries.md:99
msgid "For **Zsh**:"
msgstr "Untuk **Zsh**:"

#: src/appendix-07-cairo-binaries.md:106
msgid ""
"If you wish to get Cairo in non-interactive login shells as well, also add "
"the commands to `~/.zprofile` or `~/.zlogin`."
msgstr ""
"Jika Anda ingin mendapatkan Cairo di kerang login non-interaktif juga, juga "
"menambahkan perintah ke ~/.zprofileé atau ~ /.zgin."

#: src/appendix-07-cairo-binaries.md:108
msgid "For **Fish shell**:"
msgstr "Untuk ** Fish shell**:"

#: src/appendix-07-cairo-binaries.md:110
msgid "If you have Fish 3.2.0 or newer, execute this interactively:"
msgstr ""
"Jika Anda memiliki Fish 3,2.0 atau lebih baru, jalankan secara interaktif "
"ini:"

#: src/appendix-07-cairo-binaries.md:117
msgid "Otherwise, execute the snippet below:"
msgstr "Jika tidak, jalankan snippet di bawah:"

#: src/appendix-07-cairo-binaries.md:124
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which "
"provides alternative shell completions for many command line tools with an "
"IDE-like popup interface in the terminal window. (Note that their "
"completions are independent of Cairo's codebase so they might be slightly "
"out of sync for bleeding-edge interface changes.)"
msgstr ""
"Di MacOS, Anda mungkin juga ingin menginstal [Fig][Fig][Figttps://fig.io/) "
"yang menyediakan pelengkapan shell alternatif bagi banyak alat baris "
"perintah dengan antarmuka popup IDE-seperti di jendela terminal. (Ketahuan "
"bahwa penyelesaian mereka bebas dari codebase Cairo sehingga mereka mungkin "
"sedikit keluar dari sinkronisasi untuk perubahan antar muka pendarahan.)"

#: src/appendix-07-cairo-binaries.md:130
msgid "Restart your Shell"
msgstr "Restart Shell Anda"

#: src/appendix-07-cairo-binaries.md:132
msgid "for the `PATH` changes to take effect."
msgstr "Untuk perubahan yang berlaku."

#: src/appendix-07-cairo-binaries.md:135
msgid "\"$SHELL\""
msgstr "\"$SHELL\""

#: src/appendix-07-cairo-binaries.md:138
msgid ""
"Installing Cairo Manually ([Guide](https://github.com/auditless/cairo-"
"template) by [Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""
"Instalasi Cairo Manually ([Guide] 2.0https://github.com/auditless/cairo-"
"template) oleh [Abdel] Knuthttps://gitub.com/abdelhamidbakhta)"

#: src/appendix-07-cairo-binaries.md:140
msgid "Step 1: Install Cairo 1.0"
msgstr "Langkah 1: Pasang Cairo 1.0"

#: src/appendix-07-cairo-binaries.md:142
msgid ""
"If you are using an x86 Linux system and can use the release binary, "
"download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""
"Jika Anda menggunakan sistem Linux x86 dan dapat menggunakan biner rilis, "
"download Cairo di sini: <https://github.com/starkware-libs/cairo/releases>."

#: src/appendix-07-cairo-binaries.md:144
msgid ""
"For everyone else, we recommend compiling Cairo from source as follows:"
msgstr ""
"Untuk orang lain, kami menyarankan kompilasi Cairo dari sumber sebagai "
"berikut:"

#: src/appendix-07-cairo-binaries.md:147
msgid "# Start by defining environment variable CAIRO_ROOT\n"
msgstr "# Mulai dengan mendefinisikan variabel lingkungan CAIRO_ROOT\n"

#: src/appendix-07-cairo-binaries.md:148
msgid "\"${HOME}/.cairo\""
msgstr "\"${HOME}/.cairo\""

#: src/appendix-07-cairo-binaries.md:149
msgid "# Create .cairo folder if it doesn't exist yet\n"
msgstr "# Buat folder.cairo jika belum ada\n"

#: src/appendix-07-cairo-binaries.md:152
msgid "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
msgstr "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"

#: src/appendix-07-cairo-binaries.md:155
msgid ""
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the compiler\n"
"# Fetch all tags (versions)\n"
msgstr ""
"# OPSIAL/RECOMMENDED: Jika Anda ingin menginstal versi spesifik dari "
"kompiler # Ambil semua tag (versi)\n"

#: src/appendix-07-cairo-binaries.md:158
msgid "# View tags (you can also do this in the Cairo compiler repository)\n"
msgstr ""
"# Tilik tag (Anda juga dapat melakukan ini dalam repositori kompiler "
"Cairo)\n"

#: src/appendix-07-cairo-binaries.md:160
msgid "# Checkout the version you want\n"
msgstr "¶ Checkout versi yang Anda inginkan\n"

#: src/appendix-07-cairo-binaries.md:163
msgid "# Generate release binaries\n"
msgstr "# Hasilkan rilis binaries\n"

#: src/appendix-07-cairo-binaries.md:168
msgid "."
msgstr "."

#: src/appendix-07-cairo-binaries.md:170
msgid "**NOTE: Keeping Cairo up to date**"
msgstr "**NOTE: Menjaga Cairo up to date**"

#: src/appendix-07-cairo-binaries.md:172
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to"
" do is pull the latest changes and rebuild as follows:"
msgstr ""
"Sekarang bahwa kompiler Cairo Anda berada dalam repositori kloning, yang "
"perlu Anda lakukan adalah menarik perubahan terbaru dan membangun kembali "
"sebagai berikut:"

#: src/appendix-07-cairo-binaries.md:179
msgid "Step 2: Add Cairo 1.0 Executables to Your Path"
msgstr "Langkah 2: Tambah Cairo 1,0 Executables to Your Path"

#: src/appendix-07-cairo-binaries.md:182
msgid "\"$CAIRO_ROOT/target/release:$PATH\""
msgstr "\"$CAIRO_ROOT/target/release:$PATH\""

#: src/appendix-07-cairo-binaries.md:185
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path "
"accordingly.**"
msgstr ""
"**NOTE: Jika dipasang dari biner Linux, menyesuaikan jalur tujuan sesuai.**"

#: src/appendix-07-cairo-binaries.md:187
msgid "Step 3: Setup Language Server"
msgstr "Langkah 3: Tata Server Bahasa"

#: src/appendix-07-cairo-binaries.md:189
msgid "VS Code Extension"
msgstr "Ekstensi Kode VS"

#: src/appendix-07-cairo-binaries.md:191
msgid ""
"If you have the previous Cairo 0 extension installed, you can "
"disable/uninstall it."
msgstr ""
"Jika Anda memasang ekstensi Cairo 0 sebelumnya, Anda dapat "
"menonaktifkan/menyalakannya."

#: src/appendix-07-cairo-binaries.md:192
msgid ""
"Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation. You can find the link to the extension "
"[here](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false),"
" or just search for \"Cairo 1.0\" in the VS Code marketplace."
msgstr ""
"Instal ekstensi Cairo 1 untuk penandaan sintaks yang tepat dan navigasi "
"kode. Anda dapat menemukan link ke ekstensi [di "
"sini]bahttps://marketstudio.com/items?item=starkware.cairo1&sr=false), atau "
"hanya mencari \"Cairo 1.0\" di pasar Kode VS."

#: src/appendix-07-cairo-binaries.md:193
msgid ""
"The extension will work out of the box once you will have "
"[Scarb](./ch01-03-hello-scarb.md) installed."
msgstr ""
"Extension akan bekerja dari kotak setelah Anda akan memiliki [Scarb] alb. "
"/ch01-03-hello-scarb) dipasang."

#: src/appendix-07-cairo-binaries.md:195
msgid "Cairo Language Server without Scarb"
msgstr "Cairo Language Server tanpa Scarb"

#: src/appendix-07-cairo-binaries.md:197
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language "
"Server with the compiler binary. From [Step 1](#installing-cairo-with-a-"
"script-installer-by-fran), the `cairo-language-server` binary should be "
"built and executing this command will copy its path into your clipboard."
msgstr ""
"Jika Anda tidak ingin bergantung pada Scarb, Anda masih dapat menggunakan "
"Server Bahasa Cairo dengan binari kompiler. Dari [Langkah 1] [Step "
"1][installing-cairo-with-a-script-installer-by-fran), biner ▪cairo-language-"
"server harus dibangun dan melaksanakan perintah ini akan menyalin jalan ke "
"dalam clipboard Anda."

#: src/appendix-07-cairo-binaries.md:204
msgid ""
"Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting"
" the path."
msgstr ""
"Update ▪cairo1.languageServerPath dari ekstensi Cairo 1.0 dengan menempelkan"
" jalur."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"All through the previous sections, you've mostly written programs with a "
"`main` entrypoint. In the coming sections, you will learn to write and "
"deploy Starknet contracts."
msgstr ""
"Semua melalui bagian sebelumnya, Anda sebagian besar telah menulis program "
"dengan titik masuk åmainé. di bagian yang akan datang, Anda akan belajar "
"untuk menulis dan menyebarkan kontrak Starknet."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"One of the key applications of the Cairo language is writing smart contracts"
" for the Starknet network. Starknet is a permissionless decentralized "
"network that leverages zk-STARKs technology for scalability. As a Layer 2 "
"(L2) scalability solution for Ethereum, Starknet aims to provide fast, "
"secure, and low-cost transactions. It operates as a validity rollup, "
"commonly known as a zero-knowledge rollup, and is built on top of the Cairo "
"VM."
msgstr ""
"Salah satu aplikasi kunci bahasa Cairo adalah menulis kontrak cerdas untuk "
"jaringan Starknet. Starknet adalah jaringan terdesentralisasi tanpa izin "
"yang memanfaatkan teknologi zk-STARKs untuk skalabilitas. Sebagai solusi "
"skalal 2 (L2) untuk Ethereum, Starknet bertujuan untuk menyediakan cepat, "
"aman, dan rendah biaya transaksi. Ini beroperasi sebagai rollup validitas, "
"umumnya dikenal sebagai rollup nol-tahu, dan dibangun di atas Cairo VM."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Starknet contracts are programs specifically designed to run within the "
"Starknet OS. The Starknet OS is a Cairo program itself, which means that any"
" operation executed by the Starknet OS can be proven and succinctly "
"verified. Smart contracts can access Starknet's persistent state through the"
" OS, enabling them to read or modify variables in Starknet’s state, "
"communicate with other contracts, and interact seamlessly with the "
"underlying Layer 1 (L1) network."
msgstr ""
"Kontrak Starknet adalah program yang dirancang secara khusus untuk "
"dijalankan dalam OS Starknet. OS Starknet adalah program Cairo sendiri, yang"
" berarti bahwa setiap operasi yang dijalankan oleh OS Starknet dapat "
"dibuktikan dan diverifikasi secara tepat. Kontrak cerdas dapat mengakses "
"negara Starknet yang gigih melalui OS, memungkinkan mereka untuk membaca "
"atau memodifikasi variabel dalam negara Starknet, berkomunikasi dengan "
"kontrak lain, dan berinteraksi dengan lapisan bawah 1 (L1) jaringan."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"If you want to learn more about the Starknet network itself, its "
"architecture and the tooling available, you should read the [Starknet "
"Book](https://book.starknet.io/). In this book, we will only focus on "
"writing smart contracts in Cairo."
msgstr ""
"Jika Anda ingin belajar lebih banyak tentang jaringan Starknet itu sendiri, "
"arsitekturnya dan tooling yang tersedia, Anda harus membaca [Buku Starknet] "
"2.0https://book.starknet.io/). dalam buku ini, kita hanya akan fokus pada "
"menulis kontrak cerdas di Cairo."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Scarb"
msgstr "Scarb"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Scarb facilitates smart contract development for Starknet. To enable this "
"feature, you'll need to make some configurations in your _Scarb.toml_ file "
"(see [Installation](./ch01-01-installation.md) for how to install Scarb)."
msgstr ""
"Scarb memfasilitasi pengembangan kontrak pintar bagi Starknet. Untuk "
"mengaktifkan fitur ini, Anda perlu membuat beberapa konfigurasi dalam berkas"
" _Scarb.toml_ Anda (lihat [Instalasi]./ch01-01-installation.mlasi) untuk "
"cara memasang Scarb)."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"First, add the `starknet` dependency to your _Scarb.toml_ file. Next, enable"
" the Starknet contract compilation of the package by adding a "
"`[[target.starknet-contract]]` section. By default, specifying this target "
"will build a Sierra Contract Class file, which can be deployed on Starknet. "
"If you omit to specify the target, your package will compile but will not "
"produce an output that you can use with Starknet."
msgstr ""
"Pertama, tambahkan ketergantungan Ástarknet ke file _Scarb.toml_ Anda. "
"Berikutnya, aktifkan kompilasi kontrak Starknet dari paket dengan "
"menambahkan sebuah å[target.starknet-contract]. Secara baku, spesifikasikan "
"target ini akan membangun sebuah berkas Sierra Contract Class, yang dapat "
"digunakan di Starknet. Jika Anda tidak menspesifikasikan target, paket Anda "
"akan dikompilasi tetapi tidak akan menghasilkan keluaran yang dapat Anda "
"gunakan dengan Starknet."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Below is the minimal _Scarb.toml_ file required to compile a crate "
"containing Starknet contracts:"
msgstr ""
"Di bawah ini adalah minimal file _Scarb.toml_ diperlukan untuk mengkompilasi"
" peti berisi kontrak Starknet:"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.6.3\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"nama [paket] = \"package_name\" versi = \"0.1.0\" [dependensi] rinnet = "
"\">=2.6.3\" [[target.Starknet-contract]]]"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"To compile contracts defined in your package's dependencies, please refer to"
" the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-"
"target.html#compiling-external-contracts)."
msgstr ""
"Untuk mengkompilasi kontrak yang didefinisikan dalam ketergantungan paket "
"Anda, silakan merujuk ke [Konsersi "
"Scarb][Scarb].https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-"
"target.htl# kompliling-external-contracts)."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Starknet Foundry"
msgstr "Pendirian Starknet"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Starknet Foundry is a tool chain for Starknet smart contract development. It"
" supports many features, including writing and running tests with advanced "
"features, deploying contracts, interacting with the Starknet network, and "
"more."
msgstr ""
"Pendirian Starknet adalah alat untuk pengembangan kontrak pintar Starknet. "
"dan lebih banyak lagi."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"We'll describe Starknet Foundry in more detail in [Chapter "
"17](./ch17-02-testing-smart-contracts.md#testing-smart-contracts-with-"
"starknet-foundry) when discussing Starknet smart contract testing and "
"security."
msgstr ""
"Kami akan menggambarkan Starknet Foundry dalam rincian lebih lanjut di "
"[Chapter ofnectann. /ch17-02-testing-smart-contracts.m#testing-mart-"
"contracts-with-starknet-foundry) ketika membahas Starknet uji cobaan cerdas "
"dan keamanan."

#: src/ch13-01-general-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart contracts"
" are, what they are used for, and why blockchain developers would use Cairo "
"and Starknet. If you are already familiar with blockchain programming, feel "
"free to skip this chapter. The last part might still be interesting though."
msgstr ""
"Bab ini akan memberikan pengenalan tingkat tinggi untuk apa kontrak cerdas, "
"apa yang mereka gunakan, dan mengapa pengembang blockchain akan menggunakan "
"Cairo dan Starknet. jika Anda sudah akrab dengan program blockchain, silakan"
" lewati bab ini. bagian terakhir mungkin masih menarik meskipun."

#: src/ch13-01-general-introduction-to-smart-contracts.md:6
msgid "Smart Contracts"
msgstr "Kontrak Cerdas"

#: src/ch13-01-general-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth "
"of Ethereum. Smart contracts are essentially programs deployed on a "
"blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that "
"are executed based on specific inputs. They primarily consist of two "
"components: storage and functions. Once deployed, users can interact with "
"smart contracts by initiating blockchain transactions containing execution "
"data (which function to call and with what input). Smart contracts can "
"modify and read the storage of the underlying blockchain. A smart contract "
"has its own address and is considered a blockchain account, meaning it can "
"hold tokens."
msgstr ""
"Kontrak cerdas mendapatkan popularitas dan menjadi lebih luas dengan "
"kelahiran Ethereaum. Kontrak cerdas pada dasarnya digunakan pada sebuah "
"rantai blok. Istilah \"kontrak cerdas\" agak menyesatkan, karena mereka "
"bukan \"smart\" atau \"contracts\" tapi lebih tepatnya kode dan instruksi "
"yang dijalankan berdasarkan masukan spesifik. Mereka terutama terdiri dari "
"dua komponen: penyimpanan dan fungsi. Sekali digunakan, pengguna dapat "
"berinteraksi dengan kontrak cerdas dengan memulai transaksi blockchain yang "
"berisi data (yang disebut dan dengan masukan). Kontrak cerdas dapat "
"memodifikasi dan membaca penyimpanan di bawah rantai blok."

#: src/ch13-01-general-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on "
"the blockchain. For example, on Ethereum and the [EVM-compatible "
"ecosystem](https://ethereum.org/en/developers/docs/evm/), the most commonly "
"used language is Solidity, while on Starknet, it is Cairo. The way the code "
"is compiled also differs based on the blockchain. On Ethereum, Solidity is "
"compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then "
"into Cairo Assembly (CASM)."
msgstr ""
"Bahasa pemrograman yang digunakan untuk menulis kontrak cerdas bervariasi "
"tergantung pada rantai blok. Sebagai contoh, pada Ethereum dan [EVM-kosistem"
" yang saling kompatibel] Nicohttps://etherum.org/en/develpers/docs/evm/), "
"bahasa yang paling umum digunakan adalah Soliditas, sedangkan di Starknet, "
"itu Cairo. Cara kode dikompilasi juga berbeda berdasarkan pada rantai blok. "
"Pada Etherum, Solidity dikompilasi ke dalam bytecode. On Starknet, Cairo "
"disusun ke Sierra dan kemudian ke dalam rangkaian Cairo (CAS)."

#: src/ch13-01-general-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are "
"**permissionless**, meaning anyone can deploy a smart contract on the "
"network (within the context of a decentralized blockchain, of course). Smart"
" contracts are also **transparent**; the data stored by the smart contract "
"is accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write "
"smart contracts that use other smart contracts. Smart contracts can only "
"access and interact with data from the blockchain they are deployed on. They"
" require third-party software (called _oracles_) to access external data "
"(the price of a token for instance)."
msgstr ""
"Kontrak cerdas memiliki beberapa karakteristik unik. Kontrak cerdas juga "
"**transparan**; data yang disimpan oleh kontrak cerdas dapat diakses oleh "
"siapapun. Kode yang menyusun kontrak dapat juga transparan, mengaktifkan "
"**komposabilitas**. Hal ini memungkinkan pengembang untuk menulis kontrak "
"cerdas yang menggunakan kontrak cerdas. Kontrak cerdas hanya dapat diakses "
"dan berinteraksi dengan jaringan data yang dijalankan. Mereka memerlukan "
"perangkat lunak ketiga (yang disebut _ortal_s) akses ke eksternal."

#: src/ch13-01-general-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, "
"it is required to know what the other contracts look like. Hence, Ethereum "
"developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to "
"build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs (Non-"
"Fungible Tokens) like `CryptoPunks` or `Everai`."
msgstr ""
"Untuk pengembang membangun kontrak cerdas yang dapat berinteraksi satu sama "
"lain, dibutuhkan untuk mengetahui seperti apa kontrak lainnya. Oleh karena "
"itu, para pengembang Etherem mulai membangun standar untuk pengembangan "
"kontrak cerdas, yang ÁERCxx--. Dua standar yang paling sering digunakan dan "
"terkenal adalah yang digunakan dan terkenal adalah yang digunakan untuk "
"membangun token seperti ÁUSDCER, ÁDAI atau ÁRK (C721, untuk NFT) seperti NFT"
" (No-Fungible Toungble Token) atau Erai."

#: src/ch13-01-general-introduction-to-smart-contracts.md:18
msgid "Use Cases"
msgstr "Gunakan Kasus"

#: src/ch13-01-general-introduction-to-smart-contracts.md:20
msgid ""
"There are many possible use cases for smart contracts. The only limits are "
"the technical constraints of the blockchain and the creativity of "
"developers."
msgstr ""
"Ada banyak kasus yang mungkin digunakan untuk kontrak cerdas. hanya batasan "
"teknis dari rantai blok dan kreativitas pengembang."

#: src/ch13-01-general-introduction-to-smart-contracts.md:22
msgid "DeFi"
msgstr "DeFi"

#: src/ch13-01-general-introduction-to-smart-contracts.md:24
msgid ""
"For now, the principal use case for smart contracts is similar to that of "
"Ethereum or Bitcoin, which is essentially handling money. In the context of "
"the alternative payment system promised by Bitcoin, smart contracts on "
"Ethereum enable the creation of decentralized financial applications that no"
" longer rely on traditional financial intermediaries. This is what we call "
"DeFi (decentralized finance). DeFi consists of various projects such as "
"lending/borrowing applications, decentralized exchanges (DEX), on-chain "
"derivatives, stablecoins, decentralized hedge funds, insurance, and many "
"more."
msgstr ""
"Untuk saat ini, kasus dasar untuk kontrak cerdas sama dengan kontrak "
"Ethereum atau Bitcoin, yang pada dasarnya menangani uang. dalam konteks "
"sistem pembayaran alternatif yang dijanjikan oleh Bitcoin, kontrak cerdas di"
" Etherum memungkinkan pembuatan aplikasi keuangan terdesentralisasi yang "
"tidak lagi bergantung pada perantara keuangan tradisional. Inilah yang kita "
"sebut DeFi (konsentrasi keuangan terderalisasi). DeFi terdiri dari berbagai "
"proyek seperti pinjaman/borrowing aplikasi, destrolisasi (DEX), pada turunan"
" turunan, stabilitas stabil, penetapan yang layak, dana asuransi, dan lebih "
"banyak lagi."

#: src/ch13-01-general-introduction-to-smart-contracts.md:26
msgid "Tokenization"
msgstr "Tokenisasi"

#: src/ch13-01-general-introduction-to-smart-contracts.md:28
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such "
"as real estate, art, or precious metals. Tokenization divides an asset into "
"digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and "
"simplify the buying and selling process."
msgstr ""
"Kontrak cerdas dapat memfasilitasi tokenisasi aset dunia nyata, seperti real"
" estate, seni, atau logam berharga."

#: src/ch13-01-general-introduction-to-smart-contracts.md:30
msgid "Voting"
msgstr "Voting"

#: src/ch13-01-general-introduction-to-smart-contracts.md:32
msgid ""
"Smart contracts can be used to create secure and transparent voting systems."
" Votes can be recorded on the blockchain, ensuring immutability and "
"transparency. The smart contract can then automatically tally the votes and "
"declare the results, minimizing the potential for fraud or manipulation."
msgstr ""
"Kontrak cerdas dapat digunakan untuk menciptakan sistem suara yang aman dan "
"transparan. pilihan dapat direkam pada rantai blok, memastikan immutability "
"dan transparansi. kontrak cerdas kemudian secara otomatis dapat menghitung "
"suara dan menyatakan hasil, meminimalkan potensi untuk penipuan atau "
"manipulasi."

#: src/ch13-01-general-introduction-to-smart-contracts.md:34
msgid "Royalties"
msgstr "Royalti"

#: src/ch13-01-general-introduction-to-smart-contracts.md:36
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and "
"other content creators. When a piece of content is consumed or sold, the "
"smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for "
"intermediaries."
msgstr ""
"Kontrak cerdas dapat mengatur pembayaran royalti untuk seniman, musisi, dan "
"pembuat konten lainnya. ketika sebuah konten dikonsumsi atau dijual, kontrak"
" cerdas dapat secara otomatis menghitung dan mendistribusikan royalti kepada"
" pemilik yang sah, memastikan kompensasi yang adil dan mengurangi kebutuhan "
"perantara."

#: src/ch13-01-general-introduction-to-smart-contracts.md:38
msgid "Decentralized Identities DIDs"
msgstr "Identitas yang decentralisasi"

#: src/ch13-01-general-introduction-to-smart-contracts.md:40
msgid ""
"Smart contracts can be used to create and manage digital identities, "
"allowing individuals to control their personal information and share it with"
" third parties securely. The smart contract could verify the authenticity of"
" a user's identity and automatically grant or revoke access to specific "
"services based on the user's credentials."
msgstr ""
"Kontrak cerdas dapat digunakan untuk menciptakan dan mengelola identitas "
"digital, memungkinkan individu untuk mengontrol informasi pribadi mereka dan"
" berbagi dengan pihak ketiga dengan aman. Kontrak cerdas dapat memverifikasi"
" keaslian identitas pengguna dan secara otomatis memberikan atau mencabut "
"akses ke layanan spesifik berdasarkan kredensial pengguna."

#: src/ch13-01-general-introduction-to-smart-contracts.md:46
msgid "The Rise of Starknet and Cairo"
msgstr "Naiknya Starknet dan Cairo"

#: src/ch13-01-general-introduction-to-smart-contracts.md:48
msgid ""
"Ethereum, being the most widely used and resilient smart contract platform, "
"became a victim of its own success. With the rapid adoption of some "
"previously mentioned use cases, mainly DeFi, the cost of performing "
"transactions became extremely high, rendering the network almost unusable. "
"Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue."
msgstr ""
"Etherum, menjadi platform kontrak cerdas yang paling banyak digunakan dan "
"tangguh, menjadi korban keberhasilannya sendiri. dengan adopsi cepat dari "
"beberapa kasus sebelumnya yang disebutkan penggunaan, terutama DeFi, biaya "
"untuk melakukan transaksi menjadi sangat tinggi, membuat jaringan hampir "
"tidak dapat digunakan. Insinyur dan peneliti di ekosistem mulai bekerja pada"
" solusi untuk mengatasi masalah skalabilitas ini."

#: src/ch13-01-general-introduction-to-smart-contracts.md:50
msgid ""
"A famous trilemma called The Blockchain Trilemma in the blockchain space "
"states that it is hard to achieve a high level of scalability, "
"decentralization, and security simultaneously; trade-offs must be made. "
"Ethereum is at the intersection of decentralization and security. "
"Eventually, it was decided that Ethereum's purpose would be to serve as a "
"secure settlement layer, while complex computations would be offloaded to "
"other networks built on top of Ethereum. These are called Layer 2s (L2s)."
msgstr ""
"Trilemma terkenal yang disebut The Blockchain Trilema di blok rantai ruang "
"negara-negara yang sulit untuk mencapai tingkat skalabilitas tinggi, "
"layakisasi, dan keamanan secara simultan; trade-offs harus dibuat. Etherum "
"berada di persimpangan decentralization dan keamanan. pada akhirnya, "
"diputuskan bahwa Etherum's tujuan akan melayani sebagai lapisan penyelesaian"
" yang aman, sementara komputasi kompleks akan diturunkan ke jaringan lain "
"dibangun di atas Etherum. ini disebut Layer 2s (2s)."

#: src/ch13-01-general-introduction-to-smart-contracts.md:52
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. "
"Both approaches involve compressing and batching numerous transactions "
"together, computing the new state, and settling the result on Ethereum (L1)."
" The difference lies in the way the result is settled on L1. For optimistic "
"rollups, the new state is considered valid by default, but there is a 7-day "
"window for nodes to identify malicious transactions."
msgstr ""
"Kedua tipe utama dari L2 adalah rollups optimis dan validitas rollups. "
"Keduanya melibatkan kompresi dan batching banyak transaksi bersama-sama, "
"komputasi negara baru, dan menyelesaikan hasilnya pada Ethereum (L1). "
"Perbedaannya terletak pada cara hasilnya diselesaikan pada L1. Untuk optimis"
" rollups, negara baru dianggap valid secara baku, tetapi ada 7-hari jendela "
"untuk nodes untuk mengidentifikasi transaksi jahat."

#: src/ch13-01-general-introduction-to-smart-contracts.md:54
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove "
"that the new state has been correctly computed. This is the purpose of "
"STARKs, this cryptographic technology could permit validity rollups to scale"
" significantly more than optimistic rollups. You can learn more about STARKs"
" from Starkware's Medium [article](https://medium.com/starkware/starks-"
"starkex-and-starknet-9a426680745a), which serves as a good primer."
msgstr ""
"Sebagai kontras, validitas rollups, seperti Starknet, menggunakan "
"kriptografi untuk membuktikan bahwa negara baru telah dihitung dengan benar."
" ini adalah tujuan dari STARKs, teknologi kriptografis ini dapat "
"memungkinkan validitas untuk skala yang jauh lebih besar daripada rollups "
"optimis. Anda dapat belajar lebih banyak tentang STARKs dari Starkware's Med"
" [article]://dium.com/starkware/stark-starkex-starkex-starknet-a4266745a), "
"yang berfungsi sebagai primar yang baik."

#: src/ch13-01-general-introduction-to-smart-contracts.md:56
msgid ""
"Starknet's architecture is thoroughly described in the [Starknet "
"Book](https://book.starknet.io/ch03-00-architecture.html), which is a great "
"resource to learn more about the Starknet network."
msgstr ""
"Arsitektur Starknet dijelaskan secara menyeluruh dalam [Buku "
"Starknet][Hehttps://book.starknet.io/ch03-00-architecture.html], yang "
"merupakan sumber daya yang besar untuk mempelajari lebih banyak tentang "
"jaringan Starknet."

#: src/ch13-01-general-introduction-to-smart-contracts.md:58
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work "
"with STARKs and make them general-purpose. With Cairo, we can write "
"**provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another."
msgstr ""
"Ini adalah bahasa yang dikembangkan khusus untuk bekerja dengan STARKs dan "
"membuatnya menjadi tujuan umum. dengan Cairo, kita dapat menulis kode yang "
"dapat dibuktikan dalam konteks Starknet, ini memungkinkan bukti benarnya "
"komputasi dari satu negara ke negara lain."

#: src/ch13-01-general-introduction-to-smart-contracts.md:60
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM"
" (either as-is or adapted) as a base layer, Starknet employs its own VM. "
"This frees developers from the constraints of the EVM, opening up a broader "
"range of possibilities. Coupled with decreased transaction costs, the "
"combination of Starknet and Cairo creates an exciting playground for "
"developers. Native account abstraction enables more complex logic for "
"accounts, that we call \"Smart Accounts\", and transaction flows. Emerging "
"use cases include **transparent AI** and machine learning applications. "
"Finally, **blockchain games** can be developed entirely **on-chain**. "
"Starknet has been specifically designed to maximize the capabilities of "
"STARK proofs for optimal scalability."
msgstr ""
"Tidak seperti kebanyakan pesaing Starknet yang memilih untuk menggunakan EVM"
" (misalnya atau beradaptasi) sebagai lapisan dasar, Starknet menggunakan VM "
"sendiri. ini membebaskan para pengembang dari keterbatasan EVM, membuka "
"berbagai kemungkinan yang lebih luas. ditambah dengan berkurangnya biaya "
"transaksi, kombinasi Starknet dan Cairo menciptakan taman bermain yang "
"menarik bagi pengembang."

#: src/ch13-01-general-introduction-to-smart-contracts.md:62
msgid ""
"Learn more about Account Abstraction in the [Starknet "
"Book](https://book.starknet.io/ch04-00-account-abstraction.html)."
msgstr ""
"Pelajari lebih banyak tentang Akun Abstraction dalam [Buku "
"Starknet].https://book.starknet.io/ch04-00-account-abstraction.html)."

#: src/ch13-01-general-introduction-to-smart-contracts.md:68
msgid "Cairo Programs and Starknet Contracts: What Is the Difference?"
msgstr "Program Cairo dan Kontrak Starknet: Apa Perbedaannya?"

#: src/ch13-01-general-introduction-to-smart-contracts.md:70
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts"
" previously learned in this book are still applicable to write Starknet "
"contracts. As you may have already noticed, a Cairo program must always have"
" a `main` function that serves as the entry point for this program:"
msgstr ""
"Kontrak Starknet adalah superset khusus program Cairo, sehingga konsep yang "
"sebelumnya dipelajari dalam buku ini masih berlaku untuk menulis kontrak "
"Starknet."

#: src/ch13-01-general-introduction-to-smart-contracts.md:77
msgid ""
"Contracts deployed on the Starknet network are essentially programs that are"
" run by the sequencer, and as such, have access to Starknet's state. "
"Contracts do not have a `main` function but one or multiple functions that "
"can serve as entry points."
msgstr ""
"Kontrak yang dikerahkan pada jaringan Starknet pada dasarnya adalah program "
"yang dijalankan oleh pengurut, dan karena itu, memiliki akses ke negara "
"Starknet. Kontrak tidak memiliki fungsi utama kecuali satu atau beberapa "
"fungsi yang dapat berfungsi sebagai titik masuk."

#: src/ch13-01-general-introduction-to-smart-contracts.md:79
msgid ""
"Starknet contracts are defined within [modules](./ch07-02-defining-modules-"
"to-control-scope.md). For a module to be handled as a contract by the "
"compiler, it must be annotated with the `#[starknet::contract]` attribute."
msgstr ""
"Kontrak Starknet didefinisikan dalam [modules][. /ch07-02-defining-modules-"
"to-control-scope.md). Untuk sebuah modul yang akan ditangani sebagai kontrak"
" oleh kompiler, ia harus dienotasi dengan atribut.#[starknet::contract]."

#: src/ch13-02-anatomy-of-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts using a "
"very simple smart contract as example. You will learn how to write a "
"contract that allows anyone to store a single number on the Starknet "
"blockchain."
msgstr ""
"Bab ini akan memperkenalkan anda kepada dasar-dasar kontrak Starknet "
"menggunakan kontrak cerdas yang sangat sederhana sebagai contoh. anda akan "
"belajar bagaimana menulis kontrak yang memungkinkan siapa pun untuk "
"menyimpan satu nomor pada rantai blok Starknet."

#: src/ch13-02-anatomy-of-a-simple-contract.md:5
msgid ""
"Let's consider the following contract for the whole chapter. It might not be"
" easy to understand it all at once, but we will go through it step by step:"
msgstr ""
"Mari kita pertimbangkan kontrak berikut untuk seluruh bab. mungkin tidak "
"mudah untuk memahami semuanya sekaligus, tapi kita akan pergi melalui itu "
"langkah demi langkah:"

#: src/ch13-02-anatomy-of-a-simple-contract.md:34
msgid "<span class=\"caption\">Listing 13-1: A simple storage contract</span>"
msgstr ""
"<span class=\"caption\">Listing 13-1: Sebuah kontrak penyimpanan "
"sederhana</span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:36
msgid "What Is this Contract?"
msgstr "Apa Kontrak ini?"

#: src/ch13-02-anatomy-of-a-simple-contract.md:38
msgid ""
"Contracts are defined by encapsulating state and logic within a module "
"annotated with the `#[starknet::contract]` attribute."
msgstr ""
"Kontrak didefinisikan dengan merangkumkan keadaan dan logika dalam sebuah "
"modul yang dianotasi dengan atribut aktivita ▪#[starknet::contract]."

#: src/ch13-02-anatomy-of-a-simple-contract.md:40
msgid ""
"The state is defined within the `Storage` struct, and is always initialized "
"empty. Here, our struct contains a single a field called `stored_data` of "
"type `u128` (unsigned integer of 128 bits), indicating that our contract can"
" store any number between 0 and \\\\( {2^{128}} - 1 \\\\)."
msgstr ""
"Di sini, struktur kami berisi satu bidang yang disebut Ástorage_data tipe "
"·u128 (tidak tertandai integer 128 bits), menunjukkan bahwa kontrak kami "
"dapat menyimpan nomor apapun antara 0 dan \\\\ (2{128)} - 1\\\\)."

#: src/ch13-02-anatomy-of-a-simple-contract.md:42
msgid ""
"The logic is defined by functions that interact with the state. Here, our "
"contract defines and publicly exposes the functions `set` and `get` that can"
" be used to modify or retrieve the value of the stored variable. You can "
"think of it as a single slot in a database that you can query and modify by "
"calling functions of the code that manages the database."
msgstr ""
"Logika didefinisikan oleh fungsi yang berinteraksi dengan negara. di sini, "
"kontrak kami mendefinisikan dan mengekspos secara terbuka fungsi-fungsi "
"tersebut dan dapat digunakan untuk memodifikasi atau mengambil nilai dari "
"variabel yang tersimpan. Anda dapat menganggapnya sebagai slot tunggal dalam"
" database yang dapat Anda periksa dan modifikasi dengan memanggil fungsi "
"kode yang mengatur database."

#: src/ch13-02-anatomy-of-a-simple-contract.md:45
msgid "The Interface: the Contract's Blueprint"
msgstr "The Interface: the Contract's Blueprint"

#: src/ch13-02-anatomy-of-a-simple-contract.md:55
msgid "<span class=\"caption\">Listing 13-2: A basic contract interface</span>"
msgstr ""
"<span class=\"caption\">Listing 13-2: Sebuah antar muka kontrak dasar</span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:58
msgid ""
"Interfaces represent the blueprint of the contract. They define the "
"functions that the contract exposes to the outside world. In Cairo, they're "
"defined by annotating a trait with the `#[starknet::interface]` attribute. "
"All functions of the trait are considered public functions of any contract "
"that implements this trait, and are callable from the outside world."
msgstr ""
"Antar muka mewakili cetak biru kontrak. Mereka mendefinisikan fungsi yang "
"dieksposkan kontrak ke dunia luar. Di Cairo, mereka didefinisikan dengan "
"mengnotasi sebuah sifat dengan atribut antar-muka:. Semua fungsi sifat "
"dianggap fungsi publik dari setiap kontrak yang menerapkan sifat ini, dan "
"dapat dipanggil dari dunia luar."

#: src/ch13-02-anatomy-of-a-simple-contract.md:60
msgid ""
"All contract interfaces use a generic type for the `self` parameter, "
"representing the contract state. We chose to name this generic parameter "
"`TContractState` in our interface, but this is not enforced and any name can"
" be chosen."
msgstr ""
"Semua antarmuka kontrak menggunakan sebuah tipe generik untuk parameter "
"sendiri, mewakili kondisi kontrak. Kami memilih untuk menamai parameter "
"generik ini TContractState di antarmuka kami, tapi ini tidak berlaku dan "
"nama apapun yang dapat dipilih."

#: src/ch13-02-anatomy-of-a-simple-contract.md:62
msgid ""
"In our interface, note the generic type `TContractState` of the `self` "
"argument which is passed by reference to the `set` function. Seeing the "
"`self` argument passed in a contract function tells us that this function "
"can access the state of the contract. The `ref` modifier implies that `self`"
" may be modified, meaning that the storage variables of the contract may be "
"modified inside the `set` function."
msgstr ""
"Dalam interface kami, perhatikan tipe umum dari argumen umum TContractstate "
"dari diri sendiri yang dilewatkan sebagai referensi ke fungsi ·set. Melihat "
"argumen diri sendiri lewat dalam sebuah fungsi kontrak memberitahu kita "
"bahwa fungsi ini dapat mengakses keadaan dari kontrak. Pemodifikasi yang "
"menyatakan bahwa sendiri dapat dimodifikasi, berarti bahwa variabel "
"penyimpanan dari kontrak dapat diubah di dalam fungsi thoseset."

#: src/ch13-02-anatomy-of-a-simple-contract.md:64
msgid ""
"On the other hand, the `get` function takes a snapshot of `TContractState`, "
"which immediately tells us that it does not modify the state (and indeed, "
"the compiler will complain if we try to modify storage inside the `get` "
"function)."
msgstr ""
"Di sisi lain, fungsinya mengambil foto dari Contractstate, yang langsung "
"memberi tahu kita bahwa fungsinya tidak memodifikasi negara (dan memang, "
"kompiler akan mengeluh jika kita mencoba memodifikasi penyimpanan di dalam "
"fungsi thoseget)."

#: src/ch13-02-anatomy-of-a-simple-contract.md:66
msgid ""
"By leveraging the [traits & impls](./ch08-02-traits-in-cairo.md) mechanism "
"from Cairo, we can make sure that the actual implementation of the contract "
"matches its interface. In fact, you will get a compilation error if your "
"contract doesn’t conform with the declared interface. For example, Listing "
"13-3 shows a wrong implementation of the `ISimpleStorage` interface, "
"containing a slightly different `set` function that doesn't have the same "
"signature."
msgstr ""
"Dengan memanfaatkan mekanisme [traits & impls][ch08-02-traits-in-cairo.med) "
"dari Cairo, kita dapat memastikan bahwa implementasi kontrak yang sebenarnya"
" cocok dengan antarmukanya. Pada kenyataannya, Anda akan mendapatkan "
"kesalahan kompilasi jika kontrak Anda tidak sesuai dengan antarmuka yang "
"dideklarasikan. Sebagai contoh, Daftar 13-3 menunjukkan implementasi yang "
"salah dari antarmuka RIAISIMPLEage CD, berisi fungsi yang sedikit berbeda "
"yang tidak memiliki tanda tangan yang sama."

#: src/ch13-02-anatomy-of-a-simple-contract.md:78
msgid ""
"<span class=\"caption\">Listing 13-3: A wrong implementation of the "
"interface of the contract. This does not compile, as the signature of `set` "
"doesn't match the trait's.</span>"
msgstr ""
"<span class=\"caption\">Listing 13-3: Sebuah implementasi yang salah dari "
"antar muka kontrak. Ini tidak mengkompilasi, sebagai tanda tangan dari set "
"tidak cocok dengan sifat.</span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:80
msgid ""
"Trying to compile a contract using this implementation will result in the "
"following error:"
msgstr ""
"Mencoba mengkompilasi kontrak menggunakan implementasi ini akan "
"mengakibatkan galat berikut:"

#: src/ch13-02-anatomy-of-a-simple-contract.md:100
msgid "Public Functions Defined in an Implementation Block"
msgstr "Fungsi Publik Didefinisikan dalam Blok Implementasi"

#: src/ch13-02-anatomy-of-a-simple-contract.md:102
msgid "Before we explore things further down, let's define some terminology."
msgstr ""
"Sebelum kita menjelajahi hal-hal lebih lanjut ke bawah, mari kita "
"definisikan beberapa terminologi."

#: src/ch13-02-anatomy-of-a-simple-contract.md:104
msgid ""
"In the context of Starknet, a _public function_ is a function that is "
"exposed to the outside world. A public function can be called by anyone, "
"either from outside the contract or from within the contract itself. In the "
"example above, `set` and `get` are public functions."
msgstr ""
"Dalam konteks Starknet, fungsi _publik adalah fungsi yang terpapar dunia "
"luar. Fungsi publik dapat dipanggil oleh siapa saja, baik dari luar kontrak "
"atau dari dalam kontrak itu sendiri."

#: src/ch13-02-anatomy-of-a-simple-contract.md:106
msgid ""
"What we call an _external_ function is a public function that can be "
"directly invoked through a Starknet transaction and that can mutate the "
"state of the contract. `set` is an external function."
msgstr ""
"Apa yang kita sebut fungsi _external adalah fungsi publik yang dapat secara "
"langsung dipanggil melalui transaksi Starknet dan yang dapat mengubah "
"keadaan kontrak."

#: src/ch13-02-anatomy-of-a-simple-contract.md:108
msgid ""
"A _view_ function is a public function that is typically read-only and "
"cannot mutate the state of the contract. However, this limitation is only "
"enforced by the compiler, and not by Starknet itself. We will discuss the "
"implications of this in a later section. `get` is a view function."
msgstr ""
"Fungsi _view_ adalah fungsi publik yang biasanya hanya dibaca dan tidak "
"dapat mengubah keadaan kontrak. Namun, pembatasan ini hanya ditegakkan oleh "
"kompiler, dan bukan oleh Starknet sendiri. Kita akan membahas implikasi dari"
" ini dalam bagian selanjutnya."

#: src/ch13-02-anatomy-of-a-simple-contract.md:123
msgid ""
"<span class=\"caption\">Listing 13-4: `SimpleStorage` implementation</span>"
msgstr "<span class=\"caption\">Listing 13-4:.impleStorage) implementasi</span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:125
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in "
"order to match the interface, the public functions of the contract must be "
"defined in an implementation of this trait — which allows us to make sure "
"that the implementation of the contract matches its interface."
msgstr ""
"Karena antarmuka kontrak didefinisikan sebagai sifat æisimpleStorage, untuk "
"mencocokkan antarmuka, fungsi publik dari kontrak harus didefinisikan dalam "
"implementasi sifat ini yang memungkinkan kita untuk memastikan bahwa "
"implementasi kontrak cocok dengan antarmukanya."

#: src/ch13-02-anatomy-of-a-simple-contract.md:127
msgid ""
"However, simply defining the functions in the implementation block is not "
"enough. The implementation block must be annotated with the "
"`#[abi(embed_v0)]` attribute. This attribute exposes the functions defined "
"in this implementation to the outside world — forget to add it and your "
"functions will not be callable from the outside. All functions defined in a "
"block marked as `#[abi(embed_v0)]` are consequently _public functions_."
msgstr ""
"Namun, hanya mendefinisikan fungsi-fungsi dalam blok implementasi tidak "
"cukup. Blok implementasi harus dianotasi dengan atribut <0). Atribut ini "
"mengekspos fungsi yang didefinisikan dalam implementasi ini ke dunia luar "
"lupa untuk menambahkannya dan fungsi-fungsi Anda tidak akan dapat dipanggil "
"dari luar. Semua fungsi yang didefinisikan dalam sebuah blok yang ditandai "
"sebagai ▪[abireadyembed_v0]"

#: src/ch13-02-anatomy-of-a-simple-contract.md:129
msgid ""
"Because the `SimpleStorage` contract is defined as a module, we need to "
"access the interface defined in the parent module. We can either bring it to"
" the current scope with the `use` keyword, or refer to it directly using "
"`super`."
msgstr ""
"Karena kontrak 'SimpleStorage' ini didefinisikan sebagai modul, kita perlu "
"mengakses antarmuka yang didefinisikan dalam modul induk."

#: src/ch13-02-anatomy-of-a-simple-contract.md:131
msgid ""
"When writing the implementation of an interface, the `self` parameter in the"
" trait methods **must** be of type `ContractState`. The `ContractState` type"
" is generated by the compiler, and gives access to the storage variables "
"defined in the `Storage` struct. Additionally, `ContractState` gives us the "
"ability to emit events. The name `ContractState` is not surprising, as it’s "
"a representation of the contract’s state, which is what we think of `self` "
"in the contract interface trait. When `self` is a snapshot of "
"`ContractState`, only read access is allowed, and emitting events is not "
"possible."
msgstr ""
"Ketika menulis implementasi dari sebuah antarmuka, sebuah parameter diri "
"sendiri dalam metode sifat ** Must** akan bertipe seperti kontractate. Tipe "
"kontractate yang dihasilkan oleh compiler, dan memberikan akses ke variabel "
"penyimpanan yang didefinisikan dalam struktur thosetorage. Selain itu, ▪ "
"Kontractántate memberi kita kemampuan untuk memancarkan peristiwa. Nama "
"Contractate those is not surprictate, karena itu merupakan presentation of "
"the constructs state, yaitu apa yang kita pikirkan tentang dirinya dalam "
"interfaces."

#: src/ch13-02-anatomy-of-a-simple-contract.md:135
msgid "Accessing and Modifying the Contract's State"
msgstr "Mengakses dan Mengubah Negara Bagian Kontrak"

#: src/ch13-02-anatomy-of-a-simple-contract.md:137
msgid ""
"Two methods are commonly used to access or modify the state of a contract:"
msgstr ""
"Dua metode umumnya digunakan untuk mengakses atau memodifikasi keadaan "
"sebuah kontrak:"

#: src/ch13-02-anatomy-of-a-simple-contract.md:138
msgid ""
"`read`, which returns the value of a storage variable. This method is called"
" on the variable itself and does not take any argument."
msgstr ""
"Metode ini disebut pada variabel itu sendiri dan tidak mengambil argumen "
"apapun."

#: src/ch13-02-anatomy-of-a-simple-contract.md:144
msgid ""
"`write`, which allows to write a new value in a storage slot. This method is"
" also called on the variable itself and takes one argument, which is the "
"value to be written. Note that `write` may take more than one argument, "
"depending on the type of the storage variable. For example, writing on a "
"mapping requires 2 arguments: the key and the value to be written."
msgstr ""
"Metode ini juga disebut pada variabel itu sendiri dan mengambil satu "
"argumen, yang merupakan nilai untuk ditulis. Perlu dicatat bahwa tulisan "
"dapat mengambil lebih dari satu argumen, tergantung pada tipe variabel "
"penyimpanan. Sebagai contoh, menulis pada pemetaan membutuhkan 2 argumen: "
"kunci dan nilai untuk ditulis."

#: src/ch13-02-anatomy-of-a-simple-contract.md:150
msgid ""
"Reminder: if the contract state is passed as a snapshot with `@` instead of "
"passed by reference with `ref`, attempting to modify the contract state will"
" result in a compilation error."
msgstr ""
"Pengingat: jika negara kontrak dilewatkan sebagai sebuah snapshot dengan "
"those@Neué daripada dilewatkan oleh referensi dengan årefé, mencoba untuk "
"memodifikasi negara kontrak akan menghasilkan kesalahan kompilasi."

#: src/ch13-02-anatomy-of-a-simple-contract.md:152
msgid ""
"This contract does not do much apart from allowing anyone to store a single "
"number that is accessible by anyone in the world. Anyone could call `set` "
"again with a different value and overwrite the current number. Nevertheless,"
" each value stored in the storage of the contract will still be stored in "
"the history of the blockchain. Later in this book, you will see how you can "
"impose access restrictions so that only you can alter the number."
msgstr ""
"Kontrak ini tidak banyak berbeda dari membiarkan orang menyimpan satu nomor "
"yang dapat diakses oleh siapa pun di dunia. namun, setiap nilai yang "
"disimpan dalam penyimpanan kontrak akan tetap disimpan dalam sejarah rantai "
"blok. kemudian di buku ini, Anda akan melihat bagaimana Anda dapat "
"memaksakan pembatasan akses sehingga hanya Anda yang dapat mengubah nomor "
"tersebut."

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"In the previous section, we gave an introductory example of a smart contract"
" written in Cairo, describing the basic blocks to build smart contracts on "
"Starknet. In this section, we'll be taking a deeper look at all the "
"components of a smart contract, step by step."
msgstr ""
"Di bagian sebelumnya, kami memberikan contoh pengantar kontrak cerdas yang "
"ditulis di Cairo, menggambarkan blok dasar untuk membangun kontrak cerdas di"
" Starknet."

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"When we discussed [_interfaces_](./ch13-02-anatomy-of-a-simple-"
"contract.md#the-interface-the-contracts-blueprint), we specified the "
"difference between the two types of _public functions_, i.e., _external "
"functions_ and _view functions_, and we mentioned how to interact with the "
"_storage_ of a contract."
msgstr ""
"Ketika kita membahas [_interfaces_][/ch13-02-anatomy-of-a-simple-"
"contract.m#the-interface-the-contracts-blueprint), kita menentukan perbedaan"
" antara dua jenis fungsi _public_, misalnya., fungsi _external_ dan _view "
"fungsi_, dan kita menyebutkan bagaimana berinteraksi dengan _storage_ "
"kontrak."

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "At this point, you should have multiple questions that come to mind:"
msgstr ""
"Pada titik ini, Anda harus memiliki beberapa pertanyaan yang datang ke "
"pikiran:"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How can I store more complex data types?"
msgstr "Bagaimana saya dapat menyimpan lebih banyak tipe data yang kompleks?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How do I define internal/private functions?"
msgstr "Bagaimana saya mendefinisikan internal/private fungsi?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How can I emit events? How can I index them?"
msgstr "Bagaimana aku bisa mengeluarkan sesuatu?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "Is there a way to reduce the boilerplate?"
msgstr "Apakah ada cara untuk mengurangi boilerplate?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"Luckily, we'll be answering all these questions in this chapter. Let's "
"consider the `NameRegistry` contract in Listing 14-1 that we'll be using "
"throughout this chapter:"
msgstr "Untungnya, kita akan menjawab semua pertanyaan di bab ini."

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:62 src/ch14-01-contract-storage.md:184
#: src/ch14-01-contract-storage.md:297 src/ch14-01-contract-storage.md:403
#: src/ch14-01-contract-storage.md:509 src/ch14-01-contract-storage.md:615
#: src/ch14-01-contract-storage.md:727 src/ch14-01-contract-storage.md:833
#: src/ch14-02-contract-functions.md:38
msgid "// Public functions inside an impl block\n"
msgstr "// Fungsi Publik dalam sebuah blok impl\n"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:79 src/ch14-01-contract-storage.md:201
#: src/ch14-01-contract-storage.md:314 src/ch14-01-contract-storage.md:420
#: src/ch14-01-contract-storage.md:526 src/ch14-01-contract-storage.md:632
#: src/ch14-01-contract-storage.md:744 src/ch14-01-contract-storage.md:850
#: src/ch14-02-contract-functions.md:97
msgid "// Standalone public function\n"
msgstr "// Fungsi publik Standalone\n"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:85 src/ch14-01-contract-storage.md:207
#: src/ch14-01-contract-storage.md:320 src/ch14-01-contract-storage.md:426
#: src/ch14-01-contract-storage.md:532 src/ch14-01-contract-storage.md:638
#: src/ch14-01-contract-storage.md:750 src/ch14-01-contract-storage.md:856
#: src/ch14-02-contract-functions.md:112
msgid "// Could be a group of functions about a same topic\n"
msgstr "//Bisa jadi sekelompok fungsi tentang topik yang sama\n"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:102 src/ch14-01-contract-storage.md:224
#: src/ch14-01-contract-storage.md:337 src/ch14-01-contract-storage.md:443
#: src/ch14-01-contract-storage.md:549 src/ch14-01-contract-storage.md:655
#: src/ch14-01-contract-storage.md:767 src/ch14-01-contract-storage.md:873
#: src/ch14-02-contract-functions.md:129
msgid "// Free function\n"
msgstr "// Fungsi bebas\n"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"<span class=\"caption\">Listing 14-1: Our reference contract for this "
"chapter</span>"
msgstr ""
"<span class=\"caption\">Listing 14-1: Kontrak referensi kami untuk "
"bab</span>"

#: src/ch14-01-contract-storage.md:3
msgid ""
"The most common way for interacting with a contract’s storage is through "
"storage variables. As stated previously, storage variables allow you to "
"store data that will be stored in the contract's storage that is itself "
"stored on the blockchain. These data are persistent and can be accessed and "
"potentially modified anytime once the contract is deployed."
msgstr ""
"Cara yang paling umum untuk berinteraksi dengan sebuah kontrak yang disimpan"
" di penyimpanan adalah melalui variabel penyimpanan. Seperti yang dinyatakan"
" sebelumnya, variabel penyimpanan memungkinkan Anda untuk menyimpan data "
"yang akan disimpan dalam penyimpanan kontrak yang sendiri disimpan di blok "
"rantai. Data ini gigih dan dapat diakses dan berpotensi dimodifikasi kapan "
"saja setelah kontrak dikerahkan."

#: src/ch14-01-contract-storage.md:5
msgid ""
"Storage variables in Starknet contracts are stored in a special struct "
"called `Storage`:"
msgstr ""
"Variabel penyimpanan di kontrak Starknet disimpan dalam struktur khusus yang"
" disebut Storage:"

#: src/ch14-01-contract-storage.md:111
msgid ""
"The `Storage` struct is a [struct](./ch05-00-using-structs-to-structure-"
"related-data.md) like any other, except that it **must** be annotated with "
"the `#[storage]` attribute. This annotation tells the compiler to generate "
"the required code to interact with the blockchain state, and allows you to "
"read and write data from and to storage. Moreover, this allows you to define"
" storage mappings using the dedicated `LegacyMap` type."
msgstr ""
"Strukturnya adalah sebuah struktur [struct][struct]. /ch05-00-posting-"
"structs-to-structural-dikaitkan-data.md) seperti yang lain, kecuali bahwa "
"itu **harus dinotasikan dengan atribut those#[storage] those annotasi ini "
"memberitahu compiler untuk membuat kode yang diperlukan untuk berinteraksi "
"dengan negara rantai blok, dan memungkinkan Anda untuk membaca dan menulis "
"data dari dan ke penyimpanan. Selain itu, ini memungkinkan Anda untuk "
"mendefinisikan pemetaan penyimpanan menggunakan tipe yang berdedikasi."

#: src/ch14-01-contract-storage.md:113
msgid ""
"Variables declared in the `Storage` struct are not stored contiguously but "
"in different locations in the contract's storage. The storage address of a "
"particular variable is determined by the variable's name, and the eventual "
"keys of the variable if it is a mapping."
msgstr ""
"Variabel yang dideklarasikan dalam struktur lturia tidak disimpan secara "
"kontiguously tetapi di lokasi yang berbeda dalam penyimpanan kontrak. Alamat"
" penyimpanan dari variabel tertentu ditentukan oleh nama variabel, dan kunci"
" akhir variabel jika itu adalah pemetaan."

#: src/ch14-01-contract-storage.md:117
msgid "Addresses of Storage Variables"
msgstr "Alamat Variabel Penyimpanan"

#: src/ch14-01-contract-storage.md:119
msgid "The address of a storage variable is computed as follows:"
msgstr "Alamat dari variabel penyimpanan dihitung sebagai berikut:"

#: src/ch14-01-contract-storage.md:121
msgid ""
"If the variable is a single value, the address is the `sn_keccak` hash of "
"the ASCII encoding of the variable's name. `sn_keccak` is Starknet's version"
" of the Keccak256 hash function, whose output is truncated to 250 bits."
msgstr ""
"Jika variabelnya adalah satu nilai, alamatnya adalah versi dari fungsi "
"keccak256 dari pengkodean ASCII dari nama variabel."

#: src/ch14-01-contract-storage.md:123
msgid ""
"If the variable is composed of multiple values (i.e., a tuple, a struct or "
"an enum), we also use the `sn_keccak` hash of the ASCII encoding of the "
"variable's name to determine the base address in storage. Then, depending on"
" the type, the storage layout will differ. See the [\"Storing Custom "
"Types\"](./ch14-01-contract-storage.md#storing-custom-types) section."
msgstr ""
"Jika variabelnya terdiri dari beberapa nilai (misalnya., sebuah tuple, "
"sebuah struct atau enum), kami juga menggunakan ·sn_keccak--h dari "
"pengkodean ASCII dari nama variabel untuk menentukan alamat dasar dalam "
"penyimpanan. Kemudian, tergantung pada tipe, tata letak penyimpanan akan "
"berbeda. Lihat [\"Storing Custom Typs\"] susah./ch-contract-"
"torage.m#storing-custom-type) bagian."

#: src/ch14-01-contract-storage.md:125
msgid ""
"If the variable is a [mapping](./ch14-01-contract-storage.html#storage-"
"mappings) with a key `k`, the address of the value at key `k` is "
"`h(sn_keccak(variable_name),k)`, where ℎ is the Pedersen hash and the final "
"value is taken modulo \\\\( {2^{251}} - 256\\\\). If the key is composed of "
"more than one `felt252`, the address of the value will be "
"`h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)`, with `k_1,...,k_n` "
"being all `felt252` that constitute the key. In the case of mappings to "
"complex values (e.g., tuples or structs), then this complex value lies in a "
"continuous segment starting from the address calculated with the previous "
"formula. Note that 256 field elements is the current limitation on the "
"maximal size of a complex storage value."
msgstr ""
"Jika variabelnya [mapping]. /ch14-01-contract-storage.html#mage-mappings) "
"dengan kunci yang telah diambil \\\\k://1} kunci - 256} - 256). Jika kunci "
"terdiri dari lebih dari satu quartavable_name), k), k), di mana hersen hash "
"dan nilai akhir diambil modulo \\ \\\\{2{1}."

#: src/ch14-01-contract-storage.md:127
msgid ""
"You can access the address of a storage variable by calling the `address` "
"function on the variable, which returns a `StorageBaseAddress` value."
msgstr ""
"Anda dapat mengakses alamat dari variabel penyimpanan dengan memanggil "
"fungsi ·addressé pada variabel, yang mengembalikan nilai ▪StorageBaseAverss."

#: src/ch14-01-contract-storage.md:236
msgid "Interacting with Storage Variables"
msgstr "Interacting dengan Variabel Penyimpanan"

#: src/ch14-01-contract-storage.md:238
msgid ""
"Variables stored in the `Storage` struct can be accessed and modified using "
"the `read` and `write` functions, respectively. As previously mentioned, you"
" can get their address in storage using the `address` function. All these "
"functions are automatically generated by the compiler for each storage "
"variable."
msgstr ""
"Variabel yang disimpan dalam struktur retorage dapat diakses dan diubah "
"dengan menggunakan fungsi yang dibaca dan ditulis secara otomatis, seperti "
"yang disebutkan sebelumnya, Anda dapat mendapatkan alamat mereka dalam "
"penyimpanan menggunakan fungsi ·addressà. Semua fungsi ini secara otomatis "
"dihasilkan oleh kompiler untuk setiap variabel penyimpanan."

#: src/ch14-01-contract-storage.md:240
msgid ""
"To read the value of the `owner` storage variable, which is a single value, "
"we call the `read` function on the `owner` variable, passing in no "
"parameters."
msgstr ""
"Untuk membaca nilai dari variabel penyimpanan yang dimiliki pemilik, yang "
"merupakan satu nilai, kita sebut fungsinya pada variabel åowner, yang tidak "
"ada parameternya."

#: src/ch14-01-contract-storage.md:346
msgid ""
"To read the value of the storage variable `names`, which is a mapping from "
"`ContractAddress` to `felt252`, we call the `read` function on the `names` "
"variable, passing in the key `address` as a parameter. If the mapping had "
"more than one key, we would pass in the other keys as parameters as well."
msgstr ""
"Untuk membaca nilai dari variabel penyimpanan, yang merupakan pemetaan dari "
"contractAddress, menjadi 252, kita sebut fungsi baca di variabel åname, "
"melewati kunci sebagai parameter. Jika pemetaan memiliki lebih dari satu "
"kunci, kita akan melewati tombol lain juga parameter."

#: src/ch14-01-contract-storage.md:452
msgid ""
"To write a new value to the storage slot of a storage variable, we call the "
"`write` function passing in the eventual keys and the value as arguments. As"
" with the `read` function, the number of arguments depends on the storage "
"variable type. Here, we only pass in the value to write to the `owner` "
"variable as it is a simple variable."
msgstr ""
"Untuk menulis nilai baru ke slot penyimpanan dari variabel penyimpanan, kami"
" menyebut fungsi menulis yang melewati kunci yang akhirnya dan nilai sebagai"
" argumen. seperti dengan fungsi Áreadé, jumlah argumen tergantung pada tipe "
"variabel penyimpanan. Di sini, kami hanya lulus dalam nilai untuk menulis ke"
" variabel thoseowneré karena itu adalah variabel sederhana."

#: src/ch14-01-contract-storage.md:558
msgid ""
"In this second example, we need to pass `user` and `name` as arguments, "
"because `names` is a mapping, with `user` as key and `name` as value."
msgstr ""
"Dalam contoh kedua ini, kita perlu melewati pengguna dan nama samaran "
"sebagai argumen, karena nama adalah pemetaan, dengan kunci dan nama yang "
"sama nilainya."

#: src/ch14-01-contract-storage.md:664
msgid "Storing Custom Types"
msgstr "Menyimpan Tipe Gubahan"

#: src/ch14-01-contract-storage.md:666
msgid ""
"The `Store` trait, defined in the `starknet::storage_access` module, is used"
" to specify how a type should be stored in storage. In order for a type to "
"be stored in storage, it **must** implement the `Store` trait. Most types "
"from the core library, such as unsigned integers (`u8`, `u128`, `u256`...), "
"`felt252`, `bool`, `ByteArray`, `ContractAddress`, etc. implement the "
"`Store` trait and can thus be stored without further action."
msgstr ""
"Sifat yang harus disimpan dalam penyimpanan, didefinisikan dalam ·starknet::"
" storage_access_accessé modul, digunakan untuk menentukan bagaimana sebuah "
"tipe harus disimpan dalam penyimpanan. Dalam rangka untuk jenis yang "
"disimpan dalam penyimpanan, itu *usstore** mengimplementasikan sifat ÁStore."
" Kebanyakan tipe dari perpustakaan inti, seperti integers unsigned (u8, "
"u128, ▪256), ±2, ántray, dan lain-lain."

#: src/ch14-01-contract-storage.md:668
msgid ""
"But what if you wanted to store a type that you defined yourself, such as an"
" enum or a struct? In that case, you have to explicitly tell the compiler "
"how to store this type."
msgstr ""
"Tapi bagaimana jika Anda ingin menyimpan tipe yang Anda definisikan sendiri,"
" seperti enum atau struct? Dalam hal ini, Anda harus secara eksplisit "
"memberitahu kompiler bagaimana menyimpan jenis ini."

#: src/ch14-01-contract-storage.md:670
msgid ""
"In our example, we want to store a `Person` struct in storage, which is only"
" possible by implementing the `Store` trait for the `Person` type. This can "
"be simply achieved by adding a `#[derive(starknet::Store)]` attribute on top"
" of our struct definition. Note that all the members of the struct need to "
"implement the `Store` trait."
msgstr ""
"Dalam contoh kami, kami ingin menyimpan sebuah bangunan di penyimpanan, yang"
" hanya mungkin dengan mengimplementasikan sifat untuk tipe ÉPersoné. Ini "
"dapat dicapai dengan menambahkan sebuah ▪#[dederive Donnellystarknet::Store)"
" atribut di atas definisi struct kami. perhatikan bahwa semua anggota "
"struktur perlu menerapkan sifat ÁStore."

#: src/ch14-01-contract-storage.md:776
msgid ""
"Similarly, Enums can only be written to storage if they implement the "
"`Store` trait, which can be trivially derived as long as all associated "
"types implement the `Store` trait."
msgstr ""
"Demikian pula, Enums hanya dapat ditulis untuk disimpan jika mereka "
"menerapkan sifat åstore, yang dapat diambil secara sepele selama semua jenis"
" yang terkait menerapkan sifat åstore."

#: src/ch14-01-contract-storage.md:882
msgid ""
"You might have noticed that we also derived `Drop` and `Serde` on our custom"
" types. Both of them are required for properly serializing arguments passed "
"to entrypoints and deserializing their outputs."
msgstr ""
"Anda mungkin juga memperhatikan bahwa kami juga mendapat informasi dari "
"Deprop dan tipe-tipe custom kami. Keduanya diperlukan untuk membuat argumen "
"serial yang tepat untuk masuk dan mengurangi keluaran mereka."

#: src/ch14-01-contract-storage.md:884
msgid "Structs Storage Layout"
msgstr "Tata Letak Penyimpanan Struktur"

#: src/ch14-01-contract-storage.md:886
msgid ""
"On Starknet, structs are stored in storage as a sequence of primitive types."
" The elements of the struct are stored in the same order as they are defined"
" in the struct definition. The first element of the struct is stored at the "
"base address of the struct, which is computed as specified in [\"Addresses "
"of Storage Variables\"](./ch14-01-contract-storage.html#addresses-of-"
"storage-variables) section and can be obtained by calling `var.address()`, "
"and subsequent elements are stored at addresses contiguous to the first "
"element. For example, the storage layout for the `owner` variable of type "
"`Person` will result in the following layout:"
msgstr ""
"Pada Starknet, struktur disimpan dalam urutan tipe primitif. Elemen-elemen "
"dari struct disimpan dalam urutan yang sama seperti yang didefinisikan dalam"
" definisi struct. Elemen pertama dari struktur disimpan di dasar alamat "
"struct, yang dihitung seperti yang ditentukan dalam [\"Alamat dari Variabel "
"Penyimpanan\"]./ch14-01-contract-torage.Hmladdress-of-tor-variable) dan "
"dapat diperoleh dengan memanggil Á.address\"), alamat selanjutnya disimpan "
"pada elemen konig untuk contoh pertama. Untuk layouter, untuk layouter \\\\:"

#: src/ch14-01-contract-storage.md:890
msgid "Fields"
msgstr "Fields"

#: src/ch14-01-contract-storage.md:890 src/ch14-01-contract-storage.md:905
#: src/ch14-01-contract-storage.md:912
msgid "Address"
msgstr "Alamat"

#: src/ch14-01-contract-storage.md:892
msgid "name"
msgstr "nama"

#: src/ch14-01-contract-storage.md:892
msgid "owner.address()"
msgstr "Pemilik.address[address]"

#: src/ch14-01-contract-storage.md:893
msgid "address"
msgstr "alamat"

#: src/ch14-01-contract-storage.md:893
msgid "owner.address() +1"
msgstr "pemilik.address Allah) +1"

#: src/ch14-01-contract-storage.md:895
msgid ""
"Note that tuples are similarly stored in contract's storage, with the first "
"element of the tuple being stored at the base address, and subsequent "
"elements stored contiguously."
msgstr ""
"Perhatikan bahwa tuples juga disimpan dalam penyimpanan kontrak, dengan "
"elemen pertama dari tuple yang disimpan di alamat dasar, dan unsur - unsur "
"berikutnya yang tersimpan dengan kontguously."

#: src/ch14-01-contract-storage.md:899
msgid "Enums Storage Layout"
msgstr "Tata Letak Penyimpanan Enums"

#: src/ch14-01-contract-storage.md:901
msgid ""
"When you store an enum variant, what you're essentially storing is the "
"variant's index and eventual associated values. This index starts at 0 for "
"the first variant of your enum and increments by 1 for each subsequent "
"variant. If your variant has an associated value, this value is stored "
"starting from the address immediately following the address of the index of "
"the variant. For example, suppose we have the `RegistrationType` enum with "
"the `finite` variant that carries an associated limit date, and the "
"`infinite` variant without associated data. The storage layout for the "
"`finite` variant would look like this:"
msgstr ""
"Ketika Anda menyimpan sebuah varian enum, apa yang pada dasarnya Anda simpan"
" adalah indeks varian dan akhirnya terkait. Indeks ini dimulai pada 0 untuk "
"varian pertama dari enum dan inkremen Anda oleh 1 untuk setiap varian "
"berikutnya. Jika varian Anda memiliki nilai yang terkait, nilai ini disimpan"
" mulai dari alamat berikut alamat dari indeks varian. Sebagai contoh, "
"misalkan kita memiliki varian ▪RegitrasiTypeáum dengan varian yang "
"mengandung batas yang terkait, dan varian yang berhubungan tanpa data yang "
"terkait."

#: src/ch14-01-contract-storage.md:905 src/ch14-01-contract-storage.md:912
msgid "Element"
msgstr "Elemen"

#: src/ch14-01-contract-storage.md:907
msgid "Variant index (0 for finite)"
msgstr "Indeks varian (0 untuk terbatas)"

#: src/ch14-01-contract-storage.md:907 src/ch14-01-contract-storage.md:914
msgid "registration_type.address()"
msgstr "register_type.address Allah)"

#: src/ch14-01-contract-storage.md:908
msgid "Associated limit date"
msgstr "Batas waktu yang diasosiasikan"

#: src/ch14-01-contract-storage.md:908
msgid "registration_type.address() + 1"
msgstr "register_type.address Allah) + 1"

#: src/ch14-01-contract-storage.md:910
msgid "while the storage layout for the `infinite` would be as follows:"
msgstr ""
"Sementara tata letak penyimpanan untuk æinfiniteé akan seperti berikut:"

#: src/ch14-01-contract-storage.md:914
msgid "Variant index (1 for infinite)"
msgstr "Indeks varian (1 untuk tak terbatas)"

#: src/ch14-01-contract-storage.md:916
msgid "Storage Mappings"
msgstr "Pemetaan Penyimpanan"

#: src/ch14-01-contract-storage.md:918
msgid ""
"Storage mappings are similar to hash tables in that they allow mapping keys "
"to values. However, unlike a typical hash table, the key data itself is not "
"stored - only its hash is used to look up the associated value in the "
"contract's storage. Mappings do not have a concept of length or whether a "
"key/value pair is set. All values are by default set to 0. The only way to "
"remove an entry from a mapping is to set its value to the default zero "
"value."
msgstr ""
"Pemetaan penyimpanan mirip dengan tabel hash yang memungkinkan pemetaan "
"kunci ke nilai-nilai. Namun, tidak seperti tabel hash yang khas, data kunci "
"itu sendiri tidak disimpan - hanya hash yang digunakan untuk melihat nilai "
"yang terkait dalam penyimpanan kontrak. Mapping tidak memiliki konsep "
"panjang atau apakah pasangan kunci/nilai diset. Semua nilai diatur secara "
"baku ke 0. Satu-satunya cara untuk menghapus entri dari sebuah pemetaan "
"adalah untuk mengatur nilainya ke nilai baku nol."

#: src/ch14-01-contract-storage.md:921
msgid ""
"Mappings are only used to compute the location of data in the storage of a "
"contract given certain keys. They are thus **only allowed as storage "
"variables**. They cannot be used as parameters or return parameters of "
"contract functions, and cannot be used as types inside structs."
msgstr ""
"Pemetaan hanya digunakan untuk menghitung lokasi data dalam penyimpanan "
"sebuah kontrak yang diberikan kunci tertentu. Mereka dengan demikian ** "
"hanya diperbolehkan sebagai variabel penyimpanan **. Mereka tidak dapat "
"digunakan sebagai parameter atau parameter kembali dari fungsi kontrak, dan "
"tidak dapat digunakan sebagai tipe dalam struktur."

#: src/ch14-01-contract-storage.md:933
msgid ""
"To declare a mapping, use the `LegacyMap` type enclosed in angle brackets "
"`<>`, specifying the key and value types."
msgstr ""
"Untuk menyatakan suatu pemetaan, gunakan tipe 'LegacyMapp' yang dilampirkan "
"dalam kurung sudut <>, tentukan tipe kunci dan nilai."

#: src/ch14-01-contract-storage.md:936
msgid ""
"You can also create more complex mappings with multiple keys. You can find "
"in Listing 14-2 the popular `allowances` storage variable of the ERC20 "
"Standard which maps an `owner` and an allowed `spender` to their `allowance`"
" amount using multiple keys passed inside a tuple:"
msgstr ""
"Anda juga dapat membuat pemetaan yang lebih kompleks dengan berbagai kunci. "
"Anda dapat menemukan di Listing 14-2 variabel penyimpanan yang populer dari "
"ERC20 Standard yang memetakan sebuah pemilik dan sebuah oposter yang "
"diijinkan untuk jumlah yang diijinkan oleh mereka menggunakan beberapa kunci"
" melewati sebuah tuple:"

#: src/ch14-01-contract-storage.md:945
msgid ""
"<span class=\"caption\">Listing 14-2: Storing a mapping with multiple keys "
"inside a tuple</span>"
msgstr ""
"<span class=\"caption\">Listing 14-2: Menyimpan sebuah pemetaan dengan "
"beberapa kunci di dalam sebuah tuple</span>"

#: src/ch14-01-contract-storage.md:947
msgid ""
"The address in storage of a variable stored in a mapping is computed "
"according to the description in the [\"Addresses of Storage "
"Variables\"](./ch14-01-contract-storage.html#addresses-of-storage-variables)"
" section."
msgstr ""
"Alamat dalam penyimpanan variabel yang disimpan dalam sebuah pemetaan "
"dihitung sesuai dengan deskripsi dalam [\"Alamat Variabel Penyimpanan\"]] "
"susah payah/ch14-01-contract-storage.htl#addresses-of-storage-variables) "
"bagian."

#: src/ch14-01-contract-storage.md:949
msgid ""
"If the key of a mapping is a struct, each element of the struct constitutes "
"a key. Moreover, the struct should implement the `Hash` trait, which can be "
"derived with the `#[derive(Hash)]` attribute. For example, if you have a "
"struct with two fields, the address will be "
"`h(h(sn_keccak(variable_name),k_1),k_2)` modulo \\\\( {2^{251}} - 256\\\\), "
"where `k_1` and `k_2` are the values of the two fields of the struct."
msgstr ""
"Jika kunci dari sebuah pemetaan adalah sebuah struct, setiap elemen dari "
"struct merupakan sebuah kunci. Selain itu, struct harus mengimplementasikan "
"sifat, yang dapat diturunkan dengan atribut ▪#[derive Allahh]]]. Sebagai "
"contoh, jika Anda memiliki sebuah struktur dengan dua ruas, alamat akan "
"menjadi ·h (holth)_ccakánkvariable_name), k_1), k_2) modulo\\\\ {{2251} -} "
"25\\\\1), di mana 2k_2 dan 2k dari area struktur."

#: src/ch14-01-contract-storage.md:951
msgid ""
"Similarly, in the case of a nested mapping using a tuple as key, such as "
"`LegacyMap::<(ContractAddress, ContractAddress), u8>`, the address will be "
"computed in the same way, with each element of the tuple being a key: "
"`h(h(sn_keccak(variable_name),k_1),k_2)`."
msgstr ""
"Demikian pula, dalam kasus pemetaan nested menggunakan tuple sebagai kunci, "
"seperti ▪LegacyMap::<BalchiscoContractAress, ContractAverss), u8>, alamat "
"akan dihitung dengan cara yang sama, dengan setiap elemen tuple menjadi "
"kunci: Áh Allahn_ccakánkvariable_name),k_1),k_2)."

#: src/ch14-02-contract-functions.md:3
msgid ""
"In this section, we are going to be looking at the different types of "
"functions you could encounter in Starknet smart contracts."
msgstr ""
"Di bagian ini, kita akan melihat berbagai jenis fungsi yang bisa kau temui "
"di kontrak pintar Starknet."

#: src/ch14-02-contract-functions.md:5
msgid ""
"Functions can access the contract's state easily via `self: ContractState`, "
"which abstracts away the complexity of underlying system calls "
"(`storage_read_syscall` and `storage_write_syscall`). The compiler provides "
"two modifiers: `ref` and `@` to decorate `self`, which intends to "
"distinguish view and external functions."
msgstr ""
"Fungsi-fungsi dapat mengakses keadaan kontrak dengan mudah melalui diri "
"sendiri: ContractState, yang abstrak dari kompleks sistem yang mendasari "
"panggilan (alokasi_read_syscall) dan ·storage_write_syscall)."

#: src/ch14-02-contract-functions.md:7
msgid "1. Constructors"
msgstr "1. Konstruktor"

#: src/ch14-02-contract-functions.md:9
msgid ""
"Constructors are a special type of function that only runs once when "
"deploying a contract, and can be used to initialize the state of a contract."
msgstr ""
"Konstruktor adalah jenis fungsi khusus yang hanya berjalan sekali ketika "
"menyebarkan kontrak, dan dapat digunakan untuk menginisialisasi keadaan "
"kontrak."

#: src/ch14-02-contract-functions.md:20
msgid "Some important rules to note:"
msgstr "Beberapa aturan penting untuk dicatat:"

#: src/ch14-02-contract-functions.md:22
msgid "A contract can't have more than one constructor."
msgstr "Kontrak tidak bisa memiliki lebih dari satu konstruktor."

#: src/ch14-02-contract-functions.md:23
msgid ""
"The constructor function must be named `constructor`, and must be annotated "
"with the `#[constructor]` attribute."
msgstr "Fungsi konstruktor harus diberi nama atribut konstruktor."

#: src/ch14-02-contract-functions.md:25
msgid ""
"The `constructor` function might take arguments, which are passed when "
"deploying the contract. In our example, we pass some value corresponding to "
"a `Person` type as argument in order to store the `owner` information "
"(address and name) in the contract."
msgstr ""
"Fungsi konstruktor mungkin mengambil argumen, yang dilewatkan ketika "
"menyebarkan kontrak. sebagai contoh, kita melewatkan beberapa nilai yang "
"berhubungan dengan tipe argumen untuk menyimpan informasi pemilik (alamat "
"dan nama) dalam kontrak."

#: src/ch14-02-contract-functions.md:27
msgid ""
"Note that the `constructor` function **must** take `self` as a first "
"argument, corresponding to the state of the contract, generally passed by "
"reference with the `ref` keyword to be able to modify the contract's state. "
"We will explain `self` and its type shortly."
msgstr ""
"Perhatikan bahwa fungsi konstruktor **harus ** mengambil diri sebagai "
"argumen pertama, sesuai dengan keadaan kontrak, yang biasanya diteruskan "
"dengan referensi dengan kata kunci untuk dapat mengubah keadaan kontrak. "
"Kami akan menjelaskan sendiri dan tipenya tidak lama lagi."

#: src/ch14-02-contract-functions.md:29
msgid "2. Public Functions"
msgstr "2. Fungsi Publik"

#: src/ch14-02-contract-functions.md:31
msgid ""
"As stated previously, public functions are accessible from outside of the "
"contract. They are usually defined inside an implementation block annotated "
"with the `#[abi(embed_v0)]` attribute, but might also be defined "
"independently under the `#[external(v0)]` attribute."
msgstr ""
"Seperti yang telah dinyatakan sebelumnya, fungsi publik dapat diakses dari "
"luar kontrak. Mereka biasanya didefinisikan di dalam sebuah blok "
"implementasi yang dianotasi dengan atribut <0), tetapi juga dapat "
"didefinisikan secara independen di bawah atribut ▪#[external fotostockv0)."

#: src/ch14-02-contract-functions.md:33
msgid ""
"The `#[abi(embed_v0)]` attribute means that all functions embedded inside it"
" are implementations of the Starknet interface of the contract, and "
"therefore potential entry points."
msgstr ""
"Atribut yang tertanam di dalamnya adalah implementasi antar-muka Starknet "
"dari kontrak, dan oleh karena itu potensial titik masuk."

#: src/ch14-02-contract-functions.md:35
msgid ""
"Annotating an impl block with the `#[abi(embed_v0)]` attribute only affects "
"the visibility (i.e., public vs private/internal) of the functions it "
"contains, but it doesn't inform us on the ability of these functions to "
"modify the state of the contract."
msgstr ""
"Mengumumkan sebuah blok impl dengan fungsi-fungsi yang dikandungnya, tetapi "
"tidak memberi tahu kita tentang kemampuan fungsi-fungsi ini untuk mengubah "
"keadaan kontrak."

#: src/ch14-02-contract-functions.md:56
msgid ""
"Similarly to the `constructor` function, all public functions, either "
"standalone functions annotated with the `#[external(v0)]` or functions "
"within an impl block annotated with the `#[abi(embed_v0)]` attribute, "
"**must** take `self` as a first argument. This is not the case for private "
"functions."
msgstr ""
"Demikian pula dengan fungsi-fungsi pengkonstruktor, semua fungsi publik, "
"baik fungsi standalone dinotasikan dengan atribut Â#[external Allahv0)] atau"
" fungsi dalam sebuah blok impl dianotasi dengan atribut ·[abihombed_v0), "
"**must** mengambil diri sebagai argumen pertama. Ini bukan kasus untuk "
"fungsi-fungsi pribadi."

#: src/ch14-02-contract-functions.md:58
msgid "External Functions"
msgstr "Fungsi Eksternal"

#: src/ch14-02-contract-functions.md:60
msgid ""
"External functions are _public_ functions where the `self: ContractState` "
"argument is passed by reference with the `ref` keyword, which exposes both "
"the `read` and `write` access to storage variables. This allows modifying "
"the state of the contract via `self` directly."
msgstr ""
"Fungsi eksternal adalah fungsi _public_ dimana diri sendiri: Argumen "
"Kontrakstate dilewatkan oleh referensi dengan kata kunci ·refé, yang "
"mengekspos kedua akses thosereadà dan ·writeà ke variabel penyimpanan. Hal "
"ini memungkinkan memodifikasi keadaan kontrak melalui thoseselfself secara "
"langsung."

#: src/ch14-02-contract-functions.md:69
msgid "View Functions"
msgstr "Tilik Fungsi"

#: src/ch14-02-contract-functions.md:71
msgid ""
"View functions are _public_ functions where the `self: ContractState` "
"argument is passed as snapshot, which only allows the `read` access to "
"storage variables, and restricts writes to storage made via `self` by "
"causing compilation errors. The compiler will mark their `state_mutability` "
"to `view`, preventing any state modification through `self` directly."
msgstr ""
"Fungsi tampilan adalah _public_fungsi dimana diri_ sendiri: Argumen "
"ContractState dilewatkan sebagai snapshot, yang hanya memungkinkan akses ke "
"variabel penyimpanan, dan membatasi menulis ke penyimpanan yang dibuat "
"melalui thoseself dengan menyebabkan kesalahan kompilasi. compiler akan "
"menandai ▪_mutability_mutability mereka untuk melihat, mencegah setiap "
"modifikasi negara melalui ▪selfself secara langsung."

#: src/ch14-02-contract-functions.md:80
msgid "State Mutability of Public Functions"
msgstr "Mutabilitas Negara Fungsi Publik"

#: src/ch14-02-contract-functions.md:82
msgid ""
"However, as you may have noticed, passing `self` as a snapshot only "
"restricts the storage write access via `self` at compile time. It does not "
"prevent state modification via direct system calls, nor calling another "
"contract that would modify the state."
msgstr ""
"Namun, seperti yang mungkin Anda perhatikan, melewati diri sendiri sebagai "
"snapshot hanya membatasi akses penyimpanan menulis melalui waktu sendiri. "
"tidak mencegah modifikasi negara melalui panggilan sistem langsung, atau "
"menghubungi kontrak lain yang akan memodifikasi negara."

#: src/ch14-02-contract-functions.md:84
msgid ""
"The read-only property of view functions is not enforced on Starknet, and "
"sending a transaction targeting a view function _could_  change the state."
msgstr ""
"Properti hanya-baca dari fungsi tilikan tidak diwajibkan pada Starknet, dan "
"mengirim transaksi menargetkan fungsi pkamung _bisa_ mengubah keadaan."

#: src/ch14-02-contract-functions.md:86
msgid ""
"In conclusion, even though external and view functions are distinguished by "
"the Cairo compiler, **all public functions** can be called through an invoke"
" transaction and have the potential to modify states on Starknet. Also, all "
"public functions can be queried via `starknet_call` on Starknet, which will "
"not create a transaction and hence will not change the state."
msgstr ""
"Sebagai kesimpulan, meskipun fungsi eksternal dan tampilan dibedakan oleh "
"kompiler Cairo, ** semua fungsi publik dapat dipanggil melalui transaksi "
"pemanggilan dan memiliki potensi untuk memodifikasi negara di Starknet. "
"Juga, semua fungsi publik dapat dipicu melalui Ástarknet_callé di Starknet, "
"yang tidak akan membuat sebuah transaksi dan oleh karena itu tidak akan "
"mengubah keadaan."

#: src/ch14-02-contract-functions.md:88
msgid ""
"**Warning:** This is different from the EVM where a `staticcall` opcode is "
"provided, which prevents storage modifications in the current context and "
"subcontexts. Hence developers **should not** have the assumption that "
"calling a view function on another contract cannot modify the state."
msgstr ""
"** Peringatan:** Ini berbeda dari EVM dimana opkode opkode ·staticcall telah"
" disediakan, yang mencegah modifikasi penyimpanan dalam konteks dan "
"subkonteks saat ini. Oleh karena itu pengembang ** seharusnya tidak memiliki"
" asumsi bahwa memanggil fungsi tampilan pada kontrak lain tidak dapat "
"memodifikasi negara."

#: src/ch14-02-contract-functions.md:90
msgid "Standalone Public Functions"
msgstr "Standar Fungsi Publik"

#: src/ch14-02-contract-functions.md:92
msgid ""
"It is also possible to define public functions outside of an implementation "
"of a trait, using the `#[external(v0)]` attribute. Doing this will "
"automatically generate the corresponding ABI, allowing these standalone "
"public functions to be callable by anyone from the outside. These functions "
"can also be called from within the contract just like any function in "
"Starknet contracts. The first parameter must be `self`."
msgstr ""
"Ada juga kemungkinan untuk mendefinisikan fungsi publik di luar implementasi"
" suatu sifat, dengan menggunakan atribut [externtal Allahv0]]. Melakukan ini"
" akan secara otomatis menghasilkan ABI yang sesuai, memungkinkan fungsi "
"publik mandiri ini dapat dipanggil oleh siapapun dari luar. Fungsi ini juga "
"dapat dipanggil dari dalam kontrak sama seperti setiap fungsi dalam kontrak "
"Starknet. Parameter pertama harus menjadi dirinya sendiri."

#: src/ch14-02-contract-functions.md:94
msgid ""
"Here, we define a standalone `get_contract_name` function outside of an impl"
" block:"
msgstr ""
"Di sini, kita mendefinisikan fungsi standaronal "
"\\u200b\\u200b\\u200\\u200\\u200b\\u200\\u200\\u200\\u200\\u200\\u200b\\u200\\u200\\u200\\u200\\u200\\u200\\u200\\u200\\u200\\u200)"
" \\an\\an\\u200\\u200\\u1\\u200\\an:"

#: src/ch14-02-contract-functions.md:104
msgid "3. Private Functions"
msgstr "3. Fungsi Pribadi"

#: src/ch14-02-contract-functions.md:106
msgid ""
"Functions that are not defined with the `#[external(v0)]` attribute or "
"inside a block annotated with the `#[abi(embed_v0)]` attribute are private "
"functions (also called internal functions). They can only be called from "
"within the contract."
msgstr ""
"Fungsi yang tidak didefinisikan dengan atribut ·[external[v0)]] atau di "
"dalam sebuah blok yang dianotasi dengan atribut ·abiánmbed_v0] adalah "
"fungsi-fungsi privat (juga disebut fungsi internal). Mereka hanya dapat "
"dipanggil dari dalam kontrak."

#: src/ch14-02-contract-functions.md:108
msgid ""
"They can be grouped in a dedicated impl block (e.g., in components, to "
"easily import internal functions all at once in the embedding contracts) or "
"just be added as free functions inside the contract module. Note that these "
"2 methods are equivalent. Just choose the one that makes your code more "
"readable and easy to use."
msgstr ""
"Mereka dapat dikelompokkan dalam blok impl yang didedikasikan (misalnya, "
"dalam komponen, untuk dengan mudah mengimpor fungsi internal sekaligus dalam"
" kontrak embedding) atau hanya ditambahkan sebagai fungsi bebas dalam modul "
"kontrak. Perlu dicatat bahwa 2 metode ini setara. Pilih satu yang membuat "
"kode Anda lebih mudah dibaca dan mudah digunakan."

#: src/ch14-02-contract-functions.md:135
msgid ""
"Wait, what is this `#[generate_trait]` attribute? Where is the trait "
"definition for this implementation? Well, the `#[generate_trait]` attribute "
"is a special attribute that tells the compiler to generate a trait "
"definition for the implementation block. This allows you to get rid of the "
"boilerplate code of defining a trait with generic parameters and "
"implementing it for the implementation block. With this attribute, we can "
"simply define the implementation block directly, without any generic "
"parameter, and use `self: ContractState` in our functions."
msgstr ""
"Tunggu, apa atribut khusus ini yang memberitahu kompiler untuk menghasilkan "
"definisi sifat untuk blok implementasi ini? Di mana definisi sifat untuk "
"implementasi ini? Nah, yang Nah, yang [generate_trait] terjadi adalah "
"atribut khusus yang memberitahu kompiler untuk menghasilkan definisi sifat "
"untuk blok implementasi. Hal ini memungkinkan Anda untuk menyingkirkan kode "
"tempalate dari mendefinisikan sifat dengan parameter generik dan "
"mengimplementasikannya untuk blok implementasi. Dengan atribut ini, kita "
"hanya dapat mendefinisikan blok implementasi langsung, tanpa parameter umum,"
" dan gunakan sendiri: KontrakStasi dalam fungsi kita."

#: src/ch14-02-contract-functions.md:137
msgid ""
"The `#[generate_trait]` attribute is mostly used to define private impl "
"blocks. It might also be used in addition to `#[abi(per_item)]` to define "
"the various entrypoints of a contract (see [next "
"section](./ch14-02-contract-functions.md#4-abiper_item-attribute))."
msgstr ""
"atribut 'generate_trait' sebagian besar digunakan untuk mendefinisikan blok "
"impl privat. Ini juga dapat digunakan sebagai tambahan untuk "
"fungsi.md#[abiper_item)]) untuk menentukan berbagai titik masuk dari kontrak"
" (lihat [bagian berikutnya]./ch14-02-contract-functionions.md#4-abiper_ite-"
"atribute))."

#: src/ch14-02-contract-functions.md:139
msgid ""
"Note: using `#[generate_trait]` in addition to the `#[abi(embed_v0)]` "
"attribute for a public impl block is not recommended, as it will result in a"
" failure to generate the corresponding ABI. Public functions should only be "
"defined in an impl block annotated with `#[generate_trait]` if this block is"
" also annotated with the `#[abi(per_item)]` attribute."
msgstr ""
"Catatan: menggunakan ▪[generate_trait] sebagai tambahan untuk "
"itu#[abi[abinbed_v0)]] atribut untuk blok impl publik tidak disarankan, "
"karena itu akan mengakibatkan kegagalan untuk menghasilkan ABI yang sesuai. "
"Fungsi-fungsi publik seharusnya hanya didefinisikan dalam sebuah blok impl "
"dianotasi dengan ▪[generate_trait] ¶¶ jika blok ini juga dinotasi dengan "
"atribut ▪abi[abiperite_m]."

#: src/ch14-02-contract-functions.md:144
msgid "`[abi(per_item)]` Attribute"
msgstr "▪[abi[per_item)] Atribut"

#: src/ch14-02-contract-functions.md:146
msgid ""
"You can also define the entrypoint type of functions individually inside an "
"impl block using the`#[abi(per_item)]` attribute on top of your impl. It is "
"often used with the `#[generate_trait]` attribute, as it allows you to "
"define entrypoints without an explicit interface. In this case, the "
"functions will not be grouped under an impl in the ABI. Note that when using"
" `#[abi(per_item)]` attribute, public functions need to be annotated with "
"the `#[external(v0)]` attribute - otherwise, they will not be exposed and "
"will be considered as private functions."
msgstr ""
"Anda juga dapat mendefinisikan tipe titik masuk dari fungsi secara "
"individual dalam sebuah blok impl menggunakan \"#[abiper_item)] atribut di "
"atas impl Anda. Hal ini sering digunakan dengan atribut ▪[generate_trait], "
"seperti yang memungkinkan Anda untuk mendefinisikan titik masuk tanpa "
"antarmuka eksplisit. Dalam hal ini, fungsi tidak akan dikelompokkan di bawah"
" impl dalam ABI. Perhatikan bahwa ketika menggunakan atribut "
"▪[abiperite_mitte], fungsi publik perlu dienotasi dengan \\#[exital0) - atau"
" mereka tidak akan terpapar sebagai fungsi pribadi."

#: src/ch14-02-contract-functions.md:148
msgid "Here is a short example:"
msgstr "Berikut contoh singkatnya:"

#: src/ch14-02-contract-functions.md:160
msgid "// this is a constructor function\n"
msgstr "//ini adalah fungsi konstruktor\n"

#: src/ch14-02-contract-functions.md:164
msgid "// this is a public function\n"
msgstr "//Ini adalah fungsi publik\n"

#: src/ch14-02-contract-functions.md:168
msgid "// this is a l1_handler function\n"
msgstr "//Ini adalah sebuah fungsi l1_handler\n"

#: src/ch14-02-contract-functions.md:171
msgid "// this is an internal function\n"
msgstr "//Ini adalah fungsi internal\n"

#: src/ch14-02-contract-functions.md:177
msgid ""
"In the case of `#[abi(per_item)]` attribute usage without "
"`#[generate_trait]`, it will only be possible to include `constructor`, "
"`l1-handler` and `internal` functions in the trait implementation. Indeed, "
"`#[abi(per_item)]` only works with a trait that is not defined as a Starknet"
" interface. Hence, it will be mandatory to create another trait defined as "
"interface to implement public functions."
msgstr ""
"Dalam kasus ini, hanya akan mungkin untuk menyertakan "
"▪constructorál1-handler (property) dan fungsi international dalam "
"implementasi sifat. Memang, ·abi_traitm] hanya akan bekerja dengan sifat "
"yang tidak didefinisikan sebagai antarmuka Starknet. Oleh karena itu, itu "
"akan wajib untuk membuat antarmuka lain yang didefinisikan untuk "
"mengimplementasikan fungsi publik."

#: src/ch14-03-contract-events.md:3
msgid ""
"Events are custom data structures that are emitted by smart contracts during"
" execution. They provide a way for smart contracts to communicate with the "
"external world by logging information about specific occurrences in a "
"contract."
msgstr ""
"Peristiwa-peristiwa adalah struktur data kustom yang dipancarkan oleh "
"kontrak cerdas selama eksekusi. Mereka menyediakan cara bagi kontrak cerdas "
"untuk berkomunikasi dengan dunia luar dengan mencatat informasi tentang "
"kejadian tertentu dalam kontrak."

#: src/ch14-03-contract-events.md:5
msgid ""
"Events play a crucial role in the integration of smart contracts in real-"
"world applications. Take, for instance, the Non-Fungible Tokens (NFTs) "
"minted on Starknet. An event is emitted each time a token is minted. This "
"event is indexed and stored in some database, allowing applications to "
"display almost instantaneously useful information to users. If the contract "
"doesn't emit an event when minting a new token, it would be less practical, "
"with the need of querying the state of the blockchain to get the data "
"needed."
msgstr ""
"Peristiwa memainkan peran penting dalam integrasi kontrak cerdas di aplikasi"
" dunia nyata. Ambil, misalnya, Token Non-Fungible (NFT) yang dicetak di "
"Starknet. Sebuah peristiwa dipancarkan setiap kali sebuah token dicetak. "
"Peristiwa ini diindeks dan disimpan dalam beberapa database, memungkinkan "
"aplikasi untuk menampilkan informasi yang hampir seketika berguna kepada "
"pengguna. Jika kontrak tidak memancarkan suatu peristiwa ketika mencetak "
"token baru, itu akan kurang praktis, dengan kebutuhan dari query negara "
"rantai blok untuk mendapatkan data yang dibutuhkan."

#: src/ch14-03-contract-events.md:7
msgid "Defining Events"
msgstr "Peristiwa - Peristiwa yang Ditetapkan"

#: src/ch14-03-contract-events.md:9
msgid ""
"All the different events in a contract are defined under the `Event` enum, "
"which must implement the `starknet::Event` trait. This trait is defined in "
"the core library as follows:"
msgstr ""
"Semua peristiwa yang berbeda dalam kontrak didefinisikan di bawah enum "
"ÉEvent, yang harus mengimplementasikan åstarknet::Event) sifat ini "
"didefinisikan dalam perpustakaan inti sebagai berikut:"

#: src/ch14-03-contract-events.md:18
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate "
"an implementation for the above trait, instantiated with the `Event` type, "
"which in our example is the following enum:"
msgstr ""
"Atribut:Event) menyebabkan kompiler untuk menghasilkan implementasi untuk "
"sifat di atas, instansi dengan tipe ÉEventó, yang dalam contoh kita adalah "
"enum berikut:"

#: src/ch14-03-contract-events.md:29
msgid ""
"Each variant of the `Event` enum has to be a struct or an enum, and each "
"variant needs to implement the `starknet::Event` trait itself. Moreover, the"
" members of these variants must implement the `Serde` trait (_c.f._ "
"[Appendix C: Serializing with Serde](./appendix-03-derivable-"
"traits.html#serializing-with-serde)), as keys/data are added to the event "
"using a serialization process."
msgstr ""
"Setiap varian dari enum harus berupa struct atau enum, dan setiap varian "
"perlu mengimplementasikan sifat "
"Éstarknet::Eventix-03-traits.htl#menimplementasikan-serde), sebagai "
"kunci/data ditambahkan ke kejadian yang menggunakan proses serial."

#: src/ch14-03-contract-events.md:31
msgid ""
"The auto-implementation of the `starknet::Event` trait will implement the "
"`append_keys_and_data` function for each variant of our `Event` enum. The "
"generated implementation will append a single key based on the variant name "
"(`StoredName`), and then recursively call `append_keys_and_data` in the impl"
" of the `Event` trait for the variant’s type."
msgstr ""
"Implementasi auto-implementation dari enum thosestarknet: Event; sifat akan "
"mengimplementasikan auto-implemental_keys_and_data untuk setiap varian kami."
" Implementasi yang dihasilkan akan menambahkan satu kunci berdasarkan nama "
"varian (Nemetored), dan kemudian secara recursive call "
"·append_keys_keys_and_ata dalam impl &amp;Eventánaity sifat untuk varians."

#: src/ch14-03-contract-events.md:33
msgid ""
"In our example, the `Event` enum contains only one variant, which is a "
"struct named `StoredName`. We chose to name our variant with the same name "
"as the struct name, but this is not enforced."
msgstr ""
"Dalam contoh kami, enum mengandung hanya satu varian, yaitu struct bernama "
"StoredName. kami memilih untuk menamai varian kami dengan nama yang sama "
"dengan nama struct, tapi ini tidak dipaksakan."

#: src/ch14-03-contract-events.md:44
msgid ""
"Whenever an enum that derives the `starknet::Event` trait has an enum "
"variant, this enum is nested by default. Therefore, the list of keys "
"corresponding to the variant’s name will include the `sn_keccak` hash of the"
" variant's name itself. This can be superfluous, typically when using "
"embedded components in contracts. Indeed, in such cases, we might want the "
"events defined in the components to be emitted without any additional data, "
"and it could be useful to annotate the enum variant with the `#[flat]` "
"attribute. By doing so, we allow to opt out of the nested behavior and "
"ignore the variant name in the serialization process. On the other hand, "
"nested events have the benefit of distinguishing between the main contract "
"event and different components events, which might be helpful."
msgstr ""
"Setiap kali enum ini bersarang secara baku. Oleh karena itu, daftar kunci "
"yang berhubungan dengan nama varian akan mencakup Ás_keccaká hash dari nama "
"varian itu sendiri. Hal ini dapat menjadi superfluous, biasanya ketika "
"menggunakan komponen yang tertanam dalam kontrak. Memang, dalam kasus "
"seperti itu, kita mungkin ingin peristiwa yang didefinisikan dalam komponen "
"untuk dipancarkan tanpa adanya data tambahan, dan dapat berguna untuk "
"melafalkan varian enum varian dengan atribut yang sedang terjadi."

#: src/ch14-03-contract-events.md:46
msgid ""
"In our contract, we defined an event named `StoredName` that emits the "
"contract address of the caller and the name stored within the contract, "
"where the `user` field is serialized as a key and the `name` field is "
"serialized as data."
msgstr ""
"Dalam kontrak kami, kami mendefinisikan sebuah peristiwa bernama æStoredNama"
" yang memancarkan alamat kontrak dari pemanggil dan nama yang tersimpan "
"dalam kontrak, di mana medan pengiring serial sebagai kunci dan medan nama "
"serial sebagai data."

#: src/ch14-03-contract-events.md:48
msgid ""
"Indexing events fields allows for more efficient queries and filtering of "
"events. To index a field as a key of an event, simply annotate it with the "
"`#[key]` attribute as demonstrated in the example for the `user` key. By "
"doing so, any indexed field will allow queries of events that contain a "
"given value for that field with \\\\( O(log(n)) \\\\) time complexity, while"
" non indexed fields require any query to iterate over all events, providing "
"\\\\( O(n) \\\\) time complexity."
msgstr ""
"Indexing fields fields memungkinkan untuk queries yang lebih efisien dan "
"penyaringan kejadian. Untuk menindeks sebuah field sebagai kunci dari suatu "
"acara, hanya mengnotasinya dengan atribut åkey] seperti yang ditunjukkan "
"dalam contoh untuk kunci Áuser. Dengan melakukan itu, lapangan indeks apapun"
" akan memungkinkan queries dari peristiwa yang mengandung nilai yang "
"diberikan untuk bidang itu dengan \\\\ (\\\\ániglogánian) \\) waktu "
"kompleksitas, sementara daerah tidak terindeks membutuhkan query apapun "
"untuk itu selama semua peristiwa, menyediakan \\ \\ \\ \\ \\\\ Allah) waktu "
"kompleks."

#: src/ch14-03-contract-events.md:50
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: name "
"})`, a key corresponding to the name ` StoredName`, specifically "
"`sn_keccak(StoredName)`, is appended to the keys list. `user`is serialized "
"as key, thanks to the `#[key]` attribute, while address is serialized as "
"data. After everything is processed, we end up with the following keys and "
"data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [name]`."
msgstr ""
"Ketika memancarkan acara itu dengan dirinya sendiri.emit_StoredName), "
"pengguna, nama: nama], sebuah kunci yang berhubungan dengan nama [keyName "
"[key], sementara alamat diserialisasi sebagai data. Setelah semuanya "
"diproses, kita berakhir dengan kunci dan data berikut: tombol = "
"snke_ccaktor\"Stor\"), dan [ameameed]"

#: src/ch14-03-contract-events.md:54
msgid "Emitting Events"
msgstr "Emitting Events"

#: src/ch14-03-contract-events.md:56
msgid ""
"After defining events, we can emit them using `self.emit`, with the "
"following syntax:"
msgstr ""
"Setelah mendefinisikan kejadian, kita dapat memancarkannya dengan "
"menggunakan sendiri.emit, dengan sintaks berikut:"

#: src/ch14-03-contract-events.md:62
msgid ""
"The `emit` function is called on `self` and takes a reference to `self`, "
"i.e., state modification capabilities are required. Therefore, it is not "
"possible to emit events in view functions."
msgstr ""
"Fungsi modifikasi negara diperlukan, karena itu, tidak mungkin untuk "
"memancarkan peristiwa dalam pandangan fungsi."

#: src/ch15-00-starknet-cross-contract-interactions.md
msgid ""
"Interactions between smart contracts are an important feature when creating "
"complex decentralized applications, as it allows for composability and "
"separation of concerns. This chapter sheds light on how to make contracts "
"interact with each other."
msgstr ""
"Interaksi antara kontrak cerdas adalah fitur penting ketika membuat aplikasi"
" yang terdesentralisasi kompleks, seperti yang memungkinkan untuk "
"komposabilitas dan pemisahan kekhawatiran. Bab ini memberikan cahaya tentang"
" bagaimana membuat kontrak berinteraksi satu sama lain."

#: src/ch15-00-starknet-cross-contract-interactions.md
msgid ""
"Specifically, you'll learn about ABIs, contract interfaces, the contract and"
" library dispatchers and their low-level system call equivalents!"
msgstr ""
"Secara khusus, Anda akan belajar tentang ABI, antarmuka kontrak, kontrak dan"
" perpustakaan operator dan sistem tingkat rendah mereka panggilan setara!"

#: src/ch15-01-abis-and-contract-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a "
"common practice which enables us to build flexible contracts that can speak "
"with each other."
msgstr ""
"Interaksi silang antara kontrak cerdas pada rantai blok adalah praktek umum "
"yang memungkinkan kita untuk membangun kontrak fleksibel yang dapat "
"berbicara satu sama lain."

#: src/ch15-01-abis-and-contract-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr ""
"Mencapai ini di Starknet membutuhkan sesuatu yang kita sebut antarmuka."

#: src/ch15-01-abis-and-contract-interfaces.md:7
msgid "ABI - Application Binary Interface"
msgstr "ABI - Aplikasi Antarmuka Biner"

#: src/ch15-01-abis-and-contract-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the "
"contract's functions and structures, giving anyone (or any other contract) "
"the ability to form encoded calls to it. It is a blueprint that instructs "
"how functions should be called, what input parameters they expect, and in "
"what format."
msgstr ""
"Di Starknet, ABI dari sebuah kontrak adalah representasi JSON dari fungsi "
"dan struktur kontrak, memberikan siapa pun (atau kontrak lain) kemampuan "
"untuk membentuk panggilan terkode untuk itu. Ini adalah cetak biru yang "
"memerintahkan bagaimana fungsi harus disebut, parameter masukan apa yang "
"mereka harapkan, dan dalam bentuk apa."

#: src/ch15-01-abis-and-contract-interfaces.md:11
msgid ""
"While we write our smart contract logics in high-level Cairo, they are "
"stored on the VM as executable bytecodes which are in binary formats. Since "
"this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods "
"which can be called to a smart contract for execution. Without an ABI, it "
"becomes practically impossible for external actors to understand how to "
"interact with a contract."
msgstr ""
"Sementara kita menulis logika kontrak cerdas kita di Cairo tingkat tinggi, "
"mereka disimpan di VM sebagai bytecode executable yang dalam format biner. "
"karena bytecode ini bukan manusia yang dapat dibaca, itu membutuhkan "
"interpretasi untuk dipahami. Ini adalah di mana ABI datang ke bermain, "
"mendefinisikan metode spesifik yang dapat dipanggil ke kontrak cerdas untuk "
"eksekusi. tanpa ABI, itu menjadi praktis mustahil bagi aktor eksternal untuk"
" memahami bagaimana berinteraksi dengan kontrak."

#: src/ch15-01-abis-and-contract-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data "
"correctly, making it understandable by the smart contract and vice versa. "
"When you interact with a smart contract through a block explorer like "
"[Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), "
"they use the contract's ABI to format the data you send to the contract and "
"the data it returns."
msgstr ""
"ABI biasanya digunakan di frontends dApp, memungkinkannya untuk memformat "
"data dengan benar, membuatnya dimengerti oleh kontrak cerdas dan sebaliknya."
" Ketika Anda berinteraksi dengan kontrak cerdas melalui penjelajah blok "
"seperti [Voyager] Tyronehttps://voyager.online/) atau "
"[Starkscan]://httpsscan.co/), mereka menggunakan kontrak ABI untuk format "
"data yang Anda kirim ke kontrak dan datanya kembali."

#: src/ch15-01-abis-and-contract-interfaces.md:15
#: src/ch16-05-02-randomness.md:25
msgid "Interface"
msgstr "Antarmuka"

#: src/ch15-01-abis-and-contract-interfaces.md:17
msgid ""
"The interface of a contract is a list of the functions it exposes publicly. "
"It specifies the function signatures (name, parameters, visibility and "
"return value) contained in a smart contract without including the function "
"body."
msgstr ""
"Antar muka sebuah kontrak adalah daftar fungsi yang dieksposkan secara "
"terbuka. Ini menspesifikasikan tanda tangan fungsi (nama, parameter, "
"visibilitas, nilai kembali) yang terkandung dalam kontrak cerdas tanpa "
"termasuk tubuh fungsi."

#: src/ch15-01-abis-and-contract-interfaces.md:20
msgid ""
"Contract interfaces in Cairo are traits annotated with the "
"`#[starknet::interface]` attribute. If you are new to traits, check out the "
"dedicated chapter on [traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"Antarmuka kontrak di Cairo dihafalkan dengan atribut:: interface]. Jika Anda"
" baru dengan sifat-sifat, periksa bab yang didedikasikan pada "
"[traits][/ch08-02-traits-in-cairo.md)."

#: src/ch15-01-abis-and-contract-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the "
"`TContractState` type. This is required for functions to access the "
"contract's storage, so that they can read and write to it."
msgstr ""
"Salah satu spesifikasi penting adalah bahwa sifat ini harus umum di atas "
"jenis åTContractState. Ini diperlukan untuk fungsi untuk mengakses "
"penyimpanan kontrak, sehingga mereka dapat membaca dan menulis untuk itu."

#: src/ch15-01-abis-and-contract-interfaces.md:24
msgid ""
"Note: The contract constructor is not part of the interface. Nor are "
"internal functions part of the interface."
msgstr ""
"Catatan: Konstruktor kontrak bukan bagian dari antarmuka. Begitu juga fungsi"
" internal bagian dari antar muka."

#: src/ch15-01-abis-and-contract-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's "
"a generic trait over the `TContractState` type. `view` functions have a self"
" parameter of type `@TContractState`, while `external` functions have a self"
" parameter of type passed by reference `ref self: TContractState`."
msgstr ""
"Ini contoh antarmuka untuk kontrak kontok ERC20. seperti yang Anda lihat, "
"ini adalah sifat umum atas tipe åTContractate."

#: src/ch15-01-abis-and-contract-interfaces.md:55
msgid "<span class=\"caption\">Listing 15-1: A simple ERC20 Interface.</span>"
msgstr "<span class=\"caption\">Listing 15-1: A simple ERC20 Interface.</span>"

#: src/ch15-01-abis-and-contract-interfaces.md:57
msgid ""
"In the next chapter, we will see how we can call contracts from other smart "
"contracts using _dispatchers_ and _syscalls_ ."
msgstr ""
"Dalam bab berikutnya, kita akan melihat bagaimana kita dapat memanggil "
"kontrak dari kontrak cerdas lainnya menggunakan _dispatchers_ dan "
"_syscalls_."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:3
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically"
" created and exported by the compiler. Let's consider an interface that we "
"named IERC20, these would be:"
msgstr ""
"Setiap kali antarmuka kontrak didefinisikan, dua dispatcher secara otomatis "
"dibuat dan diekspor oleh kompiler. Mari kita pertimbangkan antarmuka yang "
"kita namai IERC20, ini akan menjadi:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:5
msgid "The Contract Dispatcher `IERC20Dispatcher`"
msgstr "Dispatcher Kontrak ÉIERC20 Dispatcher"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:6
msgid "The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr "The Library Dispatcher ÉIERC20Library Dispatcher"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:8
msgid ""
"The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to "
"call the functions defined in the interface on the dispatcher struct."
msgstr ""
"Komiler juga menghasilkan sebuah sifat ÉIERC20 DispatcherTrait, memungkinkan"
" kita untuk memanggil fungsi yang didefinisikan dalam antarmuka pada "
"dispatcher struct."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:10
msgid ""
"In this chapter, we are going to discuss what these are, how they work and "
"how to use them."
msgstr ""
"Dalam bab ini, kita akan membahas apa ini, bagaimana mereka bekerja dan "
"bagaimana menggunakannya."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:12
msgid ""
"To effectively break down the concepts in this chapter, we are going to be "
"using the IERC20 interface from the previous chapter (refer to Listing "
"15-1)."
msgstr ""
"Untuk memecahkan konsep secara efektif dalam bab ini, kita akan menggunakan "
"antarmuka IERC20 dari bab sebelumnya (refer ke Listing 15-1)."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:14
msgid "Contract Dispatcher"
msgstr "Dispatcher Kontrak"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` "
"attribute automatically generate a dispatcher and a trait on compilation. "
"Our `IERC20` interface is expanded into something like this:"
msgstr ""
"Seperti yang telah disebutkan sebelumnya, sifat-sifat yang dinotasi dengan "
"interface::: interface] atribut secara otomatis menghasilkan sebuah operator"
" dan sifat pada kompilasi. Antar muka kita diperluas menjadi sesuatu seperti"
" ini:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:19
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to"
" keep this chapter concise and straight to the point, we focused on one view"
" function `name`, and one external function `transfer`."
msgstr ""
"**Note:** Kode diperluas untuk antarmuka IERC20 kami jauh lebih panjang, "
"tetapi untuk menjaga bab ini ringkas dan langsung ke titik, kami berfokus "
"pada satu fungsi ånameá, dan satu fungsi eksternal."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:37
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:41
msgid "// starknet::call_contract_syscall is called in here\n"
msgstr "// starnet::call_contract_syscall dipanggil kesini\n"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:46
msgid ""
"<span class=\"caption\">Listing 15-2: An expanded form of the "
"IERC20Dispatcher trait.</span>"
msgstr ""
"<span class=\"caption\">Listing 15-2: Bentuk terekspansi dari sifat IERC20 "
"Dispatcher.</span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a "
"contract address and implements the `DispatcherTrait` generated by the "
"compiler, allowing us to call functions from another contract. This means "
"that we can instantiate a struct with the address of the contract we want to"
" call, and then simply call the functions defined in the interface on the "
"dispatcher struct as if they were methods of that type."
msgstr ""
"Seperti yang Anda lihat, dispatcher \"classic\" hanya sebuah struktur yang "
"membungkus alamat kontrak dan menerapkan dispatcherTrait yang dihasilkan "
"oleh kompiler, memungkinkan kita untuk memanggil fungsi dari kontrak lain. "
"Ini berarti bahwa kita dapat mengaktifkan struktur dengan alamat kontrak "
"kita ingin menelepon, dan kemudian hanya panggilan fungsi didefinisikan "
"dalam antarmuka dispender struktur seolah-olah mereka adalah metode tipe "
"itu."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:50
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes "
"thanks to the power of Cairo plugins."
msgstr ""
"Hal ini juga layak dicatat bahwa semua ini abstrak di belakang layar berkat "
"kekuatan plugin Cairo."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:52
msgid "Calling Contracts using the Contract Dispatcher"
msgstr "Memanggil Kontrak menggunakan Dispatcher Kontrak"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:54
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to "
"call functions defined on an ERC-20 token. Calling `transfer_token` will "
"modify the state of the contract deployed at `contract_address`."
msgstr ""
"Ini adalah contoh dari sebuah kontrak bernama 'TokenWrapper' menggunakan "
"sebuah operator untuk memanggil fungsi yang didefinisikan pada ERC-20 token."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:94
msgid "//**** Specify interface here ****//\n"
msgstr "/**** Nyatakan antarmuka di sini ****/ /\n"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:125
msgid ""
"<span class=\"caption\">Listing 15-3: A sample contract which uses the "
"Contract Dispatcher.</span>"
msgstr ""
"<span class=\"caption\">Listing 15-3: Sebuah contoh kontrak yang menggunakan"
" Dispatcher Kontrak.</span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:127
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` generated by the compiler, which allows us to make calls "
"to the methods implemented for the `IERC20Dispatcher` struct (`name`, "
"`transfer`, etc), passing in the `contract_address` of the contract we want "
"to call in the `IERC20Dispatcher` struct."
msgstr ""
"Seperti yang Anda lihat, kami pertama-tama harus mengimpor dispatcherTrait "
"20 discont (artial Trait) dan ÁRC20 Dispatcher) yang pertama kali dihasilkan"
" oleh kompiler, yang memungkinkan kami untuk membuat panggilan ke metode "
"yang diimplementasikan untuk struktur ÉRC20 Dispatcher (profer, dll), yang "
"lewat dalam versuscontract_address dari kontrak yang kami ingin hubungi di "
"struktur."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:129
msgid "Library Dispatcher"
msgstr "Dispatcher Pustaka"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library "
"dispatcher lies in the execution context of the logic defined in the class. "
"While regular dispatchers are used to call functions from **contracts** "
"(with an associated state), library dispatchers are used to call **classes**"
" (stateless)."
msgstr ""
"Perbedaan kunci antara operator kontrak dan dispatcher perpustakaan terletak"
" pada konteks eksekusi logika yang didefinisikan dalam kelas. Sementara "
"operator reguler digunakan untuk memanggil fungsi dari **contracts** (dengan"
" keadaan terkait), pengiriman perpustakaan digunakan untuk memanggil "
"**class** (tak berdasar)."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr "Mari kita pertimbangkan dua kontrak A dan B."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the "
"execution context of the logic defined in B is that of B. This means that "
"the value returned by `get_caller_address()` in B will return the address of"
" A, and updating a storage variable in B will update the storage of B."
msgstr ""
"Ketika A menggunakan dispatcher (dispatcher) untuk memanggil fungsi dari "
"**contract** B, konteks eksekusi logika yang didefinisikan dalam B adalah B."
" Ini berarti bahwa nilai yang dikembalikan oleh ▪Get_caller_addunderd) di B "
"akan mengembalikan alamat A, dan memperbarui variabel penyimpanan di B akan "
"memperbarui penyimpanan B."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B,"
" the execution context of the logic defined in B's class is that of A. This "
"means that the value returned by `get_caller_address()` variable in B will "
"return the address of the caller of A, and updating a storage variable in "
"B's class will update the storage of A (remember that the **class** of B is "
"stateless; there is no state that can be updated!)"
msgstr ""
"Ketika A menggunakan dispatcher (Dispatcher) untuk memanggil fungsi dari "
"**class** dari B, konteks eksekusi dari logika yang didefinisikan dalam "
"kelas B adalah A. Ini berarti nilai yang dikembalikan oleh "
"varivator_caller_address) (*class** dari B akan mengembalikan alamat "
"pemanggil A, dan memperbarui variabel penyimpanan di kelas B akan "
"memperbarui penyimpanan A (ingat bahwa *class** dari Bless adalah negara "
"bagian; tidak ada keadaan yang dapat diperbarui)!"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:139
msgid ""
"The expanded form of the struct and trait generated by the compiler look "
"like:"
msgstr ""
"Bentuk terekspansi dari struktur dan sifat yang dihasilkan oleh kompiler "
"terlihat seperti:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:157
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:161
msgid "// starknet::syscalls::library_call_syscall  is called in here\n"
msgstr "// starnet::syscalls::library_call_syscall dipanggil kesini\n"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:166
msgid ""
"<span class=\"caption\">Listing 15-4: An expanded form of the IERC20 "
"trait.</span>"
msgstr ""
"<span class=\"caption\">Listing 15-4: Bentuk terekspansi dari sifat "
"IERC20.</span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:168
msgid ""
"Notice that the main difference between the regular contract dispatcher and "
"the library dispatcher is that the former uses `call_contract_syscall` while"
" the latter uses `library_call_syscall`."
msgstr ""
"Perhatikan bahwa perbedaan utama antara operator kontrak reguler dan "
"dispatcher perpustakaan adalah bahwa mantan penggunaan "
"▪call_contract_syscall_syscallé sementara yang terakhir menggunakan "
"▪library_call_syscall#."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:170
msgid "Calling Contracts using the Library Dispatcher"
msgstr "Memanggil Kontrak menggunakan Library Dispatcher"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:172
msgid ""
"Below's a sample code for calling contracts using the Library Dispatcher."
msgstr ""
"Berikut ini adalah contoh kode untuk memanggil kontrak menggunakan Library "
"Dispatcher."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:208
msgid ""
"<span class=\"caption\">Listing 15-5: A sample contract using the Library "
"Dispatcher.</span>"
msgstr ""
"<span class=\"caption\">Listing 15-5: Sebuah kontrak cuplikan menggunakan "
"Library Dispatcher.</span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:210
msgid ""
"As you can see, we had to first import in our contract the "
"`IContractADispatcherTrait` and `IContractALibraryDispatcher` which were "
"generated from our interface by the compiler. Then, we can create an "
"instance of `IContractALibraryDispatcher` passing in the `class_hash` of the"
" class we want to make library calls to. From there, we can call the "
"functions defined in that class, executing its logic in the context of our "
"contract. When we call `set_value` on ContractA, it will make a library call"
" to the `set_value` function in IContractA, updating the value of the "
"storage variable `value` in ContractA."
msgstr ""
"Seperti yang dapat Anda lihat, kami harus mengimpor pertama kali dalam "
"kontrak kami, kami harus mengimpornya terlebih dahulu dalam kontrak kami. "
"Kemudian, kami dapat membuat contoh dari CHOIContractALALERTRAIT (discort) "
"dan di kelas yang kami ingin membuat panggilan perpustakaan dari sana. Dari "
"sana, kami dapat menyebut fungsi yang didefinisikan dalam kelas tersebut, "
"mengeksekusi logikanya dalam konteks kontrak kami. Ketika kami menyebut "
"'Dispatbrary Dispatcher' (Dispatcherry Dispatcher' (Dispatcher), akan "
"membuat sebuah perpustakaan menjadi sebuah fungsi yang sangat bernilai."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:212
msgid "Using low-level syscalls"
msgstr "Menggunakan syscall tingkat rendah"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:214
msgid ""
"Another way to call other contracts and classes is to use the "
"`starknet::call_contract_syscall`and `starknet::library_call_syscall` system"
" calls. The dispatchers we described in the previous sections are high-level"
" syntaxes for these low-level system calls."
msgstr ""
"Cara lain untuk memanggil kontrak lain dan kelas adalah dengan menggunakan "
"sistem call åstarknet:call_contract_syscall_scall:::library_syscall_syscallé"
" calls. Para operator yang kami deskripsikan di seksi sebelumnya adalah "
"sintaks tingkat tinggi untuk panggilan sistem tingkat rendah ini."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:216
msgid ""
"Using these syscalls can be handy for customized error handling or to get "
"more control over the serialization/deserialization of the call data and the"
" returned data. Here's an example demonstrating how to use a "
"`call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr ""
"Menggunakan syscall ini dapat berguna untuk penanganan galat yang "
"disesuaikan atau untuk mendapatkan lebih banyak kontrol atas "
"serialisasi/deserialisasi dari data panggilan dan data yang dikembalikan. "
"Berikut adalah contoh menunjukkan bagaimana menggunakan sebuah "
"▪call_contract_sycallé untuk memanggil fungsi ERC20:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:254
msgid "\"transferFrom\""
msgstr "\"Transfer From\""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:265
msgid ""
"<span class=\"caption\">Listing 15-6: A sample contract using "
"syscalls.</span>"
msgstr ""
"<span class=\"caption\">Listing 15-6: Sebuah kontrak cuplikan menggunakan "
"syscalls.</span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:267
msgid ""
"To use this syscall, we passed in the contract address, the selector of the "
"function we want to call (see next section), and the call arguments."
msgstr ""
"Untuk menggunakan syscall ini, kami melewati alamat kontrak, pemilih dari "
"fungsi yang ingin kami panggil (lihat bagian berikutnya), dan argumen "
"panggilan."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:269
msgid ""
"The call arguments must be provided as an array of `felt252`. To build this "
"array, we serialize the expected function parameters into an "
"`Array<felt252>` using the `Serde` trait, and then pass this array as "
"calldata. At the end, we are returned a serialized value which we'll need to"
" deserialize ourselves!"
msgstr ""
"Argumen panggilan harus disediakan sebagai sebuah array "
"\\\\fnCandara\\fs60\\b1\\4cH000000\\4aH80}untuk membangun array yang "
"diharapkan menjadi sebuah array<felt252> {\\4cH1011FF\\fnGill Sans Ultra "
"Bold Condensed\\fs60\\b1\\4cH000000\\4aH80}dan kemudian melewati array ini "
"sebagai calldata."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:271
msgid "Entry Point Selector"
msgstr "Pemilih Titik Masukan"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:273
msgid ""
"In the context of a smart contract, a selector is a unique identifier for a "
"specific entrypoint of a contract. When a transaction is sent to a contract,"
" it includes the selector in the calldata to specify which function should "
"be executed."
msgstr ""
"Dalam konteks kontrak pintar, pemilih adalah identifier unik untuk titik "
"masuk tertentu dari sebuah kontrak. Ketika transaksi dikirim ke sebuah "
"kontrak, itu termasuk pemilih dalam calldata untuk menentukan fungsi mana "
"yang mesti dijalankan."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:275
msgid ""
"On Starknet, the selector is computed by applying the `sn_keccak` hash "
"function to the string representation of the function name. If the function "
"name is `transfer`, the selector can be computed with "
"`selector!(\"transfer\")`"
msgstr ""
"Di Starknet, pemilih menghitung dengan menerapkan fungsi hash dari string "
"representasi dari nama fungsi."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:277
msgid ""
"Note that in `starknet::call_contract_syscall`, we didn't specify the "
"function name as a string, but rather used the `selector!` macro, which "
"computes the `sn_keccak` hash of the provided function signature."
msgstr ""
"Perhatikan bahwa dalam åstarknet:call_contract_syscallé, kami tidak "
"menspesifikasikan nama fungsi sebagai string, tetapi lebih memilih "
"menggunakan makro!, yang menghitung hash fungsi yang diberikan."

#: src/ch16-01-optimizing-storage-costs.md:3
msgid ""
"Bit-packing is a simple concept: use as few bits as possible to store a "
"piece of data. When done well, it can significantly reduce the size of the "
"data you need to store. This is especially important in smart contracts, "
"where storage is expensive."
msgstr ""
"Mengepak bit adalah konsep sederhana: gunakan beberapa bit mungkin untuk "
"menyimpan sepotong data. Ketika dilakukan dengan baik, ia dapat secara "
"signifikan mengurangi ukuran data yang perlu Anda simpan. Hal ini terutama "
"penting dalam kontrak pintar, di mana penyimpanan mahal."

#: src/ch16-01-optimizing-storage-costs.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage "
"usage to reduce gas costs. Indeed, most of the cost associated with a "
"transaction is related to storage updates; and each storage slot costs gas "
"to write to. This means that by packing multiple values into fewer slots, "
"you can decrease the gas cost incurred by the users of your smart contract."
msgstr ""
"Ketika menulis Cairo kontrak cerdas, sangat penting untuk mengoptimalkan "
"penggunaan penyimpanan untuk mengurangi biaya gas. Memang, sebagian besar "
"biaya yang terkait dengan transaksi terkait dengan pemutakhiran; dan setiap "
"slot penyimpanan gas biaya untuk ditulis. Ini berarti bahwa dengan mengepak "
"beberapa nilai ke slot yang lebih sedikit, Anda dapat mengurangi biaya gas "
"yang dikeluarkan oleh pengguna kontrak pintar Anda."

#: src/ch16-01-optimizing-storage-costs.md:8
msgid "Integer Structure and Bitwise Operators"
msgstr "Integer Structure dan Operator Bitwise"

#: src/ch16-01-optimizing-storage-costs.md:10
msgid ""
"An integer is coded on a certain number of bits, depending on its size (For "
"example, a `u8` integer is coded on 8 bits)."
msgstr ""
"Sebuah integer dikodekan pada sejumlah bit tertentu, tergantung pada "
"ukurannya (misalnya, sebuah integer dikodekan pada 8 bit)."

#: src/ch16-01-optimizing-storage-costs.md:19
msgid ""
"Intuitively, several integers can be combined into a single integer if the "
"size of this single integer is greater than or equal to the sum of the sizes"
" of the integers (For example, two `u8` and one `u16` in one `u32`)."
msgstr ""
"Secara intuitif, beberapa integer dapat digabung menjadi satu integer jika "
"ukuran integer tunggal ini lebih besar atau sama dengan jumlah dari ukuran "
"integer (misalnya, dua ·u8) dan satu Áu16 dalam satu Áu32)."

#: src/ch16-01-optimizing-storage-costs.md:21
msgid "But, to do that, we need some bitwise operators:"
msgstr "Tapi, untuk melakukan itu, kita perlu beberapa operator bitwise:"

#: src/ch16-01-optimizing-storage-costs.md:23
msgid ""
"multiplying or dividing an integer by a power of 2 shifts the integer value "
"to the left or to the right respectively"
msgstr ""
"mengalikan atau membagi bilangan integer dengan kekuatan dari 2 menggeser "
"nilai integer ke kiri atau ke kanan masing-masing"

#: src/ch16-01-optimizing-storage-costs.md:32
msgid ""
"applying a mask (`AND` operator) on an integer value isolates some bits of "
"this integer"
msgstr ""
"menerapkan topeng (AND) pada nilai integer mengisolasi beberapa bit integer "
"ini"

#: src/ch16-01-optimizing-storage-costs.md:41
msgid ""
"adding (`OR` operator) two integers will combine both values into a single "
"one."
msgstr ""
"menambahkan (Negara operator) dua integer akan menggabungkan kedua nilai "
"menjadi satu."

#: src/ch16-01-optimizing-storage-costs.md:50
msgid ""
"With these bitwise operators, let's see how to combine two `u8` integers "
"into a single `u16` integer (called `packing`) and reversely (called "
"`unpacking`) in the following example:"
msgstr ""
"Dengan operator bitwise ini, mari kita lihat bagaimana menggabungkan dua "
"bilangan integer menjadi satu integer (disebut pengepakan secara terbalik) "
"dalam contoh berikut:"

#: src/ch16-01-optimizing-storage-costs.md:59
msgid "Bit-packing in Cairo"
msgstr "Mengepak bit di Cairo"

#: src/ch16-01-optimizing-storage-costs.md:61
msgid ""
"The storage of a Starknet smart contract is a map with 2<sup>251</sup> "
"slots, where each slot is a `felt252` which is initialized to 0."
msgstr ""
"Penyimpanan sebuah kontrak cerdas Starknet adalah peta dengan "
"2<sup>251</sup> slot, di mana masing-masing slot adalah a TMT252-- yang "
"diinisialisasi menjadi 0."

#: src/ch16-01-optimizing-storage-costs.md:63
msgid ""
"As we saw earlier, to reduce gas costs due to storage updates, we have to "
"use as few bits as possible, so we have to organize stored variables by "
"packing them."
msgstr ""
"Seperti yang kita lihat sebelumnya, untuk mengurangi biaya gas karena "
"pemutakhiran penyimpanan, kita harus menggunakan beberapa bit sebisa "
"mungkin, jadi kita harus mengatur variabel yang tersimpan dengan "
"mengemasnya."

#: src/ch16-01-optimizing-storage-costs.md:65
msgid ""
"For example, consider the following `Sizes` struct with 3 fields of "
"different types: one `u8`, one `u32` and one `u64`. The total size is 8 + 32"
" + 64 = 104 bits. This is less than a slot size (i.e 251 bits) so we can "
"pack them together to be stored into a single slot."
msgstr ""
"Sebagai contoh, perhatikan struktur berikut ini dengan 3 bidang berbagai "
"jenis: satu jenis ·u8, satu åu32 dan satu ukuran total adalah 8 + 32 + 64 = "
"104 bits. ini kurang dari ukuran slot (i.e 251 bits) sehingga kita dapat "
"mengemasnya bersama-sama untuk disimpan ke dalam slot tunggal."

#: src/ch16-01-optimizing-storage-costs.md:67
msgid ""
"Note that, as it also fits in a `u128`, it's a good practice to use the "
"smallest type to pack all your variables, so here a `u128` should be used."
msgstr ""
"Perhatikan bahwa, karena itu juga cocok dalam sebuah ·u128, itu adalah "
"praktek yang baik untuk menggunakan tipe terkecil untuk pak semua variabel "
"Anda, jadi di sini a ·u128 yang harus digunakan."

#: src/ch16-01-optimizing-storage-costs.md:77
msgid ""
"To pack these 3 variables into a `u128` we have to successively shift them "
"to the left, and finally sum them."
msgstr ""
"Untuk mengemas 3 variabel ini ke dalam sebuah ·u128. Kita harus secara "
"berturut-turut menggesernya ke kiri, dan akhirnya merangkumnya."

#: src/ch16-01-optimizing-storage-costs.md:86
msgid ""
"To unpack these 3 variables from a `u128` we have to successively shift them"
" to the right and use a mask to isolate them."
msgstr ""
"Untuk membongkar 3 variabel ini dari sebuah åu128. Kita harus secara "
"berturut-turut memindahkannya ke kanan dan menggunakan topeng untuk "
"mengisolasi mereka."

#: src/ch16-01-optimizing-storage-costs.md:95
msgid "The `StorePacking` Trait"
msgstr "Trait StorePacking."

#: src/ch16-01-optimizing-storage-costs.md:97
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into"
" fewer storage slots. `StorePacking<T, PackedT>` is a generic trait taking "
"the type you want to pack (`T`) and the destination type (`PackedT`) as "
"parameters. It provides two functions to implement: `pack` and `unpack`."
msgstr ""
"Cairo menyediakan sifat yang sangat unik untuk mengaktifkan pemompaan medan "
"ke dalam lebih sedikit slot penyimpanan. ▪StorePacking<T, PackedT>): adalah "
"sifat umum yang mengambil tipe yang ingin Anda kemas (æT) dan tipe tujuan "
"(PackedT) sebagai parameter. Ini menyediakan dua fungsi untuk "
"mengimplementasikan:"

#: src/ch16-01-optimizing-storage-costs.md:99
msgid "Here is the implementation of the example of the previous chapter:"
msgstr "Berikut ini adalah implementasi dari contoh bab sebelumnya:"

#: src/ch16-01-optimizing-storage-costs.md:138
msgid "//don't forget to import it!\n"
msgstr "/Jangan lupa mengimpornya!\n"

#: src/ch16-01-optimizing-storage-costs.md:147
msgid ""
"// This will automatically pack the\n"
"        // struct into a single u128\n"
msgstr ""
"//Ini secara otomatis akan mengepak//struct menjadi sebuah u128 tunggal\n"

#: src/ch16-01-optimizing-storage-costs.md:155
msgid ""
"// this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
msgstr ""
"//ini secara otomatis akan membongkar//packed-representation ke dalam "
"struktur Ukuran\n"

#: src/ch16-01-optimizing-storage-costs.md:166
msgid "In this code snippet, you see that:"
msgstr "Dalam snippet kode ini, Anda lihat bahwa:"

#: src/ch16-01-optimizing-storage-costs.md:168
msgid ""
"`TWO_POW_8` and `TWO_POW_40` are used to shift left in the `pack` function "
"and shift right in the `unpack`function,"
msgstr ""
"TWOW_POW_8 dan TWO_POW_40 digunakan untuk bergeser ke kiri dalam fungsi "
"paket dan bergeser tepat di fungsi åunpack,"

#: src/ch16-01-optimizing-storage-costs.md:169
msgid ""
"`MASK_8` and `MASK_32` are used to isolate a variable in the `unpack` "
"function,"
msgstr "Dan digunakan untuk mengisolasi variabel dalam fungsi åunpacké,"

#: src/ch16-01-optimizing-storage-costs.md:170
msgid ""
"all the variables from the storage are converted to `u128` to be able to use"
" bitwise operators."
msgstr ""
"semua variabel dari penyimpanan dikonversi menjadi åu128 (128) untuk dapat "
"menggunakan operator bitwise."

#: src/ch16-01-optimizing-storage-costs.md:172
msgid ""
"This technique can be used for any group of fields that fit within the bit "
"size of the packed storage type. For example, if you have a struct with "
"multiple fields whose bit sizes add up to 256 bits, you can pack them into a"
" single `u256` variable. If the bit sizes add up to 512 bits, you can pack "
"them into a single `u512` variable, and so on. You can define your own "
"structs and logic to pack and unpack them."
msgstr ""
"Teknik ini dapat digunakan untuk setiap kelompok bidang yang sesuai dengan "
"ukuran bit dari jenis penyimpanan yang dikemas. Sebagai contoh, jika Anda "
"memiliki struktur dengan beberapa bidang yang ukuran bit menambahkan hingga "
"256 bit, Anda dapat mengemasnya menjadi variabel ·u256. Jika ukuran bit "
"ditambahkan menjadi 512 bit, Anda dapat mengemasnya menjadi variabel tunggal"
" ·u12 TM, dan seterusnya. Anda dapat mendefinisikan struktur dan logika Anda"
" sendiri untuk mengemasnya."

#: src/ch16-01-optimizing-storage-costs.md:174
msgid ""
"The rest of the work is done magically by the compiler - if a type "
"implements the `StorePacking` trait, then the compiler will know it can use "
"the `StoreUsingPacking` implementation of the `Store` trait in order to pack"
" before writing and unpack after reading from storage. One important detail,"
" however, is that the type that `StorePacking::pack` spits out also has to "
"implement `Store` for `StoreUsingPacking` to work. Most of the time, we will"
" want to pack into a felt252 or u256 - but if you want to pack into a type "
"of your own, make sure that this one implements the `Store` trait."
msgstr ""
"Sisanya dilakukan secara ajaib oleh kompiler - jika sebuah tipe menerapkan "
"sifat sebelum menulis dan membongkar setelah membaca dari penyimpanan."

#: src/ch16-02-00-composability-and-components.md:1
msgid "Components: Lego-Like Building Blocks for Smart Contracts"
msgstr "Komponen: Lego-Like Building Blocks for Smart Contracts"

#: src/ch16-02-00-composability-and-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and "
"bug-prone, as this logic can hardly be reused and needs to be reimplemented "
"in each contract. But what if there was a way to snap in just the extra "
"functionality you need inside your contract, separating the core logic of "
"your contract from the rest?"
msgstr ""
"Mengembangkan kontrak berbagi logika umum dan penyimpanan dapat menyakitkan "
"dan bug-prone, karena logika ini tidak dapat digunakan kembali dan perlu "
"diimplementasikan kembali dalam setiap kontrak. tapi bagaimana jika ada cara"
" untuk snap hanya fungsionalitas ekstra yang Anda butuhkan dalam kontrak "
"Anda, memisahkan logika inti dari kontrak Anda dari sisa?"

#: src/ch16-02-00-composability-and-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating "
"reusable logic, storage, and events that can be incorporated into multiple "
"contracts. They can be used to extend a contract's functionality, without "
"having to reimplement the same logic over and over again."
msgstr ""
"Komponen menyediakan persis seperti itu. mereka adalah tambahan modular-on "
"encapsulating logika, penyimpanan, dan peristiwa yang dapat dimasukkan ke "
"dalam beberapa kontrak. mereka dapat digunakan untuk memperpanjang fungsi "
"kontrak, tanpa harus mengimplementasikan logika yang sama lagi dan lagi."

#: src/ch16-02-00-composability-and-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts "
"by plugging in a module that you or someone else wrote. This module can be a"
" simple one, like an ownership component, or more complex like a full-"
"fledged ERC20 token."
msgstr ""
"Pikirkan komponen sebagai blok Lego. mereka memungkinkan Anda untuk "
"memperkaya kontrak Anda dengan memasang modul yang Anda atau orang lain "
"tulis. modul ini dapat menjadi sederhana, seperti komponen kepemilikan, atau"
" lebih kompleks seperti ERC20 token penuh."

#: src/ch16-02-00-composability-and-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and "
"functions. Unlike a contract, a component cannot be declared or deployed. "
"Its logic will eventually be part of the contract’s bytecode it has been "
"embedded in."
msgstr ""
"Komponen adalah modul terpisah yang dapat memuat penyimpanan, acara, dan "
"fungsi. tidak seperti sebuah kontrak, sebuah komponen tidak dapat "
"dideklarasikan atau digunakan. logikanya pada akhirnya akan menjadi bagian "
"dari kontrak bytecode telah tertanam di dalamnya."

#: src/ch16-02-00-composability-and-components.md:24
msgid "What's in a Component?"
msgstr "Apa yang ada di Komponen?"

#: src/ch16-02-00-composability-and-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr "Komponen sangat mirip dengan kontrak."

#: src/ch16-02-00-composability-and-components.md:28
msgid "Storage variables"
msgstr "Variabel penyimpanan"

#: src/ch16-02-00-composability-and-components.md:29
msgid "Events"
msgstr "Kejadian"

#: src/ch16-02-00-composability-and-components.md:30
msgid "External and internal functions"
msgstr "Fungsi eksternal dan internal"

#: src/ch16-02-00-composability-and-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The "
"component's code becomes part of the contract it's embedded to."
msgstr ""
"Tidak seperti kontrak, komponen tidak dapat dikerahkan sendiri. kode "
"komponen menjadi bagian dari kontrak itu tertanam ke."

#: src/ch16-02-00-composability-and-components.md:35
msgid "Creating Components"
msgstr "Membuat Komponen"

#: src/ch16-02-00-composability-and-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a "
"`#[starknet::component]` attribute. Within this module, you can declare a ` "
"Storage` struct and `Event` enum, as usually done in "
"[contracts](./ch13-02-anatomy-of-a-simple-contract.md)."
msgstr ""
"Untuk membuat suatu komponen, pertama definisikan dalam modulnya sendiri "
"dihiasi dengan sebuah enum;[starknet::komponen] atribut. Dalam modul ini, "
"Anda dapat menyatakan sebuah struktur dan ▪Eventá, seperti biasanya "
"dilakukan dalam [kontracts] 1961./ch13-02-anomi-a-simple-contract.m)."

#: src/ch16-02-00-composability-and-components.md:41
msgid ""
"The next step is to define the component interface, containing the "
"signatures of the functions that will allow external access to the "
"component's logic. You can define the interface of the component by "
"declaring a trait with the `#[starknet::interface]` attribute, just as you "
"would with contracts. This interface will be used to enable external access "
"to the component's functions using the [dispatcher](./ch15-02-contract-"
"dispatchers-library-dispatchers-and-system-calls.md) pattern."
msgstr ""
"Langkah berikutnya adalah mendefinisikan antarmuka komponen, berisi ciri-"
"ciri fungsi yang akan memungkinkan akses eksternal ke logika komponen. Anda "
"dapat menentukan antarmuka komponen dengan menyatakan suatu sifat dengan "
"atribut ▪[starknet::interface], seperti yang Anda inginkan. Antarmuka ini "
"akan digunakan untuk mengaktifkan akses eksternal ke fungsi komponen "
"menggunakan [distcher] sebelum atau atau distcher-contract-distchers-"
"dispacher-dischers-and-stem-calls.m) pola."

#: src/ch16-02-00-composability-and-components.md:48
msgid ""
"The actual implementation of the component's external logic is done in an "
"`impl` block marked as `#[embeddable_as(name)]`. Usually, this `impl` block "
"will be an implementation of the trait defining the interface of the "
"component."
msgstr ""
"In implementasi aktual dari logika eksternal komponen dilakukan dalam sebuah"
" blok ·implocla yang ditandai sebagai \"#[terbenturan_as Allahname)]. "
"Biasanya, blok Éimplo ini akan menjadi implementasi dari sifat yang "
"mendefinisikan antarmuka komponen."

#: src/ch16-02-00-composability-and-components.md:52
msgid ""
"Note: `name` is the name that we’ll be using in the contract to refer to the"
" component. It is different than the name of your impl."
msgstr ""
"Catatan: Nama yang akan kita gunakan dalam kontrak untuk mengacu pada "
"komponennya."

#: src/ch16-02-00-composability-and-components.md:55
msgid ""
"You can also define internal functions that will not be accessible "
"externally, by simply omitting the `#[embeddable_as(name)]` attribute above "
"the internal `impl` block. You will be able to use these internal functions "
"inside the contract you embed the component in, but not interact with it "
"from outside, as they're not a part of the abi of the contract."
msgstr ""
"Anda juga dapat mendefinisikan fungsi internal yang tidak dapat diakses "
"secara eksternal, dengan hanya menghilangkan fungsi internal di dalam "
"kontrak yang Anda embed atau berinteraksi dengan komponen di luar, karena "
"mereka bukan bagian dari abi kontrak."

#: src/ch16-02-00-composability-and-components.md:61
msgid ""
"Functions within these `impl` block expect arguments like `ref self: "
"ComponentState<TContractState>` (for state-modifying functions) or `self: "
"@ComponentState<TContractState>` (for view functions). This makes the impl "
"generic over `TContractState`, allowing us to use this component in any "
"contract."
msgstr ""
"Fungsi-fungsi dalam blok ini mengharap argumen seperti 'componentstate': "
"Componentstate<TContract>) (untuk fungsi modifikasi negara) atau diri "
"sendiri: @CompentState<TContractate> (untuk fungsi tili). Hal ini membuat "
"impl generik lebih dari ÉTContractSateía, memungkinkan kita untuk "
"menggunakan komponen ini dalam kontrak apapun."

#: src/ch16-02-00-composability-and-components.md:70
msgid "Example: an Ownable Component"
msgstr "Contoh: Komponen yang Dapat Dimiliki"

#: src/ch16-02-00-composability-and-components.md:72
msgid ""
"⚠️ The example shown below has not been audited and is not intended for "
"production use. The authors are not responsible for any damages caused by "
"the use of this code."
msgstr ""
"▪ Contoh yang diperlihatkan di bawah ini belum diaudit dan tidak ditujukan "
"untuk penggunaan produksi. Penulis tidak bertanggung jawab atas kerusakan "
"apa pun yang disebabkan oleh penggunaan kode ini."

#: src/ch16-02-00-composability-and-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available "
"externally to manage ownership of a contract, would look like this:"
msgstr ""
"Antarmuka komponen yang dapat dimiliki, mendefinisikan metode yang tersedia "
"secara eksternal untuk mengelola kepemilikan kontrak, akan terlihat seperti "
"ini:"

#: src/ch16-02-00-composability-and-components.md:88
msgid "The component itself is defined as:"
msgstr "Komponen itu sendiri didefinisikan sebagai:"

#: src/ch16-02-00-composability-and-components.md:166
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The "
"only differences relate to the `#[embeddable_as]` attribute above the impl "
"and the genericity of the impl block that we will dissect in details."
msgstr ""
"Sintaks ini sebenarnya cukup mirip dengan sintaks yang digunakan untuk "
"kontrak. Perbedaan-perbedaan hanya berhubungan dengan yang "
"\"#[terbengkak_as]_as] atribut di atas impl dan generik dari blok impl yang "
"akan kita bedah secara detail."

#: src/ch16-02-00-composability-and-components.md:170
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to "
"the implementation of the interface trait, and one containing methods that "
"should not be exposed externally and are only meant for internal use. "
"Exposing the `assert_only_owner` as part of the interface wouldn't make "
"sense, as it's only meant to be used internally by a contract embedding the "
"component."
msgstr ""
"Seperti yang dapat Anda lihat, komponen kami memiliki dua blok ·implplo: "
"satu yang berhubungan dengan implementasi dari sifat antarmuka, dan satu "
"metode yang mengandung yang tidak boleh terekspos secara eksternal dan hanya"
" untuk penggunaan internal. Mengeksposisert_only_ownerà sebagai bagian dari "
"antarmuka tidak akan masuk akal, karena itu hanya dimaksudkan untuk "
"digunakan secara internal oleh kontrak yang menggabungkan komponen."

#: src/ch16-02-00-composability-and-components.md:176
msgid "A Closer Look at the `impl` Block"
msgstr "A Closer Look at the éimplin Block"

#: src/ch16-02-00-composability-and-components.md:185
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable "
"inside a contract. It allows us to specify the name of the impl that will be"
" used in the contract to refer to this component. In this case, the "
"component will be referred to as `Ownable` in contracts embedding it."
msgstr ""
"Atribut yang dapat dibenamkan ini digunakan untuk menandai impl sebagai "
"dapat dibenamkan dalam sebuah kontrak. Hal ini memungkinkan kita untuk "
"menentukan nama impl yang akan digunakan dalam kontrak untuk mengacu ke "
"komponen ini. Dalam hal ini, komponen akan disebut sebagai enembedding "
"kontrak."

#: src/ch16-02-00-composability-and-components.md:190
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, "
"with the added restriction that `TContractState` must implement the "
"`HasComponent<T>` trait. This allows us to use the component in any "
"contract, as long as the contract implements the `HasComponent` trait. "
"Understanding this mechanism in details is not required to use components, "
"but if you're curious about the inner workings, you can read more in the "
"[\"Components Under the Hood\"](./ch16-02-01-under-the-hood.md) section."
msgstr ""
"In implementasi itu sendiri adalah generik daripada "
"komponenstate<TContractstate>, dengan tambahan pembatasan yang kontraksi. "
"Memahami mekanisme ini dalam rincian tidak diperlukan untuk menggunakan "
"komponen, tetapi jika Anda ingin tahu tentang pekerjaan dalam tubuh, Anda "
"dapat membaca lebih banyak dalam \"Compents Under the "
"Hood\".HasCompponent.16-thehood-underhood."

#: src/ch16-02-00-composability-and-components.md:197
msgid ""
"One of the major differences from a regular smart contract is that access to"
" storage and events is done via the generic `ComponentState<TContractState>`"
" type and not `ContractState`. Note that while the type is different, "
"accessing storage or emitting events is done similarly via "
"`self.storage_var_name.read()` or `self.emit(...).`"
msgstr ""
"Salah satu perbedaan besar dari kontrak cerdas yang biasa adalah akses ke "
"penyimpanan dan acara dilakukan melalui umum ▪ Komponentstate<TContract> "
"tipe dan bukan tipe ÁContractState. Perhatikan bahwa ketika jenis ini "
"berbeda, mengakses penyimpanan atau memancarkan peristiwa dilakukan dengan "
"cara yang sama melalui sendiri.storage_var_name) atau Áselfselfself...)."

#: src/ch16-02-00-composability-and-components.md:203
msgid ""
"Note: To avoid the confusion between the embeddable name and the impl name, "
"we recommend keeping the suffix `Impl` in the impl name."
msgstr ""
"Catatan: Untuk menghindari kebingungan antara nama lampiran dan nama impl, "
"kami merekomendasikan agar nama akhiran tersebut tetap ada dalam nama impl."

#: src/ch16-02-00-composability-and-components.md:208
msgid "Migrating a Contract to a Component"
msgstr "Memisahkan Kontrak dengan Komponen"

#: src/ch16-02-00-composability-and-components.md:210
msgid ""
"Since both contracts and components share a lot of similarities, it's "
"actually very easy to migrate from a contract to a component. The only "
"changes required are:"
msgstr ""
"Karena kedua kontrak dan komponen berbagi banyak kesamaan, sebenarnya sangat"
" mudah untuk bermigrasi dari kontrak ke komponen. satu-satunya perubahan "
"yang diperlukan adalah:"

#: src/ch16-02-00-composability-and-components.md:214
msgid "Adding the `#[starknet::component]` attribute to the module."
msgstr "Menambahkan atribut å#[Starknet::component]å ke modul."

#: src/ch16-02-00-composability-and-components.md:215
msgid ""
"Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will "
"be embedded in another contract."
msgstr "Menambahkan aktiviti pada blok yang akan tertanam dalam kontrak lain."

#: src/ch16-02-00-composability-and-components.md:217
msgid "Adding generic parameters to the `impl` block:"
msgstr "Menambahkan parameter generik ke blok æimplo:"

#: src/ch16-02-00-composability-and-components.md:218
msgid "Adding `TContractState` as a generic parameter."
msgstr "Menambahkan 'TContractState' sebagai parameter umum."

#: src/ch16-02-00-composability-and-components.md:219
msgid "Adding `+HasComponent<TContractState>` as an impl restriction."
msgstr "Menambahkan <TContractState> sebagai pembatasan impl."

#: src/ch16-02-00-composability-and-components.md:220
msgid ""
"Changing the type of the `self` argument in the functions inside the `impl` "
"block to `ComponentState<TContractState>` instead of `ContractState`."
msgstr ""
"Mengubah tipe argumen diri sendiri dalam fungsi di dalam blok ıimploclate "
"menjadi komponenstate<TContract> bukan ContractState (kontrate)."

#: src/ch16-02-00-composability-and-components.md:223
msgid ""
"For traits that do not have an explicit definition and are generated using "
"`#[generate_trait]`, the logic is the same - but the trait is generic over "
"`TContractState` instead of `ComponentState<TContractState>`, as "
"demonstrated in the example with the `InternalTrait`."
msgstr ""
"Untuk sifat-sifat yang tidak memiliki definisi eksplisit dan dihasilkan "
"menggunakan "
"\\\\fnCandara\\fs55\\b1\\4cH000000\\4aH80}koresponponent<TContractate>"

#: src/ch16-02-00-composability-and-components.md:228
msgid "Using Components Inside a Contract"
msgstr "Menggunakan Komponen di Dalam Kontrak"

#: src/ch16-02-00-composability-and-components.md:230
msgid ""
"The major strength of components is how it allows reusing already built "
"primitives inside your contracts with a restricted amount of boilerplate. To"
" integrate a component into your contract, you need to:"
msgstr ""
"Kekuatan utama komponen adalah bagaimana hal itu memungkinkan penggunaan "
"kembali primitif dalam kontrak Anda dengan sejumlah terbatas boilerplate. "
"untuk mengintegrasikan komponen ke dalam kontrak Anda, Anda perlu:"

#: src/ch16-02-00-composability-and-components.md:234
msgid "Declare it with the `component!()` macro, specifying"
msgstr "Nyatakan dengan komponen! macro, spesifikasikan"

#: src/ch16-02-00-composability-and-components.md:236
msgid "The path to the component `path::to::component`."
msgstr "Jalan menuju jalan komponen::: Komponen."

#: src/ch16-02-00-composability-and-components.md:237
msgid ""
"The name of the variable in your contract's storage referring to this "
"component's storage (e.g. `ownable`)."
msgstr ""
"Nama variabel penyimpanan kontrakmu yang mengacu pada penyimpanan komponen "
"ini (misalnya dimiliki)."

#: src/ch16-02-00-composability-and-components.md:239
msgid ""
"The name of the variant in your contract's event enum referring to this "
"component's events (e.g. `OwnableEvent`)."
msgstr ""
"Nama varian dari acara kontrak Anda yang mengacu pada peristiwa komponen ini"
" (mis. OwnableEvent)."

#: src/ch16-02-00-composability-and-components.md:242
msgid ""
"Add the path to the component's storage and events to the contract's "
"`Storage` and `Event`. They must match the names provided in step 1 (e.g. "
"`ownable: ownable_component::Storage` and `OwnableEvent: "
"ownable_component::Event`)."
msgstr ""
"Tambahkan jalan ke penyimpanan dan kejadian komponen ke penyimpanan kontrak."
" ke tempat penyimpanan kontrak dan event (Event). Mereka harus mencocokkan "
"nama-nama yang disediakan dalam langkah 1 (mis): dapat "
"dimiliki_component:::Storage dan ▪OwnableEvent: ownable_component::Event)."

#: src/ch16-02-00-composability-and-components.md:247
msgid ""
"The storage variable **MUST** be annotated with the `#[substorage(v0)]` "
"attribute."
msgstr "Variabel penyimpanan (*MUST** akan dienotasi dengan atribut."

#: src/ch16-02-00-composability-and-components.md:250
msgid ""
"Embed the component's logic defined inside your contract, by instantiating "
"the component's generic impl with a concrete `ContractState` using an impl "
"alias. This alias must be annotated with `#[abi(embed_v0)]` to externally "
"expose the component's functions."
msgstr ""
"Tempelkan logika komponen yang didefinisikan di dalam kontrak Anda, dengan "
"mempercepat impl generik komponen dengan concrete conct contractState "
"menggunakan alias impl. Alias ini harus dienotasi dengan \"#[abi[embed_v0) "
"to eksternal mengekspos fungsi komponen."

#: src/ch16-02-00-composability-and-components.md:255
msgid ""
"As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`. "
"Indeed, we don't want to expose externally the functions defined in this "
"impl. However, we might still want to access them internally."
msgstr ""
"Seperti yang dapat Anda lihat, InternalImpl tidak ditandai dengan ml ini. "
"Namun, kita mungkin masih ingin mengaksesnya secara internal."

#: src/ch16-02-00-composability-and-components.md:259
msgid ""
"For example, to embed the `Ownable` component defined above, we would do the"
" following:"
msgstr ""
"Sebagai contoh, untuk menanamkan komponen yang dapat didefinisikan di atas, "
"kami akan melakukan hal berikut:"

#: src/ch16-02-00-composability-and-components.md:297
msgid ""
"The component's logic is now seamlessly part of the contract! We can "
"interact with the components functions externally by calling them using the "
"`IOwnableDispatcher` instantiated with the contract's address."
msgstr ""
"Kita dapat berinteraksi dengan komponen berfungsi secara eksternal dengan "
"memanggil mereka menggunakan Dispatcher yang dapat dipecahkan seketika "
"dengan alamat kontrak."

#: src/ch16-02-00-composability-and-components.md:310
msgid "Stacking Components for Maximum Composability"
msgstr "Komponen Stacking untuk Komposabilitas Maksimum"

#: src/ch16-02-00-composability-and-components.md:312
msgid ""
"The composability of components really shines when combining multiple of "
"them together. Each adds its features onto the contract. You can rely on "
"[Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) "
"implementation of components to quickly plug-in all the common "
"functionalities you need a contract to have."
msgstr ""
"Komponen-komponen ini benar-benar bersinar ketika menggabungkan beberapa "
"komponen itu bersama-sama. Masing-masing menambahkan fiturnya ke dalam "
"kontrak. Anda dapat mengandalkan [Penyesalan] kebiasaan yang Anda butuhkan "
"kontrak."

#: src/ch16-02-00-composability-and-components.md:318
msgid ""
"Developers can focus on their core contract logic while relying on battle-"
"tested and audited components for everything else."
msgstr ""
"Pengembang dapat berfokus pada logika kontrak inti mereka sambil "
"mengandalkan komponen yang diuji pertempuran dan diaudit untuk segala "
"sesuatu yang lain."

#: src/ch16-02-00-composability-and-components.md:321
msgid ""
"Components can even [depend](./ch16-02-02-component-dependencies.md) on "
"other components by restricting the `TContractstate` they're generic on to "
"implement the trait of another component. Before we dive into this "
"mechanism, let's first look at [how components work under the "
"hood](./ch16-02-01-under-the-hood.md)."
msgstr ""
"Komponen bahkan dapat [depentasi][./ch16-02-02-kompondensi-komponen.md) pada"
" komponen-komponen lain dengan membatasi ÉTContractstateå mereka generik "
"untuk menerapkan sifat komponen lain. Sebelum kita menyelam ke dalam "
"mekanisme ini, mari kita lihat dulu [bagaimana komponen bekerja di bawah "
"kapiler]./ch16-02-under-the-the-hood)."

#: src/ch16-02-01-under-the-hood.md:1
msgid "Components: Under the Hood"
msgstr "Komponen: Di Bawah Tudung"

#: src/ch16-02-01-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to Starknet contracts. But how does "
"this magic actually happen behind the scenes?"
msgstr "Komponen memberikan modularitas kuat untuk kontrak Starknet."

#: src/ch16-02-01-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the "
"mechanisms that enable component composability."
msgstr ""
"Bab ini akan menyelam jauh ke dalam internal kompiler untuk menjelaskan "
"mekanisme yang memungkinkan komposabilitas komponen."

#: src/ch16-02-01-under-the-hood.md:9
msgid "A Primer on Embeddable Impls"
msgstr "A Perdana pada Impls Dapat Dibenamkan"

#: src/ch16-02-01-under-the-hood.md:11
msgid ""
"Before digging into components, we need to understand _embeddable impls_."
msgstr ""
"Sebelum menggali komponen, kita perlu memahami impls_ yang dapat dibenamkan."

#: src/ch16-02-01-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`)"
" can be made embeddable. Embeddable impls can be injected into any contract,"
" adding new entry points and modifying the ABI of the contract."
msgstr ""
"Sebuah impl dari sifat interface Starknet (ditandai dengan "
"▪#[starknet::interface]) dapat dibuat dapat dibenamkan. dapat dibenamkan "
"impls dapat disuntikkan ke dalam kontrak apapun, menambahkan titik masukan "
"baru dan memodifikasi ABI dari kontrak."

#: src/ch16-02-01-under-the-hood.md:17
msgid "Let's look at an example to see this in action:"
msgstr "Mari kita lihat contoh untuk melihat hal ini dalam tindakan:"

#: src/ch16-02-01-under-the-hood.md:42
msgid ""
"By embedding `SimpleImpl`, we externally expose `ret4` in the contract's "
"ABI."
msgstr ""
"Dengan menanamkannya, kita akan mengeksposnya secara eksternal dalam kontrak"
" ABI."

#: src/ch16-02-01-under-the-hood.md:44
msgid ""
"Now that we’re more familiar with the embedding mechanism, we can now see "
"how components build on this."
msgstr ""
"Sekarang kita lebih akrab dengan mekanisme embedding, kita sekarang dapat "
"melihat bagaimana komponen membangun ini."

#: src/ch16-02-01-under-the-hood.md:47
msgid "Inside Components: Generic Impls"
msgstr "Komponen Dalam: Impl Generik"

#: src/ch16-02-01-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr "Ingat sintaks blok impl yang digunakan dalam komponen:"

#: src/ch16-02-01-under-the-hood.md:58
msgid "The key points:"
msgstr "Titik kuncinya:"

#: src/ch16-02-01-under-the-hood.md:60
msgid ""
"`OwnableImpl` requires the implementation of the "
"`HasComponent<TContractState>` trait by the underlying contract, which is "
"automatically generated with the `component!()` macro when using a component"
" inside a contract."
msgstr ""
"\"OwnableImplpl\" memerlukan implementasi dari "
"\"HassCompponent<TContractState>\" yang secara otomatis dihasilkan dengan "
"makro \"component\" ketika menggunakan komponen dalam kontrak."

#: src/ch16-02-01-under-the-hood.md:65
msgid ""
"The compiler will generate an impl that wraps any function in `OwnableImpl`,"
" replacing the `self: ComponentState<TContractState>` argument with `self: "
"TContractState`, where access to the component state is made via the "
"`get_component` function in the `HasComponent<TContractState>` trait."
msgstr ""
"The compiler will menghasilkan impl yang membungkus setiap fungsi dalam "
"·OwnableImplplpl, menggantikan dirinya: ComponentState<TContractState> "
"dengan dirinya sendiri: TContractstate, dimana akses ke negara komponen "
"dibuat melalui fungsi komponent_component<Contractate> sifat."

#: src/ch16-02-01-under-the-hood.md:70
msgid ""
"For each component, the compiler generates a `HasComponent` trait. This "
"trait defines the interface to bridge between the actual `TContractState` of"
" a generic contract, and `ComponentState<TContractState>`."
msgstr ""
"Untuk setiap komponen, kompiler menghasilkan sebuah sifat. Sifat ini "
"mendefinisikan antarmuka untuk menjembatani antarkonstrate yang sebenarnya "
"dari sebuah kontrak umum, dan komponentate<TContractState>."

#: src/ch16-02-01-under-the-hood.md:75
msgid "// generated per component\n"
msgstr "//dihasilkan per komponen\n"

#: src/ch16-02-01-under-the-hood.md:85
msgid ""
"In our context `ComponentState<TContractState>` is a type specific to the "
"ownable component, i.e. it has members based on the storage variables "
"defined in `ownable_component::Storage`. Moving from the generic "
"`TContractState` to `ComponentState<TContractState>` will allow us to embed "
"`Ownable` in any contract that wants to use it. The opposite direction "
"(`ComponentState<TContractState>` to `ContractState`) is useful for "
"dependencies (see the `Upgradeable` component depending on an `IOwnable` "
"implementation example in the [Components dependencies "
"](./ch16-02-02-component-dependencies.md) section)."
msgstr ""
"Dalam konteks kami, anggota-anggota yang didasarkan pada variabel "
"penyimpanan yang dapat dimiliki oleh<TContractState> adalah tipe spesifik "
"untuk komponen yang dapat dimiliki, misalnya. Ia memiliki anggota-anggota "
"yang didasarkan pada variabel penyimpanan yang dapat dimiliki: Komponen. "
"Pindah dari product umum (Kontraktate <ConponentState> ke <Kontract> untuk "
"bergantung pada komponen yang dapat diembangkan (memperankan ánabel dalam "
"setiap kontrak yang ingin menggunakannya."

#: src/ch16-02-01-under-the-hood.md:94
msgid ""
"To put it briefly, one should think of an implementation of the above "
"`HasComponent<T>` as saying: **“Contract whose state T has the upgradeable "
"component”.**"
msgstr ""
"Untuk mengatakannya secara singkat, seseorang harus memikirkan implementasi "
"dari di atas <T> sebagaimana dikatakan: ** Kontract yang negara bagian T "
"memiliki komponen yang dapat diupgrade.**"

#: src/ch16-02-01-under-the-hood.md:98
msgid "`Ownable` is annotated with the `embeddable_as(<name>)` attribute:"
msgstr "Anote dengan atribut yang dapat dibenturkan_as○<name>):"

#: src/ch16-02-01-under-the-hood.md:100
msgid ""
"`embeddable_as` is similar to `embeddable`; it only applies to impls of "
"`starknet::interface` traits and allows embedding this impl in a contract "
"module. That said, `embeddable_as(<name>)` has another role in the context "
"of components. Eventually, when embedding `OwnableImpl` in some contract, we"
" expect to get an impl with the following functions:"
msgstr ""
"Ini hanya berlaku untuk impls dari Ástarknet::interface muffile dan "
"memungkinkan embedding ini impl dalam modul kontrak. Yang mengatakan, "
"·embedable_as Allahume>) hanya memiliki peran lain dalam konteks komponen. "
"Akhirnya, ketika embedding ·OwableImpplum dalam beberapa kontrak, kami "
"berharap untuk mendapatkan sebuah impl dengan fungsi berikut:"

#: src/ch16-02-01-under-the-hood.md:112
msgid ""
"Note that while starting with a function receiving the generic type "
"`ComponentState<TContractState>`, we want to end up with a function "
"receiving `ContractState`. This is where `embeddable_as(<name>)` comes in. "
"To see the full picture, we need to see what is the impl generated by the "
"compiler due to the `embeddable_as(Ownable)` annotation:"
msgstr ""
"Perhatikan bahwa ketika dimulai dengan sebuah fungsi menerima jenis generik."
" Ini adalah di mana 'CombuntState<name>' datang. Untuk melihat gambaran "
"lengkap, kita perlu melihat apa yang impl yang dihasilkan oleh kompiler "
"karena embedable_progenable_otifable) annotasi:"

#: src/ch16-02-01-under-the-hood.md:140
msgid ""
"Note that thanks to having an impl of `HasComponent<TContractState>`, the "
"compiler was able to wrap our functions in a new impl that doesn’t directly "
"know about the `ComponentState` type. `Ownable`, whose name we chose when "
"writing `embeddable_as(Ownable)`, is the impl that we will embed in a "
"contract that wants ownership."
msgstr ""
"Perhatikan bahwa terima kasih untuk memiliki impl baru yang tidak langsung "
"tahu tentang tipe COponent<TContractState>, yang namanya kita pilih ketika "
"menulis Éembedtable_asánable), adalah impl yang akan kita masukkan ke dalam "
"kontrak yang ingin dimiliki."

#: src/ch16-02-01-under-the-hood.md:146
msgid "Contract Integration"
msgstr "Integrasi Kontrak"

#: src/ch16-02-01-under-the-hood.md:148
msgid ""
"We've seen how generic impls enable component reusability. Next let's see "
"how a contract integrates a component."
msgstr ""
"Selanjutnya mari kita lihat bagaimana kontrak mengintegrasikan komponen."

#: src/ch16-02-01-under-the-hood.md:151
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic "
"impl with the concrete `ContractState` of the contract."
msgstr ""
"Kontrak menggunakan **impl alias** untuk mempercepat impl generik komponen "
"dengan beton contractState_BAR_ dari kontrak."

#: src/ch16-02-01-under-the-hood.md:161
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl "
"alias syntax. We’re instantiating the generic `OwnableImpl<TContractState>` "
"with the concrete type `ContractState`. Recall that "
"`OwnableImpl<TContractState>` has the `HasComponent<TContractState>` generic"
" impl parameter. An implementation of this trait is generated by the "
"`component!` macro."
msgstr ""
"Garis-garis di atas menggunakan mekanisme pemasangan Cairo bersamaan dengan "
"sintaks impl alias. Kami langsung menggunakan generic "
"<TContractIplp<TContractState> dengan tipe beton <Contractstate. Sebuah "
"implmeter yang dihasilkan oleh makro!"

#: src/ch16-02-01-under-the-hood.md:167
msgid ""
"Note that only the using contract could have implemented this trait since "
"only it knows about both the contract state and the component state."
msgstr ""
"Perhatikan bahwa hanya menggunakan kontrak yang dapat menerapkan sifat ini "
"karena hanya dia yang tahu tentang keadaan kontrak dan kondisi komponen."

#: src/ch16-02-01-under-the-hood.md:171
msgid ""
"This glues everything together to inject the component logic into the "
"contract."
msgstr ""
"Ini lem semuanya bersama-sama untuk menyuntikkan logika komponen ke dalam "
"kontrak."

#: src/ch16-02-01-under-the-hood.md:173
msgid "Key Takeaways"
msgstr "Takeaway Kunci"

#: src/ch16-02-01-under-the-hood.md:175
msgid ""
"Embeddable impls allow injecting components logic into contracts by adding "
"entry points and modifying the contract ABI."
msgstr ""
"Terbenamkan impls memungkinkan menyuntikkan komponen logika ke dalam kontrak"
" dengan menambahkan titik masuk dan memodifikasi kontrak ABI."

#: src/ch16-02-01-under-the-hood.md:177
msgid ""
"The compiler automatically generates a `HasComponent` trait implementation "
"when a component is used in a contract. This creates a bridge between the "
"contract's state and the component's state, enabling interaction between the"
" two."
msgstr ""
"Secara otomatis, kompiler secara otomatis menghasilkan sebuah implementasi "
"sifat åSCoponenté ketika sebuah komponen digunakan dalam sebuah kontrak. Hal"
" ini menciptakan sebuah jembatan antara negara kontrak dan negara komponen, "
"memungkinkan interaksi antara keduanya."

#: src/ch16-02-01-under-the-hood.md:181
msgid ""
"Components encapsulate reusable logic in a generic, contract-agnostic way. "
"Contracts integrate components through impl aliases and access them via the "
"generated `HasComponent` trait."
msgstr ""
"Komponen merangkumkan logika yang dapat digunakan ulang dengan cara yang "
"generik, agnostik kontrak. Kontrak mengintegrasikan komponen melalui alias "
"impl dan mengaksesnya melalui sifat yang dihasilkan."

#: src/ch16-02-01-under-the-hood.md:184
msgid ""
"Components build on embeddable impls by defining generic component logic "
"that can be integrated into any contract wanting to use that component. Impl"
" aliases instantiate these generic impls with the contract's concrete "
"storage types."
msgstr ""
"Komponen membangun pada impls yang dapat dibenamkan dengan mendefinisikan "
"logika komponen generik yang dapat diintegrasikan ke dalam kontrak apapun "
"yang ingin menggunakan komponen tersebut. Nama alias Implate instantate ini "
"impls generik dengan tipe penyimpanan konkrit kontrak."

#: src/ch16-02-02-component-dependencies.md:3
msgid ""
"Working with components becomes more complex when we try to use one "
"component inside another. As mentioned earlier, a component can only be "
"embedded within a contract, meaning that it's not possible to embed a "
"component within another component. However, this doesn't mean that we can't"
" use one component inside another. In this section, we will see how to use a"
" component as a dependency of another component."
msgstr ""
"Bekerja dengan komponen menjadi lebih kompleks ketika kita mencoba "
"menggunakan satu komponen di dalam komponen lain. sebagaimana disebutkan "
"sebelumnya, sebuah komponen hanya dapat tertanam dalam sebuah kontrak, "
"berarti tidak mungkin untuk menanamkan komponen dalam komponen lain. namun, "
"ini tidak berarti bahwa kita tidak dapat menggunakan satu komponen di dalam "
"komponen lain. di bagian ini, kita akan melihat bagaimana menggunakan "
"komponen sebagai ketergantungan dari komponen lain."

#: src/ch16-02-02-component-dependencies.md:5
msgid ""
"Consider a component called `OwnableCounter` whose purpose is to create a "
"counter that can only be incremented by its owner. This component can be "
"embedded in any contract, so that any contract that uses it will have a "
"counter that can only be incremented by its owner."
msgstr ""
"Pertimbangkan sebuah komponen yang disebut \"OwnableCounter\" yang bertujuan"
" untuk membuat penghitung yang hanya dapat ditingkatkan oleh pemiliknya. "
"Komponen ini dapat tertanam dalam kontrak apapun, sehingga setiap kontrak "
"yang digunakan akan memiliki counter yang hanya dapat diinkrementasi oleh "
"pemiliknya."

#: src/ch16-02-02-component-dependencies.md:7
msgid ""
"The first way to implement this is to create a single component that "
"contains both counter and ownership features from within a single component."
" However, this approach is not recommended: our goal is to minimize the "
"amount of code duplication and take advantage of component reusability. "
"Instead, we can create a new component that _depends_ on the `Ownable` "
"component for the ownership features, and internally defines the logic for "
"the counter."
msgstr ""
"Cara pertama untuk mengimplementasikan hal ini adalah dengan membuat "
"komponen tunggal yang berisi counter dan fitur kepemilikan dari dalam satu "
"komponen. Namun, pendekatan ini tidak disarankan: tujuan kita adalah untuk "
"meminimalisir jumlah duplikasi kode dan mengambil keuntungan dari fungsi "
"komponen. Sebaliknya, kita dapat membuat komponen baru yang _depends_ pada "
"komponen yang dapat ditulis untuk fitur kepemilikan, dan secara internal "
"mendefinisikan logika untuk counter."

#: src/ch16-02-02-component-dependencies.md:9
msgid ""
"Listing 16-1 shows the complete implementation, which we'll break down right"
" after:"
msgstr ""
"Daftar 16-1 menunjukkan implementasi lengkap, yang akan kita rusak tepat "
"setelah:"

#: src/ch16-02-02-component-dependencies.md:58
msgid "<span class=\"caption\">Listing 16-1: An OwnableCounter Component</span>"
msgstr "<span class=\"caption\">Listing 16-1: An OwnableCounter Component</span>"

#: src/ch16-02-02-component-dependencies.md:60
msgid "Specificities"
msgstr "Spesifik"

#: src/ch16-02-02-component-dependencies.md:62
msgid "Specifying Dependencies on Another Component"
msgstr "Menentukan Ketergantungan pada Komponen Lain"

#: src/ch16-02-02-component-dependencies.md:73
msgid ""
"In [chapter 8](./ch08-02-traits-in-cairo.md), we introduced trait bounds, "
"which are used to specify that a generic type must implement a certain "
"trait. In the same way, we can specify that a component depends on another "
"component by restricting the `impl` block to be available only for contracts"
" that contain the required component. In our case, this is done by adding a "
"restriction `impl Owner: ownable_component::HasComponent<TContractState>`, "
"which indicates that this `impl` block is only available for contracts that "
"contain an implementation of the `ownable_component::HasComponent` trait. "
"This essentially means that the \\`TContractState' type has access to the "
"ownable component. See [Components under the hood](ch16-02-01-under-the-"
"hood.md#inside-components-generic-impls) for more information."
msgstr ""
"Di [chapter 8]./ch08-02-traits-in-cairo.md), kami memperkenalkan batasan-"
"batasan sifat, yang digunakan untuk menyatakan bahwa tipe generik harus "
"mengimplementasikan suatu sifat tertentu. Dengan cara yang sama, kita dapat "
"menentukan bahwa sebuah komponen tergantung pada komponen lain dengan "
"membatasi blok thoseimploplate>, yang hanya tersedia untuk kontrak yang "
"diperlukan. Dalam kasus kita, ini dilakukan dengan menambahkan sebuah "
"batasan yang dapat diterapkan oleh provider thoseimppl: "
"ownable_component:Hasponent<TractSate>, yang mengindikasikan bahwa auxmpl "
"yang tersedia hanya untuk kontrak yang tersedia untuk implementasi yang "
"diterapkan oleh individual:Haconponent-concent-comctponent."

#: src/ch16-02-02-component-dependencies.md:76
msgid ""
"Although most of the trait bounds were defined using \\[anonymous "
"parameters\\]\\[anonymous generic impl operator\\], the dependency on the "
"`Ownable` component is defined using a named parameter (here, `Owner`). We "
"will need to use this explicit name when accessing the `Ownable`component "
"within the`impl` block."
msgstr ""
"Meskipun sebagian besar batas sifat didefinisikan menggunakan \\ "
"\\\\]\\[anonim umum operator impl\\], dependensi pada komponen dapat "
"didefinisikan menggunakan sebuah parameter bernama (di sini, ownerà). Kita "
"harus menggunakan nama eksplisit ini ketika mengakses komponen dalam blok "
"▪implopla."

#: src/ch16-02-02-component-dependencies.md:78
msgid ""
"While this mechanism is verbose and may not be easy to approach at first, it"
" is a powerful leverage of the trait system in Cairo. The inner workings of "
"this mechanism are abstracted away from the user, and all you need to know "
"is that when you embed a component in a contract, all other components in "
"the same contract can access it."
msgstr ""
"Sementara mekanisme ini adalah verbose dan mungkin tidak mudah untuk "
"pendekatan pada awalnya, itu adalah pengaruh kuat sistem sifat di Cairo. "
"Cara kerja dalam mekanisme ini abstrak jauh dari pengguna, dan semua yang "
"Anda perlu tahu adalah bahwa ketika Anda menanamkan komponen dalam sebuah "
"kontrak, semua komponen lain dalam kontrak yang sama dapat mengaksesnya."

#: src/ch16-02-02-component-dependencies.md:82
msgid ""
"\\[anonymous generic impl operator\\]: ./ch08-01-generic-data-types "
"md#anonymous-generic-implementation-parameter--operator"
msgstr ""
"\\[ononim umum impl operator\\]:./ch08-01-generic-data-types md#anonymous-"
"generic-implementation-parameter--operator"

#: src/ch16-02-02-component-dependencies.md:84
msgid "Using the Dependency"
msgstr "Menggunakan Ketergantungan"

#: src/ch16-02-02-component-dependencies.md:86
msgid ""
"Now that we have made our `impl` depend on the `Ownable` component, we can "
"access its functions, storage, and events within the implementation block. "
"To bring the `Ownable` component into scope, we have two choices, depending "
"on whether we intend to mutate the state of the `Ownable` component or not. "
"If we want to access the state of the `Ownable` component without mutating "
"it, we use the `get_dep_component!` macro. If we want to mutate the state of"
" the `Ownable` component (for example, change the current owner), we use the"
" `get_dep_component_mut!` macro. Both macros take two arguments: the first "
"is `self`, either as a snapshot or by reference depending on mutability, "
"representing the state of the component using the dependency, and the second"
" is the component to access."
msgstr ""
"Sekarang kita telah membuat komponen kita bergantung pada komponen "
"åOwnableé, kita dapat mengakses fungsinya, penyimpanan, dan kejadian dalam "
"blok implementasi. untuk membawa komponen yang dapat diubah menjadi lingkup,"
" kita memiliki dua pilihan, tergantung pada apakah kita berniat untuk "
"mengubah keadaan komponen yang dapat diubah atau tidak. Jika kita ingin "
"mengakses keadaan atau tidak."

#: src/ch16-02-02-component-dependencies.md:98
msgid ""
"In this function, we want to make sure that only the owner can call the "
"`increment` function. We need to use the `assert_only_owner` function from "
"the `Ownable` component. We'll use the `get_dep_component!` macro which will"
" return a snapshot of the requested component state, and call "
"`assert_only_owner` on it, as a method of that component."
msgstr ""
"Dalam fungsi ini, kami ingin memastikan bahwa hanya pemilik yang dapat "
"dihubungi. kami akan menggunakan komponen yang dapat digunakan untuk kompen!"
" makro yang akan mengembalikan foto-foto dari negara komponen yang diminta, "
"dan memanggil salat_only_owner_owner di atasnya, sebagai metode komponen "
"tersebut."

#: src/ch16-02-02-component-dependencies.md:101
msgid ""
"For the `transfer_ownership` function, we want to mutate that state to "
"change the current owner. We need to use the `get_dep_component_mut!` macro,"
" which will return the requested component state as a mutable reference, and"
" call `transfer_ownership` on it."
msgstr ""
"Untuk fungsi transfer_owneré, kami ingin mengubah negara bagian tersebut "
"untuk mengubah pemilik saat ini. kita perlu menggunakan fungsi 'dep' "
"komponent_mut'mut! makro, yang akan mengembalikan komponen negara yang "
"diminta sebagai referensi mutabel, dan memanggil 'transfer_ownership' di "
"atasnya."

#: src/ch16-02-02-component-dependencies.md:112
msgid ""
"It works exactly the same as `get_dep_component!` except that we need to "
"pass the state as a `ref` so we can mutate it to transfer the ownership."
msgstr ""
"Ini bekerja persis sama dengan 'dep_component'! kecuali kita harus melewati "
"negara sebagai sebuah'ref' sehingga kita dapat bermutasi untuk mentransfer "
"kepemilikan."

#: src/ch16-02-03-testing-components.md:3
msgid ""
"Testing components is a bit different than testing contracts. Contracts need"
" to be tested against a specific state, which can be achieved by either "
"deploying the contract in a test, or by simply getting the `ContractState` "
"object and modifying it in the context of your tests."
msgstr ""
"Menguji komponen sedikit berbeda dari kontrak pengujian. Kontrak perlu diuji"
" terhadap negara tertentu, yang dapat dicapai dengan menyebarkan kontrak "
"dalam tes, atau hanya dengan mendapatkan objek Contracttate dan "
"memodifikasinya dalam konteks tes Anda."

#: src/ch16-02-03-testing-components.md:6
msgid ""
"Components are a generic construct, meant to be integrated in contracts, "
"that can't be deployed on their own and don't have a `ContractState` object "
"that we could use. So how do we test them?"
msgstr ""
"Komponen adalah konstruksi umum, yang dimaksudkan untuk diintegrasikan dalam"
" kontrak, yang tidak dapat dikerahkan sendiri dan tidak memiliki objek "
"contractState yang dapat kita gunakan. jadi bagaimana kita menguji mereka?"

#: src/ch16-02-03-testing-components.md:8
msgid ""
"Let's consider that we want to test a very simple component called "
"\"Counter\", that will allow each contract to have a counter that can be "
"incremented. The component is defined in Listing 16-2:"
msgstr ""
"Mari kita pertimbangkan bahwa kita ingin menguji komponen yang sangat "
"sederhana yang disebut \"Counter,\" yang akan memungkinkan setiap kontrak "
"untuk memiliki counter yang dapat diincrementasikan. Komponen didefinisikan "
"dalam Listing 16-2:"

#: src/ch16-02-03-testing-components.md:33
msgid "<span class=\"caption\">Listing 16-2: A simple Counter component</span>"
msgstr ""
"<span class=\"caption\">Listing 16-2: Sebuah komponen Counter "
"sederhana</span>"

#: src/ch16-02-03-testing-components.md:35
msgid "Testing the Component by Deploying a Mock Contract"
msgstr "Menguji Komponen dengan Menyebarkan Kontrak Mock"

#: src/ch16-02-03-testing-components.md:37
msgid ""
"The easiest way to test a component is to integrate it within a mock "
"contract. This mock contract is only used for testing purposes, and only "
"integrates the component you want to test. This allows you to test the "
"component in the context of a contract, and to use a Dispatcher to call the "
"component's entry points."
msgstr ""
"Cara termudah untuk menguji sebuah komponen adalah mengintegrasikannya dalam"
" kontrak palsu. Kontrak tiruan ini hanya digunakan untuk tujuan pengujian, "
"dan hanya mengintegrasikan komponen yang ingin Anda uji. Hal ini "
"memungkinkan Anda untuk menguji komponen dalam konteks kontrak, dan "
"menggunakan Dispatcher untuk memanggil titik masuk komponen."

#: src/ch16-02-03-testing-components.md:39
msgid "We can define such a mock contract as follows:"
msgstr "Kita dapat menentukan seperti kontrak pura-pura sebagai berikut:"

#: src/ch16-02-03-testing-components.md:65
msgid ""
"This contract is entirely dedicated to testing the `Counter` component. It "
"embeds the component with the `component!` macro, exposes the component's "
"entry points by annotating the impl aliases with `#[abi(embed_v0)]`."
msgstr ""
"Kontrak ini sepenuhnya didedikasikan untuk menguji komponen kounter. Ini "
"mencakup komponen dengan makro! mengekspos titik masuk komponen dengan "
"menyebutkan alias impl dengan ▪#[abi[embed_v0)."

#: src/ch16-02-03-testing-components.md:67
msgid ""
"We also need to define an interface that will be required to interact "
"externally with this mock contract."
msgstr ""
"Kita juga perlu mendefinisikan antarmuka yang diperlukan untuk berinteraksi "
"secara eksternal dengan kontrak tiruan ini."

#: src/ch16-02-03-testing-components.md:77
msgid ""
"We can now write tests for the component by deploying this mock contract and"
" calling its entry points, as we would with a typical contract."
msgstr ""
"Kita sekarang dapat menulis tes untuk komponen dengan menyebarkan kontrak "
"palsu ini dan memanggil titik masuknya, seperti yang kita lakukan dengan "
"kontrak yang khas."

#: src/ch16-02-03-testing-components.md:107
msgid "Testing Components Without Deploying a Contract"
msgstr "Menguji Komponen Tanpa Menyebarkan Kontrak"

#: src/ch16-02-03-testing-components.md:109
msgid ""
"In [Components under the hood](./ch16-02-01-under-the-hood.md), we saw that "
"components leveraged genericity to define storage and logic that could be "
"embedded in multiple contracts. If a contract embeds a component, a "
"`HasComponent` trait is created in this contract, and the component methods "
"are made available."
msgstr ""
"Dalam [Koponen di bawah kap mobil]. /ch16-02-under-the-hood.md), kami "
"melihat bahwa komponen berpengaruh umumitas untuk mendefinisikan penyimpanan"
" dan logika yang dapat tertanam dalam beberapa kontrak. Jika kontrak embes "
"sebuah komponen, sebuah sifat ▪HaCompponent-- diciptakan dalam kontrak ini, "
"dan metode komponen yang tersedia."

#: src/ch16-02-03-testing-components.md:111
msgid ""
"This informs us that if we can provide a concrete `TContractState` that "
"implements the `HasComponent` trait to the `ComponentState` struct, should "
"be able to directly invoke the methods of the component using this concrete "
"`ComponentState` object, without having to deploy a mock."
msgstr ""
"Hal ini memberi tahu kita bahwa jika kita dapat menyediakan konkrit "
"TContracststate yang menerapkan sifat ▪HasComponentéctate, harus dapat "
"secara langsung memanggil metode komponen yang menggunakan benda konkrit "
"ini, tanpa harus menyebarkan tiruan."

#: src/ch16-02-03-testing-components.md:113
msgid ""
"Let's see how we can do that by using type aliases. We still need to define "
"a mock contract - let's use the same as above - but this time, we won't need"
" to deploy it."
msgstr ""
"Mari kita lihat bagaimana kita dapat melakukannya dengan menggunakan nama "
"alias tipe. kita masih perlu mendefinisikan kontrak pura-pura - mari kita "
"menggunakan sama seperti di atas - tapi kali ini, kita tidak perlu "
"menyebarkannya."

#: src/ch16-02-03-testing-components.md:115
msgid ""
"First, we need to define a concrete implementation of the generic "
"`ComponentState` type using a type alias. We will use the "
"`MockContract::ContractState` type to do so."
msgstr ""
"Pertama, kita perlu mendefinisikan implementasi konkrit dari tipe umum "
"komponentstate; menggunakan nama alias."

#: src/ch16-02-03-testing-components.md:123
#: src/ch16-02-03-testing-components.md:167
msgid "// You can derive even `Default` on this type alias\n"
msgstr "#/Anda dapat memperoleh bahkan default# pada jenis alias\n"

#: src/ch16-02-03-testing-components.md:144
msgid ""
"We defined the `TestingState` type as an alias of the "
"`CounterComponent::ComponentState<MockContract::ContractState>` type. By "
"passing the `MockContract::ContractState` type as a concrete type for "
"`ComponentState`, we aliased a concrete implementation of the "
"`ComponentState` struct to `TestingState`."
msgstr ""
"Kami mendefinisikan tipe TestatingState> sebagai alias dari "
"COunterCoponent::CoponentState<ComuckContract:::ContractState> tipe. Dengan "
"melewati tipe kompontract:::Contractateé sebagai tipe konkrit untuk "
"ComponentState, kami menyebut implementasi konkrit dari COponentSate "
"éCoponentSate."

#: src/ch16-02-03-testing-components.md:146
msgid ""
"Because `MockContract` embeds `CounterComponent`, the methods of "
"`CounterComponent` defined in the `CounterImpl` block can now be used on a "
"`TestingState` object."
msgstr ""
"Karena metode CounterCounterComuntent, yang didefinisikan dalam blok "
"COunterlpl, kini dapat digunakan pada objek yang ditestasikan."

#: src/ch16-02-03-testing-components.md:148
msgid ""
"Now that we have made these methods available, we need to instantiate an "
"object of type `TestingState`, that we will use to test the component. We "
"can do so by calling the `component_state_for_testing` function, which "
"automatically infers that it should return an object of type `TestingState`."
msgstr ""
"Sekarang kita telah membuat metode-metode ini tersedia, kita perlu "
"mengkampanyekan sebuah objek dari tipe testasi, yang akan kita gunakan untuk"
" menguji komponennya. kita dapat melakukannya dengan menghubungi "
"komponent_state_for_testingà fungsi, yang secara otomatis akan mengembalikan"
" sebuah objek dari tipe Tessate."

#: src/ch16-02-03-testing-components.md:150
msgid ""
"We can even implement this as part of the `Default` trait, which allows us "
"to return an empty `TestingState` with the `Default::default()` syntax."
msgstr ""
"Kita bahkan dapat mengimplementasikan ini sebagai bagian dari sifat Default,"
" yang memungkinkan kita untuk mengembalikan sintaks yang kosong."

#: src/ch16-02-03-testing-components.md:152
msgid "Let's summarize what we've done so far:"
msgstr "Mari kita ringkaskan apa yang telah kita lakukan sejauh ini:"

#: src/ch16-02-03-testing-components.md:154
msgid "We defined a mock contract that embeds the component we want to test."
msgstr ""
"Kami mendefinisikan kontrak pura-pura yang embeds komponen kita ingin "
"menguji."

#: src/ch16-02-03-testing-components.md:155
msgid ""
"We defined a concrete implementation of `ComponentState<TContractState>` "
"using a type alias with `MockContract::ContractState`, that we named "
"`TestingState`."
msgstr ""
"Kami mendefinisikan sebuah implementasi konkrit dari komponentate<TContract>"
" menggunakan sebuah alias tipe dengan mockContract:::ContractState, yang "
"kami namai åTestingState."

#: src/ch16-02-03-testing-components.md:156
msgid ""
"We defined a function that uses `component_state_for_testing` to return a "
"`TestingState` object."
msgstr ""
"Kami mendefinisikan sebuah fungsi yang menggunakan komponent_state_for_testé"
" untuk mengembalikan sebuah objek yang sedang diuji ulang."

#: src/ch16-02-03-testing-components.md:158
msgid ""
"We can now write tests for the component by calling its functions directly, "
"without having to deploy a mock contract. This approach is more lightweight "
"than the previous one, and it allows testing internal functions of the "
"component that are not exposed to the outside world trivially."
msgstr ""
"Kita sekarang dapat menulis tes untuk komponen dengan memanggil fungsinya "
"secara langsung, tanpa harus menyebarkan kontrak tiruan. pendekatan ini "
"lebih ringan daripada sebelumnya, dan memungkinkan pengujian fungsi internal"
" komponen yang tidak terpapar ke dunia luar secara sepele."

#: src/ch16-03-upgradeability.md:1
msgid "Upgradeable Contracts"
msgstr "Kontrak Dapat Diperbarui"

#: src/ch16-03-upgradeability.md:3
msgid ""
"Starknet separates contracts into classes and instances, making it simple to"
" upgrade a contract's logic without affecting its state."
msgstr ""
"Starknet memisahkan kontrak ke dalam kelas dan contoh, membuatnya sederhana "
"untuk meningkatkan logika kontrak tanpa mempengaruhi kondisinya."

#: src/ch16-03-upgradeability.md:5
msgid ""
"A contract class is the definition of the semantics of a contract. It "
"includes the entire logic of a contract: the name of the entry points, the "
"addresses of the storage variables, the events that can be emitted, etc. "
"Each class is uniquely identified by its class hash. A class does not have "
"its own storage: it's only a definition of logic."
msgstr ""
"Sebuah kelas kontrak adalah definisi semantik dari sebuah kontrak. Ini "
"termasuk seluruh logika dari sebuah kontrak: nama titik masuk, alamat dari "
"variabel penyimpanan, peristiwa yang dapat dipancarkan, dll. Setiap kelas "
"diidentifikasi secara unik oleh hash kelasnya. Sebuah kelas tidak memiliki "
"gudang sendiri: itu hanya definisi logika."

#: src/ch16-03-upgradeability.md:7
msgid ""
"Classes are typically identified by a [class "
"hash](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-"
"hash). When declaring a class, the network registers it and assigns a unique"
" hash used to identify the class and deploy contract instances from it."
msgstr ""
"Kelas biasanya diidentifikasi oleh sebuah hash] "
"[kelas][https://docs.starknet.io/dokumentation/archicture_and_concepts/Smart_Contracts/class-"
"hash). Ketika menyatakan sebuah kelas, jaringan register itu dan menetapkan "
"hash unik digunakan untuk mengidentifikasi kelas dan menyebarkan instansi "
"kontrak dari itu."

#: src/ch16-03-upgradeability.md:9
msgid ""
"A contract instance is a deployed contract corresponding to a class, with "
"its own storage."
msgstr ""
"Sebuah kontrak adalah kontrak yang dikerahkan sesuai dengan kelas, dengan "
"penyimpanan sendiri."

#: src/ch16-03-upgradeability.md:11
msgid ""
"Starknet natively supports upgradeable contracts through the "
"`replace_class_syscall` [system "
"call](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-"
"calls-cairo1/), enabling simple contract upgrades without affecting the "
"contract's state."
msgstr ""
"Starknet secara alami mendukung peningkatan kontrak melalui kontrak yang "
"dapat diupgrade melalui ·replace_class_syscall--system "
"call]bahhttps://docs.starknet.io/documentation/archicture_and_concepts/Smart_Contracts/system-"
"cairo1/), mengaktifkan peningkatan kontrak sederhana tanpa mempengaruhi "
"keadaan kontrak."

#: src/ch16-03-upgradeability.md:16
msgid "Upgrading Contracts"
msgstr "Memperbarui Kontrak"

#: src/ch16-03-upgradeability.md:18
msgid ""
"To upgrade a contract, expose an entry point that executes "
"`replace_class_syscall` with the new class hash as an argument:"
msgstr ""
"Untuk meng-upgrade kontrak, mengekspos titik masuk yang menjalankan kembali "
"'class_syscall' dengan hash kelas baru sebagai argumen:"

#: src/ch16-03-upgradeability.md:31
msgid ""
"<span class=\"caption\">Listing 16-3: Exposing `replace_class_syscall` to "
"update the contract's class</span>"
msgstr ""
"<span class=\"caption\">Listing 16-3: Exposing "
"▪replace_class_syscall_syscallé untuk memperbarui kelas kontrak</span>"

#: src/ch16-03-upgradeability.md:33
msgid ""
"Note: Thoroughly review changes and potential impacts before upgrading, as "
"it's a delicate procedure with security implications. Don't allow arbitrary "
"addresses to upgrade your contract."
msgstr ""
"Catatan: Periksa secara menyeluruh perubahan dan dampak potensial sebelum "
"meng-upgrade, karena itu adalah prosedur yang rumit dengan implikasi "
"keamanan. jangan ijinkan alamat sewenang-wenang untuk meningkatkan kontrak "
"Anda."

#: src/ch16-03-upgradeability.md:35
msgid "Upgradeable Component"
msgstr "Komponen Upgradeable"

#: src/ch16-03-upgradeability.md:37
msgid ""
"OpenZeppelin Contracts for Cairo provides the `Upgradeable` component that "
"can be embedded into your contract to make it upgradeable. This component is"
" a simple way to add upgradeability to your contract while relying on an "
"audited library. It can be combined with the `Ownable` component to restrict"
" the upgradeability to a single address, so that the contract owner has the "
"exclusive right to upgrade the contract."
msgstr ""
"OpenZeppelin Contractions for Cairo menyediakan komponen yang dapat "
"ditingkatkan ke dalam kontrak Anda untuk membuatnya dapat diupgrade. "
"Komponen ini adalah cara sederhana untuk menambah kemampuan peningkatan "
"kontrak Anda saat mengandalkan sebuah perpustakaan audit. Komponen yang "
"dapat dikombinasikan dengan komponen yang dapat ditingkatkan untuk membatasi"
" peningkatan ke satu alamat, sehingga pemilik kontrak memiliki hak eksklusif"
" untuk meningkatkan kontrak."

#: src/ch16-03-upgradeability.md:51
msgid "/// Ownable\n"
msgstr "#/ Ownable\n"

#: src/ch16-03-upgradeability.md:56
msgid "/// Upgradeable\n"
msgstr "#/ Upgradeable\n"

#: src/ch16-03-upgradeability.md:84
msgid "// This function can only be called by the owner\n"
msgstr "/Ini fungsi hanya dapat dipanggil oleh pemilik\n"

#: src/ch16-03-upgradeability.md:87
msgid "// Replace the class hash upgrading the contract\n"
msgstr "//Ganti kelas meningkatkan kontrak\n"

#: src/ch16-03-upgradeability.md:94
msgid ""
"<span class=\"caption\">Listing 16-4 Integrating OpenZeppelin's Upgradeable "
"component in a contract</span>"
msgstr ""
"<span class=\"caption\">Listing 16-4 Integrating OpenZeppelin's Upgradeable "
"komponen dalam sebuah kontrak</span>"

#: src/ch16-03-upgradeability.md:96
msgid ""
"For more information, please refer to the [OpenZeppelin docs API "
"reference](https://docs.openzeppelin.com/contracts-"
"cairo/0.9.0/api/upgrades)."
msgstr ""
"Untuk informasi lebih lanjut, silakan merujuk ke [Referensi API Docs "
"BukaZeppelin]][Nichttps://doccs.openzepectin.com/contracts-"
"cairo/0.9.0/api/upgrades)."

#: src/ch16-04-L1-L2-messaging.md:1
msgid "L1-L2 Messaging"
msgstr "Pesan L1-L2"

#: src/ch16-04-L1-L2-messaging.md:3
msgid ""
"A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr ""
"Fitur penting dari Lapis 2 adalah kemampuannya untuk berinteraksi dengan "
"Lapis 1."

#: src/ch16-04-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` messaging system, which is different from its "
"consensus mechanism and the submission of state updates on L1. Messaging is "
"a way for smart-contracts on L1 to interact with smart-contracts on L2 (or "
"the other way around), allowing us to do \"cross-chain\" transactions. For "
"example, we can do some computations on a chain and use the result of this "
"computation on the other chain."
msgstr ""
"Starknet memiliki sistem pesan sendiri L1-L2, yang berbeda dari mekanisme "
"konsensusnya dan penyerahan pemutakhiran negara pada L1. Pesan adalah cara "
"untuk kontrak cerdas pada L1 untuk berinteraksi dengan cerdas-kontrak pada "
"L2 (atau sebaliknya), memungkinkan kita untuk melakukan transaksi \"cross-"
"chain\". Sebagai contoh, kita dapat melakukan beberapa komputasi pada rantai"
" dan menggunakan hasil dari komputasi ini pada rantai lain."

#: src/ch16-04-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to "
"bridge tokens from Ethereum to Starknet. You will simply have to deposit "
"your tokens in the L1 bridge contract, which will automatically trigger the "
"minting of the same token on L2. Another good use case for `L1-L2` messaging"
" would be [DeFi pooling](https://starkware.co/resource/defi-pooling/)."
msgstr ""
"Jembatan di Starknet semua menggunakan pesan L1-L2. katakanlah Anda ingin "
"menjembatani token dari Etherum ke Starknet. Anda hanya perlu menyimpan "
"token Anda di kontrak L1 bridge, yang secara otomatis akan memicu pemanenan "
"token yang sama pada L2."

#: src/ch16-04-L1-L2-messaging.md:9
msgid ""
"On Starknet, it's important to note that the messaging system is "
"**asynchronous** and **asymmetric**."
msgstr ""
"Di Starknet, sangatlah penting untuk mencatat bahwa sistem pesan-pesan "
"adalah (*asynchronous*** dan *asymetric**."

#: src/ch16-04-L1-L2-messaging.md:11
msgid ""
"**Asynchronous**: this means that in your contract code (being Solidity or "
"Cairo), you can't wait the result of the message being sent on the other "
"chain within your contract code execution."
msgstr ""
"**Asynchronous**: ini berarti bahwa dalam kode kontrak Anda (menjadi "
"Soliditas atau Cairo), Anda tidak bisa menunggu hasil dari pesan yang "
"dikirim pada rantai lain dalam eksekusi kode kontrak Anda."

#: src/ch16-04-L1-L2-messaging.md:12
msgid ""
"**Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is "
"fully automated by the Starknet sequencer, which means that the message is "
"being automatically delivered to the target contract on L2. However, when "
"sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the"
" message is sent on L1 by the Starknet sequencer. You must then consume the "
"message manually via a transaction on L1."
msgstr ""
"**Asymmetric**: mengirim pesan dari Etherum ke Starknet (Nekat 1->L2) "
"sepenuhnya otomatis oleh pengurut Starknet, yang berarti bahwa pesan secara "
"otomatis disampaikan ke kontrak target pada L2. Namun, ketika mengirim pesan"
" dari Starknet ke Ethereum (al->L1), hanya hash pesan yang dikirim ke L1 "
"oleh pengurut Starknet. Anda kemudian harus mengkonsumsi pesan secara manual"
" melalui transaksi pada L1."

#: src/ch16-04-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr "Mari kita menyelam ke dalam rincian."

#: src/ch16-04-L1-L2-messaging.md:18
msgid "The StarknetMessaging Contract"
msgstr "Kontrak StarknetMessaging"

#: src/ch16-04-L1-L2-messaging.md:20
msgid ""
"The crucial component of the `L1-L2` Messaging system is the "
"[`StarknetCore`](https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4)"
" contract. It is a set of Solidity contracts deployed on Ethereum that "
"allows Starknet to function properly. One of the contracts of `StarknetCore`"
" is called `StarknetMessaging` and it is the contract responsible for "
"passing messages between Starknet and Ethereum. `StarknetMessaging` follows "
"an [interface](https://github.com/starkware-libs/cairo-"
"lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6)"
" with functions allowing to send message to L2, receiving messages on L1 "
"from L2 and canceling messages."
msgstr ""
"Komponen penting dari sistem Messaging "
"[NeknetCore]://etherscan.io/alamatkan/0xC2C0C0E775444B90B6BD9C4) kontrak "
"yang diekspansikan di Etherum yang memungkinkan Stark untuk berfungsi dengan"
" baik. Salah satu kontrak dari 50,000CNCNNNCNCBBBBBBBLLBBLLCBLCBBBB dan itu "
"adalah kontrak yang bertanggung jawab antara pesan-pesan Stark dan Eumcnet."

#: src/ch16-04-L1-L2-messaging.md:51
msgid "<span class=\"caption\"> Starknet messaging contract interface</span>"
msgstr "<span class=\"caption\"> Starknet messaging antar muka kontrak</span>"

#: src/ch16-04-L1-L2-messaging.md:53
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly "
"listening to the logs emitted by the `StarknetMessaging` contract on "
"Ethereum. Once a message is detected in a log, the sequencer prepares and "
"executes a `L1HandlerTransaction` to call the function on the target L2 "
"contract. This takes up to 1-2 minutes to be done (few seconds for ethereum "
"block to be mined, and then the sequencer must build and execute the "
"transaction)."
msgstr ""
"Dalam kasus ini, pesan pada Ethereum terdeteksi dalam sebuah log, pengurutan"
" Starknet terus-menerus mendengarkan log yang dipancarkan oleh kontrak L2. "
"Ini membutuhkan 1-2 menit untuk dilakukan (beberapa detik untuk blok etereum"
" untuk ditambang, dan kemudian pengurut urutan harus membangun dan "
"menjalankan transaksi)."

#: src/ch16-04-L1-L2-messaging.md:56
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of "
"the block produced. When the sequencer produces a block, it sends the hash "
"of each message prepared by contracts execution to the `StarknetCore` "
"contract on L1, where they can then be consumed once the block they belong "
"to is proven and verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""
"pesan L2->L1R dipersiapkan oleh eksekusi kontrak di L2 dan bagian dari blok "
"yang diproduksi. ketika pengurut menghasilkan blok, mengirimkan hash dari "
"setiap pesan yang disiapkan oleh eksekusi kontrak ke kontrak kontrak "
"▪StarknetCore kontrak di L1, di mana mereka kemudian dapat dikonsumsi "
"setelah blok mereka milik terbukti dan diverifikasi pada Etherum (yang untuk"
" saat ini adalah sekitar 3-4 jam)."

#: src/ch16-04-L1-L2-messaging.md:62
msgid "Sending Messages from Ethereum to Starknet"
msgstr "Mengirim Pesan dari Etherum ke Starknet"

#: src/ch16-04-L1-L2-messaging.md:64
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity "
"contracts must call the `sendMessageToL2` function of the "
"`StarknetMessaging` contract. To receive these messages on Starknet, you "
"will need to annotate functions that can be called from L1 with the "
"`#[l1_handler]` attribute."
msgstr ""
"Jika anda ingin mengirim pesan dari Ethereum ke Starknet, kontrak Soliditas "
"anda harus memanggil fungsi L1 yang dapat dipanggil dari atribut L1 dengan "
"L1&lt;/font&gt; &lt;font color=\"#ffff00\"&gt;î&lt;/font&gt; &lt;font "
"color=\"#ffff00\"&gt;-&lt;/font&gt; &lt;font "
"color=\"#ffff00\"&gt;-&lt;/font&gt; &lt;font color=\"#ffff00\"&gt;Untuk "
"menerima pesan-pesan ini di Starknet, anda akan perlu mengumumkan fungsi "
"yang dapat dipanggil dari L1&lt;/font&gt; &lt;font color=\"#ffff00\"&gt;-"

#: src/ch16-04-L1-L2-messaging.md:66
msgid ""
"Let's take a simple contract taken from [this "
"tutorial](https://github.com/glihm/starknet-messaging-"
"dev/blob/main/solidity/src/ContractMsg.sol) where we want to send a message "
"to Starknet. The `_snMessaging` is a state variable already initialized with"
" the address of the `StarknetMessaging` contract. You can check all Starknet"
" contract and sequencer addresses "
"[here](https://docs.starknet.io/documentation/tools/important_addresses/)."
msgstr ""
"Mari kita ambil kontrak sederhana yang diambil dari [ "
"tutorial/ContractMsg.sol) di mana kita ingin mengirim pesan ke Starknet."

#: src/ch16-04-L1-L2-messaging.md:70
msgid "// Sends a message on Starknet with a single felt.\n"
msgstr "//Kirim pesan di Starknet dengan perasaan tunggal.\n"

#: src/ch16-04-L1-L2-messaging.md:79
msgid ""
"// We \"serialize\" here the felt into a payload, which is an array of "
"uint256.\n"
msgstr ""
"/Kami \"serialisasi\" di sini merasa ke dalam payload, yang merupakan array "
"Uint256.\n"

#: src/ch16-04-L1-L2-messaging.md:83
msgid "// msg.value must always be >= 20_000 wei.\n"
msgstr "//msg.value harus selalu >=20,000 wei.\n"

#: src/ch16-04-L1-L2-messaging.md:92
msgid ""
"The function sends a message with a single felt value to the "
"`StarknetMessaging` contract. Please note that if you want to send more "
"complex data you can. Just be aware that your Cairo contract will only "
"understand `felt252` data type. So you must ensure that the serialization of"
" your data into the `uint256` array follow the Cairo serialization scheme."
msgstr ""
"Fungsi mengirim pesan dengan satu perasaan nilai yang dirasakan untuk "
"kontrak StarknetMesaging. Harap dicatat bahwa jika Anda ingin mengirim data "
"yang lebih kompleks Anda bisa. Hanya perlu menyadari bahwa kontrak Cairo "
"Anda hanya akan memahami tipe data felting252. Jadi Anda harus memastikan "
"bahwa serialisasi data Anda ke dalam array serialisasi Cairo 256."

#: src/ch16-04-L1-L2-messaging.md:95
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the "
"minimum value we've to send here is `20k wei`, due to the fact that the "
"`StarknetMessaging` contract will register the hash of our message in the "
"storage of Ethereum."
msgstr ""
"Sangat penting untuk dicatat bahwa kita memiliki nilai ▪{value: msg.value}. "
"Bahkan, nilai minimum yang kita kirim di sini adalah 20k wei, karena fakta "
"bahwa kontrak starknetMesaging akan mendaftarkan hash pesan kita dalam "
"penyimpanan Ethereum."

#: src/ch16-04-L1-L2-messaging.md:98
msgid ""
"In addition to those `20k wei`, since the `L1HandlerTransaction` executed by"
" the sequencer is not tied to any account (the message originates from L1), "
"you must also ensure that you pay enough fees on L1 for your message to be "
"deserialized and processed on L2."
msgstr ""
"Selain itu, Anda juga harus memastikan bahwa Anda membayar biaya yang cukup "
"pada L1 untuk pesan Anda untuk dideserialisasi dan diproses pada L2."

#: src/ch16-04-L1-L2-messaging.md:101
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as "
"it would be done for an `Invoke` transaction. For this, you can profile the "
"gas consumption using `starkli` or `snforge` to estimate the cost of your "
"message execution."
msgstr ""
"Biaya dari L1 HandlerTransaction dihitung secara teratur seperti yang akan "
"dilakukan untuk transaksi invoke."

#: src/ch16-04-L1-L2-messaging.md:104
msgid "The signature of the `sendMessageToL2` is:"
msgstr "Tanda tangan dari 'posedMessageToL2' adalah:"

#: src/ch16-04-L1-L2-messaging.md:114
msgid "The parameters are as follows:"
msgstr "Parameter sebagai berikut:"

#: src/ch16-04-L1-L2-messaging.md:116
msgid "`toAddress`: The contract address on L2 that will be called."
msgstr "Alamat kontrak di L2 yang akan disebut."

#: src/ch16-04-L1-L2-messaging.md:117
msgid ""
"`selector`: The selector of the function of this contract at `toAddress`. "
"This selector (function) must have the `#[l1_handler]` attribute to be "
"callable."
msgstr ""
"Selektor: Pemilih dari fungsi kontrak ini pada ▪to Alamat. Selektor ini "
"(fungsi) harus memiliki atribut yang dapat dipanggil."

#: src/ch16-04-L1-L2-messaging.md:118
msgid ""
"`payload`: The payload is always an array of `felt252` (which are "
"represented by `uint256` in Solidity). For this reason we've inserted the "
"input `myFelt` into the array. This is why we need to insert the input data "
"into an array."
msgstr ""
"Untuk alasan ini kita masukkan inputnya ke dalam array ini sebabnya kita "
"perlu memasukkan data input ke dalam susunan."

#: src/ch16-04-L1-L2-messaging.md:121
msgid "On the Starknet side, to receive this message, we have:"
msgstr "Di sisi Starknet, untuk menerima pesan ini, kita punya:"

#: src/ch16-04-L1-L2-messaging.md:128
msgid ""
"// You can now use the data, automatically deserialized from the message "
"payload.\n"
msgstr ""
"//Anda sekarang dapat menggunakan data, otomatis deserialisasi dari muatan "
"pesan.\n"

#: src/ch16-04-L1-L2-messaging.md:133
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers "
"are special functions that can only be executed by a `L1HandlerTransaction`."
" There is nothing particular to do to receive transactions from L1, as the "
"message is relayed by the sequencer automatically. In your `#[l1_handler]` "
"functions, it is important to verify the sender of the L1 message to ensure "
"that our contract can only receive messages from a trusted L1 contract."
msgstr ""
"Kita perlu menambahkan atribut fungsi kita. L1 handlerTransaction. Tidak ada"
" yang dapat dilakukan untuk menerima transaksi dari L1, pesan yang "
"disampaikan oleh pengurut secara otomatis. Dalam fungsi Anda, penting untuk "
"memverifikasi pengirim pesan L1 untuk memastikan bahwa kontrak kami hanya "
"dapat menerima pesan dari kontrak L1 terpercaya."

#: src/ch16-04-L1-L2-messaging.md:138
msgid "Sending Messages from Starknet to Ethereum"
msgstr "Mengirim Pesan dari Starknet ke Ethereum"

#: src/ch16-04-L1-L2-messaging.md:140
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the "
"`send_message_to_l1` syscall in your Cairo contracts. This syscall allows "
"you to send messages to the `StarknetMessaging` contract on L1. Unlike "
"`L1->L2` messages, `L2->L1` messages must be consumed manually, which means "
"that you will need your Solidity contract to call the `consumeMessageFromL2`"
" function of the `StarknetMessaging` contract explicitly in order to consume"
" the message."
msgstr ""
"Ketika mengirim pesan dari Starknet ke Ethereum, Anda harus menggunakan "
"kontrak ·StarknetMesaging pada L1. Tidak seperti pesan L1->L2, pesan-pesan "
"yang akan dikonsumsi secara manual, yang berarti Anda akan membutuhkan "
"kontrak Soliditas untuk memanggil fungsi SIGL2."

#: src/ch16-04-L1-L2-messaging.md:142
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr ""
"Untuk mengirim pesan dari L2 ke L1, apa yang akan kita lakukan di Starknet "
"adalah:"

#: src/ch16-04-L1-L2-messaging.md:146
msgid ""
"// Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
msgstr ""
"//Ingat di sini, kita \"serialisasi\" my_felt, karena muatannya pasti / "
"sebuah Span<felt252>.\n"

#: src/ch16-04-L1-L2-messaging.md:153
msgid ""
"We simply build the payload and pass it, along with the L1 contract address,"
" to the syscall function."
msgstr ""
"Kami hanya membangun muatan dan lulus, bersama dengan alamat kontrak L1, ke "
"fungsi syscall."

#: src/ch16-04-L1-L2-messaging.md:155
msgid ""
"On L1, the important part is to build the same payload sent by the L2. Then "
"you call `consumeMessageFromL2` in you Solidity contract by passing the L2 "
"contract address and the payload. Please be aware that the L2 contract "
"address expected by the `consumeMessageFromL2` is the address of the "
"contract that sends the message on the L2 by calling "
"`send_message_to_l1_syscall`."
msgstr ""
"Pada L1, bagian yang penting adalah untuk membangun muatan yang sama yang "
"dikirim oleh L2. Kemudian Anda memanggil L2 Message FromL2 dalam diri Anda "
"kontrak Soliditas dengan melewati alamat kontrak L2 dan muatan. Harap "
"menyadari bahwa alamat kontrak L2 yang diharapkan oleh L2consumeMessage "
"FromL2, adalah alamat kontrak yang mengirimkan pesan pada L2 dengan "
"memanggil Á_mesage_tol_scall.1_sycall."

#: src/ch16-04-L1-L2-messaging.md:166
msgid "// You can use the message hash if you want here.\n"
msgstr "//Anda dapat menggunakan hash pesan jika anda ingin di sini.\n"

#: src/ch16-04-L1-L2-messaging.md:168
msgid ""
"// We expect the payload to contain only a felt252 value (which is a uint256"
" in Solidity).\n"
msgstr ""
"/Kamimengharapkan payload hanya berisi nilai felt252 (yang merupakan uint256"
" di Solidity).\n"

#: src/ch16-04-L1-L2-messaging.md:169
msgid "\"Invalid payload\""
msgstr "Muatan tidak sah."

#: src/ch16-04-L1-L2-messaging.md:173
msgid ""
"// From here, you can safely use `my_felt` as the message has been verified "
"by StarknetMessaging.\n"
msgstr ""
"//Dari sini, Anda dapat menggunakan aman-hidup seperti pesan telah "
"diverifikasi oleh Starknet Messaging.\n"

#: src/ch16-04-L1-L2-messaging.md:174
msgid "\"Invalid value\""
msgstr "\"nilai tidak sah\""

#: src/ch16-04-L1-L2-messaging.md:178
msgid ""
"As you can see, in this context we don't have to verify which contract from "
"L2 is sending the message (as we do on the L2 to verify which contract from "
"L1 is sending the message). But we are actually using the "
"`consumeMessageFromL2` of the `StarknetCore` contract to validate the inputs"
" (the contract address on L2 and the payload) to ensure we are only "
"consuming valid messages."
msgstr ""
"Seperti yang Anda lihat, dalam konteks ini kita tidak perlu memverifikasi "
"kontrak dari L2 mana yang mengirimkan pesan (seperti yang kita lakukan pada "
"L2 untuk memverifikasi kontrak dari L1 mengirim pesan). Tapi kita benar-"
"benar menggunakan Áconsume Message FromL2 (seperti yang kita lakukan pada L2"
" untuk mengesahkan masukan (alamat kontrak di L2 dan payload) untuk "
"memastikan kita hanya mengkonsumsi pesan yang valid."

#: src/ch16-04-L1-L2-messaging.md:180
msgid ""
"**Note:** The `consumeMessageFromL2` function of the `StarknetCore` contract"
" is expected to be called from a Solidity contract, and not directly on the "
"`StarknetCore` contract. The reason of that is because the `StarknetCore` "
"contract is using `msg.sender` to actually compute the hash of the message. "
"And this `msg.sender` must correspond to the `to_address` field that is "
"given to the function `send_message_to_l1_syscall` that is called on "
"Starknet."
msgstr ""
"*Note:** The Áconsume Message FromL2-- fungsi dari kontrak StarknetCore "
"diduga berasal dari kontrak Solientity, dan tidak secara langsung pada "
"kontrak ▪StarknetCore. Alasan dari itu adalah karena kontrak "
"thoseStarknetCore menggunakan msg.sender untuk benar-benar menghitung hash "
"pesan. Dan msg.der ini harus sesuai dengan lapangan aux_address yang "
"diberikan kepada fungsi yang diberikan kepada fungsi "
"directory_sendme_stoages_1s_slists."

#: src/ch16-04-L1-L2-messaging.md:182
msgid ""
"It is important to remember that on L1 we are sending a payload of "
"`uint256`, but the basic data type on Starknet is `felt252`; however, "
"`felt252` are approximately 4 bits smaller than `uint256`. So we have to pay"
" attention to the values contained in the payload of the messages we are "
"sending. If, on L1, we build a message with values above the maximum "
"`felt252`, the message will be stuck and never consumed on L2."
msgstr ""
"Sangat penting untuk diingat bahwa pada L1 kita mengirimkan muatan yang "
"kurang dari 4 bit kurang dari 256. jadi kita harus memperhatikan nilai-nilai"
" yang terkandung dalam muatan pesan yang kita kirim. jika, pada L1, kita "
"membangun pesan dengan nilai-nilai yang maksimal di atas felt252, pesan akan"
" terjebak dan tidak pernah dikonsumsi pada L2."

#: src/ch16-04-L1-L2-messaging.md:184
msgid "Cairo Serde"
msgstr "Cairo Serde"

#: src/ch16-04-L1-L2-messaging.md:186
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet "
"contracts, written in Cairo, can only understand serialized data. And "
"serialized data is always an array of `felt252`. In Solidity we have "
"`uint256` type, and `felt252` are approximately 4 bits smaller than "
"`uint256`. So we have to pay attention to the values contained in the "
"payload of the messages we are sending. If, on L1, we build a message with "
"values above the maximum `felt252`, the message will be stuck and never "
"consumed on L2."
msgstr ""
"Sebelum mengirim pesan antara L1 dan L2, Anda harus ingat bahwa kontrak "
"Starknet, yang ditulis di Cairo, hanya dapat memahami data serial. dan data "
"serial selalu berupa array dari L1 dan L1."

#: src/ch16-04-L1-L2-messaging.md:190
msgid ""
"So for instance, an actual `uint256` value in Cairo is represented by a "
"struct like:"
msgstr ""
"Sebagai contoh, nilai sebenarnya dari 256 di Cairo diwakili oleh sebuah "
"struktur seperti:"

#: src/ch16-04-L1-L2-messaging.md:199
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for "
"the `high`. This means that to send only one `u256` to Cairo, you'll need to"
" send a payload from L1 with **TWO** values."
msgstr ""
"Yang mana akan diserialisasikan sebagai perasaan **TWO**, satu untuk nada "
"rendah, dan satu untuk tinggi itu. ini berarti hanya untuk mengirim satu "
"nilai-nilai 0.256 ke Cairo, anda perlu mengirim muatan dari L1 dengan nilai-"
"nilai **TWO**."

#: src/ch16-04-L1-L2-messaging.md:202
msgid "// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
msgstr "# # Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"

#: src/ch16-04-L1-L2-messaging.md:208
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the "
"[Starknet "
"documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-"
"mechanism/)."
msgstr ""
"Jika Anda ingin mengetahui lebih banyak tentang mekanisme pesan, Anda dapat "
"mengunjungi [Trekumentasi Starknet][Architecture/Architecture/messaging-"
"mechanism/)."

#: src/ch16-04-L1-L2-messaging.md:210
msgid ""
"You can also find a [detailed guide here](https://github.com/glihm/starknet-"
"messaging-dev) to test the messaging system locally."
msgstr ""
"Anda juga dapat menemukan sebuah panduan [detailed di "
"sini][https://gitub.com/glihm/starknet-message-dev) untuk menguji pesan "
"sistem lokal."

#: src/ch16-05-oracle-interactions.md:3
msgid ""
"This section focuses on the concept of bringing off-chain data to the "
"Starknet blockchain using oracles. Oracles are third-party services that "
"serve as intermediaries, securely transmitting external data, such as asset "
"prices, weather information, or other real-world data, to blockchains and "
"smart contracts. It also provides practical examples and code snippets "
"demonstrating how developers can interact with a specific oracle named "
"Pragma on Starknet network, covering topics like querying and handling price"
" data, and verifiable random function (VRF) to generate random numbers."
msgstr ""
"Bagian ini berfokus pada konsep membawa off-chain data ke Starknet "
"blockchain menggunakan peramal. Oracles adalah layanan pihak ketiga yang "
"berfungsi sebagai perantara, secara aman mentransmisikan data eksternal, "
"seperti harga aset, informasi cuaca, atau data real-dunia lainnya, untuk "
"memblokir rantai dan kontrak cerdas. hal ini juga menyediakan contoh praktis"
" dan kode yang menunjukkan bagaimana pengembang dapat berinteraksi dengan "
"tertentu Pragma di jaringan Starknet, mencakup topik seperti menanyakan dan "
"menangani harga data, dan fungsi acak yang dapat diverifikasi (VRF) untuk "
"menghasilkan angka acak."

#: src/ch16-05-01-price-feeds.md:3
msgid ""
"Price feeds enabled by an oracle serve as a bridge between real-world data "
"feed and the blockchain. They provide real time pricing data that is "
"aggregated from multiple trusted external sources ( e.g. crypto exchanges, "
"financial data providers, etc. ) to the blockchain network."
msgstr ""
"Feed harga yang diaktifkan oleh peramal berfungsi sebagai jembatan antara "
"pakan data dunia nyata dan rantai blok. Mereka menyediakan data real time "
"pricing yang dikumpulkan dari beberapa sumber eksternal terpercaya (mis. "
"crypto pertukaran, penyedia data keuangan, dll.) ke jaringan blockchain."

#: src/ch16-05-01-price-feeds.md:5
msgid ""
"For the example in this book section, we will use Pragma Oracle to read the "
"price feed for `ETH/USD` asset pair and also showcase a mini application "
"that utilizes this feed."
msgstr ""
"Sebagai contoh di bagian buku ini, kita akan menggunakan Pragma Oracle untuk"
" membaca harga pakan untuk pasangan aset  pokoknya dan juga menampilkan "
"aplikasi mini yang menggunakan pakan ini."

#: src/ch16-05-01-price-feeds.md:7
msgid ""
"[Pragma Oracle](https://www.pragma.build/) is a leading zero knowledge "
"oracle that provides access to off-chain data on Starknet blockchain in a "
"verifiable way."
msgstr ""
"[Pragma Oracle] Hawthornehttps://www.pragma.build/) adalah peramal tanpa "
"pengetahuan terkemuka yang menyediakan akses ke off-chain data pada rantai "
"blok Starknet dengan cara yang dapat diverifikasi."

#: src/ch16-05-01-price-feeds.md:9
msgid "Add Pragma as a Project Dependency"
msgstr "Tambahkan Pragma sebagai Ketergantungan Proyek"

#: src/ch16-05-01-price-feeds.md:11
msgid ""
"To get started with integrating Pragma on your Cairo smart contract for "
"price feed data, edit your project's `Scarb.toml` file to include the path "
"to use Pragma."
msgstr ""
"Untuk memulai dengan mengintegrasikan Pragma pada kontrak cerdas Cairo Anda "
"untuk data pakan harga, edit proyek Anda apos; s carb.tomlá file untuk "
"memasukkan jalan untuk menggunakan Pragma."

#: src/ch16-05-01-price-feeds.md:13 src/ch16-05-02-randomness.md:20
msgid ""
"```toml\n"
"[dependencies]\n"
"pragma_lib = { git = \"https://github.com/astraly-labs/pragma-lib\" }\n"
"```"
msgstr "PRAGMA_lib = { git = \"https://github.com/astraly-labs/pragma-lib\" }"

#: src/ch16-05-01-price-feeds.md:18
msgid "Creating a Price Feed Contract"
msgstr "Membuat Kontrak Asupan Harga"

#: src/ch16-05-01-price-feeds.md:20
msgid ""
"After adding the required dependencies for your project, you'll need to "
"define a contract interface that includes the required pragma price feed "
"entry point."
msgstr ""
"Setelah menambahkan ketergantungan yang diperlukan bagi projek Anda, Anda "
"perlu mendefinisikan antar muka kontrak yang mencakup titik masukan pakan "
"pragma yang diperlukan."

#: src/ch16-05-01-price-feeds.md:22
msgid "Contract Interface"
msgstr "Antarmuka Kontrak"

#: src/ch16-05-01-price-feeds.md:32
msgid ""
"Of the two public functions exposed in the `IPriceFeedExample`, the one "
"necessary to interact with the pragma price feed oracle is the "
"`get_asset_price` function, a view function that takes in the `asset_id` "
"argument and returns a `u128` value."
msgstr ""
"Dari dua fungsi publik yang terpapar dalam fungsi ÉIPriceFeedExample, yang "
"diperlukan untuk berinteraksi dengan pragma feed oracle adalah fungsi "
"picture_priceFeed, fungsi tampilan yang mengambil dalam argumen ·asset_idà "
"dan kembali nilai Áu128."

#: src/ch16-05-01-price-feeds.md:34
msgid "Pragma Dependency Import to Contract"
msgstr "Pragma Ketergantungan Impor ke Kontrak"

#: src/ch16-05-01-price-feeds.md:41
msgid ""
"The snippet above shows the necessary imports you need to add to your "
"contract module in order to interact with the Pragma oracle."
msgstr ""
"snippet di atas menunjukkan impor yang diperlukan yang perlu Anda tambahkan "
"ke modul kontrak Anda untuk berinteraksi dengan Pragma Oracle."

#: src/ch16-05-01-price-feeds.md:43
msgid "Required Price Feed Function Impl in Contract"
msgstr "Diperlukan Fungsi Feed Harga Impl dalam Kontrak"

#: src/ch16-05-01-price-feeds.md:47 src/ch16-05-01-price-feeds.md:117
msgid "// Retrieve the oracle dispatcher\n"
msgstr "#/ Retrie the oracle dispatcher\n"

#: src/ch16-05-01-price-feeds.md:52 src/ch16-05-01-price-feeds.md:122
msgid "// Call the Oracle contract, for a spot entry\n"
msgstr "# # Call the Oracle contract, for a spot entry\n"

#: src/ch16-05-01-price-feeds.md:60
msgid ""
"The `get_asset_price` function is responsible for retrieving the price of "
"the asset specified by the `asset_id` argument from Pragma Oracle. The "
"`get_data_median` method is called from the `IPragmaDispatcher` instance by "
"passing the `DataType::SpotEntry(asset_id)` as an argument and its output is"
" assigned to a variable named `output` of type `PragmaPricesResponse`. "
"Finally, the function returns the price of the requested asset as a `u128`."
msgstr ""
"Fungsi 'get'_asset_price_price' bertanggung jawab untuk mengambil harga aset"
" yang dispesifikasikan oleh argumen dari Pragma Oracle. Metoda "
"'deta_median_median_median' disebut dari contoh ÉPIPragma Dispatcher. "
"Akhirnya, fungsi tersebut mengembalikan harga yang diminta sebagai sebuah "
"optimus_id_id) sebagai sebuah argumen dan hasilnya diberikan kepada variabel"
" tipe pragmapricesReponse."

#: src/ch16-05-01-price-feeds.md:62
msgid "Example Application Using Pragma Price Feed"
msgstr "Contoh Aplikasi Dengan Asupan Pragma"

#: src/ch16-05-01-price-feeds.md:96
msgid "// Calculate the amount of ETH needed\n"
msgstr "//Perhitungkan jumlah ETH yang dibutuhkan\n"

#: src/ch16-05-01-price-feeds.md:102 src/ch16-05-02-randomness.md:228
msgid "// ETH Contract Address\n"
msgstr "//Alamat Kontrak ETH\n"

#: src/ch16-05-01-price-feeds.md:105
msgid "// Transfer the ETH to the caller\n"
msgstr "//Pindahkan ETH ke pemanggil\n"

#: src/ch16-05-01-price-feeds.md:132
msgid ""
"Note: Pragma returns the value of different token pairs using the decimal "
"factor of 6 or 8. You can convert the value to the required decimal factor "
"by dividing the value by \\\\( {10^{n}} \\\\), where `n` is the decimal "
"factor."
msgstr ""
"Catatan: Pragma mengembalikan nilai pasangan token yang berbeda menggunakan "
"faktor desimal dari 6 atau 8. Anda dapat mengubah nilai ke faktor desimal "
"yang diperlukan dengan membagi nilai dengan \\\\ Valencia {10^{n}} \\\\), di"
" mana faktor desimal."

#: src/ch16-05-01-price-feeds.md:134
msgid ""
"The code above is an example implementation of an applications consuming a "
"price feed from the Pragma oracle. The contract imports necessary modules "
"and interfaces, including the `IPragmaABIDispatcher` for interacting with "
"the Pragma oracle contract and the `ERC20ABIDispatcher` for interacting with"
" the ETH ERC20 token contract."
msgstr ""
"Kode di atas adalah sebuah implementasi contoh dari sebuah aplikasi yang "
"mengkonsumsi umpan harga dari peramal Pragma. Kontrak ini mengimpor modul "
"dan antarmuka yang diperlukan, termasuk ECHC20 token kontrak dengan ETHC20."

#: src/ch16-05-01-price-feeds.md:136
msgid ""
"The contract has a `const` that stores the token pair ID of `ETH/USD`, and a"
" `Storage` struct that holds two fields `pragma_contract` and "
"`product_price_in_usd`. The constructor function initializes the "
"`pragma_contract` address and sets the `product_price_in_usd` to 100."
msgstr ""
"Kontrak ini memiliki sebuah struktur yang menyimpan pasangan token ID dari "
"ÉTH/USD, dan sebuah struktur yang memiliki dua bidang Ápragma_contractà dan "
"Árect_usd_usd. Fungsi konstruktor menginisialisasi alamat ·ra_contractía dan"
" mengatur alamat product_price_in_usd menjadi 100."

#: src/ch16-05-01-price-feeds.md:138
msgid ""
"The `buy_item` function is the main entry point for a user to purchase an "
"item. It retrieves the caller's address. It calls the `get_asset_price` "
"function to get the current price of ETH in USD using the `ETH_USD` asset "
"ID. It calculates the amount of ETH needed to buy the product based on the "
"product price in USD at the corresponding ETH price. It then checks if the "
"caller has enough ETH by calling the `balance_of` method on the ERC20 ETH "
"contract. If the caller has enough ETH, it calls the `transfer_from` method "
"of the `eth_dispatcher` instance to transfer the required amount of ETH from"
" the caller to another contract address."
msgstr ""
"Fungsi åbuy_item_price adalah titik masuk utama bagi pengguna untuk membeli "
"suatu barang. Ia mengambil kembali alamat si pemanggil. Ia menyebut fungsi "
"åget_price_price_price_factions untuk mendapatkan harga saat ini di USD "
"menggunakan ID aset ÁT_USD. Ia menghitung jumlah ETH yang diperlukan untuk "
"membeli produk berdasarkan harga produk di USD dengan harga yang sesuai. "
"Maka cek apakah pemanggil memiliki cukup ETH dengan memanggil metode "
"ERC20th. Jika pemanggil panggilan ETH, maka panggilan EVAL_Deferetth dari "
"metode eth_dispaet ke alamat lain yang diperlukan."

#: src/ch16-05-01-price-feeds.md:140
msgid ""
"The `get_asset_price` function is the entry point to interact with the "
"Pragma oracle and has been explained in the section above."
msgstr ""
"Fungsi 'get'_aset_price' adalah titik masuk untuk berinteraksi dengan Pragma"
" oracle dan telah dijelaskan di bagian atas."

#: src/ch16-05-01-price-feeds.md:142
msgid ""
"You can get a detailed guide on consuming data using Pragma price feeds "
"[here](https://docs.pragma.build/Resources/Cairo%201/data-feeds/consuming-"
"data)."
msgstr ""
"Anda bisa mendapatkan panduan rinci untuk mengkonsumsi data menggunakan "
"harga Pragma feed [di sini][di "
"sini]://docs.pragma.build/Resources/Cairo%201/data-feeds/konsuming-data)."

#: src/ch16-05-02-randomness.md:3
msgid ""
"Since all blockchains are fundamentally deterministic and most are public "
"ledgers, generating truly unpredictatable randomness on-chain presents a "
"challenge. This randomness is crucial for fair outcomes in gaming, "
"lotteries, and unique generation of NFTs. To address this, verifiable random"
" functions (VRFs) provided by oracles offer a solution. VRFs guarantee that "
"the randomness can't be predicted or tampered with, ensuring trust and "
"transparency in these applications."
msgstr ""
"Karena semua rantai blok secara fundamental menentukan dan kebanyakan adalah"
" buku besar publik, menghasilkan fungsi acak yang benar-benar tidak terduga "
"pada rantai menghadirkan sebuah tantangan. keacakan ini merupakan hal yang "
"penting untuk hasil yang adil dalam permainan, lotre, dan generasi unik dari"
" NFT. Untuk mengatasi ini, fungsi acak yang dapat diverifikasi (VRFs) "
"disediakan oleh peramal menawarkan solusi. VRF menjamin bahwa acak tidak "
"dapat diprediksi atau dirusak dengan, memastikan kepercayaan dan "
"transparansi dalam aplikasi ini."

#: src/ch16-05-02-randomness.md:5
msgid "Overview on VRFs"
msgstr "Ringkasan pada VRF"

#: src/ch16-05-02-randomness.md:7
msgid ""
"Pseudo-random but secure: VRFs use a secret key and a nonce (a unique input)"
" to generate an output that appears random. While technically 'pseudo-"
"random', it's practically impossible for another party to predict the "
"outcome without knowing the secret key."
msgstr ""
"Pseudo-random but secure: VRFs menggunakan kunci rahasia dan nonce (input "
"unik) untuk menghasilkan keluaran yang muncul secara acak. Sementara secara "
"teknis 'pseudo-random', hampir mustahil bagi partai lain untuk memprediksi "
"hasil tanpa mengetahui kunci rahasia."

#: src/ch16-05-02-randomness.md:9
msgid ""
"Verifiable output: VRFs produce not only the random number but also a proof "
"that anyone can use to independently verify that the result was generated "
"correctly according to the function's parameters."
msgstr ""
"Keluaran terverifikasi: VRFs menghasilkan tidak hanya angka acak tetapi juga"
" bukti yang dapat digunakan untuk memverifikasi secara independen bahwa "
"hasil dihasilkan dengan benar sesuai dengan parameter fungsi."

#: src/ch16-05-02-randomness.md:11
msgid "Generating Randomness with Pragma"
msgstr "Menjangkitkan Keacakan dengan Pragma"

#: src/ch16-05-02-randomness.md:13
msgid ""
"[Pragma](https://www.pragma.build/), an oracle on Starknet provides a "
"solution for generating random numbers using VRFs. Let's dive into how to "
"use Pragma VRF to generate a random number in a simple dice game contract."
msgstr ""
"[Pragma] Cresthttps://www.pragma.build/), sebuah peramal di Starknet "
"menyediakan solusi untuk menghasilkan angka acak menggunakan VRFs. Mari kita"
" menyelam ke dalam bagaimana menggunakan Pragma VRF untuk menghasilkan angka"
" acak dalam kontrak permainan dadu sederhana."

#: src/ch16-05-02-randomness.md:16
msgid "Add Pragma as a Dependency"
msgstr "Tambahkan Pragma sebagai Ketergantungan"

#: src/ch16-05-02-randomness.md:18
msgid ""
"Edit your cairo project's `Scarb.toml` file to include the path to use "
"Pragma."
msgstr ""
"Edit berkas proyek cairo Anda tentang Scarb.toml.toml untuk menyertakan "
"jalur untuk menggunakan Pragma."

#: src/ch16-05-02-randomness.md:61
msgid ""
"<span class=\"caption\">Listing 16-5 shows a contract interfaces for Pragma "
"VRF and a simple dice game.</span>"
msgstr ""
"<span class=\"caption\">Listing 16-5 menunjukkan antarmuka kontrak untuk "
"Pragma VRF dan permainan dadu sederhana.</span>"

#: src/ch16-05-02-randomness.md:63
msgid "Description of Key IPragmaVRF Entrypoints and Their Inputs"
msgstr "Keterangan Entri IPragmaVRF dan Masukan Mereka"

#: src/ch16-05-02-randomness.md:65
msgid ""
"The function `request_randomness_from_pragma` initiates a request for "
"verifiable randomness from the Pragma oracle. It does this by emitting an "
"event that triggers the following actions off-chain:"
msgstr ""
"Fungsi ·request_randomness_from_pragma-- memulai permintaan untuk "
"diverifikasi acak dari Pragma Oracle. Ini dilakukan dengan memancarkan "
"peristiwa yang memicu aksi berikut off-chain:"

#: src/ch16-05-02-randomness.md:67
msgid ""
"Randomness generation: The oracle generates random values and a "
"corresponding proof."
msgstr "Generasi acak: Peramal menghasilkan nilai acak dan bukti yang sesuai."

#: src/ch16-05-02-randomness.md:68
msgid ""
"On-chain submission: The oracle submits the generated randomness and proof "
"back to the blockchain via the `receive_random_words` callback function."
msgstr ""
"On-chain submission: The oracle submits the random submits the randenness "
"and product back to the block chain melalui fungsi callback "
"éreceive_random_words."

#: src/ch16-05-02-randomness.md:70
msgid "`request_randomness_from_pragma` Inputs"
msgstr "Permintaan_randomness_from_pragma thoseputs"

#: src/ch16-05-02-randomness.md:72
msgid ""
"`seed`: A value used to initialize the randomness generation process. This "
"should be unique to ensure unpredictable results."
msgstr "Ini harus unik untuk memastikan hasil yang tak terduga."

#: src/ch16-05-02-randomness.md:73
msgid ""
"`callback_address`: The contract address where the `receive_random_words` "
"function will be called to deliver the generated randomness. It is typically"
" the address of your deployed contract implementing Pragma VRF."
msgstr ""
"Panggilan kembali_address): Alamat kontrak di mana fungsi pemegang kontrak "
"yang digunakan akan dipanggil untuk menyampaikan keacakan yang dihasilkan. "
"Ini biasanya adalah alamat kontrak anda yang digunakan untuk "
"mengimplementasikan Pragma VRF."

#: src/ch16-05-02-randomness.md:74
msgid ""
"`callback_fee_limit`: The maximum amount of gas you're willing to spend on "
"executing the `receive_random_words` callback function."
msgstr ""
"Panggilkembali_fee_limit: Jumlah maksimum gas yang akan Anda habiskan untuk "
"menjalankan fungsi panggilan kembali."

#: src/ch16-05-02-randomness.md:75
msgid ""
"`publish_delay`: The minimum delay (in blocks) between requesting randomness"
" and the oracle fulfilling the request."
msgstr ""
"Penundaan minimum (dalam blok) antara meminta acak dan peramal memenuhi "
"permintaan."

#: src/ch16-05-02-randomness.md:76
msgid ""
"`num_words`: The number of random values (each represented as a `felt252`) "
"you want to receive in a single callback."
msgstr ""
"Jumlah nilai acak (masing-masing diwakili sebagai ± 252) Anda ingin menerima"
" satu callback."

#: src/ch16-05-02-randomness.md:77
msgid ""
"`calldata`: Additional data you want to pass to the `receive_random_words` "
"callback function."
msgstr ""
"Data tambahan yang ingin Anda sampaikan ke fungsi pemanggilan balik "
"·receive_random_words_words_nego."

#: src/ch16-05-02-randomness.md:79
msgid "`receive_randomn_words` Inputs"
msgstr "Masukan_randomn_words_receive"

#: src/ch16-05-02-randomness.md:81
msgid ""
"`requester_address`: The contract address that initiated the randomness "
"request."
msgstr "Alamat kontrak yang memulai permintaan acak."

#: src/ch16-05-02-randomness.md:82
msgid "`request_id`: A unique identifier assigned to the randomness request."
msgstr "Identifier unik yang ditugaskan untuk permintaan acak."

#: src/ch16-05-02-randomness.md:83
msgid ""
"`random_words`:  An array (span) of the generated random values (represented"
" as `felt252`)."
msgstr ""
"A array (span) dari nilai acak yang dihasilkan (diwakilkan sebagai "
"▪felt252)."

#: src/ch16-05-02-randomness.md:84
msgid ""
"`calldata`:  Additional data passed along with the initial randomness "
"request."
msgstr "Data tambahan diteruskan dengan permintaan acak awal."

#: src/ch16-05-02-randomness.md:86
msgid "Dice Game Contract"
msgstr "Dice Game Contract"

#: src/ch16-05-02-randomness.md:88
msgid ""
"This dice game contract allows players to guess a number between 1 & 6 "
"during an active game window. The contract owner then has the ability to "
"toggle the game window to disable new guesses from players. To determine the"
" winning number, the contract owner calls the "
"`request_randomness_from_pragma` function to request a random number from "
"the Pragma VRF oracle. Once the random number is received through the "
"`receive_random_words` callback function, it is stored in the "
"`last_random_number` storage variable. Each player has to call "
"`process_game_winners` function to determine if they have won or lost. The "
"`last_random_number` generated is then reduced to a number between 1 & 6, "
"and compared to the guesses of the players stored in the `user_guesses` "
"mapping, which leads to the emission of an event `GameWinner` or `GameLost`."
msgstr ""
"Kontrak dadu ini memungkinkan para pemain untuk menebak angka antara 1 & 6 "
"selama sebuah jendela permainan aktif. Pemilik kontrak kemudian memiliki "
"kemampuan untuk mengubah jendela permainan untuk menonaktifkan perkiraan "
"baru dari pemain. Untuk menentukan nomor pemenang, pemilik kontrak memanggil"
" fungsi Árequest_randomness_from_pragma--dari fungsi untuk meminta nomor "
"acak dari Pragma VRF Oracle. Setelah jumlah acak diterima melalui "
"Á_ranive_randomback fungsi panggilan, itu disimpan di "
"Álast_random_random_condom. Setiap pemutar harus memanggil Ás_winner untuk "
"menentukan apakah mereka telah kehilangan atau terakhir."

#: src/ch16-05-02-randomness.md:223
msgid ""
"// Approve the randomness contract to transfer the callback fee\n"
"            // You would need to send some ETH to this contract first to cover the fees\n"
msgstr ""
"//Setujui kontrak acak untuk mentransfer biaya callback //Anda perlu "
"mengirim beberapa ETH ke kontrak ini terlebih dahulu untuk menutupi biaya\n"

#: src/ch16-05-02-randomness.md:236
msgid "// Request the randomness\n"
msgstr "//Permintaan keacakan\n"

#: src/ch16-05-02-randomness.md:253
msgid ""
"// Have to make sure that the caller is the Pragma Randomness Oracle "
"contract\n"
msgstr "//Harus memastikan bahwa penelpon adalah kontrak Pragma Acak Oracle\n"

#: src/ch16-05-02-randomness.md:259
msgid ""
"// and that the current block is within publish_delay of the request block\n"
msgstr ""
"///dan bahwa blok saat ini berada dalam mempublikasikan_delay dari blok "
"permintaan\n"

#: src/ch16-05-02-randomness.md:273
msgid "// ETH Contract Address            \n"
msgstr "//Alamat Kontrak ETH\n"

#: src/ch16-05-02-randomness.md:282
msgid ""
"<span class=\"caption\">Listing 16-6: Simple Dice Game Contract using Pragma"
" VRF.</span>"
msgstr ""
"<span class=\"caption\">Listing 16-6: Simple Dice Game Contract menggunakan "
"Pragma VRF.</span>"

#: src/ch16-05-02-randomness.md:284
msgid "NB: Fund Your Contract After Deployment to Utilize Pragma VRF"
msgstr "NB: Fund Your Contract After Deployment to Utilize Pragma VRF"

#: src/ch16-05-02-randomness.md:286
msgid ""
"After deploying your contract that includes Pragma VRF functionalities, "
"ensure it holds sufficient ETH to cover the expenses related to requesting "
"random values. Pragma VRF requires payment for both generating the random "
"numbers and executing the callback function defined in your contract."
msgstr ""
"Setelah menyebarkan kontrak yang termasuk fungsionalitas Pragma VRF, "
"pastikan memiliki cukup ETH untuk menutupi biaya yang berhubungan dengan "
"meminta nilai acak. Pragma VRF membutuhkan pembayaran untuk kedua "
"menghasilkan nomor acak dan mengeksekusi fungsi callback didefinisikan dalam"
" kontrak Anda."

#: src/ch16-05-02-randomness.md:288
msgid ""
"For more information, please refer to the "
"[Pragma](https://docs.pragma.build/Resources/Cairo%201/randomness/randomness)"
" docs."
msgstr ""
"Untuk informasi lebih lanjut, silakan lihat dokumen "
"[Pragma][Pragma]://docs.pragma.build/Resources/Cairo%201/randomness/randomness)."

#: src/ch16-06-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, "
"utilizing various features of the Cairo programming language. Your "
"contributions are welcome and encouraged, as we aim to gather as many "
"diverse examples as possible."
msgstr ""
"Bagian ini berisi contoh tambahan kontrak cerdas Starknet, memanfaatkan "
"berbagai fitur bahasa pemrograman Cairo. kontribusi Anda diterima dan "
"dianjurkan, karena kami bertujuan untuk mengumpulkan sebanyak mungkin contoh"
" yang berbeda."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:1
msgid "Deploying and Interacting with a Voting contract"
msgstr "Menyebarkan dan Interacting dengan kontrak Voting"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the"
" contract's constructor. Three voters are initialized at this stage, and "
"their addresses are passed to an internal function **`_register_voters`**. "
"This function adds the voters to the contract's state, marking them as "
"registered and eligible to vote."
msgstr ""
"Kontrak **Vote** di Starknet dimulai dengan mendaftarkan pemilih melalui "
"konstruktor kontrak. Tiga pemilih diinisialisasi pada tahap ini, dan alamat "
"mereka dilewatkan ke fungsi internal ***_register_voters**. Fungsi ini "
"menambahkan pemilih ke negara kontrak, menandai mereka terdaftar dan "
"memenuhi syarat untuk memilih."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to "
"represent the voting options (1 and 0, respectively). These constants "
"facilitate the voting process by standardizing the input values."
msgstr ""
"Dalam kontrak, konstanta **YES** **no_** didefinisikan untuk mewakili "
"pilihan pemilih (1 dan 0, masing-masing). Konstanta ini memfasilitasi proses"
" pemilihan dengan standarisasi nilai masukan."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** "
"function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting,"
" the state of the contract is updated, recording the vote and marking the "
"voter as having voted. This ensures that the voter is not able to cast a "
"vote again within the same proposal. The casting of a vote triggers the "
"**`VoteCast`** event, logging the action."
msgstr ""
"Setelah terdaftar, seorang pemilih dapat memberikan suara menggunakan fungsi"
" **ívote**, memilih salah satu (YES) atau 0 (NO) sebagai suara mereka. "
"Ketika pemungut suara, keadaan kontrak diperbarui, merekam suara dan "
"menandai pemilih sebagai memiliki suara. Hal ini memastikan bahwa pemilih "
"tidak dapat memberikan suara dalam proposal yang sama."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized "
"action is detected, such as a non-registered user attempting to vote or a "
"user trying to vote again, the **`UnauthorizedAttempt`** event is emitted."
msgstr ""
"Kontraknya juga memonitor upaya pemungutan suara yang tidak sah. Jika aksi "
"yang tidak sah terdeteksi, seperti pengguna yang tidak terdaftar mencoba "
"memilih atau pengguna yang mencoba untuk memilih lagi, acara yang **Tak "
"berwenang Dipancarkan."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured"
" voting system, managing the lifecycle of a vote from registration to "
"casting, event logging, and result retrieval within the Starknet "
"environment. Constants like **`YES`** and **`NO`** help streamline the "
"voting process, while events play a vital role in ensuring transparency and "
"traceability."
msgstr ""
"Bersama-sama, fungsi-fungsi ini, negara bagian, konstan, dan peristiwa-"
"peristiwa menciptakan sistem suara yang terstruktur, mengelola siklus hidup "
"dari pendaftaran ke pengecoran, pencatatan peristiwa, dan menghasilkan "
"penerimaan dalam lingkungan Starknet. konstan seperti ** YAS**** dan ** NO**"
" membantu streamkan proses pemilihan, sementara peristiwa memainkan peran "
"penting dalam memastikan transparansi dan keterjejakan."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:13
msgid "Listing 16-7 shows the `Vote` contract in detail:"
msgstr "Terdaftar 16-7 menunjukkan kontrak åVoteáne secara detail:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:16
msgid ""
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
msgstr "// @dev Core Library Import untuk Traits diluar Kontrak Starknet\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:18
msgid ""
"/// @dev Trait defining the functions that can be implemented or called by "
"the Starknet Contract\n"
msgstr ""
"// @dev Trait mendefinisikan fungsi yang dapat diimplementasikan atau "
"dipanggil oleh Starknet Contract\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:22
msgid "/// @dev Function that returns the current vote status\n"
msgstr "// @dev Fungsi yang mengembalikan status suara saat ini\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:24
msgid ""
"/// @dev Function that checks if the user at the specified address is "
"allowed to vote\n"
msgstr ""
"// @dev Fungsi yang memeriksa jika pengguna pada alamat yang dinyatakan "
"diijinkan untuk memilih\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:26
msgid ""
"/// @dev Function that checks if the specified address is registered as a "
"voter\n"
msgstr ""
"// @dev Fungsi yang memeriksa jika alamat yang dinyatakan terdaftar sebagai "
"pemilih\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:28
msgid "/// @dev Function that allows a user to vote\n"
msgstr "// @dev Fungsi yang memungkinkan pengguna untuk memilih\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:31
msgid ""
"/// @dev Starknet Contract allowing three registered voters to vote on a "
"proposal\n"
msgstr ""
"// @dev Starknet Kontrak memungkinkan tiga pemilih terdaftar untuk memilih "
"proposal\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:41
msgid "/// @dev Structure that stores vote counts and voter states\n"
msgstr "// @dev Struktur yang menyimpan jumlah suara dan keadaan pemilih\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:50
msgid ""
"/// @dev Contract constructor initializing the contract with a list of "
"registered voters and 0 vote count\n"
msgstr ""
"// @dev Constructor menginisialisasi kontrak dengan daftar pemilih terdaftar"
" dan 0 jumlah suara\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:58
msgid "// Register all voters by calling the _register_voters function\n"
msgstr "// Register semua pemilih dengan memanggil fungsi _register_voters\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:61
msgid "// Initialize the vote count to 0\n"
msgstr "//Inisialisasi hitungan suara ke 0\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:66
msgid "/// @dev Event that gets emitted when a vote is cast\n"
msgstr ""
"// @dev Event yang akan dipancarkan ketika pemungutan suara dilemparkan\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:74
msgid "/// @dev Represents a vote that was cast\n"
msgstr "// @dev Mewakili pemungutan suara yang dilemparkan\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:81
msgid "/// @dev Represents an unauthorized attempt to vote\n"
msgstr "/// @dev Mewakili usaha yang tidak sah untuk memilih\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:87
msgid "/// @dev Implementation of VoteTrait for ContractState\n"
msgstr "// @dev Implementation of VoteTrait for ContractState\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:90
msgid "/// @dev Returns the voting results\n"
msgstr "// @dev Mengembalikan hasil voting\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:97
msgid "/// @dev Check whether a voter is allowed to vote\n"
msgstr "/// @dev Periksa apakah pemilih diijinkan untuk memilih\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:102
msgid "/// @dev Check whether an address is registered as a voter\n"
msgstr "/// @dev Periksa apakah alamat terdaftar sebagai pemilih\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:107
msgid "/// @dev Submit a vote\n"
msgstr "// @dev Kirim suara\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:109
msgid "\"VOTE_0_OR_1\""
msgstr "\"VOTE_0_OR_1\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:125
msgid "/// @dev Internal Functions implementation for the Vote contract\n"
msgstr "// @dev Fungsi Internal implementasi untuk kontrak Vote\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:128
msgid ""
"/// @dev Registers the voters and initializes their voting status to true "
"(can vote)\n"
msgstr ""
"// @dev Register pemilih dan menginisialisasi status suara mereka ke true "
"(dapat memilih)\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:146
msgid "/// @dev Asserts implementation for the Vote contract\n"
msgstr "// @dev Asserts implementasi untuk kontrak Voting\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:149
msgid "// @dev Internal function that checks if an address is allowed to vote\n"
msgstr ""
"// @dev Internal fungsi yang memeriksa jika alamat diijinkan untuk memilih\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:158
msgid "\"USER_NOT_REGISTERED\""
msgstr "\"USER_NOT_REGISTERED\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:159
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:440
msgid "\"USER_ALREADY_VOTED\""
msgstr "\"USER_ALREADY_VOTED\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:163
msgid "/// @dev Implement the VotingResultTrait for the Vote contract\n"
msgstr "// @dev Implementasi VotingReultTrait untuk kontrak Voting\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:166
msgid ""
"// @dev Internal function to get the voting results (yes and no vote "
"counts)\n"
msgstr ""
"// @dev Internal fungsi untuk mendapatkan hasil voting (ya dan tidak ada "
"jumlah suara)\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:174
msgid ""
"// @dev Internal function to calculate the voting results in percentage\n"
msgstr ""
"// @dev Internal fungsi untuk menghitung hasil voting dalam persentase\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:192
msgid "<span class=\"caption\">Listing 16-7: A voting smart contract</span>"
msgstr "<span class=\"caption\">Listing 16-7: Sebuah kontrak pintar voting</span>"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:194
msgid "Deploying, Calling and Invoking the Voting Contract"
msgstr "Menyebarkan, Memanggil dan Memanggil Kontrak Voting"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:196
msgid ""
"Part of the Starknet experience is deploying and interacting with smart "
"contracts."
msgstr ""
"Bagian dari pengalaman Starknet adalah menyebarkan dan berinteraksi dengan "
"kontrak cerdas."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:198
msgid ""
"Once the contract is deployed, we can interact with it by calling and "
"invoking its functions:"
msgstr ""
"Setelah kontrak dikerahkan, kita dapat berinteraksi dengan itu dengan "
"memanggil dan memanggil fungsinya:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:200
msgid ""
"Calling contracts: Interacting with external functions that only read from "
"the state. These functions do not alter the state of the network, so they "
"don't require fees or signing."
msgstr ""
"Memanggil kontrak: Interakting dengan fungsi eksternal yang hanya dibaca "
"dari negara. Fungsi ini tidak mengubah keadaan jaringan, sehingga mereka "
"tidak memerlukan biaya atau penandatanganan."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:201
msgid ""
"Invoking contracts: Interacting with external functions that can write to "
"the state. These functions do alter the state of the network and require "
"fees and signing."
msgstr ""
"Mendaftar kontrak: Berinteraksi dengan fungsi eksternal yang dapat menulis "
"ke negara. Fungsi-fungsi ini mengubah keadaan jaringan dan memerlukan biaya "
"dan penandatanganan."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:203
msgid ""
"We will setup a local development node using `katana` to deploy the voting "
"contract. Then, we'll interact with the contract by calling and invoking its"
" functions. You can also use the Goerli Testnet instead of `katana`. "
"However, we recommend using `katana` for local development and testing. You "
"can find the complete tutorial for `katana` in the [\"Katana: A Local "
"Node\"](https://book.starknet.io/ch02-04-katana.html) chapter of the "
"Starknet Book."
msgstr ""
"Kita akan membuat node pengembangan lokal menggunakan kode Goerli Testnet "
"sebagai ganti Ékatana. namun, kita merekomendasikan untuk mengembangkan dan "
"menguji lokal. kamu dapat menemukan tutorial lengkap untuk ▪katana di "
"[\"Katana: A Localde\"://https.startbook.stark.io/04-katana.html) bab "
"Starknet."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:207
msgid "The `katana` Local Starknet Node"
msgstr "Node Local Starknet."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:209
msgid ""
"`katana` is designed to support local development by the [Dojo "
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana). It will "
"allow you to do everything you need to do with Starknet, but locally. It is "
"a great tool for development and testing."
msgstr ""
"Katarana dirancang untuk mendukung pembangunan lokal oleh [Dojo "
"tim][Dojohttps://gitub.com/dojoeng/dob/main/crates/katana). Ini akan "
"memungkinkan Anda untuk melakukan segala sesuatu yang perlu Anda lakukan "
"dengan Starknet, tapi secara lokal. Ini adalah alat yang hebat untuk "
"pengembangan dan pengujian."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:211
msgid ""
"To install `katana` from the source code, please refer to the [\"Basic "
"Installation\"](https://book.starknet.io/ch02-01-basic-"
"installation.html#katana-node-installation) chapter of the Starknet Book."
msgstr ""
"Untuk instal åhttps://book.starknet.io/ch02-01-basic-"
"installation.html#katana-installation) bab dari Starknet Book."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:213
msgid ""
"Note: Please verify that the version of `katana` match the specified version"
" provided below."
msgstr ""
"Catatan: Silakan periksa apakah versi åkatana cocok dengan versi yang "
"tercantum di bawah ini."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:220
msgid ""
"To upgrade `katana` version, refer to the [\"Basic "
"Installation\"](https://book.starknet.io/ch02-01-basic-"
"installation.html#katana-node-installation) chapter of the Starknet Book."
msgstr ""
"Untuk meng-upgrade versi ókatana, merujuk ke [\"Instalasi "
"Basic\"]][https://book.starknet.io/ch02-01-basic-instalation.html#katana-"
"node-installation) bab dari buku Starknet."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:222
msgid ""
"Once you have `katana` installed, you can start the local Starknet node "
"with:"
msgstr ""
"Setelah Anda memasang åkatana, Anda dapat memulai node lokal Starknet "
"dengan:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:228
msgid ""
"This command will start a local Starknet node with 3 deployed accounts. We "
"will use these accounts to deploy and interact with the voting contract:"
msgstr ""
"Perintah ini akan memulai node Starknet lokal dengan 3 akun yang dikerahkan."
" kami akan menggunakan akun ini untuk menyebarkan dan berinteraksi dengan "
"kontrak pemungutan suara:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:233
msgid "================="
msgstr "===================="

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:249
msgid ""
"Before we can interact with the voting contract, we need to prepare the "
"voter and admin accounts on Starknet. Each voter account must be registered "
"and sufficiently funded for voting. For a more detailed understanding of how"
" accounts operate with Account Abstraction, refer to the [\"Account "
"Abstraction\"](https://book.starknet.io/ch04-00-account-abstraction.html) "
"chapter of the Starknet Book."
msgstr ""
"Sebelum kita dapat berinteraksi dengan kontrak suara, kita perlu "
"mempersiapkan akun pemilih dan admin di Starknet. Setiap akun pemilih harus "
"terdaftar dan cukup didanai untuk pemilihan. Untuk pemahaman yang lebih "
"rinci tentang bagaimana akun beroperasi dengan Abstraksi Akun, mengacu ke "
"bab [\"Account Abstraction\"]://https.Starknet.io/ch04-account-"
"abstraction.htl) bab buku Starknet."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:255
msgid "Smart Wallets for Voting"
msgstr "Dompet Pintar untuk Voting"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:257
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a "
"command line tool that allows you to interact with Starknet. You can find "
"the installation instructions in the \\[\"Basic Installation\"\\]\\[starkli "
"installation\\] chapter of the Starknet Book."
msgstr ""
"Selain Scarb Anda perlu memasang Starkli. Starkli adalah alat baris perintah"
" yang memungkinkan Anda berinteraksi dengan Starknet. Anda dapat menemukan "
"instruksi instalasi dalam \\[\"Peninstalan Basic\"\\]\\[starkli instalasi\\]"
" bab dari Starknet Book."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:259
msgid ""
"Note: Please verify that the version of `starkli` match the specified "
"version provided below."
msgstr ""
"Catatan: Silakan periksa apakah versi åstarkli cocok dengan versi yang "
"tercantum di bawah ini."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:266
msgid ""
"To upgrade `starkli` to `0.2.9`, use the `starkliup -v 0.2.9` command, or "
"simply `starkliup` which installed the latest stable version."
msgstr ""
"Untuk meng-upgrade thosestarkli menjadi 0.2.9.9, gunakan perintah 0.2.9.9, "
"atau hanya \"starkliup.\" yang menginstal versi stabil terbaru."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:268
msgid ""
"For each smart wallet we'll use, we must create a Signer within the "
"encrypted keystore and an Account Descriptor. This process is also detailed "
"in the \\[\"Testnet Deployment\"\\]\\[signer creation\\] chapter of the "
"Starknet Book."
msgstr ""
"Untuk setiap dompet pintar yang akan kita gunakan, kita harus membuat "
"penanda dalam toko kunci terenkripsi dan akun Descriptor. Proses ini juga "
"rinci dalam \\[\"Testnet Deployment\"\\]\\[penciptaan\\] bab dari Starknet "
"Book."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:270
msgid ""
"We can create Signers and Account Descriptors for the accounts we want to "
"use for voting. Let's create a smart wallet for voting in our smart "
"contract."
msgstr ""
"Kita dapat membuat Signers dan Akun Descriptor untuk akun yang ingin kita "
"gunakan untuk memilih."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:272
msgid "Firstly, we create a signer from a private key:"
msgstr "Pertama, kami membuat penandatangan dari kunci privat:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:278
msgid ""
"Then, we create the Account Descriptor by fetching the katana account we "
"want to use:"
msgstr ""
"Lalu, kami membuat Akun Descriptor dengan mengambil akun katana yang ingin "
"kami gunakan:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:284
msgid ""
"This command will create a new `account0_account.json` file containing the "
"following details:"
msgstr ""
"Perintah ini akan membuat sebuah berkas baru yang berisi rincian berikut:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:288
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:291
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:401
msgid "\"version\""
msgstr "\"versi\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:289
msgid "\"variant\""
msgstr "\"varian\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:290
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:407
msgid "\"type\""
msgstr "\"type\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:290
msgid "\"open_zeppelin\""
msgstr "\"open_zeplon\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:292
msgid "\"public_key\""
msgstr "Kunci_publik"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:292
msgid "\"<SMART_WALLET_PUBLIC_KEY>\""
msgstr "\"<SMART_WALLET_PUBLIC_KEY>\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:294
msgid "\"deployment\""
msgstr "\"kekurangan pekerjaan\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:295
msgid "\"status\""
msgstr "\"status\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:295
msgid "\"deployed\""
msgstr "\"lenyapkan\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:296
msgid "\"class_hash\""
msgstr "\"class_hash\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:296
msgid "\"<SMART_WALLET_CLASS_HASH>\""
msgstr "\"<SMART_WALLET_CLASS_HASH>\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:297
msgid "\"address\""
msgstr "\"alamat\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:297
msgid "\"<SMART_WALLET_ADDRESS>\""
msgstr "\"<SMART_WALLET_ADDRESS>\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:302
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all "
"your smart wallets) with the following command. Notice the use of the "
"`--rpc` flag and the RPC endpoint provided by `katana`:"
msgstr ""
"Anda dapat mengambil hash dompet cerdas (akan sama untuk semua dompet pintar"
" Anda) dengan perintah berikut."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:304
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr "▪ starcli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0:50"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:308
msgid ""
"For the public key, you can use the `starkli signer keystore inspect` "
"command with the directory of the keystore json file:"
msgstr ""
"Untuk kunci publik, Anda dapat menggunakan kunci penyimpanan kunci dari "
"berkas json penyimpanan kunci:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:314
msgid ""
"This process is identical for `account_1` and `account_2` in case you want "
"to have a second and a third voter."
msgstr ""
"Proses ini identik dengan proses yang terjadi pada pemilih kedua dan ketiga."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:316
msgid ""
"\\[starkli installation\\]: https://book.starknet.io/ch02-01-basic-"
"installation.html#starkli-installation) \\[signer creation\\]: "
"https://book.starknet.io/ch02-05-testnet-"
"deployment.html?highlight=signer#creating-a-signer"
msgstr ""
"\\[starkli\\]: https://book.starknet.io/ch02-01-basic-"
"installation.html#starkli-installation) \\ \\[signer pembuatan\\]: "
"https://book.starknet.io/ch02-05-testestnet-"
"deployment.html?highlight=signing-a-signer"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:319
msgid "Contract Deployment"
msgstr "Penyebaran Kontrak"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:321
msgid ""
"Before deploying, we need to declare the contract. We can do this with the "
"`starkli declare` command:"
msgstr "Sebelum menyebarkannya, kita harus mengumumkan kontraknya."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:327
msgid ""
"If the compiler version you're using is older than the one used by Starkli "
"and you encounter a `compiler-version` error while using the command above, "
"you can specify a compiler version to use in the command by adding the "
"`--compiler-version x.y.z` flag."
msgstr ""
"Jika versi kompiler yang Anda gunakan lebih tua daripada versi yang "
"digunakan oleh Starkli dan Anda menghadapi kesalahan kompiler-version ketika"
" menggunakan perintah di atas, Anda dapat menentukan versi kompiler untuk "
"digunakan dalam perintah dengan menambahkan - kompiler-version x.y.zán."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:329
msgid ""
"If you're still encountering issues with the compiler version, try upgrading"
" Starkli using the command: `starkliup` to make sure you're using the latest"
" version of starkli."
msgstr ""
"Jika Anda masih menghadapi masalah dengan versi kompiler, coba tingkatkan "
"Starkli menggunakan perintah: Ástarkliupà untuk memastikan Anda menggunakan "
"versi terbaru starkli."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:331
msgid ""
"The class hash of the contract is: "
"`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You "
"can declare this contract on Sepolia testnet and see that the class hash "
"will correspond."
msgstr ""
"Hash kelas kontrak adalah: "
"0x06974677a079b7edfad70a4da12aac0263a4cda379fca1ab1aba52. Anda dapat "
"menyatakan kontrak ini pada tesnet Sepolia dan melihat bahwa kelas hash akan"
" sesuai."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:333
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by "
"`katana`). The `--account` flag specifies the account to use for signing the"
" transaction. The account we use here is the one we created in the previous "
"step. The `--keystore` flag specifies the keystore file to use for signing "
"the transaction."
msgstr ""
"Flag RPC menspesifikasikan titik akhir untuk digunakan (yang disediakan oleh"
" ▪katana). Bendera ·--accountán menyatakan akun yang digunakan untuk "
"menandatangani transaksi. Akun yang kita gunakan di sini adalah yang kita "
"buat di langkah sebelumnya. Bendera --keystore Valentina menspesifikasikan "
"berkas keystore untuk menandatangani transaksi."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:335
msgid ""
"Since we are using a local node, the transaction will achieve finality "
"immediately. If you are using the Goerli Testnet, you will need to wait for "
"the transaction to be final, which usually takes a few seconds."
msgstr ""
"Karena kita menggunakan node lokal, transaksi akan mencapai finalitas "
"segera. yang biasanya membutuhkan beberapa detik."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:337
msgid ""
"The following command deploys the voting contract and registers voter_0, "
"voter_1, and voter_2 as eligible voters. These are the constructor "
"arguments, so add a voter account that you can later vote with."
msgstr ""
"Perintah berikut menyebarkan kontrak pemilihan dan register pemilih_0, "
"pemilih_1, dan pemilih_2 sebagai pemilih yang memenuhi syarat. Ini adalah "
"argumen konstruktor, jadi tambahkan akun pemilih yang dapat anda pilih "
"nanti."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:343
msgid "An example command:"
msgstr "Perintah contoh:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:349
msgid ""
"In this case, the contract has been deployed at an specific address: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This "
"address will be different for you. We will use this address to interact with"
" the contract."
msgstr ""
"Dalam hal ini, kontrak telah dikerahkan pada sebuah alamat spesifik: "
"0x05ea3a90be71c7c7fcd845551782188111C4611D13349. Alamat ini akan berbeda "
"untuk Anda. kami akan menggunakan alamat ini untuk berinteraksi dengan "
"kontrak."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:351
msgid "Voter Eligibility Verification"
msgstr "Verifikasi Eligibilitas Pemilih"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:353
msgid ""
"In our voting contract, we have two functions to validate voter eligibility,"
" `voter_can_vote` and `is_voter_registered`. These are external read "
"functions, which mean they don't alter the state of the contract but only "
"read the current state."
msgstr ""
"Dalam kontrak suara kami, kami memiliki dua fungsi untuk memvalidasi "
"keikutsertaan hak pilih, Ávoter_can_vote_vote dan æis_voter_listter. ini "
"adalah fungsi baca eksternal, yang berarti mereka tidak mengubah keadaan "
"kontrak tetapi hanya membaca keadaan saat ini."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:355
msgid ""
"The `is_voter_registered` function checks whether a particular address is "
"registered as an eligible voter in the contract. The `voter_can_vote` "
"function, on the other hand, checks whether the voter at a specific address "
"is currently eligible to vote, i.e., they are registered and haven't voted "
"already."
msgstr ""
"Fungsi åis_voter_listal_listed fungsi cek apakah alamat tertentu terdaftar "
"sebagai pemilih yang memenuhi syarat dalam kontrak. Fungsi tersebut akan "
"terdaftar_can_vote_vote, di sisi lain, memeriksa apakah pemilih pada alamat "
"tertentu saat ini memenuhi syarat untuk memilih, yaitu, mereka terdaftar dan"
" belum memilih sudah."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:357
msgid ""
"You can call these functions using the `starkli call` command. Note that the"
" `call` command is used for read functions, while the `invoke` command is "
"used for functions that can also write to storage. The `call` command does "
"not require signing, while the `invoke` command does."
msgstr ""
"Anda dapat memanggil fungsi-fungsi ini dengan menggunakan perintah åstarkli "
"panggilan. perhatikan bahwa perintah panggilan tersebut digunakan untuk "
"fungsi membaca, sementara perintah åinvoke digunakan untuk fungsi yang juga "
"dapat ditulis ke penyimpanan. perintah panggilan tidak memerlukan "
"penandatanganan, sementara perintah ▪invoke."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:359
msgid ""
"```bash+\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"0x05ea3a390be71c7fsd8395\\118111181111411411111111111113334 pemilih_can_vote"
" 0x03e9e18edc11x1111AC11111111f1111111111111111cd762E0 --rpc "
"http://0.0.0.0.0:50:50"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:363
msgid ""
"First we added the address of the contract, then the function we want to "
"call, and finally the input for the function. In this case, we are checking "
"whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can "
"vote."
msgstr ""
"Pertama kami menambahkan alamat kontrak, lalu fungsi yang ingin kami "
"hubungi, dan akhirnya masukan untuk fungsinya. dalam kasus ini, kami sedang "
"memeriksa apakah pemilih di alamat "
"0x03e9e18edca71a11ac3aca2E0b02a98bce19480a63a011Cd76652.0E0"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:365
msgid ""
"Since we provided a registered voter address as an input, the result is 1 "
"(boolean true), indicating the voter is eligible to vote."
msgstr ""
"Karena kami memberikan alamat pemilih terdaftar sebagai masukan, hasilnya "
"adalah 1 (kebenaran boolean), menunjukkan pemilih berhak untuk memilih."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:367
msgid ""
"Next, let's call the `is_voter_registered` function using an unregistered "
"account address to observe the output:"
msgstr ""
"Selanjutnya, mari kita sebut fungsi ▪is_voter_listed_register menggunakan "
"alamat akun tidak terdaftar untuk mengamati keluaran:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:373
msgid ""
"With an unregistered account address, the terminal output is 0 (i.e., "
"false), confirming that the account is not eligible to vote."
msgstr ""
"Dengan alamat akun yang tidak terdaftar, keluaran terminal adalah 0 (misal, "
"false), mengkonfirmasi bahwa akun tidak memenuhi syarat untuk memilih."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:375
msgid "Casting a Vote"
msgstr "Casting Voting"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:377
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! "
"To vote, we interact with the `vote` function, which is flagged as external,"
" necessitating the use of the `starknet invoke` command."
msgstr ""
"Sekarang kita telah menetapkan bagaimana untuk memverifikasi keikutsertaan "
"pemilih, kita dapat memilih! untuk memilih, kita berinteraksi dengan fungsi "
"åvoteó, yang ditandai sebagai eksternal, yang mengharuskan penggunaan "
"perintah åstarknet."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:379
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we"
" submit either `1` (for Yes) or `0` (for No) as our input. When we invoke "
"the `vote` function, we are charged a fee, and the transaction must be "
"signed by the voter; we are writing to the contract's storage."
msgstr ""
"Sintaks perintah ini mirip dengan perintah, tetapi untuk memilih, kita harus"
" menandatanganinya, atau untuk Ya, atau untuk No (untuk No) sebagai masukan "
"kita."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:389
msgid ""
"You will be prompted to enter the password for the signer. Once you enter "
"the password, the transaction will be signed and submitted to the Starknet "
"network. You will receive the transaction hash as output. With the starkli "
"transaction command, you can get more details about the transaction:"
msgstr ""
"Anda akan diminta untuk memasukkan sandi untuk penandatangan. Setelah Anda "
"memasukkan sandi, transaksi akan ditandatangani dan diserahkan ke jaringan "
"Starknet. Anda akan menerima hash transaksi sebagai keluaran. Dengan "
"perintah transaksi starkli, Anda dapat mendapatkan rincian lebih lanjut "
"tentang transaksi:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:395
msgid "This returns:"
msgstr "Kembalinya:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:399
msgid "\"transaction_hash\""
msgstr "\"Transaction_hash\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:399
msgid "\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""
msgstr "\"0x5604a972b6811060e70ed0b40959ea9E20c7220b526ec690de89907fd\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:400
msgid "\"max_fee\""
msgstr "\"max_fee\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:400
msgid "\"0x430e81\""
msgstr "\"0x430e81\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:401
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:410
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:414
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:415
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:416
msgid "\"0x1\""
msgstr "\"0x1\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:402
msgid "\"signature\""
msgstr "\"signature\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:403
msgid "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\""
msgstr "\"0x75e5e4880d7a8301b35ff4a1ed1E3d72fffefa64b6c306c31496e6e402d57\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:404
msgid "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""
msgstr "\"0xbbb6c459b35a535dd00d8ab13d7ed71273da4a8e9c1f4afe9b9b9f5454A6F51\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:406
msgid "\"nonce\""
msgstr "\"nonce\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:406
msgid "\"0x3\""
msgstr "\"0x3\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:407
msgid "\"INVOKE\""
msgstr "\"INVOKE\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:408
msgid "\"sender_address\""
msgstr "\"Sender_alamat\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:408
msgid "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""
msgstr "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fce19b7480a63a0d71cbd76652e0\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:409
msgid "\"calldata\""
msgstr "\"calldata\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:411
msgid "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""
msgstr "\"0x5ea3a3a690menjadi71c7fcd83945517f81f8188111111113349\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:412
msgid "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""
msgstr "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:413
msgid "\"0x0\""
msgstr "\"0x0\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:421
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr ""
"Jika Anda mencoba untuk memilih dua kali dengan penandatangan yang sama Anda"
" akan mendapatkan kesalahan:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:424
msgid "\"Contract error\""
msgstr "\"Kesalahan Kontract\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:427
msgid ""
"The error is not very informative, but you can get more details when looking"
" at the output in the terminal where you started `katana` (our local "
"Starknet node):"
msgstr ""
"Kesalahan tidak terlalu informatif, tetapi Anda bisa mendapatkan lebih "
"banyak rincian ketika melihat keluaran di terminal di mana Anda mulai "
"·katana-- (node Starknet lokal kami):"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:431
msgid ""
"\"Error in the called contract (0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
msgstr ""
"\"Error dalam kontrak yang disebut "
"(0x03ee9e18edc71a6df30ac3aca2a0a02a98fce19b74480a63a0d71cd76652e0): Error di"
" pc=0:81: Mendapat pengecualian saat mengeksekusi sebuah petunjuk: Custom "
"Hint Error: Eksekusi gagal. Alasan gagal: \"USER_ALREADY_VOWTED\\\"...\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:437
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr "Kunci untuk kesalahan ini adalah ÁUSER_ALREADY_VOTEDER."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:443
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the "
"accounts we want to use for voting. Remember that each Signer must be "
"created from a private key, and each Account Descriptor must be created from"
" a public key, a smart wallet address, and the smart wallet class hash "
"(which is the same for each voter)."
msgstr ""
"Kita dapat mengulangi proses untuk membuat penanda dan deskripsi akun untuk "
"akun yang ingin kita gunakan untuk memilih. ingatlah bahwa setiap "
"Penandatangan harus dibuat dari kunci pribadi, dan setiap Descriptor Akun "
"harus dibuat dari kunci publik, alamat dompet pintar, dan hash dompet pintar"
" (yang sama untuk setiap pemilih)."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:451
msgid "Visualizing Vote Outcomes"
msgstr "Visualizing Voting Outcomes"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:453
msgid ""
"To examine the voting results, we invoke the `get_vote_status` function, "
"another view function, through the `starknet call` command."
msgstr ""
"Untuk memeriksa hasil pemungutan suara, kami meminta perintah "
"åget_vote_status_status, fungsi tampilan lain, melalui panggilan åstarknet."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:459
msgid ""
"The output reveals the tally of \"Yes\" and \"No\" votes along with their "
"relative percentages."
msgstr ""
"Hasil mengungkapkan perhitungan \"Ya\" dan \"Tidak\" suara bersama dengan "
"persentase relatif mereka."

#: src/ch17-01-general-recommendations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually "
"straightforward. However, preventing unintended usage and vulnerabilities "
"can be more challenging."
msgstr ""
"Namun, mencegah penggunaan dan kerentanan yang tidak disengaja dapat lebih "
"menantang."

#: src/ch17-01-general-recommendations.md:5
msgid ""
"In smart contract development, security is very important. A single error "
"can result in the loss of valuable assets or the improper functioning of "
"certain features."
msgstr ""
"Dalam pengembangan kontrak yang cerdas, keamanan sangat penting. sebuah "
"kesalahan tunggal dapat mengakibatkan hilangnya aset berharga atau fungsi "
"yang tidak patut dari fitur-fitur tertentu."

#: src/ch17-01-general-recommendations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can "
"examine the code and interact with it. Any errors or vulnerabilities in the "
"code can be exploited by malicious actors."
msgstr ""
"Kontrak cerdas dijalankan dalam lingkungan publik di mana siapa pun dapat "
"memeriksa kode dan berinteraksi dengan itu. setiap kesalahan atau kerentanan"
" dalam kode dapat dieksploitasi oleh aktor jahat."

#: src/ch17-01-general-recommendations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart "
"contracts. By incorporating these concepts during development, you can "
"create robust and reliable smart contracts. This reduces the chance of "
"unexpected behavior or vulnerabilities."
msgstr ""
"Bab ini menyajikan rekomendasi umum untuk menulis kontrak cerdas yang aman. "
"Anda dapat menciptakan kontrak cerdas yang kuat dan dapat diandalkan. ini "
"mengurangi kemungkinan perilaku yang tak terduga atau kerentanan."

#: src/ch17-01-general-recommendations.md:11
msgid "Disclaimer"
msgstr "Disklaimer"

#: src/ch17-01-general-recommendations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security "
"issues, and it does not guarantee that your contracts will be completely "
"secure."
msgstr ""
"Pasal ini tidak menyediakan daftar lengkap dari semua kemungkinan masalah "
"keamanan, dan tidak menjamin bahwa kontrak Anda akan benar - benar aman."

#: src/ch17-01-general-recommendations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly "
"recommended to conduct external audits performed by security experts."
msgstr ""
"Jika Anda mengembangkan kontrak cerdas untuk penggunaan produksi, sangat "
"dianjurkan untuk melakukan audit eksternal yang dilakukan oleh para pakar "
"keamanan."

#: src/ch17-01-general-recommendations.md:17
msgid "Mindset"
msgstr "Mindset"

#: src/ch17-01-general-recommendations.md:19
msgid ""
"Cairo is a highly safe language inspired by Rust. It is designed in a way "
"that forces you to cover all possible cases. Security issues on Starknet "
"mostly arise from the way smart contract flows are designed, not much from "
"the language itself."
msgstr ""
"Cairo adalah bahasa yang sangat aman yang terinspirasi oleh Rust ini "
"dirancang dengan cara yang memaksa Anda untuk menutup semua kasus yang "
"mungkin masalah keamanan di Starknet sebagian besar muncul dari cara kontrak"
" pintar dirancang, tidak banyak dari bahasa itu sendiri."

#: src/ch17-01-general-recommendations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart "
"contracts. Try to always consider all possible scenarios when writing code."
msgstr ""
"Mengadopsi pola pikir keamanan adalah langkah awal dalam menulis kontrak "
"cerdas yang aman. Cobalah untuk selalu mempertimbangkan semua skenario yang "
"mungkin ketika menulis kode."

#: src/ch17-01-general-recommendations.md:23
msgid "Viewing Smart Contracts as Finite State Machines"
msgstr "Memandang Kontrak Cerdas sebagai Mesin Negara Bagian Finite"

#: src/ch17-01-general-recommendations.md:25
msgid ""
"Transactions in smart contracts are atomic, meaning they either succeed or "
"fail without making any changes."
msgstr ""
"Transaksi dalam kontrak pintar adalah atom, berarti mereka berhasil atau "
"gagal tanpa membuat perubahan apapun."

#: src/ch17-01-general-recommendations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial "
"states defined by the constructor constraints, and external functions "
"represent a set of possible state transitions. A transaction is nothing more"
" than a state transition."
msgstr ""
"Pikirkan kontrak cerdas sebagai mesin negara: mereka memiliki satu set "
"negara bagian awal didefinisikan oleh batasan konstruktor, dan fungsi "
"eksternal mewakili set kemungkinan transisi negara. transaksi tidak lebih "
"dari transisi negara."

#: src/ch17-01-general-recommendations.md:29
msgid ""
"The `assert!` or `panic!` macros can be used to validate conditions before "
"performing specific actions. You can learn more about these on the "
"[Unrecoverable Errors with panic](./ch09-01-unrecoverable-errors-with-"
"panic.md) page."
msgstr ""
"Makro dapat digunakan untuk memvalidasi kondisi sebelum melakukan aksi "
"tertentu. Anda dapat mempelajari lebih banyak tentang ini pada halaman [ "
"Error Tak Dapat Dicover dengan panik]./ch09-01-unrecoverable-erers-with-"
"panic.md)."

#: src/ch17-01-general-recommendations.md:31
msgid "These validations can include:"
msgstr "Validasi ini dapat mencakup:"

#: src/ch17-01-general-recommendations.md:33
msgid "Inputs provided by the caller"
msgstr "Masukan yang disediakan oleh pemanggil"

#: src/ch17-01-general-recommendations.md:34
msgid "Execution requirements"
msgstr "Eksekusi persyaratan"

#: src/ch17-01-general-recommendations.md:35
msgid "Invariants (conditions that must always be true)"
msgstr "Invarian (kondisi yang harus selalu benar)"

#: src/ch17-01-general-recommendations.md:36
msgid "Return values from other function calls"
msgstr "Nilai kembali dari pemanggilan fungsi lain"

#: src/ch17-01-general-recommendations.md:38
msgid ""
"For example, you could use the `assert!` macro to validate that a user has "
"enough funds to perform a withdraw transaction. If the condition is not met,"
" the transaction will fail and the state of the contract will not change."
msgstr ""
"Sebagai contoh, Anda bisa menggunakan makro untuk mengesahkan bahwa pengguna"
" memiliki dana yang cukup untuk melakukan transaksi penarikan."

#: src/ch17-01-general-recommendations.md:45
msgid "\"Insufficient funds\""
msgstr "\"Dana tidak cukup\""

#: src/ch17-01-general-recommendations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly"
" define the boundaries of possible state transitions for each function in "
"your smart contract. These checks ensure that the behavior of the contract "
"stays within the expected limits."
msgstr ""
"Menggunakan fungsi ini untuk memeriksa kondisi menambah batasan yang "
"membantu dengan jelas menentukan batas kemungkinan transisi keadaan untuk "
"setiap fungsi dalam kontrak pintar Anda. Cek ini memastikan bahwa perilaku "
"kontrak tetap dalam batas yang diharapkan."

#: src/ch17-01-general-recommendations.md:53
msgid "Recommendations"
msgstr "Rekomendasi"

#: src/ch17-01-general-recommendations.md:55
msgid "Checks Effects Interactions Pattern"
msgstr "Memeriksa Dampak Pola Interaksi"

#: src/ch17-01-general-recommendations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to "
"prevent reentrancy attacks on Ethereum. While reentrancy is harder to "
"achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""
"pola Checks Effects Interactions adalah pola desain umum yang digunakan "
"untuk mencegah serangan reentrancy pada Etherum. sementara reentrancy lebih "
"sulit untuk dicapai di Starknet, masih disarankan untuk menggunakan pola ini"
" dalam kontrak cerdas Anda."

#: src/ch17-01-general-recommendations.md:61
msgid ""
"The pattern consists of following a specific order of operations in your "
"functions:"
msgstr ""
"Pola terdiri dari mengikuti urutan spesifik operasi dalam fungsi Anda:"

#: src/ch17-01-general-recommendations.md:63
msgid ""
"**Checks**: Validate all conditions and inputs before performing any state "
"changes."
msgstr ""
"**Checks**: Validate semua kondisi dan masukan sebelum melakukan perubahan "
"keadaan."

#: src/ch17-01-general-recommendations.md:64
msgid "**Effects**: Perform all state changes."
msgstr "** Effects**: Lakukan semua perubahan keadaan."

#: src/ch17-01-general-recommendations.md:65
msgid ""
"**Interactions**: All external calls to other contracts should be made at "
"the end of the function."
msgstr ""
"Semua panggilan eksternal ke kontrak lain harus dibuat pada akhir fungsi."

#: src/ch17-01-general-recommendations.md:67
msgid "Access Control"
msgstr "Kontrol Akses"

#: src/ch17-01-general-recommendations.md:69
msgid ""
"Access control is the process of restricting access to certain features or "
"resources. It is a common security mechanism used to prevent unauthorized "
"access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""
"Kendali akses adalah proses membatasi akses ke fitur atau sumber daya "
"tertentu. Ini adalah mekanisme keamanan umum yang digunakan untuk mencegah "
"akses yang tidak sah terhadap informasi atau aksi yang sensitif. Dalam "
"kontrak cerdas, beberapa fungsi sering kali dibatasi oleh pengguna atau "
"peran tertentu."

#: src/ch17-01-general-recommendations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. "
"This pattern consists of defining a set of roles and assigning them to "
"specific users. Each function can then be restricted to specific roles."
msgstr ""
"Anda dapat mengimplementasikan pola kendali akses untuk mengelola hak akses "
"dengan mudah. Pola ini terdiri dari mendefinisikan satu set peran dan "
"memberikannya kepada pengguna tertentu. Setiap fungsi dapat dibatasi untuk "
"peran spesifik."

#: src/ch17-01-general-recommendations.md:92
msgid "// Role 'owner': only one address\n"
msgstr "//Kehendak 'owner': hanya satu alamat\n"

#: src/ch17-01-general-recommendations.md:94
msgid "// Role 'role_a': a set of addresses\n"
msgstr "//Gabung 'role_a': satu set alamat\n"

#: src/ch17-01-general-recommendations.md:103
msgid "// Guard functions to check roles\n"
msgstr "//Guard fungsi untuk memeriksa peran\n"

#: src/ch17-01-general-recommendations.md:118
msgid "\"Not owner\""
msgstr "\"Bukan pemilik\""

#: src/ch17-01-general-recommendations.md:123
msgid "\"Not role A\""
msgstr "\"Not role A\""

#: src/ch17-01-general-recommendations.md:126
msgid "// You can easily combine guards to perform complex checks\n"
msgstr ""
"//Anda dapat dengan mudah menggabungkan penjaga untuk melakukan pemeriksaan "
"kompleks\n"

#: src/ch17-01-general-recommendations.md:128
msgid "\"Not allowed\""
msgstr "\"Tidak diperbolehkan\""

#: src/ch17-01-general-recommendations.md:131
msgid "// Functions to manage roles\n"
msgstr "/ Fungsi untuk mengelola peran\n"

#: src/ch17-01-general-recommendations.md:138
msgid ""
"// You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
msgstr ""
"/Anda sekarang dapat fokus pada logika bisnis kontrak Anda / / dan "
"mengurangi kompleksitas kode Anda dengan menggunakan fungsi penjaga\n"

#: src/ch17-02-testing-smart-contracts.md:3
msgid ""
"Testing smart contracts is a critical part of the development process. It is"
" important to ensure that smart contracts behave as expected and that they "
"are secure."
msgstr ""
"Menguji kontrak cerdas adalah bagian penting dari proses pengembangan "
"penting untuk memastikan kontrak cerdas berperilaku seperti yang diharapkan "
"dan bahwa mereka aman."

#: src/ch17-02-testing-smart-contracts.md:5
msgid ""
"In a previous section of the Cairo Book, we learned how to write and "
"structure our tests for Cairo programs. We demonstrated how these tests "
"could be run using the `scarb` command-line tool. While this approach is "
"useful for testing standalone Cairo programs and functions, it lacks "
"functionality for testing smart contracts that require control over the "
"contract state and execution context. Therefore, in this section, we will "
"introduce how to use Starknet Foundry, a smart contract development "
"toolchain for Starknet, to test your Cairo contracts."
msgstr ""
"Dalam bagian sebelumnya dari Cairo Book, kami belajar cara menulis dan "
"menstruktur tes kami untuk program Cairo. kami menunjukkan bagaimana tes ini"
" dapat dijalankan menggunakan alat baris perintah. kami akan memperkenalkan "
"cara menggunakan Starknet Foundry, sebuah alat pengembangan kontrak cerdas "
"bagi Starknet, untuk menguji kontrak Anda di Cairo."

#: src/ch17-02-testing-smart-contracts.md:8
msgid ""
"Throughout this chapter, we will be using as an example the `PizzaFactory` "
"contract in Listing 17-1 to demonstrate how to write tests with Starknet "
"Foundry."
msgstr ""
"Di seluruh bab ini, kami akan menggunakan sebagai contoh kontrak "
"PizzaFactory dalam daftar 17-1 untuk menunjukkan bagaimana menulis tes "
"dengan Starknet Foundry."

#: src/ch17-02-testing-smart-contracts.md:59
#: src/ch17-02-testing-smart-contracts.md:64
msgid "\"Amount cannot be 0\""
msgstr "\"Amount cannot be 0\""

#: src/ch17-02-testing-smart-contracts.md:69
msgid "\"Not enough pepperoni\""
msgstr "\"Tidak cukup pepperoni\""

#: src/ch17-02-testing-smart-contracts.md:70
msgid "\"Not enough pineapple\""
msgstr "\"Tidak cukup nanas\""

#: src/ch17-02-testing-smart-contracts.md:75
#: src/ch17-02-testing-smart-contracts.md:210
#: src/ch17-02-testing-smart-contracts.md:326
#: src/ch17-02-testing-smart-contracts.md:438
#: src/ch17-02-testing-smart-contracts.md:550
#: src/ch17-02-testing-smart-contracts.md:664
msgid "\"Only the owner can make pizza\""
msgstr "\"Hanya pemilik yang bisa membuat pizza\""

#: src/ch17-02-testing-smart-contracts.md:101
#: src/ch17-02-testing-smart-contracts.md:200
#: src/ch17-02-testing-smart-contracts.md:316
#: src/ch17-02-testing-smart-contracts.md:428
#: src/ch17-02-testing-smart-contracts.md:540
#: src/ch17-02-testing-smart-contracts.md:654
msgid "\"Only the owner can set ownership\""
msgstr "\"Hanya pemilik yang dapat menetapkan kepemilikan\""

#: src/ch17-02-testing-smart-contracts.md:109
msgid ""
"<span class=\"caption\">Listing 17-1: A pizza factory that needs to be "
"tested</span>"
msgstr ""
"<span class=\"caption\">Listing 17-1: Sebuah pabrik pizza yang perlu "
"diuji</span>"

#: src/ch17-02-testing-smart-contracts.md:111
msgid "Configuring your Scarb project with Starknet Foundry"
msgstr "Menata proyek Scarb Anda dengan Starknet Foundry"

#: src/ch17-02-testing-smart-contracts.md:113
msgid ""
"The settings of your Scarb project can be configured in the `Scarb.toml` "
"file. To use Starknet Foundry as your testing tool, you will need to add it "
"as a dev dependency in your `Scarb.toml` file. At the time of writing, the "
"latest version of Starknet Foundry is `v0.22.0` - but you should use the "
"latest version."
msgstr ""
"Pengaturan dari proyek Scarb Anda dapat dikonfigurasi dalam berkas "
"▪Scarb.toml.toml. Untuk menggunakan Starknet Foundry sebagai alat pengujian "
"Anda, Anda perlu menambahkannya sebagai dependensi dalam berkas ÁScarb.toml."
" Pada saat menulis, versi terbaru dari Starknet Foundry adalah <0.0.0.02 - "
"tetapi Anda harus menggunakan versi terbaru."

#: src/ch17-02-testing-smart-contracts.md:115
msgid ""
"```toml,noplayground\n"
"[dev-dependencies]\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"v0.22.0\" }\n"
"\n"
"[scripts]\n"
"test = \"snforge test\"\n"
"```"
msgstr ""
"Snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\""
" tag = \"v0.22.0\"} [scripts] test = \"snosforge test\""

#: src/ch17-02-testing-smart-contracts.md:123
msgid ""
"The `scarb test` command is configured to execute `scarb cairo-test` by "
"default. In our settings, we have configured it to execute `snforge test` "
"instead. This will allow us to run our tests using Starknet Foundry when we "
"run the `scarb test` command."
msgstr ""
"Perintah ini dikonfigurasi untuk melaksanakannya secara baku. ini akan "
"memungkinkan kita untuk menjalankan tes kita menggunakan Starknet Foundry "
"ketika kita menjalankan tes karbob."

#: src/ch17-02-testing-smart-contracts.md:125
msgid ""
"Once your project is configured, you will need to install Starknet Foundry "
"by following the installation guide from the [Starknet Foundry "
"Documentation](https://foundry-rs.github.io/starknet-foundry/getting-"
"started/installation.html). As usual, we recommend to use `asdf` to manage "
"versions of your development tools."
msgstr ""
"Setelah proyek Anda dikonfigurasi, Anda perlu memasang Starknet Foundry "
"dengan mengikuti panduan instalasi dari [Penyitaan Pendirian Starknet]"

#: src/ch17-02-testing-smart-contracts.md:127
msgid "Testing Smart Contracts with Starknet Foundry"
msgstr "Menguji Kontrak Cerdas dengan Pendirian Starknet"

#: src/ch17-02-testing-smart-contracts.md:129
msgid ""
"The usual command to run your tests using Starknet Foundry is `snforge "
"test`. However, when we configured our projects, we defined that the `scarb "
"test` command will run the `snforge test` command. Therefore, during the "
"rest of this chapter, consider that the `scarb test` command will be using "
"`snforge test` under the hood."
msgstr ""
"Perintah biasa untuk menjalankan tes menggunakan Starknet Foundry adalah tes"
" ·snforge. namun, ketika kami mengatur proyek-proyek kami, kami menyatakan "
"bahwa perintah tes karab akan menjalankan tes ·snforge."

#: src/ch17-02-testing-smart-contracts.md:131
msgid "The usual testing flow of a contract is as follows:"
msgstr "Tes yang biasa mengalir dari kontrak adalah sebagai berikut:"

#: src/ch17-02-testing-smart-contracts.md:133
msgid "Declare the class of the contract to test, identified by its name"
msgstr "Menyatakan kelas kontrak untuk menguji, diidentifikasi dengan namanya"

#: src/ch17-02-testing-smart-contracts.md:134
msgid "Serialize the constructor calldata into an array"
msgstr "Serialisasi konstruktor calldata ke dalam sebuah array"

#: src/ch17-02-testing-smart-contracts.md:135
msgid "Deploy the contract and retrieve its address"
msgstr "Sebarkan kontrak dan mengambil alamat"

#: src/ch17-02-testing-smart-contracts.md:136
msgid "Interact with the contract's entrypoint to test various scenarios"
msgstr ""
"Berinteraksi dengan titik masuk kontrak untuk menguji berbagai skenario"

#: src/ch17-02-testing-smart-contracts.md:138
msgid "Deploying the Contract to Test"
msgstr "Menyebarkan Kontrak untuk Diuji"

#: src/ch17-02-testing-smart-contracts.md:140
msgid ""
"In Listing 17-2, we wrote a function that deploys the `PizzaFactory` "
"contract and sets up the dispatcher for interactions."
msgstr ""
"Di Listing 17-2, kami menulis sebuah fungsi yang menyebarkan kontrak "
"åPizzaFactory dan mengatur operator untuk interaksi."

#: src/ch17-02-testing-smart-contracts.md:162
#: src/ch17-02-testing-smart-contracts.md:278
#: src/ch17-02-testing-smart-contracts.md:390
#: src/ch17-02-testing-smart-contracts.md:502
#: src/ch17-02-testing-smart-contracts.md:616
msgid "\"PizzaFactory\""
msgstr "\"PizzaFactory\""

#: src/ch17-02-testing-smart-contracts.md:178
#: src/ch17-02-testing-smart-contracts.md:294
#: src/ch17-02-testing-smart-contracts.md:406
#: src/ch17-02-testing-smart-contracts.md:518
#: src/ch17-02-testing-smart-contracts.md:632
msgid "\"pepperoni\""
msgstr "\"pepperoni\""

#: src/ch17-02-testing-smart-contracts.md:179
#: src/ch17-02-testing-smart-contracts.md:295
#: src/ch17-02-testing-smart-contracts.md:407
#: src/ch17-02-testing-smart-contracts.md:519
#: src/ch17-02-testing-smart-contracts.md:633
msgid "\"pineapple\""
msgstr "Nanas."

#: src/ch17-02-testing-smart-contracts.md:221
#: src/ch17-02-testing-smart-contracts.md:337
#: src/ch17-02-testing-smart-contracts.md:449
#: src/ch17-02-testing-smart-contracts.md:561
#: src/ch17-02-testing-smart-contracts.md:675
msgid "// Setup\n"
msgstr "//Setup\n"

#: src/ch17-02-testing-smart-contracts.md:226
#: src/ch17-02-testing-smart-contracts.md:342
#: src/ch17-02-testing-smart-contracts.md:454
#: src/ch17-02-testing-smart-contracts.md:566
#: src/ch17-02-testing-smart-contracts.md:680
msgid "// When\n"
msgstr "/Kapan\n"

#: src/ch17-02-testing-smart-contracts.md:229
#: src/ch17-02-testing-smart-contracts.md:345
#: src/ch17-02-testing-smart-contracts.md:457
#: src/ch17-02-testing-smart-contracts.md:569
#: src/ch17-02-testing-smart-contracts.md:683
msgid "// Then\n"
msgstr "# Then\n"

#: src/ch17-02-testing-smart-contracts.md:246
msgid "<span class=\"caption\">Listing 17-2 Deploying the contract to test</span>"
msgstr ""
"<span class=\"caption\">Listing 17-2 Menyebarkan kontrak untuk "
"menguji</span>"

#: src/ch17-02-testing-smart-contracts.md:248
msgid "Testing our Contract"
msgstr "Menguji Kontrak Kita"

#: src/ch17-02-testing-smart-contracts.md:250
msgid ""
"Determining the behavior that your contract should respect is the first step"
" in writing tests. In the `PizzaFactory` contract, we determined that the "
"contract should have the following behavior:"
msgstr ""
"Menentukan perilaku yang harus dihormati kontrak Anda adalah langkah pertama"
" dalam tes menulis."

#: src/ch17-02-testing-smart-contracts.md:252
msgid ""
"Upon deployment, the contract owner should be set to the address provided in"
" the constructor, and the factory should have 10 units of pepperoni and "
"pineapple, and no pizzas created."
msgstr ""
"Setelah penyebaran, pemilik kontrak harus ditetapkan ke alamat yang "
"disediakan di konstruktor, dan pabrik harus memiliki 10 unit pepperoni dan "
"nanas, dan tidak ada pizza dibuat."

#: src/ch17-02-testing-smart-contracts.md:253
msgid ""
"If someone tries to make a pizza and they are not the owner, the operation "
"should fail. Otherwise, the pizza count should be incremented, and an event "
"should be emitted."
msgstr ""
"Jika seseorang mencoba untuk membuat pizza dan mereka bukan pemilik, operasi"
" harus gagal. jika tidak, jumlah pizza harus meningkat, dan sebuah peristiwa"
" harus dipancarkan."

#: src/ch17-02-testing-smart-contracts.md:254
msgid ""
"If someone tries to take ownership of the contract and they are not the "
"owner, the operation should fail. Otherwise, the owner should be updated."
msgstr ""
"Jika seseorang mencoba untuk mengambil kepemilikan kontrak dan mereka bukan "
"pemilik, operasi harus gagal. Jika tidak, pemilik harus diperbarui."

#: src/ch17-02-testing-smart-contracts.md:256
msgid "Accessing Storage Variables with `load`"
msgstr "Mengakses Variabel Penyimpanan dengan åloadé"

#: src/ch17-02-testing-smart-contracts.md:362
msgid ""
"<span class=\"caption\">Listing 17-3: Testing the initial state by loading "
"storage variables </span>"
msgstr ""
"<span class=\"caption\">Listing 17-3: Menguji keadaan awal dengan memuat "
"variabel penyimpanan </span>"

#: src/ch17-02-testing-smart-contracts.md:364
msgid ""
"Once our contract is deployed, we want to assert that the initial values are"
" set as expected. If our contract has an entrypoint that returns the value "
"of a storage variable, we can call this entrypoint. Otherwise, we can use "
"the `load` function from `snforge` to load the value of a storage variable "
"inside our contract, even if not exposed by an entrypoint."
msgstr ""
"Jika kontrak kami memiliki titik masuk yang mengembalikan nilai dari "
"variabel penyimpanan, kami bisa menghubungi titik masuk ini."

#: src/ch17-02-testing-smart-contracts.md:366
msgid "Mocking the Caller Address with `start_cheat_caller_address`"
msgstr "Mocking the Caller Address with æstart_cheat_caller_address_address)"

#: src/ch17-02-testing-smart-contracts.md:368
msgid ""
"The security of our factory relies on the owner being the only one able to "
"make pizzas and transfer ownership. To test this, we can use the "
"`start_cheat_caller_address` function to mock the caller address and assert "
"that the contract behaves as expected."
msgstr ""
"Keamanan pabrik kami bergantung pada pemilik menjadi satu-satunya mampu "
"untuk membuat pizza dan kepemilikan transfer untuk menguji ini, kita dapat "
"menggunakan fungsi pemanggil dan alamat pemanggil dan menegaskan bahwa "
"kontrak berperilaku seperti yang diharapkan."

#: src/ch17-02-testing-smart-contracts.md:474
msgid ""
"<span class=\"caption\">Listing 17-4: Testing ownership of the contract by "
"mocking the caller address </span>"
msgstr ""
"<span class=\"caption\">Listing 17-4: Menguji kepemilikan kontrak dengan "
"mengejek alamat pemanggil </span>"

#: src/ch17-02-testing-smart-contracts.md:476
msgid ""
"Using `start_cheat_caller_address`, we call the `change_owner` function "
"first as the owner, and then as a different address. We assert that the "
"operation fails when the caller is not the owner, and that the owner is "
"updated when the caller is the owner."
msgstr ""
"Pertama-tama kami menggunakan fungsi 'change' sebagai pemilik, lalu sebagai "
"alamat yang berbeda. kami menegaskan bahwa operasi gagal ketika penelepon "
"bukanlah pemiliknya, dan pemiliknya diperbarui ketika si penelepon adalah "
"pemiliknya."

#: src/ch17-02-testing-smart-contracts.md:478
msgid "Capturing Events with `spy_events`"
msgstr "Menangkap Events dengan åspy_events"

#: src/ch17-02-testing-smart-contracts.md:480
msgid ""
"When a pizza is created, the contract emits an event. To test this, we can "
"use the `spy_events` function to capture the emitted events and assert that "
"the event was emitted with the expected parameters. Naturally, we can also "
"assert that the pizza count was incremented, and that only the owner can "
"make a pizza."
msgstr ""
"Ketika pizza dibuat, kontrak memancarkan sebuah kejadian. untuk menguji hal "
"ini, kita dapat menggunakan fungsi Áspy_events_eventsá untuk menangkap "
"emited events dan menegaskan bahwa peristiwa itu dipancarkan dengan "
"parameter yang diharapkan. tentu saja, kita juga dapat menegaskan bahwa "
"jumlah pizza meningkat, dan bahwa hanya pemilik dapat membuat pizza."

#: src/ch17-02-testing-smart-contracts.md:586
msgid ""
"<span class=\"caption\">Listing 17-5: Testing the events emitted when a "
"pizza is created</span>"
msgstr ""
"<span class=\"caption\">Listing 17-5: Menguji kejadian yang dipancarkan "
"ketika pizza dibuat</span>"

#: src/ch17-02-testing-smart-contracts.md:588
msgid "Accessing Internal Functions with `contract_state_for_testing`"
msgstr "Mengakses Internal functions with æcontract_state_for_testing"

#: src/ch17-02-testing-smart-contracts.md:590
msgid ""
"All the tests we have seen so far have been using a workflow that involves "
"deploying the contract and interacting with the contract's entrypoints. "
"However, sometimes we may want to test the internals of the contract "
"directly, without deploying the contract. How could this be done, if we were"
" reasoning in purely Cairo terms?"
msgstr ""
"Semua tes yang telah kita lihat sejauh ini telah menggunakan alur kerja yang"
" melibatkan penyebaran kontrak dan berinteraksi dengan titik-titik masuk "
"kontrak. namun, kadang-kadang kita mungkin ingin menguji internal kontrak "
"secara langsung, tanpa menyebarkan kontrak."

#: src/ch17-02-testing-smart-contracts.md:592
msgid ""
"Recall the struct `ContractState`, which is used as a parameter to all the "
"entrypoints of a contract. To make it short, this struct contains zero-sized"
" fields, corresponding to the storage variables of the contract. The only "
"purpose of these fields is to allow the Cairo compiler to generate the "
"correct code for accessing the storage variables. If we could create an "
"instance of this struct, we could access these storage variables directly, "
"without deploying the contract..."
msgstr ""
"Ingat struct ·ContractState, yang digunakan sebagai parameter untuk semua "
"titik masuk sebuah kontrak. Untuk membuatnya pendek, struktur ini berisi "
"daerah berukuran nol, sesuai dengan variabel penyimpanan dari kontrak. Satu-"
"satunya tujuan dari bidang ini adalah untuk memungkinkan kompiler Cairo "
"untuk menghasilkan kode yang benar untuk mengakses variabel penyimpanan. "
"Jika kita bisa membuat contoh dari struktur ini, kita bisa mengakses "
"variabel penyimpanan ini secara langsung, tanpa menyebarkan kontrak..."

#: src/ch17-02-testing-smart-contracts.md:594
msgid ""
"...and this is exactly what the `contract_state_for_testing` function does! "
"It creates an instance of the `ContractState` struct, allowing us to call "
"any function that takes as parameter a `ContractState` struct, without "
"deploying the contract. To interact with the storage variables properly, we "
"need to manually import the traits that define access to the storage "
"variables."
msgstr ""
"...dan ini persis seperti apa yang dilakukan kontract_state_for_test! Ini "
"menciptakan sebuah contoh dari struktur kontractate, memungkinkan kita untuk"
" memanggil setiap fungsi yang diperlukan sebagai parameter sebuah struktur "
"contractstate, tanpa menyebarkan kontrak. Untuk berinteraksi dengan variabel"
" penyimpanan secara benar, kita perlu mengimpor sifat-sifat yang "
"mendefinisikan akses ke variabel penyimpanan."

#: src/ch17-02-testing-smart-contracts.md:700
msgid ""
"<span class=\"caption\">Listing 17-6: Unit testing our contract without "
"deployment</span>"
msgstr ""
"<span class=\"caption\">Listing 17-6: Unit pengujian kontrak kita tanpa "
"penyebaran</span>"

#: src/ch17-02-testing-smart-contracts.md:702
msgid ""
"These imports give us access to our internal functions (notably, "
"`set_owner`), as well as the read/write access to the `owner` storage "
"variable. Once we have these, we can interact with the contract directly, "
"changing the address of the owner by calling the `set_owner` method, "
"accessible through `InternalTrait`, and reading the `owner` storage "
"variable."
msgstr ""
"Impor ini memberi kita akses ke fungsi internal kita (terutama, "
"setting_owner), serta akses baca/tulis ke variabel penyimpanan ▪ Pemiliknya."

#: src/ch17-02-testing-smart-contracts.md:707
msgid ""
"Note: Both approaches cannot be used at the same time. If you decide to "
"deploy the contract, you interact with it using the dispatcher. If you "
"decide to test the internal functions, you interact with the `ContractState`"
" object directly."
msgstr ""
"Catatan: Kedua pendekatan tidak dapat digunakan pada saat yang sama. Jika "
"Anda memutuskan untuk menyebarkan kontrak, Anda berinteraksi dengannya "
"dengan menggunakan operator. jika Anda memutuskan untuk menguji fungsi "
"internal, Anda berinteraksi dengan objek Contractate secara langsung."

#: src/ch17-02-testing-smart-contracts.md:728
msgid ""
"The output of the tests shows that all the tests passed successfully, along "
"with an estimation of the gas consumed by each test."
msgstr ""
"Hasil tes menunjukkan bahwa semua tes berhasil, bersama dengan estimasi gas "
"yang dikonsumsi oleh setiap tes."

#: src/ch17-02-testing-smart-contracts.md:732
msgid ""
"In this chapter, we learned how to test smart contracts using Starknet "
"Foundry. We demonstrated how to deploy a contract and interact with it using"
" the dispatcher. We also showed how to test the contract's behavior by "
"mocking the caller address and capturing events. Finally, we demonstrated "
"how to test the internal functions of the contract directly, without "
"deploying the contract."
msgstr ""
"kami belajar bagaimana menguji kontrak cerdas menggunakan Starknet Foundry "
"kami menunjukkan bagaimana menyebarkan kontrak dan berinteraksi dengannya "
"menggunakan operator kami juga menunjukkan bagaimana menguji perilaku "
"kontrak dengan mengejek alamat pemanggil dan menangkap kejadian akhirnya, "
"kami menunjukkan bagaimana menguji fungsi internal kontrak secara langsung, "
"tanpa menyebarkan kontrak."

#: src/ch17-02-testing-smart-contracts.md:734
msgid ""
"To learn more about Starknet Foundry, refer to the [Starknet Foundry "
"documentation](https://foundry-rs.github.io/starknet-foundry/index.html)."
msgstr ""
"Untuk mengetahui lebih banyak tentang Starknet Foundry, merujuk ke "
"[Refoundry Starknet][Index.https://foundry-rs.github.io/starknet-"
"foundry/index.html)."

#: src/ch17-03-static-analysis-tools.md:3
msgid ""
"Static analysis refers to the process of examining code without its "
"execution, focusing on its structure, syntax, and properties. It involves "
"analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr ""
"Analisis statik mengacu pada proses pemeriksaan kode tanpa eksekusinya, "
"berfokus pada struktur, sintaks, dan propertinya. Hal ini mencakup "
"menganalisis kode sumber untuk mengidentifikasi masalah potensial, "
"kerentanan, atau pelanggaran aturan tertentu."

#: src/ch17-03-static-analysis-tools.md:5
msgid ""
"By defining rules, such as coding conventions or security guidelines, "
"developers can utilize static analysis tools to automatically check the code"
" against these standards."
msgstr ""
"Dengan mendefinisikan aturan, seperti konvensi koding atau pedoman keamanan,"
" para pengembang dapat menggunakan alat analisis statis untuk secara "
"otomatis memeriksa kode terhadap standar - standar ini."

#: src/ch17-03-static-analysis-tools.md:7
msgid "Reference:"
msgstr "Referensi:"

#: src/ch17-03-static-analysis-tools.md:9
msgid ""
"[Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-"
"supports-cairo-1-0)"
msgstr ""
"[Sembrep Cairo 1.0 dukungan]://semgrep.dev/blog/2023/semgrep-now-supports-"
"cairo-1-0)"

#: src/ch17-03-static-analysis-tools.md:10
msgid ""
"[Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"
msgstr ""
"[Caracal, seorang ahli analisis statis Starknet] "
"[Hhttps://github.com/crytic/caracal)"

#: src/appendix-000.md
msgid ""
"The following sections contain reference material you may find useful in "
"your Starknet journey."
msgstr ""
"Bagian-bagian berikut berisi bahan referensi Anda mungkin menemukan berguna "
"dalam perjalanan Starknet Anda."

#: src/appendix-08-system-calls.md:1
msgid "Appendix A - System Calls"
msgstr "Lampiran Sebuah - Sistem Memanggil"

#: src/appendix-08-system-calls.md:3
msgid ""
"This chapter is based on the StarkNet documentation available at [StarkNet "
"Docs](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-"
"calls-cairo1/)."
msgstr ""
"Bab ini didasarkan pada dokumentasi StarkNet yang tersedia di [StarkNet "
"Docs][Hhttps://docs.starknet.io/dokumentasi/archicture_and_concepts/Smart_Contracts/system-"
"calls-cairo1/)."

#: src/appendix-08-system-calls.md:5
msgid ""
"Writing smart contracts requires various associated operations, such as "
"calling another contract or accessing the contract’s storage, that "
"standalone programs do not require."
msgstr ""
"Menulis kontrak cerdas membutuhkan berbagai operasi yang terkait, seperti "
"memanggil kontrak lain atau mengakses penyimpanan kontrak yang tidak "
"diperlukan program mandiri."

#: src/appendix-08-system-calls.md:7
msgid ""
"The Starknet contract language supports these operations by using system "
"calls. System calls enable a contract to require services from the Starknet "
"OS. You can use system calls in a function to get information that depends "
"on the broader state of Starknet, which would otherwise be inaccessible, "
"rather than local variables that appear in the function’s scope."
msgstr ""
"Bahasa kontrak Starknet mendukung operasi ini dengan menggunakan sistem "
"panggilan. Sistem panggilan memungkinkan sebuah kontrak untuk membutuhkan "
"layanan dari OS Starknet. Anda dapat menggunakan sistem panggilan dalam "
"fungsi untuk mendapatkan informasi yang tergantung pada kondisi Starknet "
"yang lebih luas, yang jika tidak dapat diakses, daripada variabel lokal yang"
" muncul dalam lingkup fungsi."

#: src/appendix-08-system-calls.md:9
msgid "Here is a list of the system calls available in Cairo 1.0:"
msgstr "Berikut adalah daftar panggilan sistem yang tersedia di Cairo 1.0:"

#: src/appendix-08-system-calls.md:11
msgid "[get_block_hash](#get_block_hash)"
msgstr "[get_block_hash][#get_block_hash]"

#: src/appendix-08-system-calls.md:12
msgid "[get_execution_info](#get_execution_info)"
msgstr "[get_execution_info] [#get_execution_info)"

#: src/appendix-08-system-calls.md:13
msgid "[call_contract](#call_contract)"
msgstr "[call_contract]Akun#call_contract)"

#: src/appendix-08-system-calls.md:14
msgid "[deploy](#deploy)"
msgstr "Font color = \"# DF01D7\" (deploy)"

#: src/appendix-08-system-calls.md:15
msgid "[emit_event](#emit_event)"
msgstr "[emit_event][emit_event]"

#: src/appendix-08-system-calls.md:16
msgid "[library_call](#library_call)"
msgstr "[pustaka_panggilan][ibrary_call]"

#: src/appendix-08-system-calls.md:17
msgid "[send_message_to_L1](#send_message_to_l1)"
msgstr "[Kirim_pesan_to_L1][kirim_pesan_ke_l1)"

#: src/appendix-08-system-calls.md:18
msgid "[replace_class](#replace_class)"
msgstr "[replace_class][replace_class]"

#: src/appendix-08-system-calls.md:19
msgid "[storage_read](#storage_read)"
msgstr "[Storage_read][storage#storage_read]"

#: src/appendix-08-system-calls.md:20
msgid "[storage_write](#storage_write)"
msgstr "[Storage_write][torage#storage_write]"

#: src/appendix-08-system-calls.md:22
msgid "`get_block_hash`"
msgstr "Get_block_hash"

#: src/appendix-08-system-calls.md:24 src/appendix-08-system-calls.md:51
#: src/appendix-08-system-calls.md:79 src/appendix-08-system-calls.md:117
#: src/appendix-08-system-calls.md:153 src/appendix-08-system-calls.md:198
#: src/appendix-08-system-calls.md:230 src/appendix-08-system-calls.md:273
#: src/appendix-08-system-calls.md:305 src/appendix-08-system-calls.md:348
msgid "Syntax"
msgstr "Sintaksis"

#: src/appendix-08-system-calls.md:32 src/appendix-08-system-calls.md:59
#: src/appendix-08-system-calls.md:87 src/appendix-08-system-calls.md:128
#: src/appendix-08-system-calls.md:161 src/appendix-08-system-calls.md:206
#: src/appendix-08-system-calls.md:238 src/appendix-08-system-calls.md:281
#: src/appendix-08-system-calls.md:313 src/appendix-08-system-calls.md:356
msgid "Description"
msgstr "Deskripsi"

#: src/appendix-08-system-calls.md:34
msgid ""
"Gets the hash of a specific StarkNet block within the range of "
"`[first_v0_12_0_block, current_block - 10]`."
msgstr ""
"Gets the hash of a specific StarkNet block within the range of "
"å[first_v0_12_0_block, current_block - readers."

#: src/appendix-08-system-calls.md:36 src/appendix-08-system-calls.md:69
#: src/appendix-08-system-calls.md:103 src/appendix-08-system-calls.md:139
#: src/appendix-08-system-calls.md:173 src/appendix-08-system-calls.md:220
#: src/appendix-08-system-calls.md:252 src/appendix-08-system-calls.md:295
#: src/appendix-08-system-calls.md:327 src/appendix-08-system-calls.md:372
msgid "Return Values"
msgstr "Nilai Kembali"

#: src/appendix-08-system-calls.md:38
msgid "Returns the hash of the given block."
msgstr "Mengembalikan hash dari blok yang diberikan."

#: src/appendix-08-system-calls.md:40
msgid "Error Messages"
msgstr "Pesan Galat"

#: src/appendix-08-system-calls.md:42
msgid ""
"`Block number out of range`: `block_number` is greater than "
"_`current_block`_`- 10`."
msgstr ""
"Nomor blok di luar jangkauan: nomor blok_number lebih besar dari "
"blok_sekarang_10."

#: src/appendix-08-system-calls.md:43
msgid "`0`: `block_number` is less than the first block number of v0.12.0."
msgstr "0: nomor blok_0 kurang dari jumlah blok pertama v0.12.0."

#: src/appendix-08-system-calls.md:45 src/appendix-08-system-calls.md:73
#: src/appendix-08-system-calls.md:107 src/appendix-08-system-calls.md:147
#: src/appendix-08-system-calls.md:192 src/appendix-08-system-calls.md:224
#: src/appendix-08-system-calls.md:267 src/appendix-08-system-calls.md:299
#: src/appendix-08-system-calls.md:342 src/appendix-08-system-calls.md:376
msgid "Common Library"
msgstr "Pustaka Umum"

#: src/appendix-08-system-calls.md:47
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls.cairo#L37)"
msgstr ""
"[syscalls.cairo][19https://github.com/starkware-"
"libs/cairo/cairo/0c8879fb24a18cad19f2c18cdecbf6ef15153/src/starknet/scalls.cairo#L37)"

#: src/appendix-08-system-calls.md:49
msgid "`get_execution_info`"
msgstr "Get_execution_info"

#: src/appendix-08-system-calls.md:61
msgid "Gets information about the original transaction."
msgstr "Dapatkan informasi tentang transaksi asli."

#: src/appendix-08-system-calls.md:63
msgid ""
"In Cairo 1.0, all block/transaction/execution context getters are batched "
"into this single system call."
msgstr ""
"Di Cairo 1,0, semua blok/transaksi/eksekusi context getters yang batch ke "
"dalam panggilan sistem tunggal."

#: src/appendix-08-system-calls.md:65 src/appendix-08-system-calls.md:97
#: src/appendix-08-system-calls.md:132 src/appendix-08-system-calls.md:167
#: src/appendix-08-system-calls.md:212 src/appendix-08-system-calls.md:246
#: src/appendix-08-system-calls.md:291 src/appendix-08-system-calls.md:321
#: src/appendix-08-system-calls.md:364
msgid "Arguments"
msgstr "Argumen"

#: src/appendix-08-system-calls.md:67 src/appendix-08-system-calls.md:175
#: src/appendix-08-system-calls.md:254 src/appendix-08-system-calls.md:297
#: src/appendix-08-system-calls.md:374
msgid "None."
msgstr "Tidak ada."

#: src/appendix-08-system-calls.md:71
msgid ""
"Returns a [struct](https://github.com/starkware-"
"libs/cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8)"
" containing the execution info."
msgstr ""
"Mengembalikan [struct][structps://github.com/starkware-"
"libs/cairo/bbbf69d4e93a60faa1363fd0152b8fcedbb00a/Corelib/src/starknet/info.cairo#Liro8)"
" berisi info eksekusi."

#: src/appendix-08-system-calls.md:75
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L35)"
msgstr ""
"Font color = \"# 404040\" siscalls.cairo]://https://gitub.com/starkware-"
"libs/cairo/cairo/cca08c8eb0eb3e58767974f20994d0ba64183/src/starknet/scalls.cairo#L35)"

#: src/appendix-08-system-calls.md:77
msgid "`call_contract`"
msgstr "Call_contract"

#: src/appendix-08-system-calls.md:89
msgid ""
"Calls a given contract. This system call expects the address of the called "
"contract, a selector for a function within that contract, and call "
"arguments."
msgstr ""
"Memanggil kontrak yang diberikan. Sistem ini mengharapkan alamat dari yang "
"disebut kontrak, pemilih untuk sebuah fungsi dalam kontrak itu, dan "
"panggilan argumen."

#: src/appendix-08-system-calls.md:91 src/appendix-08-system-calls.md:285
msgid "**Note:**"
msgstr "**Note:**"

#: src/appendix-08-system-calls.md:93
msgid ""
"An internal call can’t return Err(\\_) as this is not handled by the "
"sequencer and the Starknet OS."
msgstr ""
"Sebuah panggilan internal dapat mengembalikan Erro\\___) karena ini tidak "
"ditangani oleh pengurut dan OS Starknet."

#: src/appendix-08-system-calls.md:95
msgid ""
"If call_contract_syscall fails, this can’t be caught and will therefore "
"result in the entire transaction being reverted."
msgstr ""
"Jika call_contract_syscall gagal, ini tidak dapat ditangkap dan oleh karena "
"itu akan mengakibatkan seluruh transaksi yang dikembalikan."

#: src/appendix-08-system-calls.md:99
msgid "_`address`_: The address of the contract you want to call."
msgstr "Alamat kontrak yang ingin kau hubungi."

#: src/appendix-08-system-calls.md:100
msgid ""
"_`entry_point_selector`_: A selector for a function within that contract, "
"can be computed with the `selector!` macro."
msgstr ""
"Pemilih untuk fungsi dalam kontrak itu, dapat dihitung dengan ahli bedah!"

#: src/appendix-08-system-calls.md:101
msgid "_`calldata`_: The calldata array."
msgstr "Array calldata."

#: src/appendix-08-system-calls.md:105 src/appendix-08-system-calls.md:222
msgid "The call response, of type `SyscallResult<Span<felt252>>`."
msgstr "Respon panggilan, tipe ¤SiscallResult<Span<felt252>>>."

#: src/appendix-08-system-calls.md:109
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10)"
msgstr ""
"Font color = \"# 404040\" siscalls.cairo]://https://github.com/starkware-"
"libs/cairo/cairo/cca08c8eb0eb3e5876774f20994d0ba64183/src/starknet/scalls.cairo#L10)"

#: src/appendix-08-system-calls.md:111
msgid ""
"**Note:** This is considered a lower-level syntax for calling contracts. If "
"the interface of the called contract is available, then you can use a more "
"straightforward syntax."
msgstr ""
"**Note:** Ini dianggap sintaks tingkat bawah untuk memanggil kontrak. Jika "
"antarmuka dari kontrak yang disebut tersedia, maka Anda dapat menggunakan "
"sintaks lebih sederhana."

#: src/appendix-08-system-calls.md:115
msgid "`deploy`"
msgstr "Deploy."

#: src/appendix-08-system-calls.md:130
msgid "Deploys a new instance of a previously declared class."
msgstr "Menyebarkan contoh baru dari kelas yang sebelumnya dinyatakan."

#: src/appendix-08-system-calls.md:134
msgid "_`class_hash`_: The class hash of the contract to be deployed."
msgstr "Kelas hash dari kontrak yang akan dieksposkan."

#: src/appendix-08-system-calls.md:135
msgid ""
"_`contract_address_salt`_: The salt, an arbitrary value provided by the "
"sender. It is used in the computation of the contract’s address."
msgstr ""
"_Contract_address_salt__: Garam, nilai sewenang-wenang yang disediakan oleh "
"pengirim. Hal ini digunakan dalam komputasi alamat kontrak."

#: src/appendix-08-system-calls.md:136
msgid "_`calldata`_: The constructor’s calldata. An array of felts."
msgstr "Constructors calldata, array of felts."

#: src/appendix-08-system-calls.md:137
msgid ""
"_`deploy_from_zero`_: A flag used for the contract address computation. If "
"not set, the caller address will be used as the new contract’s deployer "
"address, otherwise 0 is used."
msgstr ""
"_BAR_deploy_from_zero__: Sebuah bendera yang digunakan untuk komputasi "
"alamat kontrak. Jika tidak diatur, alamat pemanggil akan digunakan sebagai "
"alamat pendistribusi kontrak baru, atau 0 digunakan."

#: src/appendix-08-system-calls.md:141
msgid "A tuple wrapped with SyscallResult where:"
msgstr "Sebuah tuple dibungkus dengan SyscallResult di mana:"

#: src/appendix-08-system-calls.md:143
msgid ""
"The first element is the address of the deployed contract, of type "
"`ContractAddress`."
msgstr ""
"Elemen pertama adalah alamat dari kontrak yang dikerahkan, jenis "
"contractAdrress."

#: src/appendix-08-system-calls.md:145
msgid ""
"The second element is the response array from the contract’s constructor, of"
" type `Span::<felt252>`."
msgstr ""
"Elemen kedua adalah susunan tanggapan dari konstruktor kontrak, dari tipe "
"ÁSpan::<felt252>."

#: src/appendix-08-system-calls.md:149
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls.cairo#L22)"
msgstr ""
"[syscalls.cairo]://githps.com/starkware-"
"libs/cairo/cairo/482186571ac9e574441f6fs0ce82d702a4d6/Corelib/src/starknet/syscalls.cairo#L22)"

#: src/appendix-08-system-calls.md:151
msgid "`emit_event`"
msgstr "#Emit_event#"

#: src/appendix-08-system-calls.md:163
msgid "Emits an event with a given set of keys and data."
msgstr ""
"Keluarkan suatu kejadian dengan satu set kunci dan data yang diberikan."

#: src/appendix-08-system-calls.md:165
msgid ""
"For more information and a higher-level syntax for emitting events, see "
"[Starknet "
"events](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/starknet-"
"events/)."
msgstr ""
"Untuk informasi lebih lanjut dan sintaks tingkat lebih tinggi untuk "
"memancarkan peristiwa, lihat [Starknet "
"events][Starknethttps://docs.starknet.io/documentation/archicture_and_concepts/Smart_Contracts/starknet-"
"events/)."

#: src/appendix-08-system-calls.md:169
msgid ""
"_`keys`_: The event’s keys. These are analogous to Ethereum’s event topics, "
"you can use the starknet_getEvents method to filter by these keys."
msgstr ""
"Kunci acara ini mirip dengan topik-topik peristiwa Eseum, Anda dapat "
"menggunakan metode starnet_getEvents untuk menyaring dengan kunci-kunci ini."

#: src/appendix-08-system-calls.md:171
msgid "_`data`_: The event’s data."
msgstr "Data acara."

#: src/appendix-08-system-calls.md:179
msgid ""
"The following example emits an event with two keys, the strings `status` and"
" `deposit` and three data elements: `1`, `2`, and `3`."
msgstr ""
"Contoh berikut memancarkan suatu peristiwa dengan dua tombol, senarnya dan "
"tiga unsur data: ▪1, 2; dan  (3)."

#: src/appendix-08-system-calls.md:194
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L30)"
msgstr ""
"Font color = \"# 404040\" siscalls.cairo]://https://gitub.com/starkware-"
"libs/cairo/cairo/cca08c8eb0eb3e58767974f20994d0ba64183/src/starknet/scalls.cairo#L30)"

#: src/appendix-08-system-calls.md:196
msgid "`library_call`"
msgstr "♪ Library_call ♪"

#: src/appendix-08-system-calls.md:208
msgid ""
"Calls the requested function in any previously declared class. The class is "
"only used for its logic."
msgstr ""
"Memanggil fungsi yang diminta di setiap kelas yang sebelumnya dinyatakan. "
"Kelas hanya digunakan untuk logikanya."

#: src/appendix-08-system-calls.md:210
msgid ""
"This system call replaces the known delegate call functionality from "
"Ethereum, with the important difference that there is only one contract "
"involved."
msgstr ""
"Panggilan sistem ini menggantikan fungsi panggilan delegasi yang diketahui "
"dari Ethereum, dengan perbedaan penting bahwa hanya ada satu kontrak yang "
"terlibat."

#: src/appendix-08-system-calls.md:214
msgid "_`class_hash`_: The hash of the class you want to use."
msgstr "Hash dari kelas yang ingin kau gunakan."

#: src/appendix-08-system-calls.md:216
msgid ""
"_`function_selector`_: A selector for a function within that class, can be "
"computed with the `selector!` macro."
msgstr ""
"Sebuah pemilih untuk sebuah fungsi di dalam kelas itu, dapat dihitung dengan"
" ahli bedah!"

#: src/appendix-08-system-calls.md:218
msgid "_`calldata`_: The calldata."
msgstr "Si Calldata."

#: src/appendix-08-system-calls.md:226
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L43)"
msgstr ""
"Font color = \"# 404040\" siscalls.cairo]://https://gitub.com/starkware-"
"libs/cairo/cairo/cca08c8eb0eb3e587679774f20994d0ba64183/src/starknet/scalls.cairo#L43)"

#: src/appendix-08-system-calls.md:228
msgid "`send_message_to_L1`"
msgstr "Send_message_to_L1) fs-type"

#: src/appendix-08-system-calls.md:240
msgid "Sends a message to L1."
msgstr "Mengirim pesan ke L1."

#: src/appendix-08-system-calls.md:242
msgid ""
"This system call includes the message parameters as part of the proof’s "
"output and exposes these parameters to the `StarknetCore` contract on L1 "
"once the state update, including the transaction, is received."
msgstr ""
"Panggilan sistem ini mencakup parameter pesan sebagai bagian dari bukti "
"outputs dan mengekspos parameter ini ke kontrak L1 setelah pemutakhiran "
"negara, termasuk transaksi, diterima."

#: src/appendix-08-system-calls.md:244
msgid ""
"For more information, see Starknet’s [messaging "
"mechanism](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-"
"mechanism/)."
msgstr ""
"Untuk informasi lebih lanjut, lihat Starknet [mekanisme "
"pesan][Awttps://docts.starknet.io/dokumentasi/architecture_and_concepts/Network_Architecture/messaging-"
"mechanism/)."

#: src/appendix-08-system-calls.md:248
msgid "_`to_address`_: The recipient’s L1 address."
msgstr "Alamat penerima L1."

#: src/appendix-08-system-calls.md:250
msgid "_`payload`_: The array containing the message payload."
msgstr "Array berisi muatan pesan."

#: src/appendix-08-system-calls.md:258
msgid ""
"The following example sends a message whose content is `(1,2)` to the L1 "
"contract whose address is `3423542542364363`."
msgstr ""
"Contoh berikut mengirimkan pesan yang isinya adalah å1,2) ke kontrak L1 yang"
" alamatnya adalah 33423542542364363."

#: src/appendix-08-system-calls.md:269
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51)"
msgstr ""
"Font color = \"# 404040\" siscalls.cairo]://https://gitub.com/starkware-"
"libs/cairo/cairo/cca08c8eb0eb3e58767974f20994d0ba64183/src/starknet/scalls.cairo#L51)"

#: src/appendix-08-system-calls.md:271
msgid "`replace_class`"
msgstr "replace_class_class"

#: src/appendix-08-system-calls.md:283
msgid ""
"Once `replace_class` is called, the class of the calling contract (i.e. the "
"contract whose address is returned by `get_contract_address` at the time the"
" syscall is called) will be replaced by the class whose hash is given by the"
" class_hash argument."
msgstr ""
"Setelah replace_class_class called, kelas dari kontrak pemanggilan (mis. "
"kontrak yang alamat yang dikembalikan oleh argumen class_hash."

#: src/appendix-08-system-calls.md:287
msgid ""
"After calling `replace_class`, the code currently executing from the old "
"class will finish running."
msgstr ""
"Setelah memanggil åreplace_class_class, kode yang saat ini mengeksekusi dari"
" kelas lama akan selesai berjalan."

#: src/appendix-08-system-calls.md:289
msgid ""
"The new class will be used from the next transaction onwards or if the "
"contract is called via the `call_contract` syscall in the same transaction "
"(after the replacement)."
msgstr ""
"Kelas baru akan digunakan dari transaksi berikutnya dan seterusnya atau jika"
" kontrak disebut melalui siscall_contract; dalam transaksi yang sama "
"(setelah penggantian)."

#: src/appendix-08-system-calls.md:293
msgid ""
"_`class_hash`_: The hash of the class you want to use as a replacement."
msgstr "Hash dari kelas yang ingin kau gunakan sebagai pengganti."

#: src/appendix-08-system-calls.md:301
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L77)"
msgstr ""
"Font color = \"# 404040\" siscalls.cairo]://https://gitub.com/starkware-"
"libs/cairo/cairo/cca08c8eb0eb3e587679774f20994d0ba64183/src/starknet/scalls.cairo#L77)"

#: src/appendix-08-system-calls.md:303
msgid "`storage_read`"
msgstr "Storage_read"

#: src/appendix-08-system-calls.md:315
msgid "Gets the value of a key in the storage of the calling contract."
msgstr "Mendapatkan nilai kunci dalam penyimpanan kontrak pemanggilan."

#: src/appendix-08-system-calls.md:317
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.read()`, which enables you to read storage variables that"
" are defined explicitly in the contract."
msgstr ""
"Panggilan sistem ini menyediakan akses langsung ke setiap kunci yang mungkin"
" ada dalam penyimpanan, berbeda dengan Ávar.readó), yang memungkinkan Anda "
"membaca variabel penyimpanan yang didefinisikan secara eksplisit dalam "
"kontrak."

#: src/appendix-08-system-calls.md:319 src/appendix-08-system-calls.md:362
msgid ""
"For information on accessing storage by using the storage variables, see "
"[storage "
"variables](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-"
"storage/#storage_variables)."
msgstr ""
"Untuk informasi tentang mengakses penyimpanan dengan menggunakan variabel "
"penyimpanan, lihat [variabel penyimpanan]bahi [stracts/contract-"
"storage/#storage_variables]."

#: src/appendix-08-system-calls.md:323 src/appendix-08-system-calls.md:366
msgid ""
"_`address_domain`_: The domain of the key, used to separate between "
"different data availability modes. This separation is used in Starknet to "
"offer different data availability modes. Currently, only the onchain mode "
"(where all updates go to L1), indicated by domain `0`, is supported. Other "
"address domains which will be introduced in the future will behave "
"differently in terms of publication (in particular, they will not be posted "
"on L1, creating a tradeoff between cost and security)."
msgstr ""
"_doddress_domain__: Domain kunci, yang digunakan untuk memisahkan antara "
"mode ketersediaan data yang berbeda. Pemisahan ini digunakan di Starknet "
"untuk menawarkan mode ketersediaan data yang berbeda. Saat ini, hanya pada "
"mode onchain (dimana semua pemutakhiran pergi ke L1), yang diindikasikan "
"oleh domain ▪0, didukung. Alamat lain yang akan diperkenalkan di masa depan "
"akan berperilaku berbeda dalam hal publikasi (khususnya, mereka tidak akan "
"diposting pada L1, membuat pertukaran antara biaya dan keamanan)."

#: src/appendix-08-system-calls.md:325 src/appendix-08-system-calls.md:368
msgid "_`address`_: The requested storage address."
msgstr "Alamat penyimpanan yang diminta."

#: src/appendix-08-system-calls.md:329
msgid "The value of the key, of type `SyscallResult<felt252>`."
msgstr "Nilai kunci, jenis ¤SiscallResult<felt252>."

#: src/appendix-08-system-calls.md:344
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60)"
msgstr ""
"Font color = \"# 404040\" siscalls.cairo]://https://gitub.com/starkware-"
"libs/cairo/cairo/cca08c8eb0eb3e587679774f20994d0ba64183/src/starknet/scalls.cairo#L60)"

#: src/appendix-08-system-calls.md:346
msgid "`storage_write`"
msgstr "Storage_write"

#: src/appendix-08-system-calls.md:358
msgid "Sets the value of a key in the storage of the calling contract."
msgstr "Mengatur nilai sebuah kunci dalam penyimpanan kontrak pemanggilan."

#: src/appendix-08-system-calls.md:360
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.write()`, which enables you to write to storage variables"
" that are defined explicitly in the contract."
msgstr ""
"Panggilan sistem ini menyediakan akses langsung ke setiap kunci yang mungkin"
" ada dalam penyimpanan, berbeda dengan åvar.writeó), yang memungkinkan Anda "
"untuk menulis ke variabel penyimpanan yang didefinisikan secara eksplisit "
"dalam kontrak."

#: src/appendix-08-system-calls.md:370
msgid "_`value`_: The value to write to the key."
msgstr "Nilai untuk menulis ke kunci."

#: src/appendix-08-system-calls.md:378
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L70)"
msgstr ""
"Font color = \"# 404040\" siscalls.cairo]://https://gitub.com/starkware-"
"libs/cairo/cairo/cca08c8eb0eb3e58767974f20994d0ba64183/src/starknet/scalls.cairo#L70)"
