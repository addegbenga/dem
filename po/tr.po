#
msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: 2024-07-01T00:37:38+01:00\n"
"PO-Revision-Date: 2024-02-05 16:55+0300\n"
"Last-Translator: <omeraydin2112@gmail.com>\n"
"Language-Team: tr <tr@example.com>\n"
"Language: tr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: src/SUMMARY.md src/title-page.md
msgid "The Cairo Book"
msgstr "Kahire Kitabı"

#: src/SUMMARY.md
msgid "The Cairo Book Foreword Introduction"
msgstr "Kahire Kitap Önsöz Giriş"

#: src/SUMMARY.md
msgid "The Cairo Programming Language"
msgstr "Kahire Programlama Dili"

#: src/SUMMARY.md src/ch01-00-getting-started.md
msgid "Getting Started"
msgstr "Başlarken"

#: src/SUMMARY.md src/ch01-01-installation.md:1 src/ch01-01-installation.md:22
msgid "Installation"
msgstr "Kurulum"

#: src/SUMMARY.md
msgid "Hello, World!"
msgstr "Merhaba Dünya!"

#: src/SUMMARY.md src/ch02-00-common-programming-concepts.md
msgid "Common Programming Concepts"
msgstr "Ortak Programlama Kavramları"

#: src/SUMMARY.md src/ch02-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr "Değişkenler ve Mutabilite"

#: src/SUMMARY.md src/ch02-02-data-types.md:1
msgid "Data Types"
msgstr "Veri Türleri"

#: src/SUMMARY.md src/ch02-03-functions.md:1
msgid "Functions"
msgstr "Fonksiyonlar"

#: src/SUMMARY.md src/ch02-04-comments.md:1
msgid "Comments"
msgstr "Yorumlar"

#: src/SUMMARY.md src/ch02-05-control-flow.md:1
msgid "Control Flow"
msgstr "Kontrol Akışı"

#: src/SUMMARY.md src/ch03-00-common-collections.md
msgid "Common Collections"
msgstr "Ortak Koleksiyonlar"

#: src/SUMMARY.md src/ch03-01-arrays.md:1
msgid "Arrays"
msgstr "Diziler"

#: src/SUMMARY.md src/ch03-02-dictionaries.md:1
msgid "Dictionaries"
msgstr "Sözlükler"

#: src/SUMMARY.md
msgid "Understanding Ownership"
msgstr "Sahipliği Anlamak"

#: src/SUMMARY.md
msgid "What is Ownership?"
msgstr "Sahiplik nedir?"

#: src/SUMMARY.md src/ch04-02-references-and-snapshots.md:1
msgid "References and Snapshots"
msgstr "Kaynakça ve Snapshotlar"

#: src/SUMMARY.md src/ch05-00-using-structs-to-structure-related-data.md
msgid "Using Structs to Structure Related Data"
msgstr "Structs kullanarak ilgili verileri yapılandırın"

#: src/SUMMARY.md src/ch05-01-defining-and-instantiating-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr "Structs'ın Tanımlanması ve Anlıklaştırılması"

#: src/SUMMARY.md src/ch05-02-an-example-program-using-structs.md:1
msgid "An Example Program Using Structs"
msgstr "Structs Kullanan Bir Örnek Program"

#: src/SUMMARY.md src/ch05-03-method-syntax.md:1
msgid "Method Syntax"
msgstr "Yöntem Sözdizimi"

#: src/SUMMARY.md src/ch06-00-enums-and-pattern-matching.md
msgid "Enums and Pattern Matching"
msgstr "Enums ve Desen Eşleştirme"

#: src/SUMMARY.md src/ch06-01-enums.md:1 src/ch08-01-generic-data-types.md:181
msgid "Enums"
msgstr "Enums"

#: src/SUMMARY.md src/ch06-02-the-match-control-flow-construct.md:1
msgid "The Match Control Flow Construct"
msgstr "Maç Kontrol Akış Yapısı"

#: src/SUMMARY.md
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:1
msgid "Concise Control Flow with `if let` and `while let`"
msgstr "if let ve let let ile Kontrol Akışını Kısaltın while let"

#: src/SUMMARY.md
#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr "Kahire Projelerini Paketler, Sandıklar ve Modüllerle Yönetmek"

#: src/SUMMARY.md src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr "Paketler ve Sandıklar"

#: src/SUMMARY.md src/ch07-02-defining-modules-to-control-scope.md:1
msgid "Defining Modules to Control Scope"
msgstr "Modülleri Kontrol Kapsamına Tanımlama"

#: src/SUMMARY.md
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr "Modül Ağacındaki Bir Öğeye Yönlendirilecek Yollar"

#: src/SUMMARY.md
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr "use Anahtar Kelime ile Scope'a Yollar Getirmek"

#: src/SUMMARY.md src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr "Modülleri Farklı Dosyalara Ayırma"

#: src/SUMMARY.md src/ch08-01-generic-data-types.md:1
msgid "Generic Data Types"
msgstr "Genel Veri Türleri"

#: src/SUMMARY.md src/ch08-00-generic-types-and-traits.md
msgid "Generic Types and Traits"
msgstr "Genel Tipler ve Türler"

#: src/SUMMARY.md src/ch08-02-traits-in-cairo.md:1
msgid "Traits in Cairo"
msgstr "Kahire'deki Traits"

#: src/SUMMARY.md
msgid "Error Handling"
msgstr "Hata işleme"

#: src/SUMMARY.md
msgid "Unrecoverable Errors with panic"
msgstr "Panikle Kurtarılamayan Hatalar"

#: src/SUMMARY.md
msgid "Recoverable Errors with Result"
msgstr "Sonuçla Kurtarılabilir Hatalar"

#: src/SUMMARY.md src/ch10-00-testing-cairo-programs.md
msgid "Testing Cairo Programs"
msgstr "Kahire Programlarının Test Edilmesi"

#: src/SUMMARY.md src/ch10-01-how-to-write-tests.md:1
msgid "How To Write Tests"
msgstr "Testler Nasıl Yazılır"

#: src/SUMMARY.md src/ch10-02-test-organization.md:1
msgid "Testing Organization"
msgstr "Test Organizasyonu"

#: src/SUMMARY.md
msgid "Advanced Cairo Features"
msgstr "Gelişmiş Kahire Özellikleri"

#: src/SUMMARY.md src/ch11-01-custom-data-structures.md:1
msgid "Custom Data Structures"
msgstr "Özel Veri Yapıları"

#: src/SUMMARY.md src/ch11-02-smart-pointers.md:1
msgid "Smart Pointers"
msgstr "Akıllı İşaretçiler"

#: src/SUMMARY.md src/ch11-03-operator-overloading.md:1
msgid "Operator Overloading"
msgstr "Operatör Aşırı Yükleme"

#: src/SUMMARY.md src/ch11-04-hash.md:24
msgid "Working with Hashes"
msgstr "Hashes ile Çalışmak"

#: src/SUMMARY.md src/ch11-05-macros.md:1
msgid "Macros"
msgstr "Makrolar"

#: src/SUMMARY.md src/ch11-06-inlining-in-cairo.md:1
msgid "Inlining in Cairo"
msgstr "Kahire'de İniş"

#: src/SUMMARY.md src/ch11-08-printing.md:1
msgid "Printing"
msgstr "Baskı"

#: src/SUMMARY.md
msgid "Appendix (Cairo)"
msgstr "Ek (Cairo)"

#: src/SUMMARY.md
msgid "A - Keywords"
msgstr "A - Anahtar Kelimeler"

#: src/SUMMARY.md
msgid "B - Operators and Symbols"
msgstr "B - Operatörler ve Semboller"

#: src/SUMMARY.md
msgid "C - Derivable Traits"
msgstr "C - Türevlenebilir Özellikleri"

#: src/SUMMARY.md
msgid "D - The Cairo Prelude"
msgstr "D - Kahire Prelüd"

#: src/SUMMARY.md
msgid "E - Common Error Messages"
msgstr "E - Yaygın Hata Mesajları"

#: src/SUMMARY.md
msgid "F - Useful Development Tools"
msgstr "F - Faydalı Geliştirme Araçları"

#: src/SUMMARY.md
msgid "G - Installing Cairo binaries"
msgstr "G - Kahire ikililerinin kurulması"

#: src/SUMMARY.md
msgid "Smart Contracts in Cairo"
msgstr "Kahire'de Akıllı Sözleşmeler"

#: src/SUMMARY.md src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Introduction to Starknet Smart Contracts"
msgstr "Starknet Akıllı Sözleşmelere Giriş"

#: src/SUMMARY.md src/ch13-01-general-introduction-to-smart-contracts.md:1
msgid "General Introduction to Smart Contracts"
msgstr "Akıllı Sözleşmelere Genel Giriş"

#: src/SUMMARY.md src/ch13-02-anatomy-of-a-simple-contract.md:1
msgid "Anatomy of a Simple Contract"
msgstr "Basit Bir Sözleşmenin Anatomisi"

#: src/SUMMARY.md src/ch14-00-building-starknet-smart-contracts.md
msgid "Building Starknet Smart Contracts"
msgstr "Starknet Akıllı Sözleşmeler Oluşturma"

#: src/SUMMARY.md src/ch14-01-contract-storage.md:1
msgid "Contract Storage"
msgstr "Sözleşme Depolama"

#: src/SUMMARY.md src/ch14-02-contract-functions.md:1
msgid "Contract Functions"
msgstr "Sözleşme Fonksiyonları"

#: src/SUMMARY.md src/ch14-03-contract-events.md:1
msgid "Contract Events"
msgstr "Sözleşme Etkinlikleri"

#: src/SUMMARY.md src/ch15-00-starknet-cross-contract-interactions.md
msgid "Starknet Cross-Contract Interactions"
msgstr "Starknet Çapraz Etkileşimler"

#: src/SUMMARY.md src/ch15-01-abis-and-contract-interfaces.md:1
msgid "ABIs and Contract Interfaces"
msgstr "ABI'ler ve Sözleşme Arayüzleri"

#: src/SUMMARY.md
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:1
msgid "Contract Dispatchers, Library Dispatchers and System Calls"
msgstr "Sözleşmeli Dispatchers, Kütüphane Dispatchers ve Sistem Çağrıları"

#: src/SUMMARY.md src/ch16-00-building-advanced-starknet-smart-contracts.md
msgid "Building Advanced Starknet Smart Contracts"
msgstr "Gelişmiş Starknet Akıllı Sözleşmeler Oluşturma"

#: src/SUMMARY.md src/ch16-01-optimizing-storage-costs.md:1
msgid "Optimizing Storage Costs"
msgstr "Depolama Maliyetlerini Optimize Etme"

#: src/SUMMARY.md
msgid "Composability and Components"
msgstr "Kompozisyon ve Bileşenleri"

#: src/SUMMARY.md
msgid "Under the Hood"
msgstr "Hood'un Altında"

#: src/SUMMARY.md src/ch16-02-02-component-dependencies.md:1
msgid "Component Dependencies"
msgstr "Bileşen Bağımlılıkları"

#: src/SUMMARY.md src/ch16-02-03-testing-components.md:1
msgid "Testing Components"
msgstr "Test Bileşenleri"

#: src/SUMMARY.md
msgid "Upgradeability"
msgstr "Yükseltilebilirlik"

#: src/SUMMARY.md
msgid "L1 \\<\\> L2 Messaging"
msgstr "L1 > L2 Mesajlaşma"

#: src/SUMMARY.md src/ch16-05-oracle-interactions.md:1
msgid "Oracle Interactions"
msgstr "Oracle Etkileşimleri"

#: src/SUMMARY.md src/ch16-05-01-price-feeds.md:1
msgid "Price Feeds"
msgstr "Fiyat Beslemeleri"

#: src/SUMMARY.md src/ch16-05-02-randomness.md:1
msgid "Randomness"
msgstr "Rastgelelik"

#: src/SUMMARY.md src/ch16-06-00-other-examples.md:1
msgid "Other Examples"
msgstr "Diğer Örnekler"

#: src/SUMMARY.md
msgid "Deploying and Interacting with a Voting Contract"
msgstr "Bir Oy Sözleşmesi ile Dağıtım ve Etkileşim"

#: src/SUMMARY.md src/ch17-00-starknet-smart-contracts-security.md
msgid "Starknet Smart Contracts Security"
msgstr "Starknet Akıllı Sözleşmeler Güvenliği"

#: src/SUMMARY.md src/ch17-01-general-recommendations.md:1
msgid "General Recommendations"
msgstr "Genel Öneriler"

#: src/SUMMARY.md src/ch17-02-testing-smart-contracts.md:1
msgid "Testing Smart Contracts"
msgstr "Akıllı Sözleşmelerin Test Edilmesi"

#: src/SUMMARY.md src/ch17-03-static-analysis-tools.md:1
msgid "Static Analysis Tools"
msgstr "Statik Analiz Araçları"

#: src/SUMMARY.md
msgid "Formal Verification"
msgstr "Resmi Doğrulama"

#: src/SUMMARY.md src/appendix-00.md src/appendix-000.md
msgid "Appendix"
msgstr "Ek"

#: src/SUMMARY.md
msgid "Appendix (Starknet)"
msgstr "Ek (Starknet)"

#: src/SUMMARY.md
msgid "A - System Calls"
msgstr "A - Sistem Çağrıları"

#: src/SUMMARY.md
msgid "Cairo VM"
msgstr "Kahire VM"

#: src/SUMMARY.md src/ch00-00-introduction.md src/ch200-introduction.md
msgid "Introduction"
msgstr "Giriş"

#: src/SUMMARY.md
msgid "Architecture"
msgstr "Mimarlık"

#: src/SUMMARY.md
msgid "Memory"
msgstr "Bellek"

#: src/SUMMARY.md
msgid "Non-Deterministic Read-only Memory"
msgstr "Non-Deterministik Okuma-Sadece Bellek"

#: src/SUMMARY.md
msgid "Segments"
msgstr "Segmentler"

#: src/SUMMARY.md
msgid "Segment Value"
msgstr "Segment Değeri"

#: src/SUMMARY.md
msgid "Relocation"
msgstr "Yer Değiştirme"

#: src/SUMMARY.md
msgid "Layout"
msgstr "Yerleşim"

#: src/SUMMARY.md
msgid "Execution Model"
msgstr "Yürütme Modeli"

#: src/SUMMARY.md
msgid "Registers"
msgstr "Kayıtlar"

#: src/SUMMARY.md
msgid "Instructions"
msgstr "Talimatlar"

#: src/SUMMARY.md
msgid "Cairo Assembly (CASM)"
msgstr "Kahire Meclisi (CASM)"

#: src/SUMMARY.md
msgid "State transition"
msgstr "Durum geçişi"

#: src/SUMMARY.md
msgid "Builtins"
msgstr "Builtins"

#: src/SUMMARY.md
msgid "Memory Communication"
msgstr "Bellek İletişimi"

#: src/SUMMARY.md
msgid "List of builtins"
msgstr "Yapıtların listesi"

#: src/SUMMARY.md
msgid "Hints"
msgstr "İpucu"

#: src/SUMMARY.md
msgid "Structure"
msgstr "Yapı"

#: src/SUMMARY.md
msgid "Hint runner"
msgstr "İpucu koşucusu"

#: src/SUMMARY.md
msgid "List of hints"
msgstr "İpuçlarının listesi"

#: src/SUMMARY.md
msgid "Runner"
msgstr "Runner"

#: src/SUMMARY.md
msgid "Program"
msgstr "Program"

#: src/SUMMARY.md
msgid "Program Artifacts"
msgstr "Program Artifacts"

#: src/SUMMARY.md
msgid "Program Parsing"
msgstr "Program Ayrıştırma"

#: src/SUMMARY.md
msgid "Runner Mode"
msgstr "Runner Modu"

#: src/SUMMARY.md
msgid "Execution Mode"
msgstr "Yürütme Modu"

#: src/SUMMARY.md
msgid "Proof Mode"
msgstr "Proof Modu"

#: src/SUMMARY.md
msgid "Output"
msgstr "Çıktı"

#: src/SUMMARY.md
msgid "Cairo PIE"
msgstr "Kahire PIE"

#: src/SUMMARY.md
msgid "Memory File"
msgstr "Bellek Dosyası"

#: src/SUMMARY.md
msgid "Trace file"
msgstr "İz dosyası"

#: src/SUMMARY.md
msgid "AIR public input"
msgstr "AIR kamu girişi"

#: src/SUMMARY.md
msgid "AIR private input"
msgstr "AIR özel giriş"

#: src/SUMMARY.md
msgid "Tracer"
msgstr "Tracer"

#: src/SUMMARY.md
msgid "Implementations"
msgstr "Uygulamalar"

#: src/SUMMARY.md
msgid "Resources"
msgstr "Kaynaklar"

#: src/title-page.md
msgid ""
"By the Cairo Community and its [contributors](https://github.com/cairo-book/"
"cairo-book.github.io). Special thanks to [StarkWare](https://starkware.co/) "
"through [OnlyDust](https://www.onlydust.xyz/), and [Voyager](https://voyager."
"online/) for supporting the creation of this book."
msgstr ""
"Kahire Topluluğu ve [katkıda bulunanlar](https://github.com/cairo-book/cairo-"
"book.github.io) tarafından. [StarkWare](https://starkware.co/) aracılığıyla "
"[OnlyDust](https://www.online.com/), ve [Voyager](https://voyager.online/) "
"için bu kitabın oluşturulmasını destekleyen özel teşekkürler."

#: src/title-page.md
msgid ""
"This version of the text assumes you’re using the [Cairo Compiler](https://"
"github.com/starkware-libs/cairo) [version 2.6.3](https://github.com/"
"starkware-libs/cairo/releases). See the [Installation](ch01-01-installation."
"md) section of Chapter 1 to install or update Cairo."
msgstr ""
"Metnin bu sürümü, [Cairo Derleyicisi](https://github.com/starkware-libs/"
"cairo) [version 2.6.3](https://github.com/starkware-libs/cairo/releases] "
"kullandığınızı varsayar. Kahire'yi kurmak veya güncellemek için Bölüm 1'in "
"[Installation] (ch01-01-installation.mation.md) bölümüne bakın."

#: src/title-page.md
msgid ""
"If you want to play around with Cairo code and see how it compiles into "
"Sierra (Intermediate Representation) and CASM (Cairo Assembly), you can use "
"[cairovm.codes](https://cairovm.codes/) playground."
msgstr ""
"Kahire koduyla oynamak ve Sierra (Intermediate Representation) ve CASM "
"(Cairo Assembly) içine nasıl derlendiğini görmek istiyorsanız, [cairovm."
"codes](https://cairovm.codes/) oyun alanını kullanabilirsiniz."

#: src/ch00-01-foreword.md
msgid "Foreword"
msgstr "Önsöz"

#: src/ch00-01-foreword.md
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and "
"gradually became more expressive. The learning curve was initially steep, as "
"Cairo 0.x was a low-level language that did not entirely abstract the "
"underlying cryptographic primitives required to build a proof for the "
"execution of a program."
msgstr ""
"2020'de StarkWare, doğrulanabilir hesaplamayı destekleyen bir Turing-tam "
"programlama dili olan Cairo 0'ı yayınladı. Kahire bir montaj dili olarak "
"başladı ve yavaş yavaş daha etkileyici hale geldi. Kahire 0.x, bir programın "
"yürütülmesi için bir kanıt oluşturmak için gerekli olan temel kriptografik "
"ilkelleri tamamen soyutlamayan düşük seviyeli bir dil olduğu için öğrenme "
"eğrisi başlangıçta dikti."

#: src/ch00-01-foreword.md
msgid ""
"With the release of Cairo 1, the developer experience has considerably "
"improved, abstracting away the underlying immutable memory model of the "
"Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has "
"been built to help you create provable programs without specific knowledge "
"of its underlying architecture so that you can focus on the program itself, "
"increasing the overall security of Cairo programs. Powered by a Rust VM, the "
"execution of Cairo programs is now _blazingly_ fast, allowing you to build "
"an extensive test suite without compromising on performance."
msgstr ""
"Kahire 1'in piyasaya sürülmesiyle, geliştirici deneyimi önemli ölçüde "
"gelişti, mümkün olan yerlerde Kahire mimarisinin altında yatan değişmez "
"bellek modelini soyutladı. Rust'tan güçlü bir şekilde ilham alan Kahire 1, "
"temel mimarisi hakkında belirli bir bilgi sahibi olmadan kanıtlanabilir "
"programlar oluşturmanıza yardımcı olmak için inşa edildi, böylece programın "
"kendisine odaklanabilir, Kahire programlarının genel güvenliğini "
"artırabilirsiniz. Bir Rust VM ile güçlendirilmiş, Kahire programlarının "
"yürütülmesi artık kapsamlı bir test oluşturmaya izin vermeden _blazingly_ "
"hızlıdır."

#: src/ch00-01-foreword.md
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the "
"Cairo programming language to code their smart contracts. This allows the "
"Starknet OS to generate execution traces for transactions to be proved by a "
"prover, which is then verified on Ethereum L1 prior to updating the state "
"root of Starknet."
msgstr ""
"Starknet'te sözleşmeleri dağıtmak isteyen blok zinciri geliştiricileri, "
"akıllı sözleşmelerini kodlamak için Kahire programlama dilini kullanacaklar. "
"Bu, Starknet OS'nin, işlemlerin bir kanıtlayıcı tarafından kanıtlanması için "
"yürütme izleri üretmesine izin verir, bu da daha sonra Starknet'in devlet "
"kökünü güncellemeden önce Ethereum L1'de doğrulanır."

#: src/ch00-01-foreword.md
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit "
"from being proved on one computer and verified on other machines with lower "
"hardware requirements."
msgstr ""
"Bununla birlikte, Kahire sadece blok zinciri geliştiricileri için değildir. "
"Genel amaçlı bir programlama dili olarak, bir bilgisayarda kanıtlanmaktan ve "
"daha düşük donanım gereksinimlerine sahip diğer makinelerde doğrulanmaktan "
"yararlanacak herhangi bir hesaplama için kullanılabilir."

#: src/ch00-01-foreword.md
msgid ""
"This book is designed for developers with a basic understanding of "
"programming concepts. It is a friendly and approachable text intended to "
"help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there "
"is to know about Cairo!"
msgstr ""
"Bu kitap, temel programlama kavramları anlayışına sahip geliştiriciler için "
"tasarlanmıştır. Kahire bilginizi seviyelendirmenize yardımcı olacak, aynı "
"zamanda genel olarak programlama becerilerinizi geliştirmenize yardımcı "
"olacak dostane ve yaklaşılabilir bir metindir. Bu yüzden, dalış yapın ve "
"Kahire hakkında bilmeniz gereken her şeyi öğrenmeye hazır olun!"

#: src/ch00-01-foreword.md
msgid "Acknowledgements"
msgstr "Onaylamalar"

#: src/ch00-01-foreword.md
msgid ""
"This book would not have been possible without the help of the Cairo "
"community. We would like to thank every contributor for their contributions "
"to this book!"
msgstr ""
"Bu kitap Kahire toplumunun yardımı olmadan mümkün olmazdı. Bu kitaba "
"katkılarından dolayı her katılımcıya teşekkür etmek isteriz!"

#: src/ch00-01-foreword.md
msgid ""
"We would like to thank the Rust community for the [Rust Book](https://doc."
"rust-lang.org/book/), which has been a great source of inspiration for this "
"book. Many examples and explanations have been adapted from the Rust Book to "
"fit the Cairo programming language, as the two languages share many "
"similarities."
msgstr ""
"Bu kitap için büyük bir ilham kaynağı olan [Rust Book](https://doc.rust-lang."
"org/book/) için Rust topluluğuna teşekkür etmek istiyoruz. İki dil birçok "
"benzerliği paylaştığından, Rust Book'tan Kahire programlama diline uyacak "
"şekilde birçok örnek ve açıklama uyarlanmıştır."

#: src/ch00-00-introduction.md
msgid "What is Cairo?"
msgstr "Kahire nedir?"

#: src/ch00-00-introduction.md
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name. "
"The unique aspect of this processor is that it was not created for the "
"physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. "
"This means that you can perform time consuming operations on a machine you "
"don't trust, and check the result very quickly on a cheaper machine. While "
"Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo "
"1 is a higher level language. It first compiles to Sierra, an intermediate "
"representation of Cairo which will compile later down to a safe subset of "
"CASM. The point of Sierra is to ensure your CASM will always be provable, "
"even when the computation fails."
msgstr ""
"Kahire, aynı adı taşıyan sanal bir CPU için tasarlanmış bir programlama "
"dilidir. Bu işlemcinin benzersiz yönü, dünyamızın fiziksel kısıtlamaları "
"için değil, kriptografik olanlar için yaratılmış olması, üzerinde çalışan "
"herhangi bir programın yürütülmesini verimli bir şekilde "
"kanıtlayabilmesidir. Bu, her zaman güvenmediğiniz bir makinede zaman alıcı "
"işlemleri gerçekleştirebileceğiniz ve sonucu daha sonra daha ucuz bir "
"makinede çok hızlı bir şekilde kontrol edebileceğiniz anlamına gelir. Kahire "
"0, doğrudan CASM'ye derlendiğinde, Kahire'nin bir derlemesidir."

#: src/ch00-00-introduction.md
msgid "What Can you Do with It?"
msgstr "Bununla ne yapabilirsiniz?"

#: src/ch00-00-introduction.md
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One "
"major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a "
"decentralized blockchain platform that enables the creation of decentralized "
"applications where every single interaction between a user and a d-app is "
"verified by all the participants. Starknet is a Layer 2 built on top of "
"Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the "
"programs and generates proofs that the computations were done correctly. "
"These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and "
"reduced transaction costs while preserving Ethereum security."
msgstr ""
"Kahire, güvenilir olmayan makinelerde güvenilir değerleri hesaplamanıza izin "
"verir. Önemli bir kullanım durumu, Ethereum ölçeklendirmesi için bir çözüm "
"olan Starknet'tir. Ethereum, bir kullanıcı ve bir d-app arasındaki her bir "
"etkileşimin tüm katılımcılar tarafından doğrulandığı merkezi olmayan "
"uygulamaların oluşturulmasını sağlayan merkezi olmayan bir blok zinciri "
"platformudur. Starknet, Ethereum'un üzerine inşa edilmiş bir Katman 2'dir. "
"Tüm kullanıcı etkileşimlerini doğrulamak için ağın tüm katılımcılarına sahip "
"olmak yerine, kanıtlayıcı olarak adlandırılan güç etkileşimlerini "
"gerçekleştirir ve uygular."

#: src/ch00-00-introduction.md
msgid "What Are the Differences with Other Programming Languages?"
msgstr "Diğer Programlama Dilleri Arasındaki Farklar Nelerdir?"

#: src/ch00-00-introduction.md
msgid ""
"Cairo is quite different from traditional programming languages, especially "
"when it comes to overhead costs and its primary advantages. Your program can "
"be executed in two different ways:"
msgstr ""
"Kahire, geleneksel programlama dillerinden oldukça farklıdır, özellikle de "
"genel giderler ve birincil avantajları söz konusu olduğunda. Programınız iki "
"farklı şekilde yürütülebilir:"

#: src/ch00-00-introduction.md
msgid ""
"When executed by the prover, it is similar to any other language. Because "
"Cairo is virtualized, and because the operations were not specifically "
"designed for maximum efficiency, this can lead to some performance overhead "
"but it is not the most relevant part to optimize."
msgstr ""
"Kanıtlayıcı tarafından yürütüldüğünde, diğer dillere benzer. Kahire "
"sanallaştırıldığından ve işlemler maksimum verimlilik için özel olarak "
"tasarlanmadığından, bu bazı performans yüküne yol açabilir, ancak optimize "
"etmek için en alakalı kısım değildir."

#: src/ch00-00-introduction.md
msgid ""
"When the generated proof is verified by a verifier, it is a bit different. "
"This has to be as cheap as possible since it could potentially be verified "
"on many very small machines. Fortunately verifying is faster than computing "
"and Cairo has some unique advantages to improve it even more. A notable one "
"is non-determinism. This is a topic you will cover in more detail later in "
"this book, but the idea is that you can theoretically use a different "
"algorithm for verifying than for computing. Currently, writing custom non-"
"deterministic code is not supported for the developers, but the standard "
"library leverages non-determinism for improved performance. For example "
"sorting an array in Cairo costs the same price as copying it. Because the "
"verifier doesn't sort the array, it just checks that it is sorted, which is "
"cheaper."
msgstr ""
"Oluşturulan kanıt bir doğrulayıcı tarafından doğrulandığında, biraz "
"farklıdır. Bu, birçok çok küçük makinede potansiyel olarak doğrulanabileceği "
"için mümkün olduğunca ucuz olmalıdır. Neyse ki doğrulama işlemi, "
"hesaplamadan daha hızlıdır ve Kahire'nin daha da geliştirmek için bazı "
"benzersiz avantajları vardır. Dikkat çekici olan, belirleyici olmayan bir "
"özelliktir. Bu, daha sonra bu kitapta ele alacağınız bir konudur, ancak "
"fikir, şu anda doğrulama için teorik olarak farklı bir algoritma "
"kullanabileceğinizdir."

#: src/ch00-00-introduction.md
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, "
"memory access is immutable, meaning that once a value is written to memory, "
"it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. "
"Therefore, developers must think carefully about how they manage memory and "
"data structures in their programs to optimize performance."
msgstr ""
"Dili birbirinden ayıran bir başka özellik de bellek modelidir. Kahire'de "
"bellek erişimi değişmezdir, yani bir değer hafızaya yazıldığında "
"değiştirilemez. Kahire 1, geliştiricilerin bu kısıtlamalarla çalışmasına "
"yardımcı olan soyutlamalar sağlar, ancak tamamen değişkenliği simüle etmez. "
"Bu nedenle, geliştiriciler performanslarını optimize etmek için "
"programlarındaki bellek ve veri yapılarını nasıl yönettiklerini dikkatlice "
"düşünmelidir."

#: src/ch00-00-introduction.md
msgid "References"
msgstr "Kaynakça"

#: src/ch00-00-introduction.md
msgid "Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>"
msgstr "Kahire CPU Mimarisi: https://eprint.iacr.org/2021/1063>"

#: src/ch00-00-introduction.md
msgid ""
"Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-of-"
"cairo-1-0-exploring-sierra-7f32808421f5>"
msgstr ""
"Kahire, Sierra ve Casm: https://medium.com/nethermind-eth/under-the-hood-of-"
"cairo-1-0-exploring-sierra-7f32808421f5>"

#: src/ch00-00-introduction.md
msgid ""
"State of non determinism: <https://twitter.com/PapiniShahar/"
"status/1638203716535713798>"
msgstr ""
"Determinizmin Durumu: https://twitter.com/PapiniShahar/"
"status/1638273716535713798>"

#: src/ch01-00-getting-started.md
msgid ""
"Let’s start your Cairo journey! There’s a lot to learn, but every journey "
"starts somewhere. In this chapter, we’ll discuss:"
msgstr ""
"Kahire yolculuğuna başlayalım! Öğrenecek çok şey var, ama her yolculuk bir "
"yerden başlıyor. Bu bölümde, tartışacağız:"

#: src/ch01-00-getting-started.md
msgid ""
"Installing Scarb, which is Cairo's build toolchain and package manager, on "
"Linux, macOS, and Windows."
msgstr ""
"Kahire'nin araç zinciri ve paket yöneticisi olan Scarb'ı Linux, macOS ve "
"Windows'a yüklemek."

#: src/ch01-00-getting-started.md
msgid "Writing a program that prints `Hello, world!`."
msgstr "Merhaba, dünya! yazdıran bir program yazmak."

#: src/ch01-00-getting-started.md
msgid "Using basic Scarb commands to create a project and execute a program."
msgstr ""
"Temel Scarb komutlarını kullanarak bir proje oluşturun ve bir programı "
"çalıştırın."

#: src/ch01-00-getting-started.md
msgid "Getting Help"
msgstr "Yardım Alınıyor"

#: src/ch01-00-getting-started.md
msgid ""
"If you have any questions about Starknet or Cairo, you can ask them in the "
"[Starknet Discord server](https://discord.gg/starknet-community). The "
"community is friendly and always willing to help."
msgstr ""
"Starknet veya Kahire hakkında herhangi bir sorunuz varsa, bunları [Starknet "
"Discord sunucusu] (https://discord.gg/starknet-community) adresinden "
"isteyebilirsiniz. Topluluk arkadaş canlısı ve her zaman yardım etmeye "
"isteklidir."

#: src/ch01-00-getting-started.md
msgid "Interacting with the Cairo Chatbot"
msgstr "Kahire Chatbot'u ile etkileşim"

#: src/ch01-00-getting-started.md
msgid ""
"Cairo has its own chatbot, which can help you with Cairo-related questions. "
"The chatbot is trained on the Cairo book, and uses RAG to efficiently "
"retrieve information to provide help. You can find the chatbot on the [Cairo-"
"Chatbot](https://cairo-chatbot.vercel.app/) website."
msgstr ""
"Kahire'nin Kahire ile ilgili sorularda size yardımcı olabilecek kendi "
"chatbot'u vardır. Chatbot Kahire kitabında eğitilir ve yardım sağlamak için "
"bilgileri verimli bir şekilde almak için RAG kullanır. Chatbot'u [Cairo-"
"Chatbot](https://cairo-chatbot.vercel.app/) web sitesinde bulabilirsiniz."

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading [Scarb](https://docs.swmansion."
"com/scarb/docs). Scarb bundles the Cairo compiler and the Cairo language "
"server together in an easy-to-install package so that you can start writing "
"Cairo code right away."
msgstr ""
"Kahire basitçe indirerek kurulabilir [Scarb](https://docs.swmansion.com/"
"scarb/docs). Scarb, Kahire derleyicisini ve Kahire dil sunucusunu bir araya "
"getirir, böylece Kahire kodunu hemen yazmaya başlayabilirsiniz."

#: src/ch01-01-installation.md:5
msgid ""
"Scarb is also Cairo's package manager and is heavily inspired by [Cargo]"
"(https://doc.rust-lang.org/cargo/), Rust’s build system and package manager."
msgstr ""
"Scarb aynı zamanda Kahire'nin paket yöneticisidir ve [Cargo](https://doc."
"rust-lang.org/cargo/), Rust'un yapı sistemi ve paket yöneticisinden yoğun "
"bir şekilde ilham almaktadır."

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either "
"pure Cairo or Starknet contracts), downloading the libraries your code "
"depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""
"Scarb, kodunuzu oluşturmak (saf Kahire veya Starknet sözleşmeleri), "
"kodunuzun bağlı olduğu kütüphaneleri indirmek, bu kütüphaneleri oluşturmak "
"gibi sizin için birçok görevi yerine getirir ve VSCode Cairo 1 uzantısı için "
"LSP desteği sağlar."

#: src/ch01-01-installation.md:9
msgid ""
"As you write more complex Cairo programs, you might add dependencies, and if "
"you start a project using Scarb, managing external code and dependencies "
"will be a lot easier to do."
msgstr ""
"Daha karmaşık Kahire programları yazarken, bağımlılıklar ekleyebilirsiniz ve "
"Scarb'ı kullanarak bir projeye başlarsanız, harici kodu ve bağımlılıkları "
"yönetmek çok daha kolay olacaktır."

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr "Scarb'ı kurarak başlayalım."

#: src/ch01-01-installation.md:16
msgid "Installing Scarb"
msgstr "Scarb Kurulumu"

#: src/ch01-01-installation.md:18
msgid "Requirements"
msgstr "Gereksinimler"

#: src/ch01-01-installation.md:20
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment "
"variable."
msgstr ""
"Scarb, PATH ortam değişkeninde kullanılabilir olması için bir Git "
"çalıştırılabiliri gerektirir."

#: src/ch01-01-installation.md:24
msgid ""
"To install Scarb, please refer to the [installation instructions](https://"
"docs.swmansion.com/scarb/download). We strongly recommend that you install "
"Scarb [via asdf](https://docs.swmansion.com/scarb/download.html#install-via-"
"asdf), a CLI tool that can manage multiple language runtime versions on a "
"per-project basis. This will ensure that the version of Scarb you use to "
"work on a project always matches the one defined in the project settings, "
"avoiding problems related to version mismatches."
msgstr ""
"Scarb'ı yüklemek için lütfen [yükleme talimatları](https://docs.swmansion."
"com/scarb/download) adresine bakın. Scarb'ı [via asdf] (https://docs."
"swmansion.com/scarb/download.html#install-via-asdf) yüklemenizi şiddetle "
"tavsiye ederiz, bu, proje başına kullandığınız bir çalışma süresinde birden "
"fazla dil çalışma zamanı sürümünü yönetebilecek bir CLI aracıdır."

#: src/ch01-01-installation.md:28
msgid ""
"Please refer to the [asdf documentation](https://asdf-vm.com/guide/getting-"
"started.html) to install all prerequisites."
msgstr ""
"Lütfen tüm önkoşulları yüklemek için [asdf documentation](https://asdf-vm."
"com/guide/getting-started.html) adresine bakınız."

#: src/ch01-01-installation.md:30
msgid ""
"Once you have asdf installed locally, you can download Scarb plugin with the "
"following command:"
msgstr ""
"Asdf'yi yerel olarak yükledikten sonra, Scarb eklentisini aşağıdaki komutla "
"indirebilirsiniz:"

#: src/ch01-01-installation.md:36
msgid "This will allow you to download specific versions:"
msgstr "Bu, belirli sürümleri indirmenize izin verecektir:"

#: src/ch01-01-installation.md:42
msgid "and set a global version:"
msgstr "ve küresel bir sürüm ayarlayın:"

#: src/ch01-01-installation.md:48
msgid ""
"Otherwise, you can simply run the following command in your terminal, and "
"follow the onscreen instructions. This will install the latest stable "
"release of Scarb."
msgstr ""
"Aksi takdirde, terminalinizde aşağıdaki komutu çalıştırabilir ve ekrandaki "
"talimatları takip edebilirsiniz. Bu, Scarb'ın en son kararlı sürümünü "
"kuracaktır."

#: src/ch01-01-installation.md:51
msgid "'=https'"
msgstr "'=https'"

#: src/ch01-01-installation.md:68
msgid "Installing the VSCode Extension"
msgstr "VSCode Uzantısını Kurmak"

#: src/ch01-01-installation.md:70
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code "
"completion, and other useful features. You can install it from the [VSCode "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware."
"cairo1). Once installed, go into the extension settings, and make sure to "
"tick the `Enable Language Server` and `Enable Scarb` options."
msgstr ""
"Kahire, sözdizimi vurgulama, kod tamamlama ve diğer yararlı özellikler "
"sağlayan bir VSCode uzantısına sahiptir. [VSCode Marketplace](https://"
"marketplace.visualstudio.com/items?itemName=starkware.cairo1) adresinden "
"yükleyebilirsiniz. Kurulduktan sonra, uzantı ayarlarına gidin ve Enable "
"Language Server ve Enable Scarb seçeneklerini işaretlediğinizden emin olun."

#: src/ch01-01-installation.md:75
msgid "{{#quiz ../quizzes/ch01-01-installation.toml}}"
msgstr "#quiz../quizzes/ch01-01-installation.toml"

#: src/ch01-02-hello-world.md:1
msgid "Hello, World"
msgstr "Merhaba, Dünya"

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first "
"Cairo program. It’s traditional when learning a new language to write a "
"little program that prints the text `Hello, world!` to the screen, so we’ll "
"do the same here!"
msgstr ""
"Artık Kahire'yi Scarb üzerinden yüklediğinize göre, ilk Kahire programınızı "
"yazmanın zamanı geldi. Merhaba, dünya! metnini ekrana yazdıran küçük bir "
"program yazmak için yeni bir dil öğrenirken gelenekseldir, bu yüzden "
"aynısını burada yapacağız!"

#: src/ch01-02-hello-world.md:7
msgid ""
"Note: This book assumes basic familiarity with the command line. Cairo makes "
"no specific demands about your editing or tooling or where your code lives, "
"so if you prefer to use an integrated development environment (IDE) instead "
"of the command line, feel free to use your favorite IDE. The Cairo team has "
"developed a VSCode extension for the Cairo language that you can use to get "
"the features from the language server and code highlighting. See [Appendix F]"
"(./appendix-06-useful-development-tools.md) for more details."
msgstr ""
"Not: Bu kitap, komut satırı ile temel aşinalığı varsayar. Kahire, "
"düzenlemeniz veya takım oluşturmanız veya kodunuzun nerede yaşadığı "
"konusunda belirli bir talepte bulunmaz, bu nedenle komut satırı yerine "
"entegre bir geliştirme ortamı (IDE) kullanmayı tercih ederseniz, en "
"sevdiğiniz IDE'yi kullanmaktan çekinmeyin. Kahire ekibi, Kahire dili için, "
"dil sunucusundan ve kod vurgulamadan yararlanabileceğiniz bir VSCode "
"uzantısı geliştirdi. [Append-tool-end] (bkz."

#: src/ch01-02-hello-world.md:17
msgid "Creating a Project Directory"
msgstr "Proje Dizini Oluşturma"

#: src/ch01-02-hello-world.md:19
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t "
"matter to Cairo where your code lives, but for the exercises and projects in "
"this book, we suggest making a _cairo_projects_ directory in your home "
"directory and keeping all your projects there."
msgstr ""
"Kahire kodunuzu saklamak için bir dizin yaparak işe başlarsınız. Kodunuzun "
"nerede yaşadığı Kahire için önemli değil, ancak bu kitaptaki alıştırmalar ve "
"projeler için, ev dizininize bir _cairo_projects_ dizini hazırlamanızı ve "
"tüm projelerinizi orada tutmanızı öneririz."

#: src/ch01-02-hello-world.md:24
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory."
msgstr ""
"Bir terminal açın ve _cairo_projects_ dizini yapmak için aşağıdaki komutları "
"girin."

#: src/ch01-02-hello-world.md:26
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr "Windows'ta Linux, macOS ve PowerShell için şunları girin:"

#: src/ch01-02-hello-world.md:33
msgid "For Windows CMD, enter this:"
msgstr "Windows CMD için şunları girin:"

#: src/ch01-02-hello-world.md:36 src/ch01-02-hello-world.md:37
msgid "\"%USERPROFILE%\\cairo_projects\""
msgstr "\"%USERPROFILE%cairo_projects\" (İngilizce)."

#: src/ch01-02-hello-world.md:40
msgid ""
"Note: From now on, for each example shown in the book, we assume that you "
"will be working from a Scarb project directory. If you are not using Scarb, "
"and try to run the examples from a different directory, you might need to "
"adjust the commands accordingly or create a Scarb project."
msgstr ""
"Not: Bundan sonra, kitapta gösterilen her örnek için, bir Scarb proje "
"dizininden çalışacağınızı varsayıyoruz. Scarb kullanmıyorsanız ve örnekleri "
"farklı bir dizinden çalıştırmaya çalışıyorsanız, komutları buna göre "
"ayarlamanız veya bir Scarb projesi oluşturmanız gerekebilir."

#: src/ch01-02-hello-world.md:43
msgid "Creating a Project with Scarb"
msgstr "Scarb ile Proje Oluşturma"

#: src/ch01-02-hello-world.md:45
msgid "Let’s create a new project using Scarb."
msgstr "Scarb kullanarak yeni bir proje oluşturalım."

#: src/ch01-02-hello-world.md:47
msgid ""
"Navigate to your _cairo_projects_ directory (or wherever you decided to "
"store your code). Then run the following:"
msgstr ""
"_cairo_projects_ dizinine (veya kodunuzu saklamaya karar verdiğiniz yere) "
"gidin. Ardından aşağıdakileri çalıştırın:"

#: src/ch01-02-hello-world.md:53
msgid ""
"It creates a new directory and project called _hello_world_. We’ve named our "
"project _hello_world_, and Scarb creates its files in a directory of the "
"same name."
msgstr ""
"_hello_world_ adlı yeni bir dizin ve proje oluşturur. Projemize "
"_hello_world_ adını verdik ve Scarb dosyalarını aynı isimli bir dizinde "
"oluşturuyor."

#: src/ch01-02-hello-world.md:55
msgid ""
"Go into the _hello_world_ directory with the command `cd hello_world`. "
"You’ll see that Scarb has generated two files and one directory for us: a "
"_Scarb.toml_ file and a _src_ directory with a _lib.cairo_ file inside."
msgstr ""
"cd alo_world komutuyla _hello_world_ dizinine gidin. Scarb'ın bizim için iki "
"dosya ve bir dizin oluşturduğunu göreceksiniz: bir _Scarb.toml_ dosyası ve "
"içinde _lib.cairo_ dosyası bulunan bir _src_ dizini."

#: src/ch01-02-hello-world.md:57
msgid ""
"It has also initialized a new Git repository along with a `.gitignore` file"
msgstr "Ayrıca.gitignore dosyasıyla birlikte yeni Git deposunu başlatmıştır."

#: src/ch01-02-hello-world.md:59
msgid ""
"Note: Git is a common version control system. You can stop using version "
"control system by using the `--no-vcs` flag. Run `scarb new --help` to see "
"the available options."
msgstr ""
"Not: Git yaygın bir sürüm kontrol sistemidir. --no-vcs bayrağını kullanarak "
"sürüm kontrol sistemini kullanmayı bırakabilirsiniz. Mevcut seçenekleri "
"görmek için scarb new --help uygulamasını çalıştırın."

#: src/ch01-02-hello-world.md:62
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-1."
msgstr ""
"Tercih ettiğiniz metin editöründe _Scarb.toml_ açın. Listeleme 1-1'deki koda "
"benzer görünmelidir."

#: src/ch01-02-hello-world.md:64
msgid "<span class=\"filename\">Filename: Scarb.toml</span>"
msgstr "span class=\"filename\">Filename: Scarb.toml/span>"

#: src/ch01-02-hello-world.md:66
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"edition = \"2023_11\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/"
"docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"toml [package] name = \"hello_world\" version = \"0.1.0\" edition = "
"\"2023_11\" # https://docs.swmansion.com/scarb/docs/reference/manifest "
"[bağımlılar] # foo =  path = \"vendor/foo\""

#: src/ch01-02-hello-world.md:78
msgid ""
"<span class=\"caption\">Listing 1-1: Contents of _Scarb.toml_ generated by "
"`scarb new`</span>"
msgstr ""
"span class=\"caption=\"Listing 1-1: Contents of _Scarb.toml_ scarb new/span> "
"tarafından oluşturulan içerikler"

#: src/ch01-02-hello-world.md:80
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal "
"Language) format, which is Scarb’s configuration format."
msgstr ""
"Bu dosya [TOML](https://toml.io/) (Tom'un Açık, Minimal Dili) biçimindedir, "
"bu da Scarb'ın yapılandırma biçimidir."

#: src/ch01-02-hello-world.md:82
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr ""
"İlk satır, [package], aşağıdaki ifadelerin bir paketi yapılandırdığını "
"gösteren bir bölüm başlığıdır. Bu dosyaya daha fazla bilgi ekledikçe, diğer "
"bölümleri de ekleyeceğiz."

#: src/ch01-02-hello-world.md:84
msgid ""
"The next three lines set the configuration information Scarb needs to "
"compile your program: the name of the package and the version of Scarb to "
"use, and the edition of the prelude to use. The prelude is the collection of "
"the most commonly used items that are automatically imported into every "
"Cairo program. You can learn more about the prelude in [Appendix D](./"
"appendix-04-cairo-prelude.md)."
msgstr ""
"Sonraki üç satır, Scarb'ın programınızı derlemesi gereken yapılandırma "
"bilgilerini ayarlar: paketin adı ve kullanılacak Scarb sürümü ve "
"kullanılacak prelüd sürümü. Prelüd, her Kahire programına otomatik olarak "
"ithal edilen en yaygın kullanılan öğelerin koleksiyonudur. [Ek D] (./"
"appendix-04-cairo-prelude.md) 'deki prelüd hakkında daha fazla bilgi "
"edinebilirsiniz."

#: src/ch01-02-hello-world.md:86
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Cairo, packages of code are referred "
"to as crates. We won’t need any other crates for this project."
msgstr ""
"Son satır, [bağımlılar], projenizin bağımlılıklarından herhangi birini "
"listelemeniz için bir bölümün başlangıcıdır. Kahire'de, kod paketleri sandık "
"olarak adlandırılır. Bu proje için başka sandıklara ihtiyacımız olmayacak."

#: src/ch01-02-hello-world.md:88
msgid ""
"Note: If you're building contracts for Starknet, you will need to add the "
"`starknet` dependency as mentioned in the [Scarb documentation](https://docs."
"swmansion.com/scarb/docs/extensions/starknet/starknet-package.html)."
msgstr ""
"Not: Starknet için sözleşmeler yapıyorsanız, [Scarb dokümantasyonunda] "
"belirtildiği gibi starknet bağımlılığını eklemeniz gerekir(https://docs."
"swmansion.com/scarb/docs/extensions/starknet/starknet-package.html)."

#: src/ch01-02-hello-world.md:90
msgid ""
"The other file created by Scarb is _src/lib.cairo_, let's delete all the "
"content and put in the following content, we will explain the reason later."
msgstr ""
"Scarb tarafından oluşturulan diğer dosya _src/lib.cairo_, tüm içeriği "
"silelim ve aşağıdaki içeriğe koyalım, nedenini daha sonra açıklayacağız."

#: src/ch01-02-hello-world.md:96
msgid ""
"Then create a new file called _src/hello_world.cairo_ and put the following "
"code in it:"
msgstr ""
"Daha sonra _src/hello_world.cairo_ adında yeni bir dosya oluşturun ve "
"aşağıdaki kodu içine koyun:"

#: src/ch01-02-hello-world.md:98
msgid "<span class=\"filename\">Filename: src/hello_world.cairo</span>"
msgstr "span class=\"filename\">Dosya adı: src/hello_world.cairo/span>"

#: src/ch01-02-hello-world.md:102 src/ch01-02-hello-world.md:185
msgid "\"Hello, World!\""
msgstr "\"Merhaba Dünya!\""

#: src/ch01-02-hello-world.md:106
msgid ""
"We have just created a file called _lib.cairo_, which contains a module "
"declaration referencing another module named `hello_world`, as well as the "
"file _hello_world.cairo_, containing the implementation details of the "
"`hello_world` module."
msgstr ""
"hello_world adlı başka bir modüle atıfta bulunan bir modül deklarasyonu ve "
"hello_world.cairo_ dosyasını içeren _lib.cairo_ adlı bir dosya oluşturduk."

#: src/ch01-02-hello-world.md:108
msgid ""
"Scarb requires your source files to be located within the _src_ directory."
msgstr ""
"Scarb kaynak dosyalarınızın _src_ dizini içinde bulunmasını gerektirir."

#: src/ch01-02-hello-world.md:110
msgid ""
"The top-level project directory is reserved for README files, license "
"information, configuration files, and any other non-code-related content. "
"Scarb ensures a designated location for all project components, maintaining "
"a structured organization."
msgstr ""
"Üst düzey proje dizini README dosyaları, lisans bilgileri, yapılandırma "
"dosyaları ve kodla ilgili olmayan diğer içerikler için ayrılmıştır. Scarb, "
"yapılandırılmış bir organizasyonu koruyarak tüm proje bileşenleri için "
"belirlenmiş bir konum sağlar."

#: src/ch01-02-hello-world.md:113
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a "
"project that does use Scarb. Move the project code into the _src_ directory "
"and create an appropriate _Scarb.toml_ file. You can also use `scarb init` "
"command to generate the _src_ folder and the _Scarb.toml_ it contains."
msgstr ""
"Scarb kullanmayan bir proje başlattıysanız, Scarb kullanan bir projeye "
"dönüştürebilirsiniz. Proje kodunu _src_ dizinine taşıyın ve uygun bir _Scarb."
"toml_ dosyası oluşturun. Ayrıca, içerdiği _src_ klasörünü ve _scarb.toml_ "
"komutunu oluşturmak için scarb init komutunu kullanabilirsiniz."

#: src/ch01-02-hello-world.md:122
msgid "<span class=\"caption\"> A sample Scarb project structure</span>"
msgstr "span class=\"caption\"> Örnek bir Scarb proje yapısı/span>"

#: src/ch01-02-hello-world.md:128
msgid "Building a Scarb Project"
msgstr "Bir Scarb Projesi Oluşturmak"

#: src/ch01-02-hello-world.md:130
msgid ""
"From your _hello_world_ directory, build your project by entering the "
"following command:"
msgstr "_hello_world_ dizininden aşağıdaki komutu girerek projenizi oluşturun:"

#: src/ch01-02-hello-world.md:138
msgid ""
"This command creates a `sierra` file in _target/dev_, let's ignore the "
"`sierra` file for now."
msgstr ""
"Bu komut _target/dev_ içinde bir sierra dosyası oluşturur, şimdilik sierra "
"dosyasını görmezden gelelim."

#: src/ch01-02-hello-world.md:140
msgid ""
"If you have installed Cairo correctly, you should be able to run the `main` "
"function of your program with the `scarb cairo-run` command and see the "
"following output:"
msgstr ""
"Kahire'yi doğru bir şekilde yüklediyseniz, programınızın scarb cairo-run "
"komutuyla main işlevini çalıştırabilir ve aşağıdaki çıktıyı görebilirsiniz:"

#: src/ch01-02-hello-world.md:149
msgid ""
"Regardless of your operating system, the string `Hello, world!` should be "
"printed to the terminal."
msgstr ""
"İşletim sisteminizden bağımsız olarak, Merhaba dünya! dizgisi terminale "
"basılmalıdır."

#: src/ch01-02-hello-world.md:152
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Cairo program. That makes you a Cairo programmer — welcome!"
msgstr ""
"Eğer Merhaba, dünya! baskı yaptıysa, tebrikler! Resmi olarak bir Kahire "
"programı yazdınız. Bu sizi bir Kahire programcısı yapar - hoş geldiniz!"

#: src/ch01-02-hello-world.md:155
msgid "Anatomy of a Cairo Program"
msgstr "Bir Kahire Programının Anatomisi"

#: src/ch01-02-hello-world.md:157
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of the puzzle:"
msgstr ""
"Bu \"Merhaba dünya!\" programını ayrıntılı olarak inceleyelim. İşte "
"bulmacanın ilk parçası:"

#: src/ch01-02-hello-world.md:166
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it is always the first code that runs in every executable Cairo program. "
"Here, the first line declares a function named `main` that has no parameters "
"and returns nothing. If there were parameters, they would go inside the "
"parentheses `()`."
msgstr ""
"Bu satırlar main adlı bir fonksiyon tanımlar. main işlevi özeldir: her "
"çalıştırılabilir Kahire programında çalışan ilk koddur. Burada, ilk satır "
"main adında parametresi olmayan ve hiçbir şey döndürmeyen bir fonksiyon "
"bildirir. Parametreler olsaydı, parantezlerin içine girerlerdi ()."

#: src/ch01-02-hello-world.md:171
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around "
"all function bodies. It’s good style to place the opening curly bracket on "
"the same line as the function declaration, adding one space in between."
msgstr ""
"Fonksiyon gövdesi 'ye sarılır. Kahire, tüm fonksiyon organları etrafında "
"kıvırcık parantez gerektirir. Açılış kıvırcık parantezini fonksiyon "
"deklarasyonuyla aynı çizgiye yerleştirmek ve aralara bir boşluk eklemek iyi "
"bir stildir."

#: src/ch01-02-hello-world.md:175
msgid ""
"Note: If you want to stick to a standard style across Cairo projects, you "
"can use the automatic formatter tool available with `scarb fmt` to format "
"your code in a particular style (more on `scarb fmt` in [Appendix F](./"
"appendix-06-useful-development-tools.md)). The Cairo team has included this "
"tool with the standard Cairo distribution, as `cairo-run` is, so it should "
"already be installed on your computer!"
msgstr ""
"Not: Kahire projeleri arasında standart bir stile bağlı kalmak istiyorsanız, "
"kodunuzu belirli bir stilde biçimlendirmek için scarb fmt ile mevcut olan "
"otomatik biçimlendirici aracını kullanabilirsiniz (daha fazla scarb fmt'de "
"[Ek F] (./appendix-06-useful-development-tools.md)). Kahire ekibi bu aracı "
"standart Kahire dağıtımına dahil etti, bu yüzden iroca olması gerekiyor."

#: src/ch01-02-hello-world.md:182
msgid "The body of the `main` function holds the following code:"
msgstr "main işlevinin gövdesi aşağıdaki kodu tutar:"

#: src/ch01-02-hello-world.md:188
msgid ""
"This line does all the work in this little program: it prints text to the "
"screen. There are four important details to notice here."
msgstr ""
"Bu satır bu küçük programdaki tüm çalışmaları yapar: metni ekrana yazdırır. "
"Burada dikkat edilmesi gereken dört önemli ayrıntı vardır."

#: src/ch01-02-hello-world.md:191
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr ""
"İlk olarak, Kahire tarzı bir sekme ile değil, dört boşlukla girinti "
"yapmaktır."

#: src/ch01-02-hello-world.md:193
msgid ""
"Second, `println!` calls a Cairo macro. If it had called a function instead, "
"it would be entered as `println` (without the `!`). We’ll discuss Cairo "
"macros in more detail in the [\"Macros\"](./ch11-05-macros.md) chapter. For "
"now, you just need to know that using a `!` means that you’re calling a "
"macro instead of a normal function and that macros don’t always follow the "
"same rules as functions."
msgstr ""
"İkincisi, println! bir Kahire makrosu çağırır. Bunun yerine bir fonksiyon "
"çağırmış olsaydı, println (! olmadan) olarak girilirdi. Kahire makrolarını "
"[\"Macros\"] (./ch11-05-macros.md) bölümünde daha ayrıntılı olarak "
"tartışacağız. Şimdilik, her zaman bir! makrosu kullanarak ve bunun yerine "
"bir makro işlevi aramadığınız anlamına gelir."

#: src/ch01-02-hello-world.md:196
msgid ""
"Third, you see the `\"Hello, world!\"` string. We pass this string as an "
"argument to `println!`, and the string is printed to the screen."
msgstr ""
"Üçüncüsü, \"Merhaba, dünya!\" dizesini görüyorsunuz. Bu dizeyi println!'ye "
"bir argüman olarak geçiyoruz ve dize ekrana basılıyor."

#: src/ch01-02-hello-world.md:198
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this "
"expression is over and the next one is ready to begin. Most lines of Cairo "
"code end with a semicolon."
msgstr ""
"Dördüncü olarak, bu ifadenin sona erdiğini ve bir sonrakinin başlamaya hazır "
"olduğunu gösteren bir noktalı virgül (;) ile sonlandırırız. Kahire kodunun "
"çoğu satırı noktalı virgül ile sona erer."

#: src/ch01-02-hello-world.md:205
msgid "{{#quiz ../quizzes/ch01-02-hello-world.toml}}"
msgstr "#quiz../quizzes/ch01-02-hello-world.toml"

#: src/ch01-02-hello-world.md:207 src/ch02-05-control-flow.md:311
#: src/ch07-05-separating-modules-into-different-files.md:97
#: src/ch09-02-recoverable-errors.md:188 src/ch10-02-test-organization.md:265
#: src/ch11-01-custom-data-structures.md:345
#: src/ch11-06-inlining-in-cairo.md:269
#: src/ch17-02-testing-smart-contracts.md:730
msgid "Summary"
msgstr "Özet"

#: src/ch01-02-hello-world.md:209
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr "Scarb hakkında şimdiye kadar öğrendiklerimizi özetleyelim:"

#: src/ch01-02-hello-world.md:211
msgid ""
"We can install one or multiple Scarb versions, either the latest stable or a "
"specific one, using asdf."
msgstr ""
"Asdf kullanarak bir veya birden fazla Scarb sürümünü, en son kararlı veya "
"belirli bir sürümü yükleyebiliriz."

#: src/ch01-02-hello-world.md:212
msgid "We can create a project using `scarb new`."
msgstr "scarb new kullanarak bir proje oluşturabiliriz."

#: src/ch01-02-hello-world.md:213
msgid ""
"We can build a project using `scarb build` to generate the compiled Sierra "
"code."
msgstr ""
"Derlenmiş Sierra kodunu oluşturmak için scarb build kullanarak bir proje "
"oluşturabiliriz."

#: src/ch01-02-hello-world.md:214
msgid "We can execute a Cairo program using the `scarb cairo-run` command."
msgstr "scarb cairo-run komutunu kullanarak bir Kahire programı yürütebiliriz."

#: src/ch01-02-hello-world.md:216
msgid ""
"An additional advantage of using Scarb is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no "
"longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""
"Scarb'ı kullanmanın ek bir avantajı, hangi işletim sisteminde çalışırsanız "
"çalışın komutların aynı olmasıdır. Bu nedenle, bu noktada, artık Linux ve "
"macOS için Windows'a karşı belirli talimatlar sağlamayacağız."

#: src/ch01-02-hello-world.md:218
msgid ""
"You’re already off to a great start on your Cairo journey! This is a great "
"time to build a more substantial program to get used to reading and writing "
"Cairo code."
msgstr ""
"Kahire seyahatinize şimdiden harika bir başlangıç yapıyorsunuz! Kahire "
"kodunu okumaya ve yazmaya alışmak için daha önemli bir program oluşturmak "
"için harika bir zaman."

#: src/ch02-00-common-programming-concepts.md
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Cairo. Many programming languages have much in "
"common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain "
"the conventions around using these concepts."
msgstr ""
"Bu bölüm, hemen hemen her programlama dilinde ortaya çıkan kavramları ve "
"Kahire'de nasıl çalıştıklarını kapsar. Birçok programlama dilinin özünde çok "
"fazla ortak nokta vardır. Bu bölümde sunulan kavramların hiçbiri Kahire'ye "
"özgü değildir, ancak bunları Kahire bağlamında tartışacağız ve bu kavramları "
"kullanarak etraftaki kongreleri açıklayacağız."

#: src/ch02-00-common-programming-concepts.md
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Cairo "
"program, and learning them early will give you a strong core to start from."
msgstr ""
"Özellikle, değişkenler, temel türleri, işlevleri, yorumları ve kontrol "
"akışını öğreneceksiniz. Bu temeller her Kahire programında olacak ve bunları "
"erken öğrenmek size başlamak için güçlü bir çekirdek verecektir."

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is "
"written to, it can't be overwritten but only read from. To reflect this "
"immutable memory model, variables in Cairo are immutable by default. "
"However, the language abstracts this model and gives you the option to make "
"your variables mutable. Let’s explore how and why Cairo enforces "
"immutability, and how you can make your variables mutable."
msgstr ""
"Kahire değişmez bir bellek modeli kullanır, yani bir bellek hücresi "
"yazıldığında, üzerine yazılamaz ama sadece okunur. Bu değişmez bellek "
"modelini yansıtmak için, Kahire'deki değişkenler varsayılan olarak "
"değiştirilemez. Bununla birlikte, dil bu modeli özetler ve değişkenlerinizi "
"değiştirilebilir hale getirme seçeneği sunar. Kahire'nin değişmezliği nasıl "
"ve neden uyguladığını ve değişkenlerinizi nasıl değiştirebileceğinizi "
"araştıralım."

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t "
"change that value. To illustrate this, generate a new project called "
"_variables_ in your _cairo_projects_ directory by using `scarb new "
"variables`."
msgstr ""
"Bir değişken değiştirilemez olduğunda, bir değer bir isme bağlandığında, bu "
"değeri değiştiremezsiniz. Bunu örneklemek için, scarb yeni değişkenler "
"kullanarak _cairo_projects_ dizininizde _variables_ adında yeni bir proje "
"oluşturun."

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace "
"its code with the following code, which won’t compile just yet:"
msgstr ""
"Ardından, yeni _variables_ dizininizde, _src/lib.cairo_ dosyasını açın ve "
"kodunu henüz derlemeyecek olan aşağıdaki kodla değiştirin:"

#: src/ch02-01-variables-and-mutability.md:17
#: src/ch04-01-what-is-ownership.md:265 src/ch04-01-what-is-ownership.md:310
#: src/ch04-02-references-and-snapshots.md:26
#: src/ch04-02-references-and-snapshots.md:118
#: src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:27
#: src/ch05-01-defining-and-instantiating-structs.md:53
#: src/ch05-01-defining-and-instantiating-structs.md:89
#: src/ch05-01-defining-and-instantiating-structs.md:125
#: src/ch05-01-defining-and-instantiating-structs.md:167
#: src/ch05-01-defining-and-instantiating-structs.md:203
#: src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:50
#: src/ch05-02-an-example-program-using-structs.md:75
#: src/ch07-02-defining-modules-to-control-scope.md:80
#: src/ch07-02-defining-modules-to-control-scope.md:137
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:14
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:90
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:116
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:150
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:36
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:81
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:133
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:206
#: src/ch07-05-separating-modules-into-different-files.md:18
#: src/ch09-01-unrecoverable-errors-with-panic.md:9
#: src/ch10-01-how-to-write-tests.md:32 src/ch10-01-how-to-write-tests.md:95
#: src/ch10-01-how-to-write-tests.md:146 src/ch10-01-how-to-write-tests.md:228
#: src/ch10-01-how-to-write-tests.md:340 src/ch10-01-how-to-write-tests.md:564
#: src/ch10-01-how-to-write-tests.md:658 src/ch10-01-how-to-write-tests.md:747
msgid "<span class=\"filename\">Filename: src/lib.cairo</span>"
msgstr "span class=\"filename\">Dosya adı: src/lib.cairo/span>"

#: src/ch02-01-variables-and-mutability.md:22
#: src/ch02-01-variables-and-mutability.md:24
#: src/ch02-01-variables-and-mutability.md:89
#: src/ch02-01-variables-and-mutability.md:91
#: src/ch02-01-variables-and-mutability.md:248
#: src/ch02-01-variables-and-mutability.md:250 src/ch02-03-functions.md:71
#: src/ch02-03-functions.md:287 src/ch02-03-functions.md:325
#: src/ch02-03-functions.md:341
msgid "\"The value of x is: {}\""
msgstr "\"x'in değeri: \""

#: src/ch02-01-variables-and-mutability.md:29
msgid ""
"Save and run the program using `scarb cairo-run`. You should receive an "
"error message regarding an immutability error, as shown in this output:"
msgstr ""
"scarb cairo-run kullanarak programı kaydedin ve çalıştırın. Bu çıktıda "
"gösterildiği gibi, bir değişmezlik hatasıyla ilgili bir hata mesajı almanız "
"gerekir:"

#: src/ch02-01-variables-and-mutability.md:45
msgid ""
"This example shows how the compiler helps you find errors in your programs. "
"Compiler errors can be frustrating, but they only mean your program isn’t "
"safely doing what you want it to do yet; they do _not_ mean that you’re not "
"a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""
"Bu örnek derleyicinin programlarınızdaki hataları bulmanıza nasıl yardımcı "
"olduğunu gösterir. Derleyici hataları sinir bozucu olabilir, ancak yalnızca "
"programınızın henüz istediğiniz şeyi güvenli bir şekilde yapmadığı anlamına "
"gelir; _not_ iyi bir programcı olmadığınız anlamına gelir! Deneyimli "
"Kahirenautes hala derleyici hataları alıyor."

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"You received the error message `Cannot assign to an immutable variable.` "
"because you tried to assign a second value to the immutable `x` variable."
msgstr ""
"Değiştirilemez bir değişkene atama yapılamaz. hata iletisini aldınız, çünkü "
"x değişkenine ikinci bir değer atamaya çalıştınız."

#: src/ch02-01-variables-and-mutability.md:53
msgid ""
"It’s important that we get compile-time errors when we attempt to change a "
"value that’s designated as immutable because this specific situation can "
"lead to bugs. If one part of our code operates on the assumption that a "
"value will never change and another part of our code changes that value, "
"it’s possible that the first part of the code won’t do what it was designed "
"to do. The cause of this kind of bug can be difficult to track down after "
"the fact, especially when the second piece of code changes the value only "
"_sometimes_."
msgstr ""
"Bu özel durum hatalara yol açabileceğinden, değiştirilemez olarak belirlenen "
"bir değeri değiştirmeye çalıştığımızda derleme zamanı hataları almamız "
"önemlidir. Kodumuzun bir kısmı bir değerin asla değişmeyeceğini ve kodumuzun "
"başka bir parçasının bu değeri değiştireceğini varsayarak çalışırsa, kodun "
"ilk parçasının yapmak için tasarlandığı şeyi yapmaması mümkündür. Bu tür bir "
"hatanın nedeni, özellikle ikinci parçanın değerini takip etmek zor olabilir."

#: src/ch02-01-variables-and-mutability.md:61
msgid ""
"Cairo, unlike most other languages, has immutable memory. This makes a whole "
"class of bugs impossible, because values will never change unexpectedly. "
"This makes code easier to reason about."
msgstr ""
"Kahire, diğer dillerin aksine, değişmez bir hafızaya sahiptir. Bu, bütün bir "
"böcek sınıfını imkansız kılar, çünkü değerler asla beklenmedik bir şekilde "
"değişmez. Bu, kodun akla gelmesini kolaylaştırır."

#: src/ch02-01-variables-and-mutability.md:65
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write. Although variables are immutable by default, you can make them "
"mutable by adding `mut` in front of the variable name. Adding `mut` also "
"conveys intent to future readers of the code by indicating that other parts "
"of the code will be changing the value associated to this variable."
msgstr ""
"Ancak değiştirilebilirlik çok yararlı olabilir ve kodu yazmak için daha "
"uygun hale getirebilir. Değişkenler varsayılan olarak değiştirilemez olsa "
"da, değişken adının önüne mut ekleyerek onları değiştirilebilir hale "
"getirebilirsiniz. mut eklemek, kodun diğer bölümlerinin bu değişkenle "
"ilişkili değeri değiştireceğini belirterek, kodun gelecekteki okuyucularına "
"da niyeti iletir."

#: src/ch02-01-variables-and-mutability.md:73
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable is declared as `mut`, as we previously mentioned that Cairo's "
"memory is immutable. The answer is that the _value_ is immutable, but the "
"_variable_ isn't. The value associated to the variable can be changed. "
"Assigning to a mutable variable in Cairo is essentially equivalent to "
"redeclaring it to refer to another value in another memory cell, but the "
"compiler handles that for you, and the keyword `mut` makes it explicit. Upon "
"examining the low-level Cairo Assembly code, it becomes clear that variable "
"mutation is implemented as syntactic sugar, which translates mutation "
"operations into a series of steps equivalent to variable shadowing. The only "
"difference is that at the Cairo level, the variable is not redeclared so its "
"type cannot change."
msgstr ""
"Ancak, bu noktada bir değişkenin mut olarak ilan edildiğinde tam olarak ne "
"olduğunu merak ediyor olabilirsiniz, daha önce Kahire'nin belleğinin "
"değişmez olduğunu belirttiğimiz gibi. Cevap, _value_ değişkeninin değişkeni "
"olan değişkeni, değişkenin değişkeni olan değişkeni değil, değişkenin "
"değişkeni olan değişkeni, değişkenin değişkeni olan değişkeni, değişkeni "
"başka bir hücredeki başka bir değere atıfta bulunmak için onu yeniden ifade "
"etmeye eşdeğerdir."

#: src/ch02-01-variables-and-mutability.md:84
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr "Örneğin, aşağıdaki _src/lib.cairo_'yi değiştirelim:"

#: src/ch02-01-variables-and-mutability.md:95
msgid "When we run the program now, we get this:"
msgstr "Programı şimdi çalıştırdığımızda, şunu elde ediyoruz:"

#: src/ch02-01-variables-and-mutability.md:108
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is "
"used. Ultimately, deciding whether to use mutability or not is up to you and "
"depends on what you think is clearest in that particular situation."
msgstr ""
"mut kullanıldığında x'ye bağlı değeri 5'den 6'ya değiştirmemize izin "
"verilir. Sonuçta, mutasyona uğrayıp uğramamaya karar vermek size bağlıdır ve "
"o özel durumda en net ne düşündüğünüze bağlıdır."

#: src/ch02-01-variables-and-mutability.md:112
msgid "Constants"
msgstr "Sabitler"

#: src/ch02-01-variables-and-mutability.md:114
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and are not allowed to change, but there are a few differences between "
"constants and variables."
msgstr ""
"Değiştirilemeyen değişkenler gibi, _constants_ bir isme bağlı olan ve "
"değişmesine izin verilmeyen değerlerdir, ancak sabitler ve değişkenler "
"arasında birkaç fark vardır."

#: src/ch02-01-variables-and-mutability.md:118
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just "
"immutable by default—they’re always immutable. You declare constants using "
"the `const` keyword instead of the `let` keyword, and the type of the value "
"_must_ be annotated. We’ll cover types and type annotations in the next "
"section, [“Data Types”](./ch02-02-data-types.md), so don’t worry about the "
"details right now. Just know that you must always annotate the type."
msgstr ""
"İlk olarak, sabitlerle mut kullanmanıza izin verilmez. Sabitler sadece "
"varsayılan olarak değiştirilemez değildir - her zaman değişmezler. let "
"anahtar kelimesi yerine const anahtar kelimesini kullanarak sabitleri beyan "
"edersiniz ve _mt_ değerinin türü açıklamalıdır. Her zaman bir sonraki "
"bölümdeki [\"Data Types\"] [noktalamalar\"] ve [datam\"lar] ile ilgili "
"kaygılarınızı gidereceğiz."

#: src/ch02-01-variables-and-mutability.md:125
msgid ""
"Constant variables can be declared with any usual data type, including "
"structs, enums and fixed-size arrays."
msgstr ""
"Sabit değişkenler, structlar, enumlar ve sabit boyutlu diziler de dahil "
"olmak üzere herhangi bir olağan veri türü ile ilan edilebilir."

#: src/ch02-01-variables-and-mutability.md:127
msgid ""
"Constants can only be declared in the global scope, which makes them useful "
"for values that many parts of code need to know about."
msgstr ""
"Sabitler yalnızca küresel kapsamda ilan edilebilir, bu da onları birçok kod "
"parçasının bilmesi gereken değerler için kullanışlı kılar."

#: src/ch02-01-variables-and-mutability.md:130
msgid ""
"The last difference is that constants may natively be set only to a constant "
"expression, not the result of a value that could only be computed at runtime."
msgstr ""
"Son fark, sabitlerin doğal olarak sadece çalışma zamanında hesaplanabilen "
"bir değerin sonucu değil, sabit bir ifadeye ayarlanabilmesidir."

#: src/ch02-01-variables-and-mutability.md:133
msgid "Here’s an example of constants declaration:"
msgstr "İşte sabitler deklarasyonunun bir örneği:"

#: src/ch02-01-variables-and-mutability.md:152
msgid ""
"Nonetheless, it is possible to use the `consteval_int!` macro to create a "
"`const` variable that is the result of some computation:"
msgstr ""
"Bununla birlikte, bazı hesaplamaların sonucu olan bir const değişkeni "
"oluşturmak için consteval_int! makrosunu kullanmak mümkündür:"

#: src/ch02-01-variables-and-mutability.md:158
msgid ""
"We will dive into more detail about macros in the [dedicated section](./"
"ch11-05-macros.md)."
msgstr ""
"[özgün bölüm](./ch11-05-macros.md) 'deki makrolar hakkında daha fazla "
"ayrıntıya dalacağız."

#: src/ch02-01-variables-and-mutability.md:160
msgid ""
"Cairo's naming convention for constants is to use all uppercase with "
"underscores between words."
msgstr ""
"Kahire'nin sabitler için isimlendirme kongresi, kelimeler arasında altı "
"çizili tüm büyükleri kullanmaktır."

#: src/ch02-01-variables-and-mutability.md:162
msgid ""
"Constants are valid for the entire time a program runs, within the scope in "
"which they were declared. This property makes constants useful for values in "
"your application domain that multiple parts of the program might need to "
"know about, such as the maximum number of points any player of a game is "
"allowed to earn, or the speed of light."
msgstr ""
"Sabitler, bir programın çalıştığı süre boyunca, ilan edildikleri kapsam "
"dahilinde geçerlidir. Bu özellik, uygulama alanınızdaki sabitleri, bir "
"oyunun herhangi bir oyuncusunun kazanmasına izin verilen maksimum puan "
"sayısı veya ışık hızı gibi, programın birden fazla bölümünün bilmesi gereken "
"değerler için kullanışlı hale getirir."

#: src/ch02-01-variables-and-mutability.md:168
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in conveying the meaning of that value to future maintainers of the code. It "
"also helps to have only one place in your code you would need to change if "
"the hardcoded value needed to be updated in the future."
msgstr ""
"Programınız boyunca sabit olarak kullanılan sabit kodlu değerleri "
"adlandırmak, bu değerin anlamını kodun gelecekteki geliştiricilerine "
"iletmede yararlıdır. Ayrıca, gelecekte güncellenmesi gereken sabit kodlu "
"değer gerekiyorsa, kodunuzda değiştirmeniz gereken tek bir yere sahip "
"olmanıza yardımcı olur."

#: src/ch02-01-variables-and-mutability.md:175
msgid "Shadowing"
msgstr "Gölgeleme"

#: src/ch02-01-variables-and-mutability.md:177
msgid ""
"Variable shadowing refers to the declaration of a new variable with the same "
"name as a previous variable. Caironautes say that the first variable is "
"_shadowed_ by the second, which means that the second variable is what the "
"compiler will see when you use the name of the variable. In effect, the "
"second variable overshadows the first, taking any uses of the variable name "
"to itself until either it itself is shadowed or the scope ends. We can "
"shadow a variable by using the same variable’s name and repeating the use of "
"the `let` keyword as follows:"
msgstr ""
"Değişken gölgeleme, önceki bir değişkenle aynı adı taşıyan yeni bir "
"değişkenin deklarasyonuna atıfta bulunur. Caironautes, birinci değişkenin "
"ikinci değişken tarafından _shadowed_ olduğunu söyler, bu da ikinci "
"değişkenin, değişkenin adını kullandığınızda derleyicinin göreceği şey "
"olduğu anlamına gelir. Aslında, ikinci değişken, ilk değişkeni "
"gölgelendirir, değişkenin herhangi bir kullanımını kendisi gölgelenene veya "
"kapsam bitene kadar kendi başına izler. Değişkenin bir değişkenini "
"kullanarak gölgeleyebiliriz."

#: src/ch02-01-variables-and-mutability.md:192
msgid "\"Inner scope x value is: {}\""
msgstr "\"İç kapsam x değeri: \""

#: src/ch02-01-variables-and-mutability.md:194
msgid "\"Outer scope x value is: {}\""
msgstr "\"Dış kapsam x değeri: \""

#: src/ch02-01-variables-and-mutability.md:198
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable `x` by repeating `let x =`, taking the original value and adding "
"`1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and "
"creates a new variable, multiplying the previous value by `2` to give `x` a "
"value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the following:"
msgstr ""
"Bu program önce x değerini 5 değerine bağlar. Daha sonra let x = "
"tekrarlayarak yeni bir x değişkeni oluşturur, orijinal değeri alır ve 1 "
"ekler, böylece x değeri 6 olur. Sonra, bu kıvırcık parantez ile oluşturulan "
"bir iç kapsam içinde, üçüncü let ifadesi de x değerini çarparak yeni bir "
"değişken oluşturur."

#: src/ch02-01-variables-and-mutability.md:217
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a "
"compile-time error if we accidentally try to reassign to this variable "
"without using the `let` keyword. By using `let`, we can perform a few "
"transformations on a value but have the variable be immutable after those "
"transformations have been completed."
msgstr ""
"Gölgeleme, bir değişkeni mut olarak işaretlemekten farklıdır, çünkü "
"yanlışlıkla let anahtar kelimesini kullanmadan bu değişkene yeniden atamaya "
"çalışırsak bir derleme-zaman hatası alırız. let kullanarak, bir değer "
"üzerinde birkaç dönüşüm gerçekleştirebiliriz, ancak bu dönüşümler "
"tamamlandıktan sonra değişkenin değiştirilemez olmasını sağlayabiliriz."

#: src/ch02-01-variables-and-mutability.md:223
msgid ""
"Another distinction between `mut` and shadowing is that when we use the "
"`let` keyword again, we are effectively creating a new variable, which "
"allows us to change the type of the value while reusing the same name. As "
"mentioned before, variable shadowing and mutable variables are equivalent at "
"the lower level. The only difference is that by shadowing a variable, the "
"compiler will not complain if you change its type. For example, say our "
"program performs a type conversion between the `u64` and `felt252` types."
msgstr ""
"mut ve gölgeleme arasındaki diğer bir fark, let anahtar kelimesini tekrar "
"kullandığımızda, aynı adı tekrar kullanırken değerin türünü değiştirmemize "
"izin veren yeni bir değişken oluşturmamızdır. Daha önce de belirtildiği "
"gibi, değişken gölgeleme ve değişkenler alt seviyede eşdeğerdir. Tek fark, "
"bir değişkenin gölgelenmesiyle derleyicinin türünü değiştirirseniz şikayet "
"etmeyeceğidir. Örneğin, programımızın 25 ve bir dönüşüm gerçekleştirdiğini "
"varsayalım."

#: src/ch02-01-variables-and-mutability.md:234
msgid "\"The value of x is {} of type u64\""
msgstr "\"x'in değeri  tipi u64'tür\""

#: src/ch02-01-variables-and-mutability.md:235
msgid "// converts x to a felt, type annotation is required.\n"
msgstr "// x'i bir keçeye dönüştürür, tip annotasyonu gereklidir.\n"

#: src/ch02-01-variables-and-mutability.md:236
msgid "\"The value of x is {} of type felt252\""
msgstr "\"x'in değeri  tipi keçe252\""

#: src/ch02-01-variables-and-mutability.md:240
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type. Shadowing thus spares us from having to come up with "
"different names, such as `x_u64` and `x_felt252`; instead, we can reuse the "
"simpler `x` name. However, if we try to use `mut` for this, as shown here, "
"we’ll get a compile-time error:"
msgstr ""
"İlk x değişkeni u64 tipine sahipken, ikinci x değişkeni felt252 tipine "
"sahiptir. Gölgelendirme böylece x_u64 ve x_felt252 gibi farklı isimlerle "
"gelmek zorunda kalmaktan kurtulur; bunun yerine, daha basit x adını yeniden "
"kullanabiliriz. Ancak, bunun için mut kullanmaya çalışırsak, burada "
"derleyeceğiz."

#: src/ch02-01-variables-and-mutability.md:254
msgid ""
"The error says we were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr ""
"Hata, u64 (orijinal tip) beklediğimizi söylüyor, ancak farklı bir tipimiz "
"var:"

#: src/ch02-01-variables-and-mutability.md:269
msgid "{{#quiz ../quizzes/ch02-01-variables-and-mutability.toml}}"
msgstr "#quiz../quizzes/ch02-01-variables-and-mutability.toml"

#: src/ch02-01-variables-and-mutability.md:271
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they can have."
msgstr ""
"Şimdi değişkenlerin nasıl çalıştığını araştırdığımıza göre, sahip "
"olabilecekleri daha fazla veri türüne bakalım."

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what "
"kind of data is being specified so it knows how to work with that data. This "
"section covers two subsets of data types: scalars and compounds."
msgstr ""
"Kahire'deki her değer, Kahire'ye bu verilerle nasıl çalışacağını bilmesi "
"için ne tür verilerin belirtildiğini söyleyen belirli bir _data type_ "
"değeridir. Bu bölüm, veri türlerinin iki alt kümesini kapsar: skalerlerler "
"ve bileşikler."

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that "
"it must know the types of all variables at compile time. The compiler can "
"usually infer the desired type based on the value and its usage. In cases "
"when many types are possible, we can use a cast method where we specify the "
"desired output type."
msgstr ""
"Kahire'nin _statik olarak yazılmış bir dil olduğunu unutmayın, bu da derleme "
"zamanında tüm değişkenlerin türlerini bilmesi gerektiği anlamına gelir. "
"Derleyici genellikle değere ve kullanımına göre istenen türü çıkarabilir. "
"Birçok türün mümkün olduğu durumlarda, istenen çıktı türünü belirttiğimiz "
"bir döküm yöntemini kullanabiliriz."

#: src/ch02-02-data-types.md:16
msgid "You’ll see different type annotations for other data types."
msgstr "Diğer veri türleri için farklı tip ek açıklamalar göreceksiniz."

#: src/ch02-02-data-types.md:18
msgid "Scalar Types"
msgstr "Scalar Türleri"

#: src/ch02-02-data-types.md:20
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar "
"types: felts, integers, and booleans. You may recognize these from other "
"programming languages. Let’s jump into how they work in Cairo."
msgstr ""
"Bir _scalar_ tipi tek bir değeri temsil eder. Kahire'nin üç ana skaler tipi "
"vardır: keçeler, tam sayılar ve booleanlar. Bunları diğer programlama "
"dillerinden tanıyabilirsiniz. Kahire'de nasıl çalıştıklarına atlayalım."

#: src/ch02-02-data-types.md:24
msgid "Felt Type"
msgstr "Keçe Tipi"

#: src/ch02-02-data-types.md:26
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the "
"context of Cairo, when we say “a field element” we mean an integer in the "
"range \\\\( 0 \\leq x \\< P \\\\), where \\\\( P \\\\) is a very large prime "
"number currently equal to \\\\( {2^{251}} + 17 \\cdot {2^{192}} + 1 \\\\). "
"When adding, subtracting, or multiplying, if the result falls outside the "
"specified range of the prime number, an overflow (or underflow) occurs, and "
"an appropriate multiple of \\\\( P \\\\) is added or subtracted to bring the "
"result back within the range (i.e., the result is computed \\\\( \\mod P \\"
"\\) )."
msgstr ""
"Kahire'de, bir değişkenin veya argümanın türünü belirtmezseniz, türü "
"varsayılan olarak felt252 anahtar kelimesi ile temsil edilen bir alan "
"elemanına dönüşür. Kahire bağlamında, \"bir alan elemanı\" dediğimizde, ( 0 "
"leq x  P ) aralığındaki bir tamsayıyı kastediyoruz, burada ( P ) şu anda "
"(  2  2c)'ye eşit çok büyük bir asal sayıdır."

#: src/ch02-02-data-types.md:29
msgid ""
"The most important difference between integers and field elements is "
"division: Division of field elements (and therefore division in Cairo) is "
"unlike regular CPUs division, where integer division \\\\( \\frac{x}{y} \\"
"\\) is defined as \\\\( \\left\\lfloor \\frac{x}{y} \\right\\rfloor \\\\) "
"where the integer part of the quotient is returned (so you get \\"
"\\( \\frac{7}{3} = 2 \\\\)) and it may or may not satisfy the equation \\"
"\\( \\frac{x}{y} \\cdot y == x \\\\), depending on the divisibility of `x` "
"by `y`."
msgstr ""
"Tamsayılar ve alan elemanları arasındaki en önemli fark bölmedir: Alan "
"elemanlarının bölünmesi (ve bu nedenle Kahire'de bölünme) normal CPU'ların "
"bölünmesinden farklıdır, burada tamsayı bölmesi ( fracxy) ( leftlfloor "
"fracxy) 3 veya rightrfloor  olarak tanımlanır."

#: src/ch02-02-data-types.md:34
msgid ""
"In Cairo, the result of \\\\( \\frac{x}{y} \\\\) is defined to always "
"satisfy the equation \\\\( \\frac{x}{y} \\cdot y == x \\\\). If y divides x "
"as integers, you will get the expected result in Cairo (for example \\"
"\\( \\frac{6}{2} \\\\) will indeed result in `3`). But when y does not "
"divide x, you may get a surprising result: for example, since \\\\( 2 \\cdot "
"\\frac{P + 1}{2} = P + 1 \\equiv 1 \\mod P \\\\), the value of \\"
"\\( \\frac{1}{2} \\\\) in Cairo is \\\\( \\frac{P + 1}{2} \\\\) (and not 0 "
"or 0.5), as it satisfies the above equation."
msgstr ""
"Kahire'de, ( fracxy)'nin sonucu her zaman ( fracxy 0.5 cdot y == x ) "
"denklemini tatmin edecek şekilde tanımlanır. Eğer y x'i tam sayı olarak "
"bölerse, Kahire'de beklenen sonucu elde edersiniz (örneğin ( frac62 ) için)."

#: src/ch02-02-data-types.md:37
msgid "Integer Types"
msgstr "Integer Türleri"

#: src/ch02-02-data-types.md:39
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating "
"all types in the core library. However, it is highly recommended for "
"programmers to use the integer types instead of the `felt252` type whenever "
"possible, as the `integer` types come with added security features that "
"provide extra protection against potential vulnerabilities in the code, such "
"as overflow and underflow checks. By using these integer types, programmers "
"can ensure that their programs are more secure and less susceptible to "
"attacks or other security threats. An `integer` is a number without a "
"fractional component. This type declaration indicates the number of bits the "
"programmer can use to store the integer. Table 3-1 shows the built-in "
"integer types in Cairo. We can use any of these variants to declare the type "
"of an integer value."
msgstr ""
"Keçe252 türü, çekirdek kitaplığındaki tüm türleri oluşturmak için temel "
"olarak hizmet veren temel bir türdür. Bununla birlikte, programcıların "
"felt252 türü yerine tamsayı türlerini kullanmaları şiddetle tavsiye edilir. "
"integer türleri, koddaki potansiyel güvenlik açıklarına karşı ekstra koruma "
"sağlayan ek güvenlik özellikleri ile birlikte geldiğinden, bu tamsayı "
"türlerini kullanarak, programcıların programlarının daha fazla veya daha az "
"güvenli olmasını sağlayabilir."

#: src/ch02-02-data-types.md:44
msgid "Length"
msgstr "Uzunluk"

#: src/ch02-02-data-types.md:44
msgid "Unsigned"
msgstr "İmzasız"

#: src/ch02-02-data-types.md:46
msgid "8-bit"
msgstr "8-bit"

#: src/ch02-02-data-types.md:46
msgid "`u8`"
msgstr "u8"

#: src/ch02-02-data-types.md:47
msgid "16-bit"
msgstr "16-bit"

#: src/ch02-02-data-types.md:47
msgid "`u16`"
msgstr "u16"

#: src/ch02-02-data-types.md:48 src/ch02-02-data-types.md:52
msgid "32-bit"
msgstr "32-bit"

#: src/ch02-02-data-types.md:48
msgid "`u32`"
msgstr "u32"

#: src/ch02-02-data-types.md:49
msgid "64-bit"
msgstr "64-bit"

#: src/ch02-02-data-types.md:49
msgid "`u64`"
msgstr "u64"

#: src/ch02-02-data-types.md:50
msgid "128-bit"
msgstr "128-bit"

#: src/ch02-02-data-types.md:50
msgid "`u128`"
msgstr "u128"

#: src/ch02-02-data-types.md:51
msgid "256-bit"
msgstr "256-bit"

#: src/ch02-02-data-types.md:51
msgid "`u256`"
msgstr "u256"

#: src/ch02-02-data-types.md:52
msgid "`usize`"
msgstr "usize"

#: src/ch02-02-data-types.md:57
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is "
"just an alias for `u32`; however, it might be useful when in the future "
"Cairo can be compiled to MLIR. As variables are unsigned, they can't contain "
"a negative number. This code will cause the program to panic:"
msgstr ""
"Her varyantın açık bir boyutu vardır. Şimdilik, usize tipinin sadece u32 "
"için bir takma ad olduğunu unutmayın; ancak, gelecekte Kahire MLIR'a "
"derlenebildiğinde yararlı olabilir. Değişkenler imzasız olduğu için, negatif "
"bir sayı içeremezler. Bu kod programın paniğe neden olacaktır:"

#: src/ch02-02-data-types.md:70
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for "
"`u256` which needs 4 more bits to be stored. Under the hood, `u256` is "
"basically a struct with 2 fields: `u256 {low: u128, high: u128}`."
msgstr ""
"Daha önce bahsedilen tüm tam sayı türleri, depolanacak 4 bit daha gereken "
"u256 hariç, bir felt252'ye sığar. Başlık altında, u256 temelde 2 alanlı bir "
"yapıdır: u256 low: u128, high: u128."

#: src/ch02-02-data-types.md:72
msgid ""
"Cairo also provides support for signed integers, starting with the prefix "
"`i`. These integers can represent both positive and negative values, with "
"sizes ranging from `i8` to `i128`. Each signed variant can store numbers "
"from \\\\( -({2^{n - 1}}) \\\\) to \\\\( {2^{n - 1}} - 1 \\\\) inclusive, "
"where `n` is the number of bits that variant uses. So an i8 can store "
"numbers from \\\\( -({2^7}) \\\\) to \\\\( {2^7} - 1 \\\\), which equals "
"`-128` to `127`."
msgstr ""
"Kahire ayrıca, i öneki ile başlayan imzalı tamsayılar için destek sağlar. Bu "
"tamsayılar, i8 ile i128 arasında değişen boyutlara sahip hem pozitif hem de "
"negatif değerleri temsil edebilir. Her imzalı varyant, sayıları (2n - 1) (2n "
"- 1) ile (2n - 1) arasında saklayabilir."

#: src/ch02-02-data-types.md:75
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note "
"that number literals that can be multiple numeric types allow a type suffix, "
"such as `57_u8`, to designate the type. It is also possible to use a visual "
"separator `_` for number literals, in order to improve code readability."
msgstr ""
"Tablo 3-2'de gösterilen formlardan herhangi birine tamsayılı literaller "
"yazabilirsiniz. Birden fazla sayısal tip olabilen sayı literalleri, türü "
"belirtmek için 57_u8 gibi bir tip son ekine izin verir. Kod okunabilirliğini "
"artırmak için, sayı literalleri için görsel bir ayırıcı _ kullanmak da "
"mümkündür."

#: src/ch02-02-data-types.md:80
msgid "Numeric literals"
msgstr "Sayısal literaller"

#: src/ch02-02-data-types.md:80 src/appendix-02-operators-and-symbols.md:9
#: src/appendix-08-system-calls.md:177 src/appendix-08-system-calls.md:256
#: src/appendix-08-system-calls.md:331
msgid "Example"
msgstr "Örnek"

#: src/ch02-02-data-types.md:82
msgid "Decimal"
msgstr "Ondalık"

#: src/ch02-02-data-types.md:82
msgid "`98222`"
msgstr "98222"

#: src/ch02-02-data-types.md:83
msgid "Hex"
msgstr "Hex"

#: src/ch02-02-data-types.md:83
msgid "`0xff`"
msgstr "0xff"

#: src/ch02-02-data-types.md:84
msgid "Octal"
msgstr "Octal"

#: src/ch02-02-data-types.md:84
msgid "`0o04321`"
msgstr "0o04321"

#: src/ch02-02-data-types.md:85
msgid "Binary"
msgstr "İkili"

#: src/ch02-02-data-types.md:85
msgid "`0b01`"
msgstr "0b01"

#: src/ch02-02-data-types.md:90
msgid ""
"So how do you know which type of integer to use? Try to estimate the max "
"value your int can have and choose the good size. The primary situation in "
"which you’d use `usize` is when indexing some sort of collection."
msgstr ""
"Peki hangi tamsayı türünü kullanacağınızı nasıl biliyorsunuz? İnt'inizin "
"sahip olabileceği maksimum değeri tahmin etmeye çalışın ve iyi boyutu seçin. "
"usize'yi kullanacağınız birincil durum, bir tür koleksiyonu indekslerken."

#: src/ch02-02-data-types.md:93
msgid "Numeric Operations"
msgstr "Sayısal İşlemler"

#: src/ch02-02-data-types.md:95
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the "
"integer types: addition, subtraction, multiplication, division, and "
"remainder. Integer division truncates toward zero to the nearest integer. "
"The following code shows how you’d use each numeric operation in a `let` "
"statement:"
msgstr ""
"Kahire, tüm tam sayı türleri için beklediğiniz temel matematiksel işlemleri "
"destekler: toplama, çıkarma, çarpma, bölme ve geri kalan. Integer bölmesi en "
"yakın tam sayıya doğru sıfıra doğru keser. Aşağıdaki kod, her sayısal işlemi "
"bir let ifadesinde nasıl kullanacağınızı gösterir:"

#: src/ch02-02-data-types.md:102
msgid "// addition\n"
msgstr "// ekleme\n"

#: src/ch02-02-data-types.md:105
msgid "// subtraction\n"
msgstr "// çıkarma\n"

#: src/ch02-02-data-types.md:108
msgid "// multiplication\n"
msgstr "// çarpma\n"

#: src/ch02-02-data-types.md:111
msgid "// division\n"
msgstr "// bölme\n"

#: src/ch02-02-data-types.md:112
msgid "//result is 1\n"
msgstr "//sonuç 1\n"

#: src/ch02-02-data-types.md:113
msgid "//result is 2\n"
msgstr "//sonuç 2\n"

#: src/ch02-02-data-types.md:115
msgid "// remainder\n"
msgstr "// kalan\n"

#: src/ch02-02-data-types.md:116
msgid "// result is 3\n"
msgstr "// sonuç 3\n"

#: src/ch02-02-data-types.md:120
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates to a single value, which is then bound to a variable."
msgstr ""
"Bu ifadelerdeki her ifade bir matematiksel operatör kullanır ve tek bir "
"değere değerlendirir, bu da daha sonra bir değişkene bağlanır."

#: src/ch02-02-data-types.md:123
msgid ""
"[Appendix B](./appendix-02-operators-and-symbols.md#operators) contains a "
"list of all operators that Cairo provides."
msgstr ""
"[Ek B](./appendix-02-operators-and-symbols.md#operators) Kahire'nin "
"sağladığı tüm operatörlerin bir listesini içerir."

#: src/ch02-02-data-types.md:127
msgid "The Boolean Type"
msgstr "Boolean Tipi"

#: src/ch02-02-data-types.md:129
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two "
"possible values: `true` and `false`. Booleans are one `felt252` in size. The "
"Boolean type in Cairo is specified using `bool`. For example:"
msgstr ""
"Diğer programlama dillerinin çoğunda olduğu gibi, Kahire'deki bir Boole "
"tipinin iki olası değeri vardır: true ve false. Booleans bir felt252 "
"büyüklüğündedir. Kahire'deki Boole tipi bool kullanılarak belirtilir. "
"Örneğin:"

#: src/ch02-02-data-types.md:137
msgid "// with explicit type annotation\n"
msgstr "// açık tip açıklama ile\n"

#: src/ch02-02-data-types.md:141
msgid ""
"When declaring a `bool` variable, it is mandatory to use either `true` or "
"`false` literals as value. Hence, it is not allowed to use integer literals "
"(i.e. `0` instead of false) for `bool` declarations."
msgstr ""
"Bir bool değişkeni ilan ederken, true veya false literallerini değer olarak "
"kullanmak zorunludur. Bu nedenle, bool beyanları için tamsayı literallerinin "
"(yani 0 yerine yanlış) kullanılmasına izin verilmez."

#: src/ch02-02-data-types.md:143
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` "
"expression. We’ll cover how `if` expressions work in Cairo in the [\"Control "
"Flow\"](./ch02-05-control-flow.md) section."
msgstr ""
"Boolean değerlerini kullanmanın ana yolu, if ifadesi gibi koşulludur. if "
"ifadelerinin Kahire'de [\"Kontrol Akışı\"](./ch02-05-control-flow.md) "
"bölümünde nasıl çalıştığını ele alacağız."

#: src/ch02-02-data-types.md:148
msgid "String Types"
msgstr "Dize Çeşitleri"

#: src/ch02-02-data-types.md:150
msgid ""
"Cairo doesn't have a native type for strings but provides two ways to handle "
"them: short strings using simple quotes and ByteArray using double quotes."
msgstr ""
"Kahire, dizeler için yerli bir tipe sahip değildir, ancak bunları ele "
"almanın iki yolunu sunar: basit alıntılar kullanan kısa dizeler ve çift "
"tırnak kullanan ByteArray."

#: src/ch02-02-data-types.md:152
msgid "Short strings"
msgstr "Kısa dizeler"

#: src/ch02-02-data-types.md:154
msgid ""
"A short string is an ASCII string where each character is encoded on one "
"byte (see the [ASCII table](https://www.asciitable.com/)). For example:"
msgstr ""
"Kısa bir dize, her karakterin bir bayt üzerinde kodlandığı bir ASCII "
"dizesidir (bkz. [ASCII tablosu](https://www.asciitable.com/)))). Örneğin:"

#: src/ch02-02-data-types.md:156
msgid "`'a'` is equivalent to `0x61`"
msgstr "'a' eşittir 0x61"

#: src/ch02-02-data-types.md:157
msgid "`'b'` is equivalent to `0x62`"
msgstr "'b' eşittir 0x62"

#: src/ch02-02-data-types.md:158
msgid "`'c'` is equivalent to `0x63`"
msgstr "'c' eşittir 0x63"

#: src/ch02-02-data-types.md:159
msgid "`0x616263` is equivalent to `'abc'`."
msgstr "0x616263, 'abc''ye eşdeğerdir."

#: src/ch02-02-data-types.md:161
msgid ""
"Cairo uses the `felt252` for short strings. As the `felt252` is on 251 bits, "
"a short string is limited to 31 characters (31 \\* 8 = 248 bits, which is "
"the maximum multiple of 8 that fits in 251 bits)."
msgstr ""
"Kahire kısa dizeler için felt252 kullanır. felt252 251 bit üzerinde "
"olduğundan, kısa bir dize 31 karakterle sınırlıdır (31  * 8 = 248 bit, bu da "
"251 bite uyan 8'in maksimum katıdır)."

#: src/ch02-02-data-types.md:163
msgid ""
"You can choose to represent your short string with an hexadecimal value like "
"`0x616263` or by directly writing the string using simple quotes like "
"`'abc'`, which is more convenient."
msgstr ""
"Kısa dizenizi 0x616263 gibi onaltılık bir değerle temsil etmeyi veya daha "
"uygun olan 'abc' gibi basit alıntıları kullanarak dizeyi doğrudan yazarak "
"temsil etmeyi seçebilirsiniz."

#: src/ch02-02-data-types.md:165
msgid "Here are some examples of declaring short strings in Cairo:"
msgstr "İşte Kahire'de kısa dizeler ilan etmenin bazı örnekleri:"

#: src/ch02-02-data-types.md:169 src/ch02-02-data-types.md:187
msgid "'C'"
msgstr "'C'"

#: src/ch02-02-data-types.md:175 src/ch02-02-data-types.md:193
msgid "\"this is a string which has more than 31 characters\""
msgstr "\"31'den fazla karaktere sahip bir dize\""

#: src/ch02-02-data-types.md:181
msgid "Byte Array Strings"
msgstr "Byte Dizi Dizgileri"

#: src/ch02-02-data-types.md:183
msgid ""
"With the `ByteArray` struct added in Cairo 2.4.0, you are not limited to 31 "
"characters anymore. These `ByteArray` strings are written in double quotes "
"like in the following example:"
msgstr ""
"Kahire 2.4.0'da eklenen ByteArray yapısıyla artık 31 karakterle sınırlı "
"değilsiniz. Bu ByteArray dizeleri aşağıdaki örnekte olduğu gibi çift tırnak "
"içinde yazılmıştır:"

#: src/ch02-02-data-types.md:197
msgid "Type Casting"
msgstr "Tip Döküm"

#: src/ch02-02-data-types.md:199
msgid ""
"In Cairo, you can convert scalar types from one type to another by using the "
"`try_into` and `into` methods provided by the `TryInto` and `Into` traits "
"from the core library."
msgstr ""
"Kahire'de, skaler tiplerini, çekirdek kitaplığından try_into ve into "
"tarafından sağlanan try_into ve into yöntemlerini kullanarak bir türe "
"dönüştürebilirsiniz."

#: src/ch02-02-data-types.md:201
msgid ""
"The `try_into` method allows for safe type casting when the target type "
"might not fit the source value. Keep in mind that `try_into` returns an "
"`Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""
"try_into yöntemi, hedef türün kaynak değere uymayabileceği durumlarda "
"güvenli tip dökümüne izin verir. try_into'un yeni değere erişmek için "
"açmanız gereken bir OptionT> tipini döndürdüğünü unutmayın."

#: src/ch02-02-data-types.md:203
msgid ""
"On the other hand, the `into` method can be used for type casting when "
"success is guaranteed, such as when the source type is smaller than the "
"destination type."
msgstr ""
"Öte yandan, into yöntemi, kaynak tipinin hedef tipinden daha küçük olduğu "
"zaman olduğu gibi, başarı garanti edildiğinde tip dökümü için kullanılabilir."

#: src/ch02-02-data-types.md:205
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the "
"source value to cast it to another type. The new variable's type must be "
"explicitly defined, as demonstrated in the example below."
msgstr ""
"Dönüşümü gerçekleştirmek için, var.into() veya var.try_into()'yi kaynak "
"değeri üzerinde başka bir türe atmak için arayın. Yeni değişkenin türü, "
"aşağıdaki örnekte gösterildiği gibi açıkça tanımlanmalıdır."

#: src/ch02-02-data-types.md:210
msgid ""
"// Since a felt252 might not fit in a u8, we need to unwrap the Option<T> "
"type\n"
msgstr ""
"// Bir keçe252 bir u8'e sığmayabileceğinden, OptionT> türünü açmamız "
"gerekir.\n"

#: src/ch02-02-data-types.md:216
msgid "// As a felt252 is smaller than a u256, we can use the into() method\n"
msgstr ""
"// Bir keçe252 bir u256'dan daha küçük olduğundan, into() yöntemini "
"kullanabiliriz.\n"

#: src/ch02-02-data-types.md:224
msgid "The Tuple Type"
msgstr "Tuple Tipi"

#: src/ch02-02-data-types.md:226
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a "
"variety of types into one compound type. Tuples have a fixed length: once "
"declared, they cannot grow or shrink in size."
msgstr ""
"Bir _tuple_, çeşitli türlere sahip bir dizi değeri bir bileşik tipinde bir "
"araya getirmenin genel bir yoludur. Tuples sabit bir uzunluğa sahiptir: bir "
"kez ilan edildiğinde, büyüyemezler veya küçülmezler."

#: src/ch02-02-data-types.md:230
msgid ""
"We create a tuple by writing a comma-separated list of values inside "
"parentheses. Each position in the tuple has a type, and the types of the "
"different values in the tuple don’t have to be the same. We’ve added "
"optional type annotations in this example:"
msgstr ""
"Parantez içindeki değerlerin virgülle ayrılmış bir listesini yazarak bir "
"tuple oluşturuyoruz. Tuple'daki her pozisyonun bir türü vardır ve tuple'daki "
"farklı değerlerin türleri aynı olmak zorunda değildir. Bu örnekte isteğe "
"bağlı tip ek açıklamalar ekledik:"

#: src/ch02-02-data-types.md:241
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a "
"single compound element. To get the individual values out of a tuple, we can "
"use pattern matching to destructure a tuple value, like this:"
msgstr ""
"tup değişkeni, bir tuple tek bir bileşik element olarak kabul edildiğinden "
"tüm tuple'a bağlanır. Bireysel değerleri bir tuple'dan çıkarmak için, bir "
"tuple değerini destructure etmek için desen eşlemesini kullanabiliriz, bunun "
"gibi:"

#: src/ch02-02-data-types.md:252
msgid "\"y is 6!\""
msgstr "\"Y 6 yaşında!\""

#: src/ch02-02-data-types.md:257
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then uses a pattern with `let` to take `tup` and turn it into three separate "
"variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints `y is "
"6!` as the value of `y` is `6`."
msgstr ""
"Bu program önce bir tuple oluşturur ve değişken tup'ye bağlar. Daha sonra "
"tup'yi almak ve üç ayrı değişkene dönüştürmek için let ile bir kalıp "
"kullanır, x, y ve z. Buna _destrucing_ denir çünkü tek tuple'ı üç parçaya "
"ayırır. Son olarak, program y'nin değeri olarak 6!y'yi yazdırır."

#: src/ch02-02-data-types.md:263
msgid ""
"We can also declare the tuple with value and types, and destructure it at "
"the same time. For example:"
msgstr ""
"Ayrıca tümülü değer ve türlerle beyan edebilir ve aynı anda "
"yapılandırabiliriz. Örneğin:"

#: src/ch02-02-data-types.md:272
msgid "The Unit Type ()"
msgstr "Birim Tipi ()"

#: src/ch02-02-data-types.md:274
msgid ""
"A _unit type_ is a type which has only one value `()`. It is represented by "
"a tuple with no elements. Its size is always zero, and it is guaranteed to "
"not exist in the compiled code."
msgstr ""
"Bir _unit type_ sadece bir değer () olan bir türdür. Elementsiz bir tuple "
"ile temsil edilir. Boyutu her zaman sıfırdır ve derlenen kodda bulunmaması "
"garanti edilir."

#: src/ch02-02-data-types.md:278
msgid ""
"You might be wondering why you would even need a unit type? In Cairo, "
"everything is an expression, and an expression that returns nothing actually "
"returns `()` implicitly."
msgstr ""
"Neden bir birim türüne ihtiyacınız olacağını merak ediyor olabilirsiniz? "
"Kahire'de, her şey bir ifadedir ve hiçbir şey döndürmeyen bir ifade aslında "
"()'yi dolaylı olarak döndürür."

#: src/ch02-02-data-types.md:280
msgid "{{#quiz ../quizzes/ch02-02-data-types.toml}}"
msgstr "#quiz../quizzes/ch02-02-data-types.toml"

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry "
"point of many programs. You’ve also seen the `fn` keyword, which allows you "
"to declare new functions."
msgstr ""
"Fonksiyonlar Kahire kodunda yaygındır. Dildeki en önemli işlevlerden birini "
"zaten gördünüz: birçok programın giriş noktası olan main işlevi. Ayrıca, "
"yeni işlevler beyan etmenizi sağlayan fn anahtar kelimesini de gördünüz."

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr ""
"Kahire kodu, tüm harflerin küçük olduğu ve ayrı kelimelerin altını çizdiği "
"işlev ve değişken isimler için geleneksel stil olarak _snake case_ kullanır. "
"İşte örnek bir işlev tanımı içeren bir program:"

#: src/ch02-03-functions.md:14
msgid "\"Another function.\""
msgstr "\"Başka bir fonksiyon.\""

#: src/ch02-03-functions.md:18
msgid "\"Hello, world!\""
msgstr "\"Merhaba dünya!\""

#: src/ch02-03-functions.md:23
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr ""
"Kahire'de fn'ya girerek bir fonksiyon adı ve bir dizi parantez koyarak bir "
"fonksiyon tanımlıyoruz. Kıvırcık parantezler, derleyiciye fonksiyon "
"gövdesinin nerede başladığını ve bittiğini söyler."

#: src/ch02-03-functions.md:27
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it "
"can be called from inside the `main` function. Note that we defined "
"`another_function` _before_ the `main` function in the source code; we could "
"have defined it after as well. Cairo doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr ""
"İsmini girerek tanımladığımız herhangi bir işlevi bir dizi parantezle "
"çağırabiliriz. Another_function program içinde tanımlandığından, main "
"fonksiyonunun içinden çağrılabilir. Kaynak koddaki another_function "
"_before_ain fonksiyonunu tanımladığımızı unutmayın; daha sonra da "
"tanımlayabilirdik. Kahire, fonksiyonlarınızı nerede tanımladığınızı, "
"yalnızca bir yerde gördüklerini umursamaz."

#: src/ch02-03-functions.md:34
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions "
"further. Place the `another_function` example in _src/lib.cairo_ and run it. "
"You should see the following output:"
msgstr ""
"Fonksiyonları daha fazla keşfetmek için Scarb adında _functions_ ile yeni "
"bir projeye başlayalım. another_function örneğini _src/lib.cairo_ dosyasına "
"yerleştirin ve çalıştırın. Aşağıdaki çıktıyı görmelisiniz:"

#: src/ch02-03-functions.md:49
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the `Hello, world!` message prints, and then `another_function` is "
"called and its message is printed."
msgstr ""
"Satırlar, ana işlevinde göründükleri sırada çalışır. Önce Merhaba, dünya! "
"mesaj baskıları ve daha sonra başka bir_fonksiyon çağrılır ve mesajı "
"yazdırılır."

#: src/ch02-03-functions.md:53
msgid "Parameters"
msgstr "Parametreler"

#: src/ch02-03-functions.md:55
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you "
"can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr ""
"Fonksiyonları, bir fonksiyonun imzasının bir parçası olan özel değişkenler "
"olan _parametrelere sahip olarak tanımlayabiliriz. Bir fonksiyonun "
"parametreleri olduğunda, bu parametreler için somut değerler "
"sağlayabilirsiniz. Teknik olarak, somut değerler _arguments_ olarak "
"adlandırılır, ancak gündelik konuşmada, insanlar bir fonksiyonun tanımındaki "
"değişkenler veya bir işlevi çağırdığınızda geçen somut değerler için "
"_parametre_ ve _argument_ kelimelerini birbirlerinin yerine kullanma "
"eğilimindedirler."

#: src/ch02-03-functions.md:63
msgid "In this version of `another_function` we add a parameter:"
msgstr "another_function'un bu sürümünde bir parametre ekliyoruz:"

#: src/ch02-03-functions.md:75
msgid "Try running this program; you should get the following output:"
msgstr "Bu programı çalıştırmayı deneyin; aşağıdaki çıktıyı almanız gerekir:"

#: src/ch02-03-functions.md:87
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `felt252`. When we pass `5` in to `another_function`, "
"the `println!` macro puts `5` where the pair of curly brackets containing "
"`x` was in the format string."
msgstr ""
"another_function deklarasyonunun x adında bir parametresi vardır. x türü "
"felt252 olarak belirtilir. 5'yi another_function'ye geçtiğimizde, println! "
"makro, x içeren kıvırcık parantez çiftinin format dizgesinde olduğu yere 5 "
"koyar."

#: src/ch02-03-functions.md:91
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Cairo’s design: requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also "
"able to give more helpful error messages if it knows what types the function "
"expects."
msgstr ""
"Fonksiyon imzalarında, sen _must_ her parametrenin türünü beyan eder. Bu "
"Kahire'nin tasarımında kasıtlı bir karardır: fonksiyon tanımlarında tip "
"açıklamalarının yapılması, derleyicinin ne demek istediğinizi anlamak için "
"kodun başka bir yerinde kullanmanıza neredeyse hiç ihtiyaç duymadığı "
"anlamına gelir. Derleyici, işlevin ne tür bir hata beklediğini biliyorsa, "
"daha yararlı hata mesajları da verebilir."

#: src/ch02-03-functions.md:97
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr ""
"Birden fazla parametreyi tanımlarken, parametre bildirimlerini virgüllerle "
"ayırın, şöyle:"

#: src/ch02-03-functions.md:102
msgid "\"h\""
msgstr "\"h\""

#: src/ch02-03-functions.md:106
msgid "\"The measurement is: {value}{unit_label}\""
msgstr "\"Ölçüm: valueunit_label\""

#: src/ch02-03-functions.md:110
msgid ""
"This example creates a function named `print_labeled_measurement` with two "
"parameters. The first parameter is named `value` and is a `u128`. The second "
"is named `unit_label` and is of type `ByteArray` - Cairo's internal type to "
"represent string literals. The function then prints text containing both the "
"`value` and the `unit_label`."
msgstr ""
"Bu örnek, print_labeled_measurement adında iki parametreli bir fonksiyon "
"oluşturur. İlk parametre value olarak adlandırılır ve u128'dir. İkincisi "
"unit_label olarak adlandırılır ve ByteArray - Kahire'nin iç tipi dizgi "
"harfini temsil eder. Fonksiyon daha sonra hem value hem de unit_label içeren "
"metni yazdırır."

#: src/ch02-03-functions.md:114
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/lib.cairo_ file with the preceding example and "
"run it using `scarb cairo-run`:"
msgstr ""
"Bu kodu çalıştırmayı deneyelim. Şu anda _functions_ projenizin _src/lib."
"cairo_ dosyasındaki programı önceki örnekle değiştirin ve scarb cairo-run "
"kullanarak çalıştırın:"

#: src/ch02-03-functions.md:127
msgid ""
"Because we called the function with `5` as the value for value and `\"h\"` "
"as the value for `unit_label`, the program output contains those values."
msgstr ""
"5 ile fonksiyona değer değeri ve unit_label değeri olarak \"h\" adını "
"verdiğimiz için, program çıktısı bu değerleri içerir."

#: src/ch02-03-functions.md:129
msgid "Named Parameters"
msgstr "Adlandırılmış Parametreler"

#: src/ch02-03-functions.md:131
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when "
"you call a function. This makes the function calls more readable and self-"
"descriptive. If you want to use named parameters, you need to specify the "
"name of the parameter and the value you want to pass to it. The syntax is "
"`parameter_name: value`. If you pass a variable that has the same name as "
"the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""
"Kahire'de, adlandırılmış parametreler, bir işlevi çağırdığınızda "
"argümanların adlarını belirtmenize izin verir. Bu, işlevin daha okunabilir "
"ve kendi kendini tanımlayıcı olmasını sağlar. Adlandırılmış parametreleri "
"kullanmak istiyorsanız, parametrenin adını ve ona geçmek istediğiniz değeri "
"belirtmeniz gerekir. Sözdizimi parametre_name: value'dir. Parametreyle aynı "
"adı taşıyan bir değişkeni geçerseniz, basitçe  parametresi_name'i "
"yazabilirsiniz."

#: src/ch02-03-functions.md:134
#: src/ch09-01-unrecoverable-errors-with-panic.md:72
#: src/ch09-02-recoverable-errors.md:141
#: src/appendix-03-derivable-traits.md:151
#: src/appendix-03-derivable-traits.md:200
msgid "Here is an example:"
msgstr "İşte bir örnek:"

#: src/ch02-03-functions.md:149
msgid "Statements and Expressions"
msgstr "İfadeler ve İfadeler"

#: src/ch02-03-functions.md:151
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Cairo is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions, "
"so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr ""
"Fonksiyon organları isteğe bağlı olarak bir ifade ile biten bir dizi "
"ifadeden oluşur. Şimdiye kadar ele aldığımız işlevler bir bitiş ifadesi "
"içermedi, ancak bir ifadenin bir parçası olarak bir ifade gördünüz. Kahire "
"ifadeye dayalı bir dil olduğu için, bu anlaşılması gereken önemli bir "
"ayrımdır. Diğer diller aynı ayrımlara sahip değildir, bu yüzden hangi "
"ifadelerin ve ifadelerin ve farklılıklarının işlevlerin bedenlerini nasıl "
"etkilediğine bakalım."

#: src/ch02-03-functions.md:159
msgid ""
"**Statements** are instructions that perform some action and do not return a "
"value."
msgstr ""
"**Statements** bazı eylemler gerçekleştiren ve bir değer döndürmeyen "
"talimatlardır."

#: src/ch02-03-functions.md:161
msgid ""
"**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr ""
"**Ekspresyonlar** sonuç değerine göre değerlendirilir. Bazı örneklere "
"bakalım."

#: src/ch02-03-functions.md:163
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 2-1, `let y = 6;` is a statement."
msgstr ""
"Aslında ifade ve ifadeleri zaten kullandık. let anahtar kelimesi ile bir "
"değişken oluşturmak ve ona bir değer atamak bir ifadedir. Listeleme 2-1'de "
"let y = 6; bir ifadedir."

#: src/ch02-03-functions.md:173
msgid ""
"<span class=\"caption\">Listing 2-1: A `main` function declaration "
"containing one statement</span>"
msgstr ""
"span class=\"caption\">Listing 2-1: Bir ifade içeren bir main fonksiyon "
"bildirimi/span>"

#: src/ch02-03-functions.md:175
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself."
msgstr ""
"Fonksiyon tanımları aynı zamanda ifadelerdir; önceki örneğin tamamı kendi "
"içinde bir ifadedir."

#: src/ch02-03-functions.md:177
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get "
"an error:"
msgstr ""
"İfadeler değerleri döndürmez. Bu nedenle, aşağıdaki kodun yapmaya çalıştığı "
"gibi başka bir değişkene let ifadesi atayamazsınız; bir hata alırsınız:"

#: src/ch02-03-functions.md:186
msgid "When you run this program, the error you’ll get looks like this:"
msgstr "Bu programı çalıştırdığınızda, alacağınız hata şu şekilde görünür:"

#: src/ch02-03-functions.md:226
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Cairo."
msgstr ""
"let y = 6 ifadesi bir değer döndürmez, bu yüzden x'nin bağlanması için "
"hiçbir şey yoktur. Bu, atamanın atamanın değerini döndürdüğü C ve Ruby gibi "
"diğer dillerde olanlardan farklıdır. Bu dillerde, x = y = 6 yazabilir ve hem "
"x hem de y değerine sahip olabilirsiniz 6; Kahire'de durum böyle değildir."

#: src/ch02-03-functions.md:232
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Cairo. Consider a math operation, such as `5 + 6`, "
"which is an expression that evaluates to the value `11`. Expressions can be "
"part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is "
"an expression that evaluates to the value `6`."
msgstr ""
"İfadeler bir değere değer verir ve Kahire'de yazacağınız kodun geri "
"kalanının çoğunu oluşturur. 5 + 6 gibi bir matematik işlemi düşünün, bu 11 "
"değerine değer veren bir ifadedir. İfadeler ifadelerin bir parçası olabilir: "
"2-1'in listelenmesinde, let y = 6; ifadesindeki 6 değeri değerlendiren bir "
"ifadedir."

#: src/ch02-03-functions.md:238
msgid ""
"Calling a function is an expression since it always evaluates to a value: "
"the function's explicit return value, if specified, or the 'unit' type `()` "
"otherwise."
msgstr ""
"Bir fonksiyonu çağırmak, her zaman bir değere değer verdiği için bir "
"ifadedir: fonksiyonun açık getiri değeri, belirtilmişse veya 'birim' türü () "
"aksi takdirde."

#: src/ch02-03-functions.md:240
msgid ""
"A new scope block created with curly brackets is an expression, for example:"
msgstr ""
"Kıvırcık parantezlerle oluşturulan yeni bir kapsam bloğu bir ifadedir, "
"örneğin:"

#: src/ch02-03-functions.md:249
msgid "\"The value of y is: {}\""
msgstr "\"Y'nin değeri: \""

#: src/ch02-03-functions.md:253
msgid "This expression:"
msgstr "Bu ifade:"

#: src/ch02-03-functions.md:262
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note that the `x + 1` line doesn’t have "
"a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to "
"the end of an expression, you turn it into a statement, and it will then not "
"return a value. Keep this in mind as you explore function return values and "
"expressions next."
msgstr ""
"Bu durumda, 4 değerini değerlendiren bir bloktur. Bu değer, let ifadesinin "
"bir parçası olarak y'ye bağlanır. x + 1 satırının sonunda noktalı bir virgül "
"olmadığını unutmayın, bu da şu ana kadar gördüğünüz çizgilerin çoğundan "
"farklı. İfadeler noktalı virgülleri sonlandırmayı içermez. Bir ifadenin "
"sonuna noktalı virgül eklerseniz, bu ifadeyi bir ifadeye dönüştüreceksiniz."

#: src/ch02-03-functions.md:270
msgid "Functions with Return Values"
msgstr "Dönüş Değerleri ile Fonksiyonlar"

#: src/ch02-03-functions.md:272
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Cairo, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr ""
"Fonksiyonlar, onları çağıran koda değerleri döndürebilir. Dönüş değerlerini "
"adlandırmıyoruz, ancak türlerini bir oktan sonra ilan etmeliyiz (->). "
"Kahire'de, fonksiyonun dönüş değeri, bir fonksiyonun gövdesinin bloğundaki "
"son ifadenin değeri ile eş anlamlıdır. return anahtar kelimesini kullanarak "
"ve bir değer belirleyerek bir fonksiyondan erken dönebilirsiniz, ancak çoğu "
"fonksiyon, bir fonksiyonun son ifadesini dolaylı olarak döndürür."

#: src/ch02-03-functions.md:291
msgid ""
"There are no function calls, or even `let` statements in the `five` function—"
"just the number `5` by itself. That’s a perfectly valid function in Cairo. "
"Note that the function’s return type is specified too, as `-> u32`. Try "
"running this code; the output should look like this:"
msgstr ""
"beş fonksiyonunda fonksiyon çağrıları, hatta let ifadeleri yoktursadece 5 "
"sayısı kendi başınadır. Kahire'de bu mükemmel geçerli bir fonksiyondur. -> "
"u32 olarak fonksiyonun dönüş tipinin de belirtildiğini unutmayın. Bu kodu "
"çalıştırmayı deneyin; çıktı şu şekilde görünmelidir:"

#: src/ch02-03-functions.md:306
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `u32`. Let’s examine this in more detail. There are two important "
"bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr ""
"5 in 5 fonksiyonun dönüş değeridir, bu yüzden dönüş tipi u32'dir. Bunu daha "
"ayrıntılı inceleyelim. İki önemli bit vardır: ilk olarak, let x = beş(); bir "
"fonksiyonun dönüş değerini bir değişkeni başlatmak için kullandığımızı "
"gösterir. Çünkü 5 fonksiyonu bir 5 döndürür, bu satır aşağıdakiyle aynıdır:"

#: src/ch02-03-functions.md:316
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon "
"because it’s an expression whose value we want to return. Let’s look at "
"another example:"
msgstr ""
"İkincisi, beş işlevinin parametresi yoktur ve dönüş değerinin türünü "
"tanımlar, ancak fonksiyonun gövdesi virgülsüz yalnız bir 5'dir, çünkü değeri "
"dönmek istediğimiz bir ifadedir. Başka bir örneğe bakalım:"

#: src/ch02-03-functions.md:333
msgid ""
"Running this code will print `x = 6`. But if we place a semicolon at the end "
"of the line containing `x + 1`, changing it from an expression to a "
"statement, we’ll get an error:"
msgstr ""
"Bu kodu çalıştırmak x = 6 yazdıracaktır. Ancak x + 1 içeren satırın sonuna "
"bir noktalı virgül yerleştirirsek, bir ifadeden bir ifadeye değiştirirsek, "
"bir hata alırız:"

#: src/ch02-03-functions.md:349
msgid ""
"```shell\n"
"$ scarb cairo-run \n"
"   Compiling no_listing_22_function_return_invalid v0.1.0 (listings/ch02-"
"common-programming-concepts/no_listing_24_function_return_invalid/Scarb."
"toml)\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: "
"\"()\".\n"
" --> listings/ch02-common-programming-concepts/"
"no_listing_24_function_return_invalid/src/lib.cairo:9:28\n"
"fn plus_one(x: u32) -> u32 {\n"
"                           ^\n"
"\n"
"error: could not compile `no_listing_22_function_return_invalid` due to "
"previous error\n"
"error: `scarb metadata` exited with error\n"
"\n"
"```"
msgstr ""
"shell $ scarb cairo-run Compiling no_listing_22_function_return_invalid "
"v0.1.0 (listings/ch02-common-programming-concepts/"
"no_listing_24_function_return_invalid/Scarb.toml) hatası: Beklenmedik dönüş "
"tipi. Beklenen: \"core:integer:u32\" bulundu."

#: src/ch02-03-functions.md:362
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue "
"with this code. The definition of the function `plus_one` says that it will "
"return an `u32`, but statements don’t evaluate to a value, which is "
"expressed by `()`, the unit type. Therefore, nothing is returned, which "
"contradicts the function definition and results in an error."
msgstr ""
"Ana hata iletisi, Beklenmeyen geri dönüş tipi, bu kodla temel sorunu ortaya "
"çıkarır. plus_one işlevinin tanımı, u32 döndüreceğini söyler, ancak "
"ifadeler, birim türü olan () ile ifade edilen bir değere değerlendirmez. Bu "
"nedenle, fonksiyon tanımıyla çelişen ve bir hatayla sonuçlanan hiçbir şey "
"iade edilmez."

#: src/ch02-03-functions.md:368
msgid "{{#quiz ../quizzes/ch02-03-functions.toml}}"
msgstr "#quiz../quizzes/ch02-03-functions.toml"

#: src/ch02-04-comments.md:3
msgid ""
"All programmers strive to make their code easy to understand, but sometimes "
"extra explanation is warranted. In these cases, programmers leave comments "
"in their source code that the compiler will ignore but people reading the "
"source code may find useful."
msgstr ""
"Tüm programcılar kodlarını anlaşılması kolay hale getirmek için çaba "
"gösterirler, ancak bazen ekstra açıklama garanti edilir. Bu durumlarda, "
"programcılar kaynak kodlarında derleyicinin görmezden geleceği ancak kaynak "
"kodu okuyan kişilerin yararlı bulabileceği yorumları bırakırlar."

#: src/ch02-04-comments.md:5
msgid "Here’s a simple comment:"
msgstr "İşte basit bir yorum:"

#: src/ch02-04-comments.md:8
msgid "// hello, world\n"
msgstr "// Merhaba, dünya\n"

#: src/ch02-04-comments.md:11
msgid ""
"In Cairo, the idiomatic comment style starts a comment with two slashes, and "
"the comment continues until the end of the line. For comments that extend "
"beyond a single line, you’ll need to include `//` on each line, like this:"
msgstr ""
"Kahire'de, deyimsel yorum stili iki slash ile bir yorum başlatır ve yorum "
"satırın sonuna kadar devam eder. Tek bir satırın ötesine uzanan yorumlar "
"için, her satıra /'yi dahil etmeniz gerekir, örneğin:"

#: src/ch02-04-comments.md:14
msgid ""
"// So we’re doing something complicated here, long enough that we need\n"
"// multiple lines of comments to do it! Whew! Hopefully, this comment will\n"
"// explain what’s going on.\n"
msgstr ""
"// Burada karmaşık bir şey yapıyoruz, bunu yapmak için // çok sayıda yorum "
"satırına ihtiyacımız var! Whew! Umarım, bu yorum // neler olduğunu "
"açıklayacaktır.\n"

#: src/ch02-04-comments.md:19
msgid "Comments can also be placed at the end of lines containing code:"
msgstr "Yorumlar, kod içeren satırların sonuna da yerleştirilebilir:"

#: src/ch02-04-comments.md:23
msgid "// return the sum of 1 and 4\n"
msgstr "// 1 ve 4'ün toplamını döndürür\n"

#: src/ch02-04-comments.md:27
msgid ""
"But you’ll more often see them used in this format, with the comment on a "
"separate line above the code it’s annotating:"
msgstr ""
"Ancak daha sık bu formatta kullanıldıklarını göreceksiniz, kodun üstünde "
"ayrı bir satırdaki yorumla şu şekilde ifade ediyor:"

#: src/ch02-04-comments.md:31
msgid "// this function performs a simple addition\n"
msgstr "// bu fonksiyon basit bir ekleme gerçekleştirir\n"

#: src/ch02-04-comments.md:36
msgid "Item-level Documentation"
msgstr "Öge-seviyesi Dokümantasyon"

#: src/ch02-04-comments.md:38
msgid ""
"Item-level documentation comments refer to specific items such as functions, "
"implementations, traits, etc. They are prefixed with three slashes (`///`). "
"These comments provide a detailed description of the item, examples of "
"usage, and any conditions that might cause a panic. In case of functions, "
"the comments may also include separate sections for parameter and return "
"value descriptions."
msgstr ""
"Öğe düzeyinde dokümantasyon yorumları, fonksiyonlar, uygulamalar, özellikler "
"vb. gibi belirli öğelere atıfta bulunur. Bunlar üç slash (///) ile öne "
"çıkar. Bu yorumlar, öğenin ayrıntılı bir açıklamasını, kullanım örneklerini "
"ve paniğe neden olabilecek herhangi bir durumu sağlar. Fonksiyonlar söz "
"konusu olduğunda, yorumlar parametre ve iade değeri açıklamaları için ayrı "
"bölümler de içerebilir."

#: src/ch02-04-comments.md:41
msgid ""
"/// Returns the sum of `arg1` and `arg2`.\n"
"/// `arg1` cannot be zero.\n"
"///\n"
"/// # Panics\n"
"///\n"
"/// This function will panic if `arg1` is `0`.\n"
"///\n"
"/// # Examples\n"
"///\n"
"/// ```\n"
"/// let a: felt252 = 2;\n"
"/// let b: felt252 = 3;\n"
"/// let c: felt252 = add(a, b);\n"
"/// assert(c == a + b, \"Should equal a + b\");\n"
"/// ```\n"
msgstr ""
"/// arg1 ve arg2 toplamını döndürür. /// arg1 sıfır olamaz. // // // /// # "
"Panics // // // /// arg1 0 ise bu fonksiyon "
"panikleyecektir. // // // // // // // // // // // //  // / let a: felt252 = "
"2; /// let b: felt252 = 3;\n"

#: src/ch02-04-comments.md:62
msgid "Module Documentation"
msgstr "Modül Dokümantasyonu"

#: src/ch02-04-comments.md:64
msgid ""
"Module documentation comments provide an overview of the entire module, "
"including its purpose and examples of use. These comments are meant to be "
"placed above the module they're describing and are prefixed with `//!`. This "
"type of documentation gives a broad understanding of what the module does "
"and how it can be used."
msgstr ""
"Modül dokümantasyon yorumları, amacı ve kullanım örnekleri de dahil olmak "
"üzere tüm modüle genel bir bakış sağlar. Bu yorumlar, tanımladıkları modülün "
"üzerine yerleştirilmek üzere tasarlanmıştır ve /! ile öne çıkmaktadır. Bu "
"dokümantasyon türü, modülün ne yaptığını ve nasıl kullanılabileceğini geniş "
"bir şekilde anlamayı sağlar."

#: src/ch02-04-comments.md:67
msgid ""
"//! # my_module and implementation\n"
"//!\n"
"//! This is an example description of my_module and some of its features.\n"
"//!\n"
"//! # Examples\n"
"//!\n"
"//! ```\n"
"//! mod my_other_module {\n"
"//!   use path::to::my_module;\n"
"//!\n"
"//!   fn foo() {\n"
"//!     my_module.bar();\n"
"//!   }\n"
"//! }\n"
"//! ```\n"
msgstr ""
"//! # my_module ve uygulama //! //! Bu, my_module ve bazı özelliklerinin "
"örnek bir açıklamasıdır. //! //! # Örnekler //! //!  // mod "
"my_other_module  //! kullanım yolu::::: my_module; //! fn foo()  //! "
"my_module.bar(); //!  //!\n"

#: src/ch02-04-comments.md:82
msgid "// rest of implementation...\n"
msgstr "// Uygulamanın geri kalanı...\n"

#: src/ch02-04-comments.md:86
msgid "{{#quiz ../quizzes/ch02-04-comments.toml}}"
msgstr "#quiz../quizzes/ch02-04-comments.toml"

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to "
"run some code repeatedly while a condition is true are basic building blocks "
"in most programming languages. The most common constructs that let you "
"control the flow of execution of Cairo code are if expressions and loops."
msgstr ""
"Bir koşulun doğru olup olmadığına bağlı olarak bazı kodları çalıştırma ve "
"bir koşul doğru iken bazı kodları tekrar tekrar çalıştırma yeteneği, çoğu "
"programlama dilinde temel yapı taşlarıdır. Kahire kodunun yürütme akışını "
"kontrol etmenizi sağlayan en yaygın yapılar ifadeler ve döngülerdir."

#: src/ch02-05-control-flow.md:5
msgid "`if` Expressions"
msgstr "if İfadeler"

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You "
"provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr ""
"Bir ifade, kodunuzu koşullara bağlı olarak dallandırmanıza izin veriyorsa. "
"Bir koşul sağlarsınız ve sonra, \"Bu koşul sağlanıyorsa, bu kod bloğunu "
"çalıştırın. Durum sağlanmıyorsa, bu kod bloğunu çalıştırmayın.\""

#: src/ch02-05-control-flow.md:9
msgid ""
"Create a new project called _branches_ in your _cairo_projects_ directory to "
"explore the `if` expression. In the _src/lib.cairo_ file, input the "
"following:"
msgstr ""
"if ifadesini keşfetmek için _cairo_projects_ dizininde _branches_ adlı yeni "
"bir proje oluşturun. _src/lib.cairo_ dosyasında, aşağıdakileri girin:"

#: src/ch02-05-control-flow.md:16
msgid "\"condition was true and number = {}\""
msgstr "\"koşul doğruydu ve sayı = \""

#: src/ch02-05-control-flow.md:18
msgid "\"condition was false and number = {}\""
msgstr "\"koşul yanlıştı ve numara = \""

#: src/ch02-05-control-flow.md:23
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value equal to 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets."
msgstr ""
"Tüm if ifadeleri if anahtar kelimesiyle başlar, ardından bir koşul gelir. Bu "
"durumda, durum, number değişkeninin 5'e eşit bir değere sahip olup "
"olmadığını kontrol eder. Eğer koşul true ise, koşul kıvırcık parantez içinde "
"hemen sonra çalıştırılacak kod bloğunu yerleştiririz."

#: src/ch02-05-control-flow.md:25
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the "
"condition evaluate to `false`. If you don’t provide an `else` expression and "
"the condition is `false`, the program will just skip the `if` block and move "
"on to the next bit of code."
msgstr ""
"İsteğe bağlı olarak, burada yapmayı seçtiğimiz bir else ifadesi de "
"ekleyebiliriz, koşul false olarak değerlendirildiğinde programa çalıştırmak "
"için alternatif bir kod bloğu verebiliriz. Bir else ifadesi sağlamazsanız ve "
"durum false ise, program sadece if bloğunu atlar ve bir sonraki kod bitine "
"geçer."

#: src/ch02-05-control-flow.md:27
msgid "Try running this code; you should see the following output:"
msgstr "Bu kodu çalıştırmayı deneyin; aşağıdaki çıktıyı görmelisiniz:"

#: src/ch02-05-control-flow.md:39
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition "
"`true` to see what happens:"
msgstr ""
"number değerini, ne olduğunu görmek için true koşulunu yapan bir değere "
"değiştirelim:"

#: src/ch02-05-control-flow.md:51
msgid ""
"It’s also worth noting that the condition in this code must be a `bool`. If "
"the condition isn’t a `bool`, we’ll get an error. For example, try running "
"the following code:"
msgstr ""
"Ayrıca, bu koddaki durumun bir bool olması gerektiğini de belirtmek gerekir. "
"Durum bir bool değilse, bir hata alırız. Örneğin, aşağıdaki kodu "
"çalıştırmayı deneyin:"

#: src/ch02-05-control-flow.md:58
msgid "\"number was three\""
msgstr "\"Üç numaraydı\""

#: src/ch02-05-control-flow.md:63
msgid ""
"The `if` condition evaluates to a value of 3 this time, and Cairo throws an "
"error:"
msgstr "if durumu bu kez 3 değerini değerlendirir ve Kahire bir hata atar:"

#: src/ch02-05-control-flow.md:77
msgid ""
"The error indicates that Cairo inferred the type of `number` to be a `bool` "
"based on its later use as a condition of the `if` statement. It tries to "
"create a `bool` from the value `3`, but Cairo doesn't support instantiating "
"a `bool` from a numeric literal anyway - you can only use `true` or `false` "
"to create a `bool`. Unlike languages such as Ruby and JavaScript, Cairo will "
"not automatically try to convert non-Boolean types to a Boolean. If we want "
"the `if` code block to run only when a number is not equal to 0, for "
"example, we can change the if expression to the following:"
msgstr ""
"Hata, Kahire'nin, if ifadesinin bir koşulu olarak daha sonra kullanılmasına "
"dayanarak bool tipini sayısı olarak tanımladığını gösterir. 3 değerinden bir "
"bool bloğu oluşturmaya çalışır, ancak Kahire, bool harfini sayısal olmayan "
"bir sözcükten çevirmek için bir bool'u otomatik olarak çalıştırmazsa - "
"sadece  true veya fal'ı kullanabilirsiniz."

#: src/ch02-05-control-flow.md:91
msgid "\"number was something other than zero\""
msgstr "\"Sayı sıfırdan başka bir şeydi\""

#: src/ch02-05-control-flow.md:97
msgid "Running this code will print `number was something other than zero`."
msgstr ""
"Bu kodun çalıştırılması number'ı sıfır'dan başka bir şey olarak "
"yazdıracaktır."

#: src/ch02-05-control-flow.md:99
msgid "Handling Multiple Conditions with `else if`"
msgstr "Birden fazla koşulu else if ile işlemek"

#: src/ch02-05-control-flow.md:101
msgid ""
"You can use multiple conditions by combining `if` and `else` in an `else if` "
"expression. For example:"
msgstr ""
"if ve else'yi else if ifadesinde birleştirerek birden fazla koşul "
"kullanabilirsiniz. Örneğin:"

#: src/ch02-05-control-flow.md:108
msgid "\"number is 12\""
msgstr "\"Numara 12\""

#: src/ch02-05-control-flow.md:110
msgid "\"number is 3\""
msgstr "\"Numara 3\""

#: src/ch02-05-control-flow.md:112
msgid "\"number minus 2 is 1\""
msgstr "\"sayı eksi 2 eşittir 1\""

#: src/ch02-05-control-flow.md:114
msgid "\"number not found\""
msgstr "\"sayı bulunamadı\""

#: src/ch02-05-control-flow.md:119
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr ""
"Bu programın alabileceği dört olası yolu vardır. Çalıştırdıktan sonra "
"aşağıdaki çıktıyı görmelisiniz:"

#: src/ch02-05-control-flow.md:131
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1` nor do we see the `number not found` text from the "
"`else` block. That’s because Cairo only executes the block for the first "
"true condition, and once it finds one, it doesn’t even check the rest. Using "
"too many `else if` expressions can clutter your code, so if you have more "
"than one, you might want to refactor your code. [Chapter 6](./ch06-02-the-"
"match-control-flow-construct.md) describes a powerful Cairo branching "
"construct called `match` for these cases."
msgstr ""
"Bu program çalıştırdığında, sırayla her if ifadesini kontrol eder ve koşulun "
"true olarak değerlendirdiği ilk gövdeyi çalıştırır. number - 2 == 1 bir true "
"olsa bile, number eksi 2 is 1 çıktısını görmeyiz ve else bloğundan gelen "
"number bulunamadı metnini de görmeyiz. Bunun nedeni, Kahire'nin sadece ilk "
"bloğu çalıştırıyor olmasıdır."

#: src/ch02-05-control-flow.md:135
msgid "Using `if` in a `let` Statement"
msgstr "Bir let Bildiriminde if kullanımı"

#: src/ch02-05-control-flow.md:137
msgid ""
"Because `if` is an expression, we can use it on the right side of a `let` "
"statement to assign the outcome to a variable."
msgstr ""
"if bir ifade olduğundan, sonucu bir değişkene atamak için let ifadesinin sağ "
"tarafında kullanabiliriz."

#: src/ch02-05-control-flow.md:149
msgid "\"condition was true and number is {}\""
msgstr "\"koşul doğruydu ve numara \""

#: src/ch02-05-control-flow.md:164
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression, which will be 5 here."
msgstr ""
"sayı değişkeni, burada 5 olacak olan if ifadesinin sonucuna göre bir değere "
"bağlanacaktır."

#: src/ch02-05-control-flow.md:166
msgid "Repetition with Loops"
msgstr "Loops ile tekrarlama"

#: src/ch02-05-control-flow.md:168
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Cairo provides a simple loop syntax, which will run through the code inside "
"the loop body to the end and then start immediately back at the beginning. "
"To experiment with loops, let’s create a new project called _loops_."
msgstr ""
"Bir kod bloğunu birden fazla kez çalıştırmak genellikle yararlıdır. Bu görev "
"için Kahire, döngü gövdesinin içindeki koddan sonuna kadar çalışacak ve daha "
"sonra hemen baştan başlayacak basit bir döngü sözdizimi sağlar. Döngüleri "
"denemek için, _loops_ adlı yeni bir proje oluşturalım."

#: src/ch02-05-control-flow.md:170
msgid "Cairo has two kinds of loops: `loop` and `while`."
msgstr "Kahire'nin iki tür döngüsü vardır: loop ve while."

#: src/ch02-05-control-flow.md:172
msgid "Repeating Code with `loop`"
msgstr "Kod loop ile tekrarlanıyor"

#: src/ch02-05-control-flow.md:174
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over "
"again forever or until you explicitly tell it to stop."
msgstr ""
"loop anahtar kelimesi, Kahire'ye bir kod bloğunu sonsuza kadar veya açıkça "
"durmasını söyleyene kadar tekrar tekrar çalıştırmasını söyler."

#: src/ch02-05-control-flow.md:176
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to "
"look like this:"
msgstr ""
"Örnek olarak, _loops_ dizinindeki _src/lib.cairo_ dosyasını şu şekilde "
"değiştirin:"

#: src/ch02-05-control-flow.md:181
msgid "\"again!\""
msgstr "\"Tekrar!\""

#: src/ch02-05-control-flow.md:189
msgid ""
"Note: This program would not compile without a break condition. For the "
"purpose of the example, we added a `break` statement that will never be "
"reached, but satisfies the compiler."
msgstr ""
"Not: Bu program bir mola koşulu olmadan derlemez. Örnek amacıyla, asla "
"ulaşılmayacak, ancak derleyiciyi tatmin edecek bir break ifadesi ekledik."

#: src/ch02-05-control-flow.md:191
msgid ""
"When we run this program, we’ll see `again!` printed over and over "
"continuously until either the program runs out of gas or we stop the program "
"manually. Most terminals support the keyboard shortcut ctrl-c to interrupt a "
"program that is stuck in a continual loop. Give it a try:"
msgstr ""
"Bu programı çalıştırdığımızda, program gaz bitene veya programı manuel "
"olarak durdurana kadar yine!'yi sürekli olarak basılı göreceğiz. Çoğu "
"terminal, sürekli döngüye sıkışmış bir programı kesmek için klavye kısayolu "
"ctrl-c'yi destekler. Bir deneyin:"

#: src/ch02-05-control-flow.md:193
msgid ""
"```shell\n"
"$ scarb cairo-run --available-gas=20000000\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished release target(s) in 0 seconds\n"
"     Running loops\n"
"again!\n"
"again!\n"
"again!\n"
"^Cagain!\n"
"```"
msgstr ""
"shell $ scarb cairo-run - available-gas=20000000 Derleme döngüleri v0.1.0 "
"(dosya:///projects/loops) 0 saniye içinde serbest bırakma hedefi(ler) Yine "
"Koşu döngüleri! tekrar! Cagain!"

#: src/ch02-05-control-flow.md:204
msgid ""
"The symbol `^C` represents where you pressed ctrl-c. You may or may not see "
"the word `again!` printed after the ^C, depending on where the code was in "
"the loop when it received the interrupt signal."
msgstr ""
"C sembolü, ctrl-c tuşuna bastığınız yeri temsil eder. Kesme sinyalini "
"aldığında kodun döngüde bulunduğu yere bağlı olarak, C'den sonra basılan "
"again! kelimesini görebilir veya göremeyebilirsiniz."

#: src/ch02-05-control-flow.md:206
msgid ""
"Note: Cairo prevents us from running program with infinite loops by "
"including a gas meter. The gas meter is a mechanism that limits the amount "
"of computation that can be done in a program. By setting a value to the `--"
"available-gas` flag, we can set the maximum amount of gas available to the "
"program. Gas is a unit of measurement that expresses the computation cost of "
"an instruction. When the gas meter runs out, the program will stop. In the "
"previous case, we set the gas limit high enough for the program to run for "
"quite some time."
msgstr ""
"Not: Kahire, bir gaz sayacı dahil ederek programı sonsuz döngülerle "
"çalıştırmamızı önler. Gaz sayacı, bir programda yapılabilecek hesaplama "
"miktarını sınırlayan bir mekanizmadır.  - available-gas bayrağına bir değer "
"ayarlayarak, program için mevcut olan maksimum gaz miktarını "
"ayarlayabiliriz. Gaz, bir talimatın hesaplama maliyetini ifade eden bir "
"ölçüm birimidir. Gaz sayacı bittiğinde, program bir önceki program için "
"oldukça yüksek bir süre durur."

#: src/ch02-05-control-flow.md:208
msgid ""
"It is particularly important in the context of smart contracts deployed on "
"Starknet, as it prevents from running infinite loops on the network. If "
"you're writing a program that needs to run a loop, you will need to execute "
"it with the `--available-gas` flag set to a value that is large enough to "
"run the program."
msgstr ""
"Starknet'te konuşlandırılmış akıllı sözleşmeler bağlamında özellikle "
"önemlidir, çünkü ağ üzerinde sonsuz döngüler çalıştırmayı önler. Bir döngüyü "
"çalıştırması gereken bir program yazıyorsanız, programı çalıştırmak için "
"yeterince büyük bir değere ayarlanmış  - available-gas bayrağı ile "
"yürütmeniz gerekir."

#: src/ch02-05-control-flow.md:211
msgid ""
"Now, try running the same program again, but this time with the `--available-"
"gas` flag set to `200000` instead of `2000000000000`. You will see the "
"program only prints `again!` 3 times before it stops, as it ran out of gas "
"to keep executing the loop."
msgstr ""
"Şimdi, aynı programı tekrar çalıştırmayı deneyin, ancak bu sefer  - "
"available-gas bayrağı ile 200000000000000 yerine 200000 olarak "
"ayarlanmıştır. Programın sadece döngüyü yürütmeye devam etmek için gazın "
"tükenmesi nedeniyle durmadan önce yine! 3 kez baskı yaptığını göreceksiniz."

#: src/ch02-05-control-flow.md:213
msgid ""
"Fortunately, Cairo also provides a way to break out of a loop using code. "
"You can place the `break` keyword within the loop to tell the program when "
"to stop executing the loop."
msgstr ""
"Neyse ki, Kahire ayrıca kod kullanarak bir döngüden çıkmanın bir yolunu da "
"sağlar. Döngüyü çalıştırmayı ne zaman durduracağını söylemek için break "
"anahtar kelimesini döngünün içine yerleştirebilirsiniz."

#: src/ch02-05-control-flow.md:222 src/ch02-05-control-flow.md:242
msgid "\"i = {}\""
msgstr "\"i = \""

#: src/ch02-05-control-flow.md:228
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the "
"loop and to skip the rest of the code in this iteration. Let's add a "
"`continue` statement to our loop to skip the `println!` statement when `i` "
"is equal to `5`."
msgstr ""
"continue anahtar kelimesi, programın döngünün bir sonraki yinelemesine "
"gitmesini ve bu yinelemedeki kodun geri kalanını atlamasını söyler. i  5'ye "
"eşit olduğunda, döngümüze println! ifadesini atlamak için bir continue "
"ifadesi ekleyelim."

#: src/ch02-05-control-flow.md:248
msgid ""
"Executing this program will not print the value of `i` when it is equal to "
"`5`."
msgstr "Bu programın çalıştırılması, i değerini 5'ye eşit olduğunda yazdırmaz."

#: src/ch02-05-control-flow.md:250
msgid "Returning Values from Loops"
msgstr "Döngülerden Dönen Değerler"

#: src/ch02-05-control-flow.md:252
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such as checking whether an operation has succeeded. You might also need to "
"pass the result of that operation out of the loop to the rest of your code. "
"To do this, you can add the value you want returned after the `break` "
"expression you use to stop the loop; that value will be returned out of the "
"loop so you can use it, as shown here:"
msgstr ""
"Bir loop'un kullanım alanlarından biri, bir işlemin başarılı olup olmadığını "
"kontrol etmek gibi başarısız olabileceğini bildiğiniz bir işlemi yeniden "
"denemektir. Bu işlemin sonucunu döngüden kodunuzun geri kalanına da "
"geçirmeniz gerekebilir. Bunu yapmak için, döngüyü durdurmak için "
"kullandığınız break ifadesinden sonra geri dönmek istediğiniz değeri "
"ekleyebilirsiniz; Bu değer, burada gösterildiği gibi, döngüden geri "
"döndürülecektir:"

#: src/ch02-05-control-flow.md:270
msgid "\"The result is {}\""
msgstr "\"Sonuç \""

#: src/ch02-05-control-flow.md:274
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to "
"`0`. Then we declare a variable named `result` to hold the value returned "
"from the loop. On every iteration of the loop, we check whether the "
"`counter` is equal to `10`, and then add `1` to the `counter` variable. When "
"the condition is met, we use the `break` keyword with the value `counter * "
"2`. After the loop, we use a semicolon to end the statement that assigns the "
"value to `result`. Finally, we print the value in `result`, which in this "
"case is `20`."
msgstr ""
"Döngüden önce, counter adlı bir değişkeni beyan ediyoruz ve 0 olarak "
"başlatıyoruz. Sonra döngüden dönen değeri tutmak için result adlı bir "
"değişkeni ilan ediyoruz. Döngünün her yinelemesinde, counter değeri 10 "
"değerine eşit olup olmadığını kontrol ediyoruz ve sonra counter değişkenine "
"1 ekliyoruz. Durum karşılandığında, break değerini kullanıyoruz."

#: src/ch02-05-control-flow.md:281
msgid "Conditional Loops with `while`"
msgstr "while ile koşullu döngüler"

#: src/ch02-05-control-flow.md:283
msgid ""
"A program will often need to evaluate a condition within a loop. While the "
"condition is `true`, the loop runs. When the condition ceases to be `true`, "
"the program calls `break`, stopping the loop. It’s possible to implement "
"behavior like this using a combination of `loop`, `if`, `else`, and `break`; "
"you could try that now in a program, if you’d like. However, this pattern is "
"so common that Cairo has a built-in language construct for it, called a "
"`while` loop."
msgstr ""
"Bir programın genellikle bir döngü içindeki bir durumu değerlendirmesi "
"gerekir. Durum true iken, döngü çalışır. Durum true olarak sona erdiğinde, "
"program break'yi çağırır, döngüyü durdurur. Böyle bir davranışı loop, if, "
"else ve break kombinasyonu kullanarak uygulamak mümkündür; Eğer böyle bir "
"dil inşa ettiyseniz, şimdi bunu bir programda deneyebilirsiniz."

#: src/ch02-05-control-flow.md:289
msgid ""
"In Listing 2-2, we use `while` to loop the program three times, counting "
"down each time after printing the value of `number`, and then, after the "
"loop, print a message and exit."
msgstr ""
"Listeleme 2-2'de, programı üç kez döngü yapmak için while kullanıyoruz, "
"number değerini yazdırdıktan sonra her seferinde geri sayım yapıyoruz ve "
"daha sonra döngüden sonra bir mesaj yazdırıp çıkıyoruz."

#: src/ch02-05-control-flow.md:296
msgid "\"{number}!\""
msgstr "\"numara!\""

#: src/ch02-05-control-flow.md:300
msgid "\"LIFTOFF!!!\""
msgstr "\"LİFTOFF!!!\""

#: src/ch02-05-control-flow.md:304
msgid ""
"<span class=\"caption\">Listing 2-2: Using a `while` loop to run code while "
"a condition holds `true`.</span>"
msgstr ""
"span class=\"caption\">Listing 2-2: Bir koşul true tutarken kodu çalıştırmak "
"için bir while döngüsü kullanma./span>"

#: src/ch02-05-control-flow.md:306
msgid ""
"This construct eliminates a lot of nesting that would be necessary if you "
"used `loop`, `if`, `else`, and `break`, and it’s clearer. While a condition "
"evaluates to `true`, the code runs; otherwise, it exits the loop."
msgstr ""
"Bu yapı, loop, if, else ve break kullanırsanız gerekli olacak birçok yuvayı "
"ortadan kaldırır ve daha nettir. Bir koşul true değerini değerlendirirken, "
"kod çalışır; aksi takdirde döngüden çıkar."

#: src/ch02-05-control-flow.md:309
msgid "{{#quiz ../quizzes/ch02-05-control-flow.toml}}"
msgstr "#quiz../quizzes/ch02-05-control-flow.toml"

#: src/ch02-05-control-flow.md:313
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data "
"types, functions, comments, `if` expressions and loops! To practice with the "
"concepts discussed in this chapter, try building programs to do the "
"following:"
msgstr ""
"Başardınız! Bu büyük bir bölümdü: değişkenler, veri türleri, fonksiyonlar, "
"yorumlar, if ifadeleri ve döngüleri hakkında bilgi edindiniz! Bu bölümde "
"tartışılan kavramlarla pratik yapmak için aşağıdakileri yapmak için "
"programlar oluşturmayı deneyin:"

#: src/ch02-05-control-flow.md:317
msgid "Generate the _n_\\-th Fibonacci number."
msgstr "_n_-th Fibonacci numarasını oluştur."

#: src/ch02-05-control-flow.md:318
msgid "Compute the factorial of a number _n_."
msgstr "Bir sayının faktöriyelini hesapla _n_."

#: src/ch02-05-control-flow.md:320
msgid ""
"Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr ""
"Şimdi, Kahire'deki ortak koleksiyon türlerini bir sonraki bölümde "
"inceleyeceğiz."

#: src/ch03-00-common-collections.md
msgid ""
"Cairo provides a set of common collection types that can be used to store "
"and manipulate data. These collections are designed to be efficient, "
"flexible, and easy to use. This section introduces the primary collection "
"types available in Cairo: Arrays and Dictionaries."
msgstr ""
"Kahire, verileri depolamak ve manipüle etmek için kullanılabilecek bir dizi "
"ortak toplama türü sunar. Bu koleksiyonlar verimli, esnek ve kullanımı kolay "
"olacak şekilde tasarlanmıştır. Bu bölüm, Kahire'de mevcut olan birincil "
"toplama türlerini tanıtır: Diziler ve Sözlükler."

#: src/ch03-01-arrays.md:3
msgid ""
"An array is a collection of elements of the same type. You can create and "
"use array methods by using the `ArrayTrait` trait from the core library."
msgstr ""
"Bir dizi, aynı türden öğelerin bir koleksiyonudur. Çekirdek kitaplığından "
"ArrayTrait özelliğini kullanarak dizi yöntemleri oluşturabilir ve "
"kullanabilirsiniz."

#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modification options. "
"Arrays are, in fact, queues whose values can't be modified. This has to do "
"with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of "
"an array and remove items from the front."
msgstr ""
"Dikkat edilmesi gereken önemli bir şey, dizilerin sınırlı değişiklik "
"seçeneklerine sahip olmasıdır. Diziler, aslında değerleri değiştirilemeyen "
"kuyruklardır. Bu, bir bellek yuvasına yazıldığında, üzerine yazılamaz, ancak "
"sadece ondan okunabilir. Sadece öğeleri bir dizinin sonuna ekleyebilir ve "
"öğeleri ön taraftan kaldırabilirsiniz."

#: src/ch03-01-arrays.md:8
msgid "Creating an Array"
msgstr "Bir Dizi Oluşturmak"

#: src/ch03-01-arrays.md:10
msgid ""
"Creating an array is done with the `ArrayTrait::new()` call. Here's an "
"example of creating an array and appending 3 elements to it::"
msgstr ""
"Bir dizi oluşturmak ArrayTrait::new() çağrısı ile yapılır. Burada bir dizi "
"oluşturmak ve buna 3 eleman eklemek için bir örnek::"

#: src/ch03-01-arrays.md:21
msgid ""
"When required, you can pass the expected type of items inside the array when "
"instantiating the array like this, or explicitly define the type of the "
"variable."
msgstr ""
"Gerektiğinde, diziyi bu şekilde hazırlarken dizi içinde beklenen öğe türünü "
"geçebilir veya değişkenin türünü açıkça tanımlayabilirsiniz."

#: src/ch03-01-arrays.md:31
msgid "Updating an Array"
msgstr "Bir Dizinin Güncellenmesi"

#: src/ch03-01-arrays.md:33
msgid "Adding Elements"
msgstr "Elementler Ekleme"

#: src/ch03-01-arrays.md:35
msgid ""
"To add an element to the end of an array, you can use the `append()` method:"
msgstr ""
"Bir dizinin sonuna bir eleman eklemek için append() yöntemini "
"kullanabilirsiniz:"

#: src/ch03-01-arrays.md:46
msgid "Removing Elements"
msgstr "Elementlerin Kaldırılması"

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the "
"`pop_front()` method. This method returns an `Option` that can be unwrapped, "
"containing the removed element, or `Option::None` if the array is empty."
msgstr ""
"pop_front() metodunu kullanarak yalnızca bir dizinin ön kısmından öğeleri "
"kaldırabilirsiniz. Bu yöntem, kaldırılan öğeyi içeren bir Option veya "
"Option::None dizinin boş olması durumunda bir Option döndürür."

#: src/ch03-01-arrays.md:59
msgid "\"The first value is {}\""
msgstr "\"İlk değer \""

#: src/ch03-01-arrays.md:63
msgid ""
"The above code will print `The first value is 10` as we remove the first "
"element that was added."
msgstr ""
"Yukarıdaki kod, eklenen ilk öğeyi kaldırdığımız için İlk değer 10 olarak "
"yazdıracaktır."

#: src/ch03-01-arrays.md:65
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify "
"the elements of an array once they've been added. You can only add elements "
"to the end of an array and remove elements from the front of an array. These "
"operations do not require memory mutation, as they involve updating pointers "
"rather than directly modifying the memory cells."
msgstr ""
"Kahire'de bellek değiştirilemez, bu da bir dizi elemanlarının eklendikten "
"sonra değiştirilmesinin mümkün olmadığı anlamına gelir. Sadece bir dizinin "
"sonuna elemanlar ekleyebilir ve elemanları bir dizinin önünden "
"kaldırabilirsiniz. Bu işlemler, bellek hücrelerini doğrudan değiştirmek "
"yerine işaretçileri güncellemeyi içerdiğinden, bellek mutasyonu gerektirmez."

#: src/ch03-01-arrays.md:67
msgid "Reading Elements from an Array"
msgstr "Bir Diziden Okuma Elementleri"

#: src/ch03-01-arrays.md:69
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that "
"return different types. Using `arr.at(index)` is equivalent to using the "
"subscripting operator `arr[index]`."
msgstr ""
"Dizi elemanlarına erişmek için, farklı türleri döndüren get() veya at() dizi "
"yöntemlerini kullanabilirsiniz. arr.at(index) kullanmak, arr[index] alt yazı "
"işlecini kullanmakla eşdeğerdir."

#: src/ch03-01-arrays.md:71
msgid "`get()` Method"
msgstr "get() Yöntem"

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an "
"option to a Box type (Cairo's smart-pointer type) containing a snapshot to "
"the element at the specified index if that element exists in the array. If "
"the element doesn't exist, `get` returns `None`. This method is useful when "
"you expect to access indices that may not be within the array's bounds and "
"want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [\"References and Snapshots\"](./ch04-02-"
"references-and-snapshots.md#snapshots) chapter."
msgstr ""
"get işlevi bir OptionBoxT> döndürür; bu, dizide bu eleman varsa, belirtilen "
"indeksteki elemana anlık görüntü içeren bir Kutu tipine (Cairo'nun akıllı "
"işaretçi tipi) bir seçenek döndürür. Eğer eleman yoksa, get#rep değerini "
"döndürür. Bu yöntem, dizinin sınırları içinde olmayan indekslere erişmeyi "
"beklediğinizde ve bu şekilde işlem yapmak istediğinizde kullanışlıdır."

#: src/ch03-01-arrays.md:75
msgid "Here is an example with the `get()` method:"
msgstr "İşte get() yöntemi ile bir örnek:"

#: src/ch03-01-arrays.md:82
msgid ""
"// Change this value to see different results, what would happen if the "
"index doesn't exist?\n"
msgstr ""
"// Farklı sonuçlar görmek için bu değeri değiştirin, indeks yoksa ne olur?\n"

#: src/ch03-01-arrays.md:86
msgid ""
"// Don't worry about * for now, if you are curious see Chapter 4.2 #desnap "
"operator\n"
"        // It basically means \"transform what get(idx) returned into a real "
"value\"\n"
msgstr ""
"// Şimdilik * için endişelenmeyin, eğer merak ediyorsanız Bölüm 4.2 #desnap "
"operatörü // Temel olarak \"ne al(idx) gerçek bir değere döndü\" anlamına "
"gelir.\n"

#: src/ch03-01-arrays.md:89
msgid "\"out of bounds\""
msgstr "\"Sınırların dışında\""

#: src/ch03-01-arrays.md:96
msgid "`at()` Method"
msgstr "at() Yöntem"

#: src/ch03-01-arrays.md:98
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the "
"element at the specified index using the `unbox()` operator to extract the "
"value stored in a box. If the index is out of bounds, a panic error occurs. "
"You should only use `at` when you want the program to panic if the provided "
"index is out of the array's bounds, which can prevent unexpected behavior."
msgstr ""
"Öte yandan at işlevi, bir kutuda depolanan değeri çıkarmak için unbox() "
"operatörünü kullanarak belirtilen indeksteki elemana doğrudan bir anlık "
"görüntü döndürür. Endeks sınırların dışındaysa, bir panik hatası oluşur. "
"Sağlanan dizin dizi sınırlarının dışındaysa, programın paniklemesini "
"istediğinizde yalnızca at kullanılmalıdır, bu da beklenmedik davranışları "
"önleyebilir."

#: src/ch03-01-arrays.md:100
msgid "Here is an example with the `at()` method:"
msgstr "İşte at() yöntemi ile bir örnek:"

#: src/ch03-01-arrays.md:113
msgid ""
"In this example, the variable named `first` will get the value `0` because "
"that is the value at index `0` in the array. The variable named `second` "
"will get the value `1` from index `1` in the array."
msgstr ""
"Bu örnekte, first adlı değişken 0 değerini alacaktır, çünkü bu dizideki 0 "
"dizinindeki değerdir. second adlı değişken dizideki 1 dizininden 1 değerini "
"alacaktır."

#: src/ch03-01-arrays.md:117
msgid ""
"If you want to use the subscripting operator `arr[index]`, you will need to "
"explicitly define the type of the elements of the array, otherwise it will "
"not compile. For example:"
msgstr ""
"Alt yazı operatörü arr[index] kullanmak istiyorsanız, dizinin elemanlarının "
"türünü açıkça tanımlamanız gerekir, aksi takdirde derlemez. Örneğin:"

#: src/ch03-01-arrays.md:130
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access "
"attempts, and use `get` when you prefer to handle such cases gracefully "
"without panicking."
msgstr ""
"Özetle, at'yi sınırların dışında erişim girişimlerinde panik yapmak "
"istediğinizde kullanın ve bu tür durumları paniklemeden zarif bir şekilde "
"ele almayı tercih ettiğinizde get'yi kullanın."

#: src/ch03-01-arrays.md:132
msgid "Size-related Methods"
msgstr "Boyutla ilgili yöntemler"

#: src/ch03-01-arrays.md:134
msgid ""
"To determine the number of elements in an array, use the `len()` method. The "
"return value is of type `usize`."
msgstr ""
"Bir dizideki eleman sayısını belirlemek için len() yöntemini kullanın. Dönüş "
"değeri usize tipidir."

#: src/ch03-01-arrays.md:136
msgid ""
"If you want to check if an array is empty or not, you can use the "
"`is_empty()` method, which returns `true` if the array is empty and `false` "
"otherwise."
msgstr ""
"Bir dizinin boş olup olmadığını kontrol etmek istiyorsanız, is_empty() "
"metodunu kullanabilirsiniz, bu yöntem true değerini gönderir, eğer dizi "
"boşsa ve false aksi takdirde."

#: src/ch03-01-arrays.md:138 src/ch11-05-macros.md:25
msgid "`array!` Macro"
msgstr "array! Makro"

#: src/ch03-01-arrays.md:140
msgid ""
"Sometimes, we need to create arrays with values that are already known at "
"compile time. The basic way of doing that is redundant. You would first "
"declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, "
"the compiler will expand the macro to generate the code that appends the "
"items sequentially."
msgstr ""
"Bazen, derleme zamanında zaten bilinen değerlere sahip diziler oluşturmamız "
"gerekir. Bunu yapmanın temel yolu gereksizdir. Önce diziyi ilan eder ve "
"ardından her bir değeri birer birer eklersiniz. array!, iki adımı "
"birleştirerek bu görevi yapmanın daha basit bir yoludur. Derleyici "
"zamanında, derleyici, öğeleri ardışık olarak ekleyen kodu oluşturmak için "
"makroyu genişletecektir."

#: src/ch03-01-arrays.md:143
msgid "Without `array!`:"
msgstr "array olmadan!:"

#: src/ch03-01-arrays.md:154
msgid "With `array!`:"
msgstr "array ile!:"

#: src/ch03-01-arrays.md:160
msgid "Storing Multiple Types with Enums"
msgstr "Enums ile birden fazla türün saklanması"

#: src/ch03-01-arrays.md:162
msgid ""
"If you want to store elements of different types in an array, you can use an "
"`Enum` to define a custom data type that can hold multiple types. Enums will "
"be explained in more detail in the [\"Enums and Pattern Matching\"](./"
"ch06-00-enums-and-pattern-matching.md) chapter."
msgstr ""
"Bir dizide farklı türde öğeleri saklamak istiyorsanız, birden fazla türü "
"tutabilen özel bir veri türünü tanımlamak için bir Enum kullanabilirsiniz. "
"Enumlar [\"Enums and Pattern Matching\"] (./ch06-00-enums-and-pattern-md) "
"bölümünde daha ayrıntılı olarak açıklanacaktır."

#: src/ch03-01-arrays.md:182
msgid "Span"
msgstr "Span"

#: src/ch03-01-arrays.md:184
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed "
"to provide safe and controlled access to the elements of an array without "
"modifying the original array. Span is particularly useful for ensuring data "
"integrity and avoiding borrowing issues when passing arrays between "
"functions or when performing read-only operations, as introduced in "
"[\"References and Snapshots\"](./ch04-02-references-and-snapshots.md)."
msgstr ""
"Span, bir Array'nin anlık görüntüsünü temsil eden bir yapıdır. Orijinal "
"diziyi değiştirmeden bir dizinin elemanlarına güvenli ve kontrollü erişim "
"sağlamak için tasarlanmıştır. Span, işlevler arasında diziler geçerken veya "
"[\"References and Snapshots\"] bölümünde tanıtıldığı gibi yalnızca okunur "
"işlemler gerçekleştirirken veri bütünlüğünü sağlamak ve ödünç alma "
"sorunlarından kaçınmak için özellikle yararlıdır."

#: src/ch03-01-arrays.md:186
msgid ""
"All methods provided by `Array` can also be used with `Span`, except for the "
"`append()` method."
msgstr ""
"Array tarafından sağlanan tüm yöntemler, append() yöntemi dışında Span ile "
"de kullanılabilir."

#: src/ch03-01-arrays.md:190
msgid "Turning an Array into Span"
msgstr "Bir Diziyi Span'a Çevirmek"

#: src/ch03-01-arrays.md:192
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr "Array'nin bir Span'sini oluşturmak için span() metodunu arayın:"

#: src/ch03-01-arrays.md:201
msgid "{{#quiz ../quizzes/ch03-01-arrays.toml}}"
msgstr "#quiz../quizzes/ch03-01-arrays.toml"

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The "
"`Felt252Dict<T>` data type represents a collection of key-value pairs where "
"each key is unique and associated with a corresponding value. This type of "
"data structure is known differently across different programming languages "
"such as maps, hash tables, associative arrays and many others."
msgstr ""
"Kahire, çekirdek kütüphanesinde sözlük benzeri bir tür sağlar. Felt252DictT> "
"veri türü, her anahtarın benzersiz olduğu ve karşılık gelen bir değerle "
"ilişkili olduğu bir anahtar-değer çifti koleksiyonunu temsil eder. Bu tür "
"veri yapısı, haritalar, özet tabloları, ilişkilendirme dizileri ve diğerleri "
"gibi farklı programlama dilleri arasında farklı olarak bilinir."

#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a "
"certain way for which using an `Array<T>` and indexing doesn't suffice. "
"Cairo dictionaries also allow the programmer to easily simulate the "
"existence of mutable memory when there is none."
msgstr ""
"Felt252DictT> türü, verilerinizi bir ArrayT> kullanarak ve indekslemenin "
"yeterli olmadığı belirli bir şekilde düzenlemek istediğinizde kullanışlıdır. "
"Kahire sözlükleri, programcının hiçbir şey olmadığında değişken belleğin "
"varlığını kolayca simüle etmesine de izin verir."

#: src/ch03-02-dictionaries.md:7
msgid "Basic Use of Dictionaries"
msgstr "Sözlüklerin Temel Kullanımı"

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the "
"data types of both key and value. In Cairo, the key type is restricted to "
"`felt252`, leaving only the possibility to specify the value data type, "
"represented by `T` in `Felt252Dict<T>`."
msgstr ""
"Diğer dillerde hem anahtar hem de değerin veri türlerini tanımlamak için "
"yeni bir sözlük oluştururken normaldir. Kahire'de, anahtar türü felt252 ile "
"sınırlıdır, bu da T ile temsil edilen değer veri türünü Felt252DictT> olarak "
"belirtme olanağını bırakır."

#: src/ch03-02-dictionaries.md:11
msgid ""
"The core functionality of a `Felt252Dict<T>` is implemented in the trait "
"`Felt252DictTrait` which includes all basic operations. Among them we can "
"find:"
msgstr ""
"Bir Felt252DictT>'nin temel işlevselliği, tüm temel işlemleri içeren "
"Felt252DictTrait özelliğinde uygulanır. Bunlar arasında şunları bulabiliriz:"

#: src/ch03-02-dictionaries.md:13
msgid "`insert(felt252, T) -> ()` to write values to a dictionary instance and"
msgstr "insert(felt252, T) -> () bir sözlük örneğine değerler yazmak ve"

#: src/ch03-02-dictionaries.md:14
msgid "`get(felt252) -> T` to read values from it."
msgstr "get(felt252)> Ondan değerleri okumak için T."

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other "
"language. In the following example, we create a dictionary to represent a "
"mapping between individuals and their balance:"
msgstr ""
"Bu işlevler, sözlükleri başka bir dilde olduğu gibi manipüle etmemizi "
"sağlar. Aşağıdaki örnekte, bireyler ve dengeleri arasında bir haritalamayı "
"temsil edecek bir sözlük oluşturuyoruz:"

#: src/ch03-02-dictionaries.md:26
msgid "\"Balance is not 100\""
msgstr "\"Balans 100 değil\""

#: src/ch03-02-dictionaries.md:29
msgid "\"Balance is not 200\""
msgstr "\"Balans 200 değil\""

#: src/ch03-02-dictionaries.md:33
msgid ""
"We can create a new instance of `Felt252Dict<u64>` by using the `default` "
"method of the `Default` trait and add two individuals, each one with their "
"own balance, using the `insert` method. Finally, we check the balance of our "
"users with the `get` method. These methods are defined in the "
"`Felt252DictTrait` trait in the core library."
msgstr ""
"Default özelliğinin default yöntemini kullanarak yeni bir Felt252Dictu64> "
"örneği oluşturabilir ve insert yöntemini kullanarak her biri kendi dengesine "
"sahip iki birey ekleyebiliriz. Son olarak, kullanıcılarımızın dengesini get "
"yöntemiyle kontrol ederiz. Bu yöntemler Felt252DictTrait çekirdeğinde "
"tanımlanmıştır."

#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, "
"meaning you can only write to a memory cell once but the `Felt252Dict<T>` "
"type represents a way to overcome this obstacle. We will explain how this is "
"implemented later on in [\"Dictionaries Underneath\"](./ch03-02-dictionaries."
"md#dictionaries-underneath)."
msgstr ""
"Kitap boyunca Kahire'nin hafızasının nasıl değişmez olduğunu konuştuk, yani "
"bir hafıza hücresine sadece bir kez yazabilirsiniz, ancak Felt252DictT> tipi "
"bu engelin üstesinden gelmenin bir yolunu temsil ediyor. Bunun daha sonra "
"[\"Dictionaries Underneath\"] (./ch03-02-02-dictionaries.md#dictionaries-"
"underneath) 'de nasıl uygulandığını açıklayacağız."

#: src/ch03-02-dictionaries.md:37
msgid ""
"Building upon our previous example, let us show a code example where the "
"balance of the same user changes:"
msgstr ""
"Önceki örneğimize dayanarak, aynı kullanıcının dengesinin değiştiği bir kod "
"örneği gösterelim:"

#: src/ch03-02-dictionaries.md:43
msgid "// Insert Alex with 100 balance\n"
msgstr "// Alex'i 100 denge ile ekle\n"

#: src/ch03-02-dictionaries.md:45
msgid "// Check that Alex has indeed 100 associated with him\n"
msgstr "// Alex'in gerçekten onunla ilişkili 100 olduğunu kontrol edin\n"

#: src/ch03-02-dictionaries.md:47
msgid "\"Alex balance is not 100\""
msgstr "\"Alex balance 100 değil\""

#: src/ch03-02-dictionaries.md:49
msgid "// Insert Alex again, this time with 200 balance\n"
msgstr "// Alex'i tekrar ekle, bu sefer 200 bakiyeyle\n"

#: src/ch03-02-dictionaries.md:51
msgid "// Check the new balance is correct\n"
msgstr "// Yeni bakiyenin doğru olduğunu kontrol edin\n"

#: src/ch03-02-dictionaries.md:53
msgid "\"Alex balance is not 200\""
msgstr "\"Alex balance 200 değil\""

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the 'Alex' individual twice, each time "
"using a different balance and each time that we checked for its balance it "
"had the last value inserted! `Felt252Dict<T>` effectively allows us to "
"\"rewrite\" the stored value for any given key."
msgstr ""
"Bu örnekte, 'Alex' bireyini her seferinde farklı bir denge kullanarak iki "
"kez eklediğimize ve dengesini kontrol ettiğimiz her seferinde son değeri "
"eklediğine dikkat edin! Felt252DictT> herhangi bir anahtar için depolanan "
"değeri \"yeniden yazmamızı\" etkili bir şekilde sağlar."

#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is "
"worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the "
"scenes all keys have their associated values initialized as zero. This means "
"that if for example, you tried to get the balance of an inexistent user you "
"will get 0 instead of an error or an undefined value. This also means there "
"is no way to delete data from a dictionary. Something to take into account "
"when incorporating this structure into your code."
msgstr ""
"Sözlüklerin nasıl uygulandığını açmadan ve açıklamadan önce, bir "
"Felt252DictT>'yi anlıklaştırdıktan sonra, sahnelerin arkasında tüm tuşların "
"ilişkili değerlerinin sıfır olarak başlatıldığı anlamına gelir. Bu, örneğin, "
"mevcut olmayan bir kullanıcının dengesini almaya çalışırsanız, bir hata veya "
"tanımlanmamış bir değer yerine 0 elde edeceğiniz anlamına gelir. Bu aynı "
"zamanda bir sözlükten veri silmenin bir yolu olmadığı anlamına gelir. Bu, "
"bir sözlükten veriyi silmenin bir yolu olmadığı anlamına gelir."

#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` "
"and how it mimics the same behavior as the corresponding data structures in "
"any other language, that is, externally of course. Cairo is at its core a "
"non-deterministic Turing-complete programming language, very different from "
"any other popular language in existence, which as a consequence means that "
"dictionaries are implemented very differently as well!"
msgstr ""
"Bu noktaya kadar, Felt252DictT>'nin tüm temel özelliklerini ve bunun başka "
"bir dilde, yani dışsal olarak karşılık gelen veri yapılarıyla aynı davranışı "
"nasıl taklit ettiğini gördük. Kahire özünde, var olan diğer popüler "
"dillerden çok farklı, belirleyici olmayan bir Turing-tam programlama "
"dilidir, bunun sonucu olarak sözlüklerin de çok farklı bir şekilde "
"uygulandığı anlamına gelir!"

#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about "
"`Felt252Dict<T>` inner mechanisms and the compromises that were taken to "
"make them work. After that, we are going to take a look at how to use "
"dictionaries with other data structures as well as use the `entry` method as "
"another way to interact with them."
msgstr ""
"Aşağıdaki bölümlerde, Felt252DictT> iç mekanizmaları ve onları çalıştırmak "
"için alınan ödünler hakkında bazı bilgiler vereceğiz. Bundan sonra, "
"sözlüklerin diğer veri yapılarıyla nasıl kullanılacağına ve entry yöntemini "
"onlarla etkileşime girmenin başka bir yolu olarak nasıl kullanacağımıza "
"bakacağız."

#: src/ch03-02-dictionaries.md:67
msgid "Dictionaries Underneath"
msgstr "Dictionaries Underneath Altyazıları"

#: src/ch03-02-dictionaries.md:69
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its "
"memory system is immutable, so in order to simulate mutability, the language "
"implements `Felt252Dict<T>` as a list of entries. Each of the entries "
"represents a time when a dictionary was accessed for reading/updating/"
"writing purposes. An entry has three fields:"
msgstr ""
"Kahire'nin deterministik olmayan tasarımının kısıtlamalarından biri, hafıza "
"sisteminin değiştirilemez olmasıdır, bu nedenle Felt252DictT> dilini "
"değiştirilebilirliği simüle etmek için bir giriş listesi olarak uygular. "
"Girişlerin her biri, bir sözlüğe okuma / güncelleme / yazma amacıyla "
"erişildiği bir zamanı temsil eder. Bir girişin üç alanı vardır:"

#: src/ch03-02-dictionaries.md:71
msgid ""
"A `key` field that identifies the key for this key-value pair of the "
"dictionary."
msgstr ""
"Sözlüğün bu anahtar değeri çiftinin anahtarını tanımlayan bir key alanı."

#: src/ch03-02-dictionaries.md:72
msgid ""
"A `previous_value` field that indicates which previous value was held at "
"`key`."
msgstr "Önceki değerin key'de tutulduğunu gösteren bir previous_value alanı."

#: src/ch03-02-dictionaries.md:73
msgid "A `new_value` field that indicates the new value that is held at `key`."
msgstr "key'de tutulan yeni değeri gösteren bir new_value alanı."

#: src/ch03-02-dictionaries.md:75
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would "
"internally define it as `Array<Entry<T>>` where each `Entry<T>` has "
"information about what key-value pair it represents and the previous and new "
"values it holds. The definition of `Entry<T>` would be:"
msgstr ""
"Felt252DictT> üst düzey yapıları kullanarak uygulamayı denersek, dahili "
"olarak ArrayEntryT> olarak tanımlarız; burada her EntryT> hangi anahtar "
"değeri çiftini temsil ettiği ve önceki ve yeni değerleri tuttuğu hakkında "
"bilgi sahibi olur. EntryT> tanımı:"

#: src/ch03-02-dictionaries.md:85
msgid ""
"For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be "
"registered:"
msgstr ""
"Felt252DictT> ile her etkileşimde bulunduğumuzda, yeni bir EntryT> "
"kaydedilecektir:"

#: src/ch03-02-dictionaries.md:87
msgid ""
"A `get` would register an entry where there is no change in state, and "
"previous and new values are stored with the same value."
msgstr ""
"Bir get, durum değişikliği olmayan bir girişi kaydeder ve önceki ve yeni "
"değerler aynı değerde saklanır."

#: src/ch03-02-dictionaries.md:88
msgid ""
"An `insert` would register a new `Entry<T>` where the `new_value` would be "
"the element being inserted, and the `previous_value` the last element "
"inserted before this. In case it is the first entry for a certain key, then "
"the previous value will be zero."
msgstr ""
"Bir insert yeni bir EntryT> new_value eklenecek eleman ve previous_value "
"bundan önce eklenen son eleman olacak şekilde kaydedilir. Belirli bir "
"anahtar için ilk giriş olması durumunda, önceki değer sıfır olacaktır."

#: src/ch03-02-dictionaries.md:90
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the "
"creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an "
"example of this using the `balances` dictionary from the previous section "
"and inserting the users 'Alex' and 'Maria':"
msgstr ""
"Bu giriş listesinin kullanımı, herhangi bir yeniden yazmanın olmadığını, "
"sadece Felt252DictT> etkileşimi başına yeni bellek hücrelerinin "
"oluşturulmasını gösterir. Bunun bir örneğini bir önceki bölümden balances "
"sözlüğünü kullanarak ve kullanıcıları 'Alex' ve 'Maria' ekleyerek gösterelim:"

#: src/ch03-02-dictionaries.md:108
msgid "These instructions would then produce the following list of entries:"
msgstr "Bu talimatlar daha sonra aşağıdaki giriş listesini oluşturacaktır:"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "key"
msgstr "anahtar"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "previous"
msgstr "önceki"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:145
msgid "new"
msgstr "yeni"

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:114
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:138
#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:141
#: src/ch03-02-dictionaries.md:147
msgid "Alex"
msgstr "Alex"

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:135
#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:147
#: src/ch03-02-dictionaries.md:148 src/ch03-02-dictionaries.md:149
msgid "0"
msgstr "0"

#: src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:114
#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:137
msgid "100"
msgstr "100"

#: src/ch03-02-dictionaries.md:113 src/ch03-02-dictionaries.md:115
#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:137
#: src/ch03-02-dictionaries.md:140 src/ch03-02-dictionaries.md:148
msgid "Maria"
msgstr "Maria"

#: src/ch03-02-dictionaries.md:113 src/ch03-02-dictionaries.md:115
msgid "50"
msgstr "50"

#: src/ch03-02-dictionaries.md:114
msgid "200"
msgstr "200"

#: src/ch03-02-dictionaries.md:117
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the "
"`previous` and `current` values are set properly. Also reading from 'Maria' "
"registered an entry with no change from previous to current values."
msgstr ""
"'Alex' iki kez eklendiğinden, iki kez göründüğüne ve previous ve current "
"değerlerinin düzgün bir şekilde ayarlandığına dikkat edin. Ayrıca 'Maria'dan "
"okumak, önceki değerlerden geçerli değerlere hiçbir değişiklik yapmadan bir "
"giriş kaydetti."

#: src/ch03-02-dictionaries.md:119
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each read/"
"write operation, there is a scan for the whole entry list in search of the "
"last entry with the same `key`. Once the entry has been found, its "
"`new_value` is extracted and used on the new entry to be added as the "
"`previous_value`. This means that interacting with `Felt252Dict<T>` has a "
"worst-case time complexity of `O(n)` where `n` is the number of entries in "
"the list."
msgstr ""
"Felt252DictT> uygulamasının bu yaklaşımı, her okuma/yazma işlemi için, aynı "
"key ile son girdiyi aramak için tüm giriş listesi için bir tarama olduğu "
"anlamına gelir. Giriş bulunduktan sonra, new_value, previous_value olarak "
"eklenecek yeni girdide çıkarılır ve kullanılır. Bu, Felt252Dic ile "
"etkileşimde bulunulduğu anlamına gelir."

#: src/ch03-02-dictionaries.md:121
msgid ""
"If you pour some thought into alternate ways of implementing "
"`Felt252Dict<T>` you'd surely find them, probably even ditching completely "
"the need for a `previous_value` field, nonetheless, since Cairo is not your "
"normal language this won't work. One of the purposes of Cairo is, with the "
"STARK proof system, to generate proofs of computational integrity. This "
"means that you need to verify that program execution is correct and inside "
"the boundaries of Cairo restrictions. One of those boundary checks consists "
"of \"dictionary squashing\" and that requires information on both previous "
"and new values for every entry."
msgstr ""
"Felt252DictT> uygulamasının alternatif yollarına biraz düşünce dökerseniz, "
"onları mutlaka bulursunuz, hatta Kahire normal diliniz olmadığı için "
"previous_value alanına olan ihtiyacı tamamen ortadan kaldırırsınız. "
"Kahire'nin amaçlarından biri, STARK ispat sistemi ile, hesaplama "
"bütünlüğünün kanıtlarını oluşturmaktır. Bu, uygulamadaki yeni kısıtlamaların "
"doğru ve doğru olduğunu doğrulamanız gerektiği anlamına gelir."

#: src/ch03-02-dictionaries.md:124
msgid "Squashing Dictionaries"
msgstr "Squashing Sözlükleri"

#: src/ch03-02-dictionaries.md:126
msgid ""
"To verify that the proof generated by a Cairo program execution that used a "
"`Felt252Dict<T>` is correct, we need to check that there wasn't any illegal "
"tampering with the dictionary. This is done through a method called "
"`squash_dict` that reviews each entry of the entry list and checks that "
"access to the dictionary remains coherent throughout the execution."
msgstr ""
"Felt252DictT> kullanan bir Kahire program yürütmesi tarafından oluşturulan "
"kanıtın doğru olduğunu doğrulamak için, sözlükle herhangi bir yasadışı "
"kurcalama olmadığını kontrol etmemiz gerekir. Bu, giriş listesinin her bir "
"girdisini gözden geçiren ve sözlüğe erişimin yürütme boyunca tutarlılığını "
"koruduğunu kontrol eden squash_dict adlı bir yöntem aracılığıyla yapılır."

#: src/ch03-02-dictionaries.md:128
msgid ""
"The process of squashing is as follows: given all entries with certain key "
"`k`, taken in the same order as they were inserted, verify that the ith "
"entry `new_value` is equal to the ith + 1 entry `previous_value`."
msgstr ""
"Squashing işlemi aşağıdaki gibidir: Belirli anahtar k ile tüm girdiler "
"verildiğinde, yerleştirildikleri sırada aynı sırayla alındığında, new_value "
"ith girişinin previous_value ith + 1 girişine eşit olduğunu doğrulayın."

#: src/ch03-02-dictionaries.md:130
msgid "For example, given the following entry list:"
msgstr "Örneğin, aşağıdaki giriş listesi göz önüne alındığında:"

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:138
msgid "150"
msgstr "150"

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:149
msgid "Charles"
msgstr "Charles"

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:149
msgid "70"
msgstr "70"

#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:140
msgid "250"
msgstr "250"

#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:139
msgid "40"
msgstr "40"

#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:141
msgid "300"
msgstr "300"

#: src/ch03-02-dictionaries.md:140 src/ch03-02-dictionaries.md:148
msgid "190"
msgstr "190"

#: src/ch03-02-dictionaries.md:141 src/ch03-02-dictionaries.md:147
msgid "90"
msgstr "90"

#: src/ch03-02-dictionaries.md:143
msgid "After squashing, the entry list would be reduced to:"
msgstr "Squashing'den sonra, giriş listesi aşağıdakilere indirgenir:"

#: src/ch03-02-dictionaries.md:151
msgid ""
"In case of a change on any of the values of the first table, squashing would "
"have failed during runtime."
msgstr ""
"İlk tablonun değerlerinden herhangi birinde bir değişiklik olması durumunda, "
"squashing çalışma süresi boyunca başarısız olurdu."

#: src/ch03-02-dictionaries.md:153
msgid "Dictionary Destruction"
msgstr "Sözlük Yıkımı"

#: src/ch03-02-dictionaries.md:155
msgid ""
"If you run the examples from [\"Basic Use of Dictionaries\"](./ch03-02-"
"dictionaries.md#basic-use-of-dictionaries) section, you'd notice that there "
"was never a call to squash dictionary, but the program compiled successfully "
"nonetheless. What happened behind the scene was that squash was called "
"automatically via the `Felt252Dict<T>` implementation of the `Destruct<T>` "
"trait. This call occurred just before the `balance` dictionary went out of "
"scope."
msgstr ""
"[\"Dictionaries Temel Kullanımı\"](./ch03-02-02dictionaries.md#basic-use-of-"
"dictionaries] bölümünden örnekleri çalıştırırsanız, squash sözlüğüne hiçbir "
"zaman çağrı yapılmadığını, ancak programın başarılı bir şekilde derlendiğini "
"fark edersiniz. Sahnenin arkasında olan şey, squash'ın Felt252DictT> "
"uygulaması aracılığıyla otomatik olarak çağrıldığıydı."

#: src/ch03-02-dictionaries.md:157
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of "
"scope apart from `Drop<T>`. The main difference between these two is that "
"`Drop<T>` is treated as a no-op operation, meaning it does not generate new "
"CASM while `Destruct<T>` does not have this restriction. The only type which "
"actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other "
"type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these "
"traits in [Drop and Destruct](./appendix-03-derivable-traits.md#drop-and-"
"destruct) section of Appendix C."
msgstr ""
"DestructT> özelliği, DropT> dışındaki örnekleri kapsam dışı bırakmanın başka "
"bir yolunu temsil eder. Bu ikisi arasındaki temel fark, DropT>'nin "
"DestructT> ile ilgili olarak yeni CASM oluşturmadığı anlamına gelir. "
"DestructT>'yi aktif olarak kullanan tek tür"

#: src/ch03-02-dictionaries.md:159
msgid ""
"Later in [\"Dictionaries as Struct Members\"](./ch11-01-custom-data-"
"structures.html#dictionaries-as-struct-members) section, we will have a "
"hands-on example where we implement the `Destruct<T>` trait for a custom "
"type."
msgstr ""
"Daha sonra [\"Dictionaries as Struct Members\"](./ch11-01-custom-data-"
"structures.html#dictionaries-as-struct-members] bölümünde, özel bir tip için "
"DestructT> özelliğini uyguladığımız uygulamalı bir örneğe sahip olacağız."

#: src/ch03-02-dictionaries.md:165
msgid "More Dictionaries"
msgstr "Daha fazla Sözlük"

#: src/ch03-02-dictionaries.md:167
msgid ""
"Up to this point, we have given a comprehensive overview of the "
"functionality of `Felt252Dict<T>` as well as how and why it is implemented "
"in a certain way. If you haven't understood all of it, don't worry because "
"in this section we will have some more examples using dictionaries."
msgstr ""
"Bu noktaya kadar, Felt252DictT>'nin işlevselliğinin yanı sıra belirli bir "
"şekilde nasıl ve neden uygulandığına dair kapsamlı bir genel bakış verdik. "
"Tüm bunları anlamadıysanız, endişelenmeyin, çünkü bu bölümde sözlükleri "
"kullanarak daha fazla örnek vereceğiz."

#: src/ch03-02-dictionaries.md:169
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary "
"basic functionality included in `Felt252DictTrait<T>` which we didn't "
"mention at the beginning. Soon after, we will see examples of how to use "
"`Felt252Dict<T>` with other [complex types](./ch03-02-dictionaries."
"md#dictionaries-of-types-not-supported-natively) such as `Array<T>`."
msgstr ""
"Başlangıçta bahsetmediğimiz Felt252DictTraitT> içinde yer alan bir sözlük "
"temel işlevselliğinin parçası olan entry yöntemini açıklayarak başlayacağız. "
"Kısa bir süre sonra, Felt252DictT> diğer [karmaşık tiplerle] (./ch03-02-"
"dictionaries.mddiction-of-ray-types) nasıl kullanılacağına dair örnekler "
"göreceğiz."

#: src/ch03-02-dictionaries.md:173
msgid "Entry and Finalize"
msgstr "Giriş ve Sona Erdirme"

#: src/ch03-02-dictionaries.md:175
msgid ""
"In the [\"Dictionaries Underneath\"](./ch03-02-dictionaries.md#dictionaries-"
"underneath) section, we explained how `Felt252Dict<T>` internally worked. It "
"was a list of entries for each time the dictionary was accessed in any "
"manner. It would first find the last entry given a certain `key` and then "
"update it accordingly to whatever operation it was executing. The Cairo "
"language gives us the tools to replicate this ourselves through the `entry` "
"and `finalize` methods."
msgstr ""
"[\"Dictionaries Underneath\"](./ch03-02-dictionaries.md#dictionaries-"
"underneath] bölümünde, Felt252DictT>'nin dahili olarak nasıl çalıştığını "
"açıkladık. Sözlük herhangi bir şekilde erişildiğinde her girişin bir "
"listesiydi. Önce belirli bir key verilen son girişi bulur ve daha sonra bu "
"işlemi yapmak için bize göre günceller."

#: src/ch03-02-dictionaries.md:177
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose "
"of creating a new entry given a certain key. Once called, this method takes "
"ownership of the dictionary and returns the entry to update. The method "
"signature is as follows:"
msgstr ""
"entry yöntemi, belirli bir anahtar verilen yeni bir girdi oluşturmak "
"amacıyla Felt252DictTraitT> 'nin bir parçası olarak gelir. Bir kez "
"çağrıldığında, bu yöntem sözlüğün mülkiyetini alır ve güncellemek için "
"girdiyi döndürür. Yöntem imzası aşağıdaki gibidir:"

#: src/ch03-02-dictionaries.md:183
msgid ""
"The first input parameter takes ownership of the dictionary while the second "
"one is used to create the appropriate entry. It returns a tuple containing a "
"`Felt252DictEntry<T>`, which is the type used by Cairo to represent "
"dictionary entries, and a `T` representing the value held previously. The "
"`nopanic` notation simply indicates that the function is guaranteed to never "
"panic."
msgstr ""
"İlk girdi parametresi, uygun girdiyi oluşturmak için kullanılırken sözlüğün "
"mülkiyetini alır. Kahire tarafından sözlük girdilerini temsil etmek için "
"kullanılan tür olan Felt252DictEntryT> içeren bir tuple döndürür ve daha "
"önce tutulan değeri temsil eden bir T notasyonudur. nopanic notasyonu, "
"işlevin asla paniklememesinin garanti edildiğini gösterir."

#: src/ch03-02-dictionaries.md:186
msgid ""
"The next thing to do is to update the entry with the new value. For this, we "
"use the `finalize` method which inserts the entry and returns ownership of "
"the dictionary:"
msgstr ""
"Bir sonraki yapılacak şey, girdiyi yeni değerle güncellemektir. Bunun için, "
"girdiyi ekleyen ve sözlüğün mülkiyetini iade eden finalize yöntemini "
"kullanıyoruz:"

#: src/ch03-02-dictionaries.md:192
msgid ""
"This method receives the entry and the new value as parameters, and returns "
"the updated dictionary."
msgstr ""
"Bu yöntem girdiyi ve yeni değeri parametre olarak alır ve güncellenmiş "
"sözlüğü döndürür."

#: src/ch03-02-dictionaries.md:194
msgid ""
"Let us see an example using `entry` and `finalize`. Imagine we would like to "
"implement our own version of the `get` method from a dictionary. We should "
"then do the following:"
msgstr ""
"entry ve finalize kullanarak bir örnek görelim. Bir sözlükten get yönteminin "
"kendi sürümünü uygulamak istediğimizi düşünün. O zaman şunları yapmalıyız:"

#: src/ch03-02-dictionaries.md:196
msgid "Create the new entry to add using the `entry` method."
msgstr "entry yöntemini kullanarak eklemek için yeni girişi oluşturun."

#: src/ch03-02-dictionaries.md:197
msgid ""
"Insert back the entry where the `new_value` equals the `previous_value`."
msgstr "new_value'nin previous_value'ye eşit olduğu girdiyi geri ekleyin."

#: src/ch03-02-dictionaries.md:198
msgid "Return the value."
msgstr "Değeri iade et."

#: src/ch03-02-dictionaries.md:200
msgid "Implementing our custom get would look like this:"
msgstr "Bizim özel almak uygulamak şu şekilde görünecektir:"

#: src/ch03-02-dictionaries.md:208 src/ch03-02-dictionaries.md:252
msgid "// Get the new entry and the previous value held at `key`\n"
msgstr "// Yeni girişi ve key'de tutulan önceki değeri alın\n"

#: src/ch03-02-dictionaries.md:211 src/ch03-02-dictionaries.md:255
msgid "// Store the value to return\n"
msgstr "// Geri dönmek için değeri depola\n"

#: src/ch03-02-dictionaries.md:214 src/ch03-02-dictionaries.md:258
msgid ""
"// Update the entry with `prev_value` and get back ownership of the "
"dictionary\n"
msgstr ""
"// prev_value ile girişi güncelleyin ve sözlüğün mülkiyetini geri alın\n"

#: src/ch03-02-dictionaries.md:217 src/ch03-02-dictionaries.md:261
msgid "// Return the read value\n"
msgstr "// Okuma değerini döndür\n"

#: src/ch03-02-dictionaries.md:222
msgid ""
"The `ref` keyword means that the ownership of the variable will be given "
"back at the end of the function. This concept will be explained in more "
"detail in the [\"References and Snapshots\"](./ch04-02-references-and-"
"snapshots.md) section."
msgstr ""
"ref anahtar kelimesi, değişkenin mülkiyetinin fonksiyonun sonunda geri "
"verileceği anlamına gelir. Bu kavram [\"References and Snapshots\"] (./"
"ch04-02-references-and-snapshots.md) bölümünde daha ayrıntılı olarak "
"açıklanacaktır."

#: src/ch03-02-dictionaries.md:225
msgid ""
"Implementing the `insert` method would follow a similar workflow, except for "
"inserting a new value when finalizing. If we were to implement it, it would "
"look like the following:"
msgstr ""
"insert yöntemini uygulamak, sonuçlandırırken yeni bir değer eklemek dışında, "
"benzer bir iş akışını izleyecektir. Eğer uygulayacak olsaydık, aşağıdaki "
"gibi görünürdü:"

#: src/ch03-02-dictionaries.md:233
msgid ""
"// Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exist, `_prev_value` will\n"
"    // be the default value of T.\n"
msgstr ""
"// key ile ilişkili son girdiyi alın // key yoksa, _prev_value // T'nin "
"varsayılan değeri olacağına dikkat edin.\n"

#: src/ch03-02-dictionaries.md:238
msgid ""
"// Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
msgstr ""
"// entry'yi güncellenmiş değerle sözlüğe geri ekleyin, // ve sözlüğün "
"mülkiyetini alın\n"

#: src/ch03-02-dictionaries.md:244
msgid ""
"As a finalizing note, these two methods are implemented in a similar way to "
"how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows "
"some example usage:"
msgstr ""
"Nihai bir not olarak, bu iki yöntem Felt252DictT> için insert ve get'nin "
"nasıl uygulandığına benzer şekilde uygulanır. Bu kod bazı örnek kullanımları "
"gösterir:"

#: src/ch03-02-dictionaries.md:268
msgid "// Get the last entry associated with `key`\n"
msgstr "// key ile ilişkili son girdiyi alın\n"

#: src/ch03-02-dictionaries.md:269
msgid "// Notice that if `key` does not exist, `_prev_value` will\n"
msgstr "// key yoksa, _prev_value'nin var olacağını unutmayın.\n"

#: src/ch03-02-dictionaries.md:270
msgid "// be the default value of T.\n"
msgstr "// T'nin varsayılan değeri ol.\n"

#: src/ch03-02-dictionaries.md:273
msgid "// Insert `entry` back in the dictionary with the updated value,\n"
msgstr "// Güncellenmiş değerle entry'yi sözlüğe geri ekleyin,\n"

#: src/ch03-02-dictionaries.md:274
msgid "// and receive ownership of the dictionary\n"
msgstr "// ve sözlüğün mülkiyetini almak\n"

#: src/ch03-02-dictionaries.md:281 src/ch03-02-dictionaries.md:283
msgid "'0'"
msgstr "'0'"

#: src/ch03-02-dictionaries.md:285
msgid "\"Expecting 100\""
msgstr "\"Fazla 100\""

#: src/ch03-02-dictionaries.md:294
msgid "Dictionaries of Types not Supported Natively"
msgstr "Yerli Olarak Desteklenmeyen Türlerin Sözlükleri"

#: src/ch03-02-dictionaries.md:296
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the "
"trait `Felt252DictValue<T>`. This trait defines the `zero_default` method "
"which is the one that gets called when a value does not exist in the "
"dictionary. This is implemented by some common data types, such as most "
"unsigned integers, `bool` and `felt252` - but it is not implemented for more "
"complex types such as arrays, structs (including `u256`), and other types "
"from the core library. This means that making a dictionary of types not "
"natively supported is not a straightforward task, because you would need to "
"write a couple of trait implementations in order to make the data type a "
"valid dictionary value type. To compensate this, you can wrap your type "
"inside a `Nullable<T>`."
msgstr ""
"Felt252DictT> hakkında konuşmadığımız bir kısıtlama Felt252DictValueT> "
"özelliğidir. Bu özellik, sözlükte bir değer bulunmadığında çağrılan "
"zero_default yöntemini tanımlar. Bu, imzasız tamsayılar, bool ve felt25 gibi "
"bazı yaygın veri türleri tarafından uygulanır."

#: src/ch03-02-dictionaries.md:302
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be "
"`null` in the absence of value. It is usually used in Object Oriented "
"Programming Languages when a reference doesn't point anywhere. The "
"difference with `Option` is that the wrapped value is stored inside a "
"`Box<T>` data type. The `Box<T>` type is a smart pointer that allows us to "
"use a dedicated `boxed_segment` memory segment for our data, and access this "
"segment using a pointer that can only be manipulated in one place at a time. "
"See [Smart Pointers Chapter](./ch11-02-smart-pointers.md) for more "
"information."
msgstr ""
"NullableT>, değer yokluğunda bir değere işaret edebilen veya null olabilen "
"akıllı bir işaretçi türüdür. Bir referans herhangi bir yere işaret "
"etmediğinde genellikle Nesne Yönlü Programlama Dillerinde kullanılır. Option "
"ile fark, sarılmış değerin bir BoxT> veri türünde depolanabilmesidir. BoxT> "
"tipi, bu kullanım için akıllı bir işaretçidir."

#: src/ch03-02-dictionaries.md:304
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a "
"dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are "
"storing a `Span<T>` and not an `Array<T>` because the latter does not "
"implement the `Copy<T>` trait which is required for reading from a "
"dictionary."
msgstr ""
"Bir örnek kullanarak gösterelim. Bir sözlük içinde bir Spanfelt252> "
"saklamaya çalışacağız. Bunun için NulableT> ve BoxT> kullanacağız. Ayrıca, "
"bir SpanT> ve bir ArrayT> değil, bir sözlük okumak için gerekli olan CopyT> "
"özelliğini uygulamayacağız."

#: src/ch03-02-dictionaries.md:310 src/ch03-02-dictionaries.md:359
msgid "// Create the dictionary\n"
msgstr "// Sözlük oluştur\n"

#: src/ch03-02-dictionaries.md:313 src/ch03-02-dictionaries.md:362
msgid "// Create the array to insert\n"
msgstr "// Eklemek için dizi oluştur\n"

#: src/ch03-02-dictionaries.md:316 src/ch03-02-dictionaries.md:365
msgid "// Insert it as a `Span`\n"
msgstr "// Span olarak ekle\n"

#: src/ch03-02-dictionaries.md:318 src/ch03-02-dictionaries.md:329
msgid "//...\n"
msgstr "//...\n"

#: src/ch03-02-dictionaries.md:322
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary "
"`d`. We want it to hold a `Nullable<Span>`. After that, we created an array "
"and filled it with values."
msgstr ""
"Bu kod snippet'inde, yaptığımız ilk şey yeni bir sözlük d oluşturmaktı. Bir "
"NulableSpan> tutmasını istiyoruz. Bundan sonra bir dizi oluşturduk ve "
"değerlerle doldurduk."

#: src/ch03-02-dictionaries.md:324
msgid ""
"The last step is inserting the array as a span inside the dictionary. Notice "
"that we do this using the `new` function of the `NullableTrait`."
msgstr ""
"Son adım, diziyi sözlüğün içine bir açıklık olarak yerleştirmektir. Bunu "
"NulableTrait'nin new işlevini kullanarak yaptığımıza dikkat edin."

#: src/ch03-02-dictionaries.md:326
msgid ""
"Once the element is inside the dictionary, and we want to get it, we follow "
"the same steps but in reverse order. The following code shows how to achieve "
"that:"
msgstr ""
"Element sözlüğün içine girdikten sonra ve onu elde etmek istediğimizde, aynı "
"adımları takip ediyoruz ama ters sırayla. Aşağıdaki kod bunu nasıl "
"başaracağımızı gösterir:"

#: src/ch03-02-dictionaries.md:331 src/ch03-02-dictionaries.md:368
msgid "// Get value back\n"
msgstr "// Değeri geri al\n"

#: src/ch03-02-dictionaries.md:334 src/ch03-02-dictionaries.md:371
msgid "// Search the value and assert it is not null\n"
msgstr "// Değeri arayın ve sıfır olmadığını iddia edin\n"

#: src/ch03-02-dictionaries.md:336 src/ch03-02-dictionaries.md:373
msgid "\"No value found\""
msgstr "\"Değer bulunamadı\""

#: src/ch03-02-dictionaries.md:340 src/ch03-02-dictionaries.md:377
msgid "// Verify we are having the right values\n"
msgstr "// Doğru değerlere sahip olduğumuzu doğrulayın\n"

#: src/ch03-02-dictionaries.md:341 src/ch03-02-dictionaries.md:378
msgid "\"Expecting 8\""
msgstr "\"Eksik 8\""

#: src/ch03-02-dictionaries.md:342 src/ch03-02-dictionaries.md:379
msgid "\"Expecting 9\""
msgstr "\"Beklenti 9\""

#: src/ch03-02-dictionaries.md:343 src/ch03-02-dictionaries.md:380
msgid "\"Expecting 10\""
msgstr "\"Beklenti 10\""

#: src/ch03-02-dictionaries.md:347
msgid "Here we:"
msgstr "İşte biz:"

#: src/ch03-02-dictionaries.md:349
msgid "Read the value using `get`."
msgstr "get kullanarak değeri okuyun."

#: src/ch03-02-dictionaries.md:350
msgid "Verified it is non-null using the `match_nullable` function."
msgstr "Doğrulanmış match_nullable işlevini kullanan null değildir."

#: src/ch03-02-dictionaries.md:351
msgid "Unwrapped the value inside the box and asserted it was correct."
msgstr "Kutunun içindeki değeri açtı ve doğru olduğunu iddia etti."

#: src/ch03-02-dictionaries.md:353
msgid "The complete script would look like this:"
msgstr "Senaryonun tamamı şöyle görünürdü:"

#: src/ch03-02-dictionaries.md:385
msgid "Using Arrays inside Dictionaries"
msgstr "Sözlüklerin içindeki dizileri kullanma"

#: src/ch03-02-dictionaries.md:387
msgid ""
"In the previous section, we explored how to store and retrieve complex types "
"inside a dictionary using `Nullable<T>` and `Box<T>`. Now, let's take a look "
"at how to store an array inside a dictionary and dynamically modify its "
"contents."
msgstr ""
"Önceki bölümde, NulableT> ve BoxT> kullanarak bir sözlük içindeki karmaşık "
"türleri nasıl depolayacağımızı ve geri getireceğimizi araştırdık. Şimdi, bir "
"sözlüğün içinde bir diziyi nasıl depolayacağımıza ve içeriğini dinamik "
"olarak nasıl değiştireceğimize bir göz atalım."

#: src/ch03-02-dictionaries.md:389
msgid ""
"Storing arrays in dictionaries in Cairo is slightly different from storing "
"other types. This is because arrays are more complex data structures that "
"require special handling to avoid issues with memory copying and references."
msgstr ""
"Kahire'deki sözlüklerde dizilerin depolanması, diğer türlerin "
"depolanmasından biraz farklıdır. Bunun nedeni, dizilerin bellek kopyalama ve "
"referanslarla ilgili sorunları önlemek için özel işlem gerektiren daha "
"karmaşık veri yapıları olmasıdır."

#: src/ch03-02-dictionaries.md:391
msgid ""
"First, let's look at how to create a dictionary and insert an array into it. "
"This process is pretty straightforward and follows a similar pattern to "
"inserting other types of data:"
msgstr ""
"İlk olarak, bir sözlük nasıl oluşturulacağına ve içine bir dizi nasıl "
"yerleştirileceğine bakalım. Bu işlem oldukça basittir ve diğer veri "
"türlerini eklemek için benzer bir desen izler:"

#: src/ch03-02-dictionaries.md:398
msgid "\"Array inserted successfully.\""
msgstr "\"Array başarıyla yerleştirildi.\""

#: src/ch03-02-dictionaries.md:402
msgid ""
"However, attempting to read an array from the dictionary using the `get` "
"method will result in a compiler error. This is because `get` tries to copy "
"the array in memory, which is not possible for arrays (as we've already "
"mentioned in the [previous section](./ch03-02-dictionaries.md#dictionaries-"
"of-types-not-supported-natively), `Array<T>` does not implement the "
"`Copy<T>` trait):"
msgstr ""
"Bununla birlikte, get yöntemini kullanarak sözlükten bir dizi okumaya "
"çalışmak, bir derleyici hatasıyla sonuçlanacaktır. Bunun nedeni, get diziyi "
"bellekte kopyalamaya çalışır, bu da diziler için mümkün değildir (daha önce "
"[önceki bölümde belirttiğimiz gibi]. /ch03-02-dictionaries.md#dictionaries-"
"of-types-not-natively), ArrayT> özelliği uygulanmaz."

#: src/ch03-02-dictionaries.md:411
msgid "\"Array: {:?}\""
msgstr "\"Array: :?\""

#: src/ch03-02-dictionaries.md:415
msgid "// This will cause a compiler error\n"
msgstr "// Bu bir derleyici hatasına neden olur\n"

#: src/ch03-02-dictionaries.md:417
msgid "\"No value!\""
msgstr "\"Değersiz!\""

#: src/ch03-02-dictionaries.md:424
msgid ""
"```shell\n"
"$ scarb cairo-run \n"
"   Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 (listings/ch03-"
"common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)\n"
"error: Trait has no implementation in context: core::traits::Copy::<core::"
"nullable::Nullable::<core::array::Array::<core::integer::u8>>>\n"
" --> listings/ch03-common-collections/"
"no_listing_15_dict_of_array_attempt_get/src/lib.cairo:12:20\n"
"    let val = dict.get(0); // This will cause a compiler error\n"
"                   ^*^\n"
"\n"
"error: could not compile `no_listing_15_dict_of_array_attempt_get` due to "
"previous error\n"
"error: `scarb metadata` exited with error\n"
"\n"
"```"
msgstr ""
"shell $ scarb cairo-run Compiling no_listing_15_dict_of_attempt_get v0.1.0 "
"(listings/ch03-common-collections/no_listing_15_of_atray_attempt_get/Scarb."
"toml) hatası: Trait'in bağlam içinde hiçbir uygulaması yoktur: çekirdek: "
"ras: copy:"

#: src/ch03-02-dictionaries.md:437
msgid ""
"To correctly read an array from the dictionary, we need to use dictionary "
"entries. This allows us to get a reference to the array value without "
"copying it:"
msgstr ""
"Bir diziyi sözlükten doğru okumak için sözlük girdilerini kullanmamız "
"gerekir. Bu, dizi değerine kopyalamadan bir referans almamıza izin verir:"

#: src/ch03-02-dictionaries.md:449
msgid ""
"Note: We must convert the array to a `Span` before finalizing the entry, "
"because calling `NullableTrait::new(arr)` moves the array, thus making it "
"impossible to return it from the function."
msgstr ""
"Not: NulableTrait::new(arr)'i çağırmak, diziyi işlevinden döndürmeyi "
"imkansız hale getirdiğinden, girdiyi sonlandırmadan önce diziyi Span'ya "
"dönüştürmeliyiz."

#: src/ch03-02-dictionaries.md:451
msgid ""
"To modify the stored array, such as appending a new value, we can use a "
"similar approach. The following `append_value` function demonstrates this:"
msgstr ""
"Yeni bir değer eklemek gibi depolanan diziyi değiştirmek için benzer bir "
"yaklaşım kullanabiliriz. Aşağıdaki append_value işlevi bunu gösterir:"

#: src/ch03-02-dictionaries.md:462
msgid ""
"In the `append_value` function, we access the dictionary entry, dereference "
"the array, append the new value, and finalize the entry with the updated "
"array."
msgstr ""
"append_value işlevinde, sözlük girdisine erişir, diziden çıkarım yapar, yeni "
"değeri ekler ve güncellenmiş dizi ile girişi sonlandırırız."

#: src/ch03-02-dictionaries.md:464
msgid ""
"Note: Removing an item from a stored array can be implemented in a similar "
"manner."
msgstr ""
"Not: Bir öğeyi depolanan bir diziden çıkarmak benzer bir şekilde "
"uygulanabilir."

#: src/ch03-02-dictionaries.md:466
msgid ""
"Below is the complete example demonstrating the creation, insertion, "
"reading, and modification of an array in a dictionary:"
msgstr ""
"Aşağıda bir sözlükte bir dizinin oluşturulmasını, eklenmesini, okunmasını ve "
"değiştirilmesini gösteren tam örnek verilmiştir:"

#: src/ch03-02-dictionaries.md:491
msgid "\"Before insertion: {:?}\""
msgstr "\"Eklenmeden önce: :?\""

#: src/ch03-02-dictionaries.md:495
msgid "\"After insertion: {:?}\""
msgstr "\"Eklenmeden sonra: :?\""

#: src/ch03-02-dictionaries.md:499
msgid "{{#quiz ../quizzes/ch03-02-dictionaries.toml}}"
msgstr "#quiz../quizzes/ch03-02-dictionaries.toml"

#: src/ch04-00-understanding-ownership.md
msgid "Understanding Cairo's Ownership system"
msgstr "Kahire'nin Sahiplik Sistemini Anlamak"

#: src/ch04-00-understanding-ownership.md
msgid ""
"Cairo is a language built around a linear type system that allows us to "
"statically ensure that in every Cairo program, a value is used exactly once. "
"This linear type system helps prevent runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory "
"cell, are detected at compile time. This is achieved by implementing an "
"ownership system and forbidding copying and dropping values by default. In "
"this chapter, we’ll talk about Cairo's ownership system as well as "
"references and snapshots."
msgstr ""
"Kahire, her Kahire programında statik olarak bir değerin tam olarak bir kez "
"kullanılmasını sağlayan doğrusal tip bir sistem etrafında inşa edilmiş bir "
"dildir. Bu doğrusal tip sistem, bir bellek hücresine iki kez yazma gibi bu "
"tür hatalara neden olabilecek işlemlerin derleme zamanında tespit edilmesini "
"sağlayarak çalışma zamanı hatalarını önlemeye yardımcı olur. Bu, bir "
"sahiplik sistemi uygulayarak ve varsayılan olarak kopyalama ve düşürme "
"değerlerini yasaklayarak elde edilir. Bu bölümde, Kahire'nin sahiplik ve "
"anlık göndermeler gibi özelliklerden bahsedeceğiz."

#: src/ch04-01-what-is-ownership.md:1
msgid "Ownership Using a Linear Type System"
msgstr "Lineer Tip Sistemi Kullanarak Sahiplik"

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"Cairo uses a linear type system. In such a type system, any value (a basic "
"type, a struct, an enum) must be used and must only be used once. 'Used' "
"here means that the value is either _destroyed_ or _moved_."
msgstr ""
"Kahire doğrusal tip sistemi kullanır. Böyle bir tip sistemde, herhangi bir "
"değer (temel bir tür, bir yapı, bir enum) kullanılmalı ve sadece bir kez "
"kullanılmalıdır. 'Kullanılmış' burada değerin ya _destroyed_ ya da _moved_ "
"olduğu anlamına gelir."

#: src/ch04-01-what-is-ownership.md:5
msgid "_Destruction_ can happen in several ways:"
msgstr "_Destruction_ birkaç şekilde gerçekleşebilir:"

#: src/ch04-01-what-is-ownership.md:7
msgid "a variable goes out of scope."
msgstr "Bir değişken kapsam dışına çıkar."

#: src/ch04-01-what-is-ownership.md:8
msgid "a struct is destructured."
msgstr "bir strüktür yapılandırılır."

#: src/ch04-01-what-is-ownership.md:9
msgid "explicit destruction using `destruct()`."
msgstr "destruct() kullanılarak açık imha."

#: src/ch04-01-what-is-ownership.md:11
msgid "_Moving_ a value simply means passing that value to another function."
msgstr ""
"_Moving_ bir değer basitçe bu değeri başka bir fonksiyona geçirmek anlamına "
"gelir."

#: src/ch04-01-what-is-ownership.md:13
msgid ""
"This results in somewhat similar constraints to the Rust ownership model, "
"but there are some differences. In particular, the Rust ownership model "
"exists (in part) to avoid data races and concurrent mutable access to a "
"memory value. This is obviously impossible in Cairo since the memory is "
"immutable. Instead, Cairo leverages its linear type system for two main "
"purposes:"
msgstr ""
"Bu, Rust mülkiyet modeline biraz benzer kısıtlamalarla sonuçlanır, ancak "
"bazı farklılıklar vardır. Özellikle, Rust mülkiyet modeli, veri yarışlarını "
"önlemek ve bir bellek değerine eşzamanlı olarak değişken erişim sağlamak "
"için var (kısmen). Bu, Kahire'de bellek değiştirilemez olduğu için açıkça "
"imkansızdır. Bunun yerine, Kahire doğrusal tip sistemini iki ana amaç için "
"kullanır:"

#: src/ch04-01-what-is-ownership.md:17
msgid "Ensuring that all code is provable and thus verifiable."
msgstr ""
"Tüm kodların kanıtlanabilir ve dolayısıyla doğrulanabilir olmasını sağlamak."

#: src/ch04-01-what-is-ownership.md:18
msgid "Abstracting away the immutable memory of the Cairo VM."
msgstr "Kahire sanal makinesinin değişmez hafızasını soyutlamak."

#: src/ch04-01-what-is-ownership.md:20
msgid "Ownership"
msgstr "Sahiplik"

#: src/ch04-01-what-is-ownership.md:22
msgid ""
"In Cairo, ownership applies to _variables_ and not to _values_. A value can "
"safely be referred to by many different variables (even if they are mutable "
"variables), as the value itself is always immutable. Variables however can "
"be mutable, so the compiler must ensure that constant variables aren't "
"accidentally modified by the programmer. This makes it possible to talk "
"about ownership of a variable: the owner is the code that can read (and "
"write if mutable) the variable."
msgstr ""
"Kahire'de, sahiplik _variables_ ve _values_ için geçerli değildir. Bir "
"değer, değerin kendisi her zaman değiştirilemez olduğu için, birçok farklı "
"değişken tarafından güvenle ifade edilebilir (değiştirilebilir değişkenler "
"olsa bile). Değişkenler ancak değiştirilebilir olabilir, bu nedenle "
"derleyici sabit değişkenlerin programcı tarafından yanlışlıkla "
"değiştirilmediğinden emin olmalıdır. Bu, bir değişkenin sahipliği hakkında "
"konuşmayı mümkün kılar: sahibi, okunabilen (ve yazabilen) koddur."

#: src/ch04-01-what-is-ownership.md:26
msgid ""
"This means that variables (not values) follow similar rules to Rust values:"
msgstr ""
"Bu, değişkenlerin (değerlerin değil) Rust değerlerine benzer kurallara "
"uyduğu anlamına gelir:"

#: src/ch04-01-what-is-ownership.md:28
msgid "Each variable in Cairo has an owner."
msgstr "Kahire'deki her değişkenin bir sahibi vardır."

#: src/ch04-01-what-is-ownership.md:29
msgid "There can only be one owner at a time."
msgstr "Aynı anda sadece bir sahibi olabilir."

#: src/ch04-01-what-is-ownership.md:30
msgid "When the owner goes out of scope, the variable is destroyed."
msgstr "Sahibi kapsam dışına çıktığında, değişken yok edilir."

#: src/ch04-01-what-is-ownership.md:32
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() "
"{` code in examples, so if you’re following along, make sure to put the "
"following examples inside a main function manually. As a result, our "
"examples will be a bit more concise, letting us focus on the actual details "
"rather than boilerplate code."
msgstr ""
"Şimdi temel Kahire sözdizimini geçtiğimize göre, tüm fn main()  kodunu "
"örneklere dahil etmeyeceğiz, bu yüzden takip ediyorsanız, aşağıdaki "
"örnekleri ana işlevin içine manuel olarak koyduğunuzdan emin olun. Sonuç "
"olarak, örneklerimiz biraz daha özlü olacak ve kazan plakası kodu yerine "
"gerçek ayrıntılara odaklanmamıza izin verecektir."

#: src/ch04-01-what-is-ownership.md:34
msgid "Variable Scope"
msgstr "Değişken Kapsam"

#: src/ch04-01-what-is-ownership.md:36
msgid ""
"As a first example of the linear type system, we’ll look at the _scope_ of "
"some variables. A scope is the range within a program for which an item is "
"valid. Take the following variable:"
msgstr ""
"Lineer tip sisteminin ilk örneği olarak, bazı değişkenlerin _scope_'sine "
"bakacağız. Bir kapsam, bir öğenin geçerli olduğu bir program içindeki "
"aralıktır. Aşağıdaki değişkeni alın:"

#: src/ch04-01-what-is-ownership.md:44
msgid ""
"The variable `s` refers to a short string. The variable is valid from the "
"point at which it’s declared until the end of the current _scope_. Listing "
"4-1 shows a program with comments annotating where the variable `s` would be "
"valid."
msgstr ""
"s değişkeni kısa bir dizgeyi ifade eder. Değişken, geçerli _scope_'un sonuna "
"kadar ilan edildiği noktadan itibaren geçerlidir. 4-1'i listelemek, s "
"değişkeninin nerede geçerli olacağını belirten yorumlar içeren bir programı "
"gösterir."

#: src/ch04-01-what-is-ownership.md:49
msgid "//TAG: ignore_fmt\n"
msgstr "//TAG: görmezden gel_fmt\n"

#: src/ch04-01-what-is-ownership.md:51
msgid "// s is not valid here, it’s not yet declared\n"
msgstr "// s burada geçerli değil, henüz ilan edilmedi\n"

#: src/ch04-01-what-is-ownership.md:52
msgid ""
"// s is valid from this point forward\n"
"    // do stuff with s\n"
msgstr "// s bu noktadan itibaren geçerlidir // s ile şeyler yapın\n"

#: src/ch04-01-what-is-ownership.md:54
msgid "// this scope is now over, and s is no longer valid\n"
msgstr "// bu kapsam artık bitti ve s artık geçerli değil\n"

#: src/ch04-01-what-is-ownership.md:58
msgid ""
"<span class=\"caption\">Listing 4-1: A variable and the scope in which it is "
"valid</span>"
msgstr ""
"span class=\"caption\">Liste 4-1: Bir değişken ve geçerli olduğu kapsam/span>"

#: src/ch04-01-what-is-ownership.md:60
msgid "In other words, there are two important points in time here:"
msgstr "Başka bir deyişle, burada zaman içinde iki önemli nokta vardır:"

#: src/ch04-01-what-is-ownership.md:62
msgid "When `s` comes _into_ scope, it is valid."
msgstr "s _into_ kapsamı geldiğinde geçerlidir."

#: src/ch04-01-what-is-ownership.md:63
msgid "It remains valid until it goes _out of_ scope."
msgstr "_out of_ kapsamına girene kadar geçerli kalır."

#: src/ch04-01-what-is-ownership.md:65
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is similar to that in other programming languages. Now we’ll build on top of "
"this understanding by using the `Array` type we introduced in the previous "
"[\"Arrays\"](./ch03-01-arrays.md) section."
msgstr ""
"Bu noktada, kapsamlar arasındaki ilişki ve değişkenler geçerli olduğunda, "
"diğer programlama dillerindekine benzer. Şimdi, önceki [\"Arrays\"] "
"bölümünde tanıttığımız Arrays tipini kullanarak bu anlayışın üzerine inşa "
"edeceğiz."

#: src/ch04-01-what-is-ownership.md:69
msgid "Moving values"
msgstr "Hareketli değerler"

#: src/ch04-01-what-is-ownership.md:71
msgid ""
"As said earlier, _moving_ a value simply means passing that value to another "
"function. When that happens, the variable referring to that value in the "
"original scope is destroyed and can no longer be used, and a new variable is "
"created to hold the same value."
msgstr ""
"Daha önce de belirtildiği gibi, _hareket_ bir değer basitçe bu değeri başka "
"bir fonksiyona geçirmek anlamına gelir. Bu olduğunda, orijinal kapsamdaki bu "
"değere atıfta bulunan değişken yok edilir ve artık kullanılamaz ve aynı "
"değeri tutmak için yeni bir değişken oluşturulur."

#: src/ch04-01-what-is-ownership.md:73
msgid ""
"Arrays are an example of a complex type that is moved when passing it to "
"another function. Here is a short reminder of what an array looks like:"
msgstr ""
"Diziler, başka bir fonksiyona geçerken hareket eden karmaşık bir türe "
"örnektir. Burada bir dizinin neye benzediğinin kısa bir hatırlatıcısı vardır:"

#: src/ch04-01-what-is-ownership.md:84
msgid ""
"How does the type system ensure that the Cairo program never tries to write "
"to the same memory cell twice? Consider the following code, where we try to "
"remove the front of the array twice:"
msgstr ""
"Tür sistemi, Kahire programının aynı bellek hücresine iki kez yazmaya "
"çalışmamasını nasıl sağlar? Dizinin ön kısmını iki kez kaldırmaya "
"çalıştığımız aşağıdaki kodu düşünün:"

#: src/ch04-01-what-is-ownership.md:99
msgid ""
"In this case, we try to pass the same value (the array in the `arr` "
"variable) to both function calls. This means our code tries to remove the "
"first element twice, which would try to write to the same memory cell twice "
"- which is forbidden by the Cairo VM, leading to a runtime error. "
"Thankfully, this code does not actually compile. Once we have passed the "
"array to the `foo` function, the variable `arr` is no longer usable. We get "
"this compile-time error, telling us that we would need Array to implement "
"the Copy Trait:"
msgstr ""
"Bu durumda, her iki işlev çağrısına da aynı değeri (arr değişkenindeki dizi) "
"aktarmaya çalışıyoruz. Bu, kodumuzun aynı bellek hücresine iki kez yazmaya "
"çalışacağı anlamına gelir - bu Kahire VM tarafından yasaklanmıştır, bu da "
"bir çalışma hatasına yol açar. Neyse ki, bu kod aslında derlemeye ihtiyaç "
"duymaz. Diziyi foo işlevine geçtikten sonra, değişken ar'dır."

#: src/ch04-01-what-is-ownership.md:125
msgid "The `Copy` Trait"
msgstr "Copy Trait"

#: src/ch04-01-what-is-ownership.md:127
msgid ""
"If a type implements the `Copy` trait, passing a value of that type to a "
"function does not move the value. Instead, a new variable is created, "
"referring to the same value. The important thing to note here is that this "
"is a completely free operation because variables are a Cairo abstraction "
"only and because _values_ in Cairo are always immutable. This, in "
"particular, conceptually differs from the Rust version of the `Copy` trait, "
"where the value is potentially copied in memory."
msgstr ""
"Bir tür Copy özelliğini uygularsa, bu tür bir değeri bir fonksiyona geçirmek "
"değeri hareket ettirmez. Bunun yerine, aynı değere atıfta bulunan yeni bir "
"değişken oluşturulur. Burada dikkat edilmesi gereken önemli şey, bunun "
"tamamen ücretsiz bir işlem olmasıdır, çünkü değişkenler yalnızca Kahire "
"soyutlamasıdır ve Kahire'deki _values_ her zaman değişmezdir. Bu, özellikle, "
"kavramsal olarak Copy değerinin Rust sürümünden farklıdır."

#: src/ch04-01-what-is-ownership.md:130
msgid ""
"All basic types previously described in [\"Data Types\"](./ch02-02-data-"
"types.md) implement by default the `Copy` trait."
msgstr ""
"Daha önce [\"Data Types\"](./ch02-02-data-types.md] bölümünde tanımlanan tüm "
"temel türler varsayılan olarak Copy özelliğini uygular."

#: src/ch04-01-what-is-ownership.md:132
msgid ""
"While Arrays and Dictionaries can't be copied, custom types that don't "
"contain either of them can be. You can implement the `Copy` trait on your "
"type by adding the `#[derive(Copy)]` annotation to your type definition. "
"However, Cairo won't allow a type to be annotated with Copy if the type "
"itself or any of its components doesn't implement the Copy trait."
msgstr ""
"Diziler ve Sözlükler kopyalanamazken, her ikisini de içermeyen özel türler "
"olabilir. Tür tanımınıza #[türev(Kopya)] notasyonu ekleyerek Kopya "
"özelliğini türünüze uygulayabilirsiniz. Bununla birlikte, Kahire, türün "
"kendisi veya herhangi bir bileşeni Kopyalama özelliğini uygulamazsa, bir "
"türün Kopyalama özelliği ile eklenmesine izin vermez."

#: src/ch04-01-what-is-ownership.md:148
msgid "// do something with p\n"
msgstr "// p ile bir şeyler yap\n"

#: src/ch04-01-what-is-ownership.md:152
msgid ""
"In this example, we can pass `p1` twice to the foo function because the "
"`Point` type implements the `Copy` trait. This means that when we pass `p1` "
"to `foo`, we are actually passing a copy of `p1`, so `p1` remains valid. In "
"ownership terms, this means that the ownership of `p1` remains with the "
"`main` function. If you remove the `Copy` trait derivation from the `Point` "
"type, you will get a compile-time error when trying to compile the code."
msgstr ""
"Bu örnekte, Point tipi Copy özelliğini uyguladığı için p1'yi iki kez foo "
"fonksiyonuna geçebiliriz. Bu, p1'den foo'ya geçtiğimizde, aslında p1'nin bir "
"kopyasını geçirdiğimiz anlamına gelir, bu yüzden p1  derleyicisi geçerli "
"kalır. Sahiplik açısından, bu, p1'in sahipliğini ana işlevi ile kalır."

#: src/ch04-01-what-is-ownership.md:155
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter "
"5](./ch05-00-using-structs-to-structure-related-data.md)._"
msgstr ""
"_Struct anahtar kelimesi için endişelenmeyin. Bunu [Bölüm 5](./ch05-00-using-"
"structs-to-structure-related-data.md) 'de tanıtacağız._"

#: src/ch04-01-what-is-ownership.md:160
msgid "Destroying Values - Example with FeltDict"
msgstr "Değerleri Yok Etmek - FeltDict ile Örnek"

#: src/ch04-01-what-is-ownership.md:162
msgid ""
"The other way linear types can be _used_ is by being destroyed. Destruction "
"must ensure that the 'resource' is now correctly released. In Rust, for "
"example, this could be closing the access to a file, or locking a mutex. In "
"Cairo, one type that has such behaviour is `Felt252Dict`. For provability, "
"dicts must be 'squashed' when they are destructed. This would be very easy "
"to forget, so it is enforced by the type system and the compiler."
msgstr ""
"Lineer türlerin diğer bir yolu da yok edilmektir. Yıkım, 'kaynak'ın şimdi "
"doğru bir şekilde serbest bırakılmasını sağlamalıdır. Rust'ta, örneğin, bu "
"bir dosyaya erişimi kapatmak veya bir muteks kilitlemek olabilir. Kahire'de, "
"böyle bir davranışa sahip olan bir tür Felt252Dict'dir. Provability için, "
"dicts'squashed' olmalı ve bu yüzden destromed olduğunda, unutmak çok kolay "
"olacaktır."

#: src/ch04-01-what-is-ownership.md:166
msgid "No-op Destruction: the `Drop` Trait"
msgstr "No-op Yıkım: Drop Trait"

#: src/ch04-01-what-is-ownership.md:168
msgid ""
"You may have noticed that the `Point` type in the previous example also "
"implements the `Drop` trait. For example, the following code will not "
"compile, because the struct `A` is not moved or destroyed before it goes out "
"of scope:"
msgstr ""
"Önceki örnekte yer alan Point tipinin Drop özelliğini de uyguladığını fark "
"etmiş olabilirsiniz. Örneğin, aşağıdaki kod derlemez, çünkü A yapısı kapsam "
"dışına çıkmadan önce taşınmaz veya yok edilmez:"

#: src/ch04-01-what-is-ownership.md:175
msgid "// error: Variable not dropped.\n"
msgstr "// hata: Değişken düşmedi.\n"

#: src/ch04-01-what-is-ownership.md:179
msgid ""
"However, types that implement the `Drop` trait are automatically destroyed "
"when going out of scope. This destruction does nothing, it is a no-op - "
"simply a hint to the compiler that this type can safely be destroyed once "
"it's no longer useful. We call this \"dropping\" a value."
msgstr ""
"Bununla birlikte, Drop özelliğini uygulayan türler, kapsam dışına çıkarken "
"otomatik olarak yok edilir. Bu yıkım hiçbir şey yapmaz, bu bir hayır-op - "
"derleyiciye bu türün artık kullanışlı olmadığında güvenli bir şekilde yok "
"edilebileceğine dair bir ipucu. Buna bir değer \"dropping\" diyoruz."

#: src/ch04-01-what-is-ownership.md:181
msgid ""
"At the moment, the `Drop` implementation can be derived for all types, "
"allowing them to be dropped when going out of scope, except for dictionaries "
"(`Felt252Dict`) and types containing dictionaries. For example, the "
"following code compiles:"
msgstr ""
"Şu anda, sözlükler (Felt252Dict) ve sözlükler içeren türler hariç, Drop "
"uygulaması tüm türler için türetilebilir. Örneğin, aşağıdaki kod derlenir:"

#: src/ch04-01-what-is-ownership.md:189
msgid "// Now there is no error.\n"
msgstr "// Şimdi hata yok.\n"

#: src/ch04-01-what-is-ownership.md:193
msgid "Destruction with a Side-effect: the `Destruct` Trait"
msgstr "Yan Etki ile Yıkım: Destruct Trait"

#: src/ch04-01-what-is-ownership.md:195
msgid ""
"When a value is destroyed, the compiler first tries to call the `drop` "
"method on that type. If it doesn't exist, then the compiler tries to call "
"`destruct` instead. This method is provided by the `Destruct` trait."
msgstr ""
"Bir değer yok edildiğinde, derleyici ilk önce bu türdeki drop yöntemini "
"çağırmaya çalışır. Eğer mevcut değilse, derleyici bunun yerine destruct "
"adını vermeye çalışır. Bu yöntem Destruct özelliği ile sağlanır."

#: src/ch04-01-what-is-ownership.md:197
msgid ""
"As said earlier, dictionaries in Cairo are types that must be \"squashed\" "
"when destructed, so that the sequence of access can be proven. This is easy "
"for developers to forget, so instead dictionaries implement the `Destruct` "
"trait to ensure that all dictionaries are _squashed_ when going out of "
"scope. As such, the following example will not compile:"
msgstr ""
"Daha önce de belirtildiği gibi, Kahire'deki sözlükler, yok edildiğinde "
"\"kararlanması\" gereken türlerdir, böylece erişim sırası kanıtlanabilir. "
"Bu, geliştiricilerin unutması kolaydır, bunun yerine sözlükler, tüm "
"sözlüklerin kapsam dışına çıkarken _squashed_ olmasını sağlamak için "
"Destruct özelliğini uygular. Bu nedenle, aşağıdaki örnek derlemeyecektir:"

#: src/ch04-01-what-is-ownership.md:210
msgid "If you try to run this code, you will get a compile-time error:"
msgstr "Bu kodu çalıştırmaya çalışırsanız, derleme zamanı hatası alırsınız:"

#: src/ch04-01-what-is-ownership.md:227
msgid ""
"When `A` goes out of scope, it can't be dropped as it implements neither the "
"`Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the "
"`Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr ""
"A kapsam dışına çıktığında, ne Drop (bir sözlük içerdiği ve derive(Drop)) ne "
"de Destruct özelliğini uyguladığı için bırakılamaz. Bunu düzeltmek için, A "
"tipi için Destruct özellik uygulamasını türetebiliriz:"

#: src/ch04-01-what-is-ownership.md:236
msgid "// No error here\n"
msgstr "// Burada hata yok\n"

#: src/ch04-01-what-is-ownership.md:240
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically "
"`squashed`, and the program will compile."
msgstr ""
"Şimdi, A kapsam dışına çıktığında, sözlüğü otomatik olarak squashed olacak "
"ve program derlenecektir."

#: src/ch04-01-what-is-ownership.md:242
msgid "Copy Array Data with `clone`"
msgstr "Dizi Verilerini clone ile Kopyala"

#: src/ch04-01-what-is-ownership.md:244
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common "
"method called `clone`. We’ll discuss method syntax in a dedicated section in "
"[Chapter 5](./ch05-03-method-syntax.md), but because methods are a common "
"feature in many programming languages, you’ve probably seen them before."
msgstr ""
"Bir Array'nin verilerini derinden kopyalamak istiyorsak, clone adlı ortak "
"bir yöntem kullanabiliriz. [Bölüm 5](./ch05-03-method-syntax.md) 'deki özel "
"bir bölümde yöntem sözdizimi tartışacağız, ancak yöntemler birçok "
"programlama dilinde yaygın bir özellik olduğundan, muhtemelen bunları daha "
"önce görmüşsünüzdür."

#: src/ch04-01-what-is-ownership.md:246
msgid "Here’s an example of the `clone` method in action."
msgstr "İşte eylemde clone yönteminin bir örneği."

#: src/ch04-01-what-is-ownership.md:255
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being "
"executed and that code may be expensive. It’s a visual indicator that "
"something different is going on. In this case, the _value_ `arr1` refers to "
"is being copied, resulting in new memory cells being used, and a new "
"_variable_ `arr2` is created, referring to the new copied value."
msgstr ""
"clone çağrısını gördüğünüzde, bazı keyfi kodların çalıştırıldığını ve bu "
"kodun pahalı olabileceğini bilirsiniz. Bu, farklı bir şeyin devam ettiğini "
"gösteren görsel bir göstergedir. Bu durumda, _value_ arr1, yeni bellek "
"hücrelerinin kullanılmasıyla sonuçlanan kopyalanıyor ve yeni kopyalanan "
"değere atıfta bulunan yeni bir _variable_ arr2 yaratılıyor."

#: src/ch04-01-what-is-ownership.md:260
msgid "Return Values and Scope"
msgstr "Dönüş Değerleri ve Kapsamı"

#: src/ch04-01-what-is-ownership.md:262
msgid ""
"Returning values is equivalent to _moving_ them. Listing 4-2 shows an "
"example of a function that returns some value, with similar annotations as "
"those in Listing 4-1."
msgstr ""
"Geri dönen değerler, _hareket eden_'ye eşittir. 4-2'yi listelemek, Listeleme "
"4-1'dekilere benzer açıklamalarla, bir değer döndüren bir fonksiyonun "
"örneğini gösterir."

#: src/ch04-01-what-is-ownership.md:272
msgid ""
"// gives_ownership moves its return\n"
"                                          // value into a1\n"
msgstr "// gives_ ownership return // değerini a1'e taşır\n"

#: src/ch04-01-what-is-ownership.md:275
msgid "// a2 comes into scope\n"
msgstr "// a2 kapsamına girer\n"

#: src/ch04-01-what-is-ownership.md:277
msgid ""
"// a2 is moved into\n"
"                                          // takes_and_gives_back, which "
"also\n"
"                                          // moves its return value into a3\n"
msgstr ""
"// a2 içine taşınır // takes_and_gives_back, ayrıca // dönüş değerini a3'e "
"taşır\n"

#: src/ch04-01-what-is-ownership.md:281
msgid ""
"// Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
msgstr ""
"// Burada, a3 kapsam dışına çıkar ve bırakılır. a2 taşındı, yani hiçbir "
"şey // olmuyor. a1 kapsam dışına çıkar ve düşer.\n"

#: src/ch04-01-what-is-ownership.md:284
msgid ""
"// gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
msgstr ""
"// giving_ownership // return değerini // onu çağıran fonksiyona "
"taşıyacaktır.\n"

#: src/ch04-01-what-is-ownership.md:288 src/ch04-01-what-is-ownership.md:296
msgid "// some_a comes into scope\n"
msgstr "// bazı_a kapsamına girer\n"

#: src/ch04-01-what-is-ownership.md:290
msgid ""
"// some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr "// some_a döndürülür ve // sahipliği çağrıya taşır // fonksiyon\n"

#: src/ch04-01-what-is-ownership.md:294
msgid "// This function takes an instance some_a of A and returns it\n"
msgstr "// Bu fonksiyon A'nın bir kısmını alır ve onu döndürür\n"

#: src/ch04-01-what-is-ownership.md:298
msgid ""
"// some_a is returned and \n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr "// some_a döndürülür ve // sahipliği çağrıya taşır // fonksiyon\n"

#: src/ch04-01-what-is-ownership.md:304
msgid "<span class=\"caption\">Listing 4-2: Moving return values</span>"
msgstr ""
"span class=\"caption\">Liste 4-2: Geri dönüş değerlerinin taşınması/span>"

#: src/ch04-01-what-is-ownership.md:306
msgid ""
"While this works, moving into and out of every function is a bit tedious. "
"What if we want to let a function use a value but not move the value? It’s "
"quite annoying that anything we pass in also needs to be passed back if we "
"want to use it again, in addition to any data resulting from the body of the "
"function that we might want to return as well."
msgstr ""
"Bu işe yararken, her fonksiyona girip çıkmak biraz sıkıcıdır. Bir "
"fonksiyonun bir değer kullanmasına izin vermek, ancak değeri hareket "
"ettirmemek istersek ne olur? Geçtiğimiz herhangi bir şeyin, fonksiyonun "
"gövdesinden kaynaklanan ve geri dönmek isteyebileceğimiz herhangi bir veriye "
"ek olarak, tekrar kullanmak istersek geri geçirilmesi gerektiği oldukça "
"sinir bozucudur."

#: src/ch04-01-what-is-ownership.md:308
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing "
"4-3."
msgstr ""
"Kahire, Liste 4-3'te gösterildiği gibi, bir tuple kullanarak birden fazla "
"değer döndürmemize izin veriyor."

#: src/ch04-01-what-is-ownership.md:320
msgid "// len() returns the length of an array\n"
msgstr "// len() bir dizinin uzunluğunu döndürür\n"

#: src/ch04-01-what-is-ownership.md:326
msgid "<span class=\"caption\">Listing 4-3: Returning many values</span>"
msgstr "span class=\"caption\">Liste 4-3: Birçok değer döndürme/span>"

#: src/ch04-01-what-is-ownership.md:328
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be "
"common. Luckily for us, Cairo has two features for passing a value without "
"destroying or moving it, called _references_ and _snapshots_."
msgstr ""
"Ancak bu çok fazla tören ve ortak olması gereken bir konsept için çok fazla "
"iş. Neyse ki, Kahire, _references_ ve _snapshots_ olarak adlandırılan bir "
"değeri yok etmeden veya hareket ettirmeden geçmek için iki özelliğe sahiptir."

#: src/ch04-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in previous Listing 4-3 is that we have to "
"return the `Array` to the calling function so we can still use the `Array` "
"after the call to `calculate_length`, because the `Array` was moved into "
"`calculate_length`."
msgstr ""
"Önceki Listeleme 4-3'teki tuple koduyla ilgili sorun, Array'yi arama "
"işlevine geri döndürmemiz gerektiğidir, böylece calculate_length çağrısından "
"sonra Array'yi hala kullanabiliriz, çünkü Array calculate_length'ye taşındı."

#: src/ch04-02-references-and-snapshots.md:8
msgid "Snapshots"
msgstr "Snapshots"

#: src/ch04-02-references-and-snapshots.md:10
msgid ""
"In the previous chapter, we talked about how Cairo's ownership system "
"prevents us from using a variable after we've moved it, protecting us from "
"potentially writing twice to the same memory cell. However, it's not very "
"convenient. Let's see how we can retain ownership of the variable in the "
"calling function using snapshots."
msgstr ""
"Bir önceki bölümde, Kahire'nin sahiplik sisteminin onu taşıdıktan sonra bir "
"değişkeni kullanmamızı nasıl engellediği hakkında konuştuk, potansiyel "
"olarak iki kez aynı bellek hücresine yazmamızı koruyor. Ancak, çok uygun "
"değil. Çağrı fonksiyonundaki değişkenin sahipliğini anlık görüntüler "
"kullanarak nasıl koruyabileceğimizi görelim."

#: src/ch04-02-references-and-snapshots.md:15
msgid ""
"In Cairo, a snapshot is an immutable view of a value at a certain point in "
"time. Recall that memory is immutable, so modifying a value actually creates "
"a new memory cell. The old memory cell still exists, and snapshots are "
"variables that refer to that \"old\" value. In this sense, snapshots are a "
"view \"into the past\"."
msgstr ""
"Kahire'de anlık görüntü, belirli bir zamanda bir değerin değişmez bir "
"görünümüdür. Hafızanın değişmez olduğunu hatırlayın, bu nedenle bir değeri "
"değiştirmek aslında yeni bir bellek hücresi yaratır. Eski bellek hücresi "
"hala var ve anlık görüntüler o \"eski\" değere atıfta bulunan "
"değişkenlerdir. Bu anlamda, anlık görüntüler \"geçmişe\" bir görünümdür."

#: src/ch04-02-references-and-snapshots.md:20
msgid ""
"Here is how you would define and use a `calculate_length` function that "
"takes a snapshot of an array as a parameter instead of taking ownership of "
"the underlying value. In this example, the `calculate_length` function "
"returns the length of the array passed as a parameter. As we're passing it "
"as a snapshot, which is an immutable view of the array, we can be sure that "
"the `calculate_length` function will not mutate the array, and ownership of "
"the array is kept in the `main` function."
msgstr ""
"Alttaki değerin sahipliğini almak yerine bir diziyi parametre olarak "
"görüntüleyen bir calculate_length fonksiyonunu nasıl tanımlar ve "
"kullanırsınız. Bu örnekte, calculate_length işlevi, parametre olarak geçen "
"dizinin uzunluğunu döndürür. Dizinin değişmez bir görünümü olan bir anlık "
"görüntü olarak geçerken, dizinin calculate_length fonksiyonunun sessiz "
"kalmayacağından emin olabiliriz."

#: src/ch04-02-references-and-snapshots.md:31
msgid "// Take a snapshot of `arr1` at this point in time\n"
msgstr "// Bu noktada arr1'nin anlık görüntüsünü alın\n"

#: src/ch04-02-references-and-snapshots.md:32
msgid "// Mutate `arr1` by appending a value\n"
msgstr "// arr1 değerini ekleyerek Mutate\n"

#: src/ch04-02-references-and-snapshots.md:35
msgid "// Calculate the length of the array when the snapshot was taken\n"
msgstr "// Ekran görüntüsü çekildiğinde dizinin uzunluğunu hesaplayın\n"

#: src/ch04-02-references-and-snapshots.md:36
#: src/ch04-02-references-and-snapshots.md:67
msgid "// Calculate the current length of the array\n"
msgstr "// Dizinin mevcut uzunluğunu hesapla\n"

#: src/ch04-02-references-and-snapshots.md:37
msgid "\"The length of the array when the snapshot was taken is {}\""
msgstr "\"Snapshot çekildiğinde dizinin uzunluğu \""

#: src/ch04-02-references-and-snapshots.md:38
msgid "\"The current length of the array is {}\""
msgstr "\"Aracın mevcut uzunluğu \""

#: src/ch04-02-references-and-snapshots.md:46
msgid ""
"Note: it is only possible to call the `len()` method on an array snapshot "
"because it is defined as such in the `ArrayTrait` trait. If you try to call "
"a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on non-"
"snapshot types."
msgstr ""
"Not: ArrayTrait özelliğinde olduğu gibi tanımlandığı için len() metodunu "
"yalnızca bir dizi anlık görüntüsünde aramak mümkündür. Bir anlık görüntüdeki "
"anlık görüntüler için tanımlanmamış bir yöntemi çağırmaya çalışırsanız, "
"derleme hatası alırsınız. Ancak, anlık görüntü olmayan türlerde anlık "
"görüntü bekleyen yöntemleri arayabilirsiniz."

#: src/ch04-02-references-and-snapshots.md:48
msgid "The output of this program is:"
msgstr "Bu programın çıktısı:"

#: src/ch04-02-references-and-snapshots.md:61
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note that we pass `@arr1` into "
"`calculate_length` and, in its definition, we take `@Array<u128>` rather "
"than `Array<u128>`."
msgstr ""
"İlk olarak, değişken deklarasyondaki ve fonksiyon dönüş değerindeki tüm tül "
"kodunun kaybolduğuna dikkat edin. İkincisi, arr1'yi calculate_length'ye "
"aktardığımızı ve tanımında Arrayu128> yerine Arrayu128>'yi aldığımızı "
"unutmayın."

#: src/ch04-02-references-and-snapshots.md:64
msgid "Let’s take a closer look at the function call here:"
msgstr "Buradaki fonksiyon çağrısına daha yakından bakalım:"

#: src/ch04-02-references-and-snapshots.md:70
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because "
"a snapshot is an immutable view of a value at a specific point in time, the "
"usual rules of the linear type system are not enforced. In particular, "
"snapshot variables always implement the `Drop` trait, never the `Destruct` "
"trait, even dictionary snapshots."
msgstr ""
"arr1 sözdizimi, arr1'deki değerin anlık görüntüsünü oluşturmamızı sağlar. "
"Bir anlık görüntü, belirli bir noktada bir değerin değişmez bir görünümü "
"olduğundan, doğrusal tip sisteminin olağan kuralları uygulanmaz. Özellikle, "
"anlık görüntü değişkenleri her zaman Drop özelliğini uygularlar, asla "
"Destruct özelliği, hatta sözlük anlık görüntüleri."

#: src/ch04-02-references-and-snapshots.md:72
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type "
"of the parameter `arr` is a snapshot. Let’s add some explanatory annotations:"
msgstr ""
"Benzer şekilde, fonksiyonun imzası, arr parametresinin türünün bir anlık "
"görüntü olduğunu belirtmek için  kullanır. Bazı açıklayıcı açıklamalar "
"ekleyelim:"

#: src/ch04-02-references-and-snapshots.md:76
msgid "// array_snapshot is a snapshot of an Array\n"
msgstr "// array_snapshot bir Array'in anlık görüntüsüdür\n"

#: src/ch04-02-references-and-snapshots.md:79
msgid ""
"// Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` "
"contains, the original `arr` can still be used.\n"
msgstr ""
"// Burada, array_snapshot kapsam dışına çıkar ve bırakılır. // Ancak, "
"orijinal dizi arr'nin içerdiği şeyin bir görünümü olduğundan, orijinal arr "
"hala kullanılabilir.\n"

#: src/ch04-02-references-and-snapshots.md:83
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any "
"function parameter’s scope, but the underlying value of the snapshot is not "
"dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to "
"return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""
"array_snapshot değişkeninin geçerli olduğu kapsam, herhangi bir fonksiyon "
"parametresinin kapsamı ile aynıdır, ancak array_snapshot kullanımı "
"durduğunda anlık görüntünün altında yatan değer düşürülmez. Fonksiyonlar "
"gerçek değerler yerine parametreler olarak anlık görüntülere sahip "
"olduğunda, orijinal değerin sahipliğini geri vermek için değerleri geri "
"vermemize gerek kalmaz, çünkü hiçbir zaman sahip olmadık."

#: src/ch04-02-references-and-snapshots.md:85
msgid "Desnap Operator"
msgstr "Desnap Operatörü"

#: src/ch04-02-references-and-snapshots.md:87
msgid ""
"To convert a snapshot back into a regular variable, you can use the `desnap` "
"operator `*`, which serves as the opposite of the `@` operator."
msgstr ""
"Bir anlık görüntüyü normal bir değişkene geri dönüştürmek için,  "
"operatörünün tam tersi olarak hizmet veren desnap operatörü *'yi "
"kullanabilirsiniz."

#: src/ch04-02-references-and-snapshots.md:89
msgid ""
"Only `Copy` types can be desnapped. However, in the general case, because "
"the value is not modified, the new variable created by the `desnap` operator "
"reuses the old value, and so desnapping is a completely free operation, just "
"like `Copy`."
msgstr ""
"Sadece Copy türleri çıkarılabilir. Ancak, genel durumda, değer "
"değiştirilmediği için, desnap operatörü tarafından oluşturulan yeni değişken "
"eski değeri yeniden kullanır ve böylece desnapping, tıpkı Copy gibi tamamen "
"ücretsiz bir işlemdir."

#: src/ch04-02-references-and-snapshots.md:91
msgid ""
"In the following example, we want to calculate the area of a rectangle, but "
"we don't want to take ownership of the rectangle in the `calculate_area` "
"function, because we might want to use the rectangle again after the "
"function call. Since our function doesn't mutate the rectangle instance, we "
"can pass the snapshot of the rectangle to the function, and then transform "
"the snapshots back into values using the `desnap` operator `*`."
msgstr ""
"Aşağıdaki örnekte, bir dikdörtgenin alanını hesaplamak istiyoruz, ancak "
"calculate_area fonksiyonundaki dikdörtgenin mülkiyetini almak istemiyoruz, "
"çünkü fonksiyon çağrısından sonra dikdörtgeni tekrar kullanmak "
"isteyebiliriz. Fonksiyonumuz dikdörtgen örneğini mutasyona uğratmadığından, "
"dikdörtgenin anlık görüntüsünü fonksiyona geçirebilir ve ardından anlık "
"görüntüleri desnap operatörünü kullanarak değerlere dönüştürebiliriz *."

#: src/ch04-02-references-and-snapshots.md:103
msgid "\"Area: {}\""
msgstr "\"Alan: \""

#: src/ch04-02-references-and-snapshots.md:107
msgid ""
"// As rec is a snapshot to a Rectangle, its fields are also snapshots of the "
"fields types.\n"
"    // We need to transform the snapshots back into values using the desnap "
"operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for "
"u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for "
"desnapping the snapshots.\n"
msgstr ""
"// Rec bir dikdörtgene anlık görüntü olduğundan, alanları da alan tiplerinin "
"anlık görüntüleridir. // Desnap operatörü * kullanarak anlık görüntüleri "
"tekrar değerlere dönüştürmemiz gerekir. // Bu, yalnızca tip kopyalanabilirse "
"mümkündür, bu u64 için geçerlidir. // Burada,  *  hem yüksekliği hem de "
"genişliği çarpmak için ve anlık görüntüleri silmek için kullanılır.\n"

#: src/ch04-02-references-and-snapshots.md:115
msgid ""
"But, what happens if we try to modify something we’re passing as a snapshot? "
"Try the code in Listing 4-4. Spoiler alert: it doesn’t work!"
msgstr ""
"Ancak, anlık görüntü olarak geçtiğimiz bir şeyi değiştirmeye çalışırsak ne "
"olur? Listeleme 4-4'teki kodu deneyin. Spoiler uyarısı: çalışmıyor!"

#: src/ch04-02-references-and-snapshots.md:140
msgid ""
"<span class=\"caption\">Listing 4-4: Attempting to modify a snapshot value</"
"span>"
msgstr ""
"span class=\"caption\">Liste 4-4: Bir anlık görüntü değerini değiştirmeye "
"çalışmak/span>"

#: src/ch04-02-references-and-snapshots.md:142
msgid "Here’s the error:"
msgstr "İşte hata:"

#: src/ch04-02-references-and-snapshots.md:162
msgid "The compiler prevents us from modifying values associated to snapshots."
msgstr ""
"Derleyici, anlık görüntülerle ilişkili değerleri değiştirmemizi engeller."

#: src/ch04-02-references-and-snapshots.md:164
msgid "Mutable References"
msgstr "Değiştirilebilir Referanslar"

#: src/ch04-02-references-and-snapshots.md:166
msgid ""
"We can achieve the behavior we want in Listing 4-4 by using a _mutable "
"reference_ instead of a snapshot. Mutable references are actually mutable "
"values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they "
"allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution. In Cairo, a "
"parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""
"Listeleme 4-4'te istediğimiz davranışı anlık görüntü yerine bir _mutable "
"reference_ kullanarak elde edebiliriz. Değiştirilebilir referanslar aslında "
"fonksiyonun sonunda dolaylı olarak döndürülen bir fonksiyona aktarılan, "
"sahipliğini çağrı bağlamına geri dönen değişken değerlerdir. Bunu yaparak, "
"yürütmenin sonunda otomatik olarak geri döndürerek geçirilen değeri "
"değiştirmenize izin verirler. Kahire'de, bir parametre mut ref reference "
"kullanılarak geçirilebilir."

#: src/ch04-02-references-and-snapshots.md:169
msgid ""
"**Note**: In Cairo, a parameter can only be passed as _mutable reference_ "
"using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""
"**Not**: Kahire'de, değişken mut ile değiştirilebilir olarak ilan edilirse, "
"bir parametre sadece ref değiştiricisi kullanılarak _mutable reference_ "
"olarak geçirilebilir."

#: src/ch04-02-references-and-snapshots.md:171
msgid ""
"In Listing 4-5, we use a mutable reference to modify the value of the "
"`height` and `width` fields of the `Rectangle` instance in the `flip` "
"function."
msgstr ""
"Listeleme 4-5'te, flip işlevindeki height ve width alanlarının değerini "
"değiştirmek için değişken bir referans kullanırız."

#: src/ch04-02-references-and-snapshots.md:183
msgid "\"height: {}, width: {}\""
msgstr "\"yükseklik:, genişlik: \""

#: src/ch04-02-references-and-snapshots.md:193
msgid ""
"<span class=\"caption\">Listing 4-5: Use of a mutable reference to modify a "
"value</span>"
msgstr ""
"span class=\"caption\">Liste 4-5: Bir değeri değiştirmek için "
"değiştirilebilir bir referans kullanımı/span>"

#: src/ch04-02-references-and-snapshots.md:195
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of "
"`rec` into `flip` with `ref rec`, and update the function signature to "
"accept a mutable reference with `ref rec: Rectangle`. This makes it very "
"clear that the `flip` function will mutate the value of the `Rectangle` "
"instance passed as parameter."
msgstr ""
"İlk olarak, rec'yi mut olarak değiştiririz. Sonra rec'nin değişken bir "
"referansını ref rec ile flip'ye geçiririz ve ref rec: Dikdörtgen ile "
"değişken bir referansı kabul etmek için fonksiyon imzasını güncelleriz. Bu, "
"flip fonksiyonunun parametre olarak geçen Rectangle örneğinin değerini "
"değiştireceğini çok net bir şekilde ortaya koymaktadır."

#: src/ch04-02-references-and-snapshots.md:197
msgid "The output of the program is:"
msgstr "Programın çıktısı:"

#: src/ch04-02-references-and-snapshots.md:209
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been "
"swapped."
msgstr ""
"Beklendiği gibi, rec değişkeninin height ve width alanları değiştirilmiştir."

#: src/ch04-02-references-and-snapshots.md:211
msgid "{{#quiz ../quizzes/ch04-02-references-and-snapshots.toml}}"
msgstr "#quiz../quizzes/ch04-02-references-and-snapshots.toml"

#: src/ch04-02-references-and-snapshots.md:213
msgid "Small Recap"
msgstr "Küçük Özet"

#: src/ch04-02-references-and-snapshots.md:215
msgid ""
"Let’s recap what we’ve discussed about the linear type system, ownership, "
"snapshots, and references:"
msgstr ""
"Lineer tip sistemi, sahiplik, anlık görüntüler ve referanslar hakkında "
"tartıştığımız şeyleri özetleyelim:"

#: src/ch04-02-references-and-snapshots.md:217
msgid "At any given time, a variable can only have one owner."
msgstr "Herhangi bir zamanda, bir değişkenin yalnızca bir sahibi olabilir."

#: src/ch04-02-references-and-snapshots.md:218
msgid ""
"You can pass a variable by-value, by-snapshot, or by-reference to a function."
msgstr ""
"Değişken bir by-value, by-snapshot veya by-reference'i bir fonksiyona "
"aktarabilirsiniz."

#: src/ch04-02-references-and-snapshots.md:219
msgid ""
"If you pass-by-value, ownership of the variable is transferred to the "
"function."
msgstr ""
"Eğer değer üzerinden geçerseniz, değişkenin mülkiyeti fonksiyona aktarılır."

#: src/ch04-02-references-and-snapshots.md:220
msgid ""
"If you want to keep ownership of the variable and know that your function "
"won’t mutate it, you can pass it as a snapshot with `@`."
msgstr ""
"Değişkenin mülkiyetini korumak ve işlevinizin mutasyona uğramayacağını "
"bilmek istiyorsanız,  ile anlık görüntü olarak aktarabilirsiniz."

#: src/ch04-02-references-and-snapshots.md:221
msgid ""
"If you want to keep ownership of the variable and know that your function "
"will mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""
"Değişkenin mülkiyetini korumak ve işlevinizin onu mutasyona uğratacağını "
"bilmek istiyorsanız, bunu ref ile değiştirilebilir bir referans olarak "
"geçebilirsiniz."

#: src/ch05-00-using-structs-to-structure-related-data.md
msgid ""
"A struct, or structure, is a custom data type that lets you package together "
"and name multiple related values that make up a meaningful group. If you’re "
"familiar with an object-oriented language, a struct is like an object’s data "
"attributes. In this chapter, we’ll compare and contrast tuples with structs "
"to build on what you already know and demonstrate when structs are a better "
"way to group data."
msgstr ""
"Bir yapı veya yapı, anlamlı bir grup oluşturan birden fazla ilgili değeri "
"birlikte paketlemenizi ve adlandırmanızı sağlayan özel bir veri türüdür. "
"Nesne yönelimli bir dile aşinaysanız, bir yapı bir nesnenin veri nitelikleri "
"gibidir. Bu bölümde, yapıtların veriyi gruplandırmanın daha iyi bir yolu "
"olduğunda, zaten bildiklerinizi inşa etmek ve göstermek için yapıtlarla "
"karşılaştıracağız."

#: src/ch05-00-using-structs-to-structure-related-data.md
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called methods, to specify behavior associated with a struct type. Structs "
"and enums (discussed in the [next chapter](ch06-01-enums.md)) are the "
"building blocks for creating new types in your program’s domain to take full "
"advantage of Cairo's compile-time type checking."
msgstr ""
"Yapıtların nasıl tanımlanacağını ve hazırlanacağını göstereceğiz. Bir yapı "
"tipiyle ilişkili davranışları belirtmek için ilişkili işlevlerin, özellikle "
"de yöntemler olarak adlandırılan ilişkili işlevlerin nasıl tanımlanacağını "
"tartışacağız. Yapıtlar ve enumlar (bir sonraki bölümde tartışılmıştır) "
"(ch06-01-enums.md) programınızın alanında Kahire'nin tam zamanlı "
"derlemesinden yararlanmak için yeni türler oluşturmak için yapı taşlarıdır."

#: src/ch05-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in the [Data Types](ch02-02-data-"
"types.md) section, in that both hold multiple related values. Like tuples, "
"the pieces of a struct can be different types. Unlike with tuples, in a "
"struct you’ll name each piece of data so it’s clear what the values mean. "
"Adding these names means that structs are more flexible than tuples: you "
"don’t have to rely on the order of the data to specify or access the values "
"of an instance."
msgstr ""
"Structs, [Veri Türleri] (ch02-02-data-types.md) bölümünde tartışılan "
"tuples'e benzer, her ikisi de birden fazla ilgili değer taşır. Tuples gibi, "
"bir struct'un parçaları farklı türlerde olabilir. Tuples'ın aksine, bir "
"struct'ta her bir veri parçasını adlandırırsınız, böylece değerlerin ne "
"anlama geldiğini açıkça belirtirsiniz. Bu isimlerin eklenmesi, struct'lerin "
"tuple'lerden daha esnek olduğu anlamına gelir."

#: src/ch05-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call fields. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""
"Bir yapıyı tanımlamak için, struct anahtar kelimesini girer ve tüm yapıyı "
"adlandırırız. Bir yapıtın adı, birlikte gruplanan veri parçalarının önemini "
"tanımlamalıdır. Daha sonra, kıvırcık parantezlerin içinde, alan dediğimiz "
"veri parçalarının adlarını ve türlerini tanımlarız. Örneğin, Listeleme 5-1, "
"bir kullanıcı hesabı hakkındaki bilgileri depolayan bir yapıyı gösterir."

#: src/ch05-01-defining-and-instantiating-structs.md:20
msgid "<span class=\"caption\">Listing 5-1: A `User` struct definition</span>"
msgstr "span class=\"caption\">Listing 5-1: A User struct description/span>"

#: src/ch05-01-defining-and-instantiating-structs.md:22
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for "
"the type, and instances fill in that template with particular data to create "
"values of the type."
msgstr ""
"Tanımladıktan sonra bir struct kullanmak için, her bir alan için somut "
"değerler belirleyerek bu struct'un bir _instance_'sini oluşturuyoruz. "
"struct'un adını belirterek bir örnek oluşturuyoruz ve sonra _key: value_ "
"çiftleri içeren kıvırcık kelimeler ekliyoruz, burada anahtarlar alanların "
"isimleri ve diğer değerler gibi, bu alanlarda saklamak istediğimiz "
"verilerdir."

#: src/ch05-01-defining-and-instantiating-structs.md:25
msgid ""
"For example, we can declare two particular users as shown in Listing 5-2."
msgstr ""
"Örneğin, Listeleme 5-2'de gösterildiği gibi iki belirli kullanıcı ilan "
"edebiliriz."

#: src/ch05-01-defining-and-instantiating-structs.md:40
#: src/ch05-01-defining-and-instantiating-structs.md:43
#: src/ch05-01-defining-and-instantiating-structs.md:65
#: src/ch05-01-defining-and-instantiating-structs.md:101
#: src/ch05-01-defining-and-instantiating-structs.md:137
#: src/ch05-01-defining-and-instantiating-structs.md:182
#: src/ch05-01-defining-and-instantiating-structs.md:219
msgid "\"someusername123\""
msgstr "\"someusername123\" (İngilizce)."

#: src/ch05-01-defining-and-instantiating-structs.md:40
#: src/ch05-01-defining-and-instantiating-structs.md:43
#: src/ch05-01-defining-and-instantiating-structs.md:65
#: src/ch05-01-defining-and-instantiating-structs.md:101
#: src/ch05-01-defining-and-instantiating-structs.md:137
#: src/ch05-01-defining-and-instantiating-structs.md:182
#: src/ch05-01-defining-and-instantiating-structs.md:219
msgid "\"someone@example.com\""
msgstr "\"birisi@example.com\""

#: src/ch05-01-defining-and-instantiating-structs.md:49
msgid ""
"<span class=\"caption\">Listing 5-2: Creating two instances of the `User` "
"struct</span>"
msgstr ""
"span class=\"caption\">Listing 5-2: User struct/span> iki örnek oluşturma"

#: src/ch05-01-defining-and-instantiating-structs.md:51
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access `user1`'s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email` "
"field of a mutable `User` instance."
msgstr ""
"Bir yapılandırmadan belirli bir değer elde etmek için nokta notasyonu "
"kullanırız. Örneğin, user1 e-posta adresine erişmek için user1.email "
"kullanırız. Eğer örnek değiştirilebilirse, nokta notasyonu kullanarak ve "
"belirli bir alana atayarak bir değeri değiştirebiliriz. 5-3 listelemek, "
"email değişken User örneğindeki değerin nasıl değiştirileceğini gösterir."

#: src/ch05-01-defining-and-instantiating-structs.md:67
#: src/ch05-01-defining-and-instantiating-structs.md:103
#: src/ch05-01-defining-and-instantiating-structs.md:139
msgid "\"anotheremail@example.com\""
msgstr "\"başkaemail@example.com\""

#: src/ch05-01-defining-and-instantiating-structs.md:81
msgid ""
"<span class=\"caption\">Listing 5-3: Changing the value in the email field "
"of a `User` instance</span>"
msgstr ""
"span class=\"caption\">Listeleme 5-3: Bir Kullanıcı örneğinin e-posta "
"alanındaki değeri değiştirme/span>"

#: src/ch05-01-defining-and-instantiating-structs.md:83
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to "
"mark only certain fields as mutable."
msgstr ""
"Dikkat edin, bütün olay değiştirilebilir olmalıdır; Kahire sadece belirli "
"alanları değiştirilebilir olarak işaretlememize izin vermez."

#: src/ch05-01-defining-and-instantiating-structs.md:85
msgid ""
"As with any expression, we can construct a new instance of the struct as the "
"last expression in the function body to implicitly return that new instance."
msgstr ""
"Herhangi bir ifadede olduğu gibi, bu yeni örneği dolaylı olarak geri "
"döndürmek için fonksiyon gövdesindeki son ifade olarak strüktün yeni bir "
"örneğini oluşturabiliriz."

#: src/ch05-01-defining-and-instantiating-structs.md:87
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""
"Listeleme 5-4, verilen e-posta ve kullanıcı adı ile bir User örneği döndüren "
"bir build_user işlevi gösterir. active alanı true değerini alır ve "
"sign_in_count değeri 1 değerini alır."

#: src/ch05-01-defining-and-instantiating-structs.md:117
msgid ""
"<span class=\"caption\">Listing 5-4: A `build_user` function that takes an "
"email and username and returns a `User` instance.</span>"
msgstr ""
"span class=\"caption\">Listing 5-4: Bir e-posta ve kullanıcı adı alan ve bir "
"User örneği döndüren bir build_user işlevi./span>"

#: src/ch05-01-defining-and-instantiating-structs.md:119
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""
"Fonksiyon parametrelerini yapı alanları ile aynı isimle adlandırmak "
"mantıklıdır, ancak email ve username alan adlarını ve değişkenlerini "
"tekrarlamak zorunda kalmak biraz sıkıcıdır. Yapıtın daha fazla alanı "
"olsaydı, her ismi tekrarlamak daha da can sıkıcı olurdu. Neyse ki, uygun bir "
"kısa el var!"

#: src/ch05-01-defining-and-instantiating-structs.md:121
msgid "Using the Field Init Shorthand"
msgstr "Field Init Shorthand Kullanımı"

#: src/ch05-01-defining-and-instantiating-structs.md:123
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the field init shorthand syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 5-5."
msgstr ""
"Parametre adları ve yapı alanı adları Listeleme 5-4'te tam olarak aynı "
"olduğundan, build_user'ı yeniden yazmak için alanı init shorthand sözdizimi "
"kullanabiliriz, böylece tam olarak aynı davranır ancak Listeleme 5-5'te "
"gösterildiği gibi username ve email tekrarlarına sahip değildir."

#: src/ch05-01-defining-and-instantiating-structs.md:153
msgid ""
"<span class=\"caption\">Listing 5-5: A `build_user` function that uses field "
"init shorthand because the `username` and `email` parameters have the same "
"name as struct fields.</span>"
msgstr ""
"span class=\"caption\">Listeleme 5-5: username ve email parametreleri struct "
"alanları ile aynı isme sahip olduğu için field init shorthand kullanan bir "
"build_user fonksiyonu./span>"

#: src/ch05-01-defining-and-instantiating-structs.md:155
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""
"Burada, email adında bir alana sahip olan User yapısının yeni bir örneğini "
"oluşturuyoruz. email alanının değerini build_user işlevinin email "
"parametresindeki değere ayarlamak istiyoruz. email alanı ve email "
"parametresi aynı isme sahip olduğundan, email yerine email yazmamız "
"yeterlidir."

#: src/ch05-01-defining-and-instantiating-structs.md:157
msgid "Creating Instances from Other Instances with Struct Update Syntax"
msgstr "Struct Update Syntax ile Diğer Instances'lardan Instances Oluşturma"

#: src/ch05-01-defining-and-instantiating-structs.md:159
msgid ""
"It’s often useful to create a new instance of a struct that includes most of "
"the values from another instance, but changes some. You can do this using "
"_struct update syntax_."
msgstr ""
"Genellikle, başka bir örnekten gelen değerlerin çoğunu içeren, ancak "
"bazılarını değiştiren yeni bir yapılandırma örneği oluşturmak yararlıdır. "
"Bunu _struct güncelleme sözdizimi_ kullanarak yapabilirsiniz."

#: src/ch05-01-defining-and-instantiating-structs.md:163
msgid ""
"First, in Listing 5-6 we show how to create a new `User` instance in `user2` "
"regularly, without the update syntax. We set a new value for `email` but "
"otherwise use the same values from `user1` that we created in Listing 5-2."
msgstr ""
"İlk olarak, Listeleme 5-6'da, güncelleme sözdizimi olmadan user2'de düzenli "
"olarak yeni bir User örneğinin nasıl oluşturulacağını gösteririz. email için "
"yeni bir değer belirleriz, ancak Listeleme 5-2'de oluşturduğumuz user1 ile "
"aynı değerleri kullanırız."

#: src/ch05-01-defining-and-instantiating-structs.md:179
#: src/ch05-01-defining-and-instantiating-structs.md:216
msgid "// --snip--\n"
msgstr "// --snip--\n"

#: src/ch05-01-defining-and-instantiating-structs.md:188
#: src/ch05-01-defining-and-instantiating-structs.md:222
msgid "\"another@example.com\""
msgstr "\"başka@example.com\""

#: src/ch05-01-defining-and-instantiating-structs.md:197
msgid ""
"<span class=\"caption\">Listing 5-6: Creating a new `User` instance using "
"all but one of the values from `user1`</span>"
msgstr ""
"span class=\"caption\">Liste 5-6: user1/span> 'den gelen değerlerden birini "
"kullanarak yeni bir User örneği oluşturma"

#: src/ch05-01-defining-and-instantiating-structs.md:199
msgid ""
"Using struct update syntax, we can achieve the same effect with less code, "
"as shown in Listing 5-7. The syntax `..` specifies that the remaining fields "
"not explicitly set should have the same value as the fields in the given "
"instance."
msgstr ""
"Yapısal güncelleme sözdizimi kullanılarak, Listeleme 5-7'de gösterildiği "
"gibi, daha az kodla aynı etkiyi elde edebiliriz. Sözdizimi.., açıkça "
"ayarlanmamış kalan alanların, verilen örnekteki alanlarla aynı değere sahip "
"olması gerektiğini belirtir."

#: src/ch05-01-defining-and-instantiating-structs.md:229
msgid ""
"<span class=\"caption\">Listing 5-7: Using struct update syntax to set a new "
"`email` value for a `User` instance but to use the rest of the values from "
"`user1`</span>"
msgstr ""
"span class=\"caption\">Listeleme 5-7: Bir Kullanıcı örneği için yeni bir "
"email değeri ayarlamak için yapılandırma güncelleme sözdiziminin "
"kullanılması, ancak user1/span> 'den kalan değerlerin kullanılması"

#: src/ch05-01-defining-and-instantiating-structs.md:232
msgid ""
"The code in Listing 5-7 also creates an instance of `user2` that has a "
"different value for `email` but has the same values for the `username`, "
"`active`, and `sign_in_count` fields as `user1`. The `..user1` part must "
"come last to specify that any remaining fields should get their values from "
"the corresponding fields in `user1`, but we can choose to specify values for "
"as many fields as we want in any order, regardless of the order of the "
"fields in the struct’s definition."
msgstr ""
"Listeleme 5-7'deki kod, email için farklı bir değere sahip olan, ancak "
"username, active ve sign_in_count alanları için user1 ile aynı değerlere "
"sahip olan user2 örneğini de oluşturur..user1 bölümündeki tanım, kalan "
"alanların user1'deki karşılık gelen alanlardan kendi değerlerini almasını "
"istemek için son sırada gelmelidir, ancak user1user1'deki değerleri "
"seçebiliriz."

#: src/ch05-01-defining-and-instantiating-structs.md:240
msgid ""
"Note that the struct update syntax uses `=` like an assignment; this is "
"because it moves the data, just as we saw in the [\"Moving Values\"](ch04-01-"
"what-is-ownership.md#moving-values)<!-- ignore --> section. In this example, "
"we can no longer use `user1` as a whole after creating `user2` because the "
"`ByteArray` in the `username` field of `user1` was moved into `user2`. If we "
"had given `user2` new `ByteArray` values for both `email` and `username`, "
"and thus only used the `active` and `sign_in_count` values from `user1`, "
"then `user1` would still be valid after creating `user2`. Both `active` and "
"`sign_in_count` are types that implement the `Copy` trait, so the behavior "
"we discussed in the [\"`Copy` Trait\"](ch04-01-what-is-ownership.md#the-copy-"
"trait)<!-- ignore --> section would apply."
msgstr ""
"Yapıt güncelleme sözdiziminin = bir ödev gibi kullandığını unutmayın; bunun "
"nedeni, verileri, [\"Moving Values\"] [ch04-01-is-ownership.md#moving-"
"values] bölümünde gördüğümüz gibi, user1 değerini bir bütün olarak Byteray'i "
"oluşturduktan sonra, user2'yi kullanamayacağımızı belirtmektir."

#: src/ch05-01-defining-and-instantiating-structs.md:249
msgid "{{#quiz ../quizzes/ch05-01-defining-and-instantiating-structs.toml}}"
msgstr "#quiz../quizzes/ch05-01-defining-ve-intifiating-structs.toml"

#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr ""
"Yapıtları ne zaman kullanmak isteyebileceğimizi anlamak için, bir "
"dikdörtgenin alanını hesaplayan bir program yazalım. Tek değişkenler "
"kullanarak başlayacağız ve bunun yerine yapıtları kullanana kadar programı "
"yeniden düzenleyeceğiz."

#: src/ch05-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the "
"width and height of a rectangle specified in pixels and calculate the area "
"of the rectangle. Listing 5-8 shows a short program with one way of doing "
"exactly that in our project’s _src/lib.cairo_."
msgstr ""
"Scarb ile piksel cinsinden belirtilen bir dikdörtgenin genişliğini ve "
"yüksekliğini alacak ve dikdörtgenin alanını hesaplayacak _rectangles_ adlı "
"yeni bir proje yapalım. 5-8'i listelemek, projemizin _src/lib.cairo_ "
"bölümünde tam olarak bunu yapmanın bir yolu olan kısa bir programı gösterir."

#: src/ch05-02-an-example-program-using-structs.md:14
#: src/ch05-02-an-example-program-using-structs.md:56
#: src/ch05-02-an-example-program-using-structs.md:86
#: src/ch05-03-method-syntax.md:28 src/ch05-03-method-syntax.md:70
msgid "\"Area is {}\""
msgstr "\"Area is \" (İngilizce)."

#: src/ch05-02-an-example-program-using-structs.md:22
msgid ""
"<span class=\"caption\">Listing 5-8: Calculating the area of a rectangle "
"specified by separate width and height variables.</span>"
msgstr ""
"span class=\"caption\">Listeleme 5-8: Ayrı genişlik ve yükseklik "
"değişkenleriyle belirtilen bir dikdörtgenin alanını hesaplamak./span>"

#: src/ch05-02-an-example-program-using-structs.md:24
msgid "Now run the program with `scarb cairo-run`:"
msgstr "Şimdi scarb cairo-run ile programı çalıştırın:"

#: src/ch05-02-an-example-program-using-structs.md:36
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr ""
"Bu kod, her boyuttaki area fonksiyonunu çağırarak dikdörtgenin alanını "
"bulmayı başarır, ancak bu kodu net ve okunabilir hale getirmek için daha "
"fazlasını yapabiliriz."

#: src/ch05-02-an-example-program-using-structs.md:38
msgid "The issue with this code is evident in the signature of `area`:"
msgstr "Bu kodla ilgili sorun area imzasında açıkça görülmektedir:"

#: src/ch05-02-an-example-program-using-structs.md:44
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our "
"program that the parameters are related. It would be more readable and more "
"manageable to group width and height together. We’ve already discussed one "
"way we might do that in the [Tuple Section of Chapter 2](ch02-02-data-types."
"html#the-tuple-type)."
msgstr ""
"area işlevinin bir dikdörtgenin alanını hesaplaması gerekir, ancak "
"yazdığımız fonksiyonun iki parametresi vardır ve programımızın hiçbir "
"yerinde parametrelerin ilgili olduğu net değildir. Grup genişliği ve "
"yüksekliği birlikte daha okunabilir ve daha yönetilebilir olurdu. Bunu "
"[Bölüm 2'nin Tuple Bölümünde] (ch02-02-data-types.html#the-tuple-type) "
"yapabiliriz."

#: src/ch05-02-an-example-program-using-structs.md:46
msgid "Refactoring with Tuples"
msgstr "Tuples ile refactoring"

#: src/ch05-02-an-example-program-using-structs.md:48
msgid "Listing 5-9 shows another version of our program that uses tuples."
msgstr ""
"5-9'u listelemek, programımızın tuples kullanan başka bir sürümünü gösterir."

#: src/ch05-02-an-example-program-using-structs.md:65
msgid ""
"<span class=\"caption\">Listing 5-9: Specifying the width and height of the "
"rectangle with a tuple.</span>"
msgstr ""
"span class=\"caption\">Listing 5-9: Dikdörtgenin genişliğini ve yüksekliğini "
"bir tuple ile belirtmek./span>"

#: src/ch05-02-an-example-program-using-structs.md:67
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is "
"less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""
"Bir bakıma, bu program daha iyi. Tuples biraz yapı ekleyelim ve şimdi sadece "
"bir argümanı geçiyoruz. Ancak başka bir şekilde, bu sürüm daha az açıktır: "
"tuples elementlerini adlandırmıyor, bu yüzden tuple'ın parçalarına "
"endekslenmemiz gerekiyor, böylece hesaplamamız daha az belirgin hale geliyor."

#: src/ch05-02-an-example-program-using-structs.md:69
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but "
"if we want to calculate the difference, it would matter! We would have to "
"keep in mind that `width` is the tuple index `0` and `height` is the tuple "
"index `1`. This would be even harder for someone else to figure out and keep "
"in mind if they were to use our code. Because we haven’t conveyed the "
"meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""
"Genişliği ve yüksekliği karıştırmak alan hesaplaması için önemli olmazdı, "
"ancak farkı hesaplamak istiyorsak, önemli olurdu! width'nin tuple indeksi 0 "
"ve height'nin tuple indeksi 1 olduğunu akılda tutmak zorundayız. Bu, bir "
"başkasının kodumuzu kullanması durumunda hatalarını anlaması ve akılda "
"tutması daha da zor olurdu. Çünkü şimdi kodumuzun anlamını iletmedik."

#: src/ch05-02-an-example-program-using-structs.md:71
msgid "Refactoring with Structs: Adding More Meaning"
msgstr "Structs ile Refactoring: Daha Fazla Anlam Eklemek"

#: src/ch05-02-an-example-program-using-structs.md:73
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts."
msgstr ""
"Verileri etiketleyerek anlam eklemek için yapılar kullanıyoruz. "
"Kullandığımız tümülü, parçaların adları kadar bütün için de bir isim olan "
"bir yapıya dönüştürebiliriz."

#: src/ch05-02-an-example-program-using-structs.md:94
msgid ""
"<span class=\"caption\">Listing 5-10: Defining a `Rectangle` struct.</span>"
msgstr ""
"span class=\"caption=\"Listing 5-10: Defining a Rectangle struct./span> "
"(İngilizce)."

#: src/ch05-02-an-example-program-using-structs.md:96
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u64`. Then, in `main`, we created a particular instance of `Rectangle` "
"that has a width of `30` and a height of `10`. Our `area` function is now "
"defined with one parameter, which we’ve named `rectangle` which is of type "
"`Rectangle` struct. We can then access the fields of the instance with dot "
"notation, and it gives descriptive names to the values rather than using the "
"tuple index values of `0` and `1`."
msgstr ""
"Burada bir yapı tanımladık ve ona Rectangle adını verdik. Kıvırcık parantez "
"içinde, alanları width ve height olarak tanımladık, her ikisi de u64 tipine "
"sahip olan alanlar. Sonra, main cinsinden, 30 genişliğinde ve 10 "
"yüksekliğinde olmayan belirli bir Rectangle dizisi oluşturduk. area "
"fonksiyonu"

#: src/ch05-02-an-example-program-using-structs.md:98
msgid "{{#quiz ../quizzes/ch05-02-an-example-program-using-structs.toml}}"
msgstr "#quiz../quizzes/ch05-02-an-example-program-using-structs.toml"

#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a name, they can have parameters and a return value, and they contain "
"some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a struct (or an enum "
"which we cover in [Chapter 6](./ch06-01-enums.md)), and their first "
"parameter is always `self`, which represents the instance of the type the "
"method is being called on."
msgstr ""
"_Methods_ fonksiyonlara benzer: onları fn anahtar kelimesi ve bir isimle "
"beyan ediyoruz, parametrelere ve bir dönüş değerine sahip olabilirler ve "
"yöntem başka bir yerden çağrıldığında çalışan bazı kodlar içerirler. "
"Fonksiyonların aksine, yöntemler bir yapı (veya [Bölüm 6] (./ch06-01-enums."
"md olarak adlandırılan) bağlamında tanımlanır ve her zaman ilk parametredir."

#: src/ch05-03-method-syntax.md:5
msgid "Defining Methods"
msgstr "Tanımlama Yöntemleri"

#: src/ch05-03-method-syntax.md:7
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter and instead make an `area` method defined on the `Rectangle` "
"struct, as shown in Listing 5-11"
msgstr ""
"Bir Rectangle örneğine sahip olan area fonksiyonunu parametre olarak "
"değiştirelim ve bunun yerine Listeleme 5-11'de gösterildiği gibi Rectangle "
"yapısında tanımlanan bir area yöntemi yapalım."

#: src/ch05-03-method-syntax.md:32
msgid "Listing 5-11: Defining an `area` method on the `Rectangle` struct."
msgstr "Listeleme 5-11: Rectangle yapısında bir area yönteminin tanımlanması."

#: src/ch05-03-method-syntax.md:34
msgid ""
"To define the function within the context of `Rectangle`, we start an `impl` "
"(implementation) block for a trait `RectangleTrait` that defines the methods "
"that can be called on a `Rectangle` instance. As impl blocks can only be "
"defined for traits and not types, we need to define this trait first - but "
"it's not meant to be used for anything else."
msgstr ""
"Rectangle bağlamında fonksiyonu tanımlamak için, bir RectangleTrait özelliği "
"için bir impl (uygulama) bloğu başlatırız. Bu, Rectangle örneğinde "
"çağrılabilecek yöntemleri tanımlar. İmpl blokları sadece özellikler için "
"tanımlanabilir ve türler için değil, bu özelliği ilk olarak tanımlamamız "
"gerekir - ancak başka bir şey için kullanılması amaçlanmamıştır."

#: src/ch05-03-method-syntax.md:36
msgid ""
"Everything within this `impl` block will be associated with the `Rectangle` "
"type. Then we move the `area` function within the `impl` curly brackets and "
"change the first (and in this case, only) parameter to be `self` in the "
"signature and everywhere within the body. In `main`, where we called the "
"`area` function and passed `rect1` as an argument, we can instead use "
"_method syntax_ to call the `area` method on our `Rectangle` instance. The "
"method syntax goes after an instance: we add a dot followed by the method "
"name, parentheses, and any arguments."
msgstr ""
"Bu impl bloğundaki her şey Rectangle türü ile ilişkilendirilecektir. Sonra "
"impl kıvırcık parantez içindeki area fonksiyonunu hareket ettirip ilk (ve bu "
"durumda, sadece) parametreyi self olarak imzaya ve vücudumuzun her yerine "
"ekleriz. main'de, area fonksiyonu dediğimiz ve rect1'i bir argüman olarak "
"geçtiğimiz main."

#: src/ch05-03-method-syntax.md:38
msgid ""
"In the signature for `area`, we use `self: @Rectangle` instead of "
"`rectangle: @Rectangle`. Methods must have a parameter named `self`, for "
"their first parameter, and the type of `self` indicates the type that method "
"can be called on. Methods can take ownership of `self`, but `self` can also "
"be passed by snapshot or by reference, just like any other parameter."
msgstr ""
"area için imzada self: @Rectangle yerine rectangle kullanıyoruz. Yöntemler, "
"ilk parametreleri için self adında bir parametreye sahip olmalıdır ve self "
"türü, yöntemin çağrılabileceği türe işaret eder. Yöntemler self'in "
"mülkiyetini alabilir, ancak self aynı zamanda anlık görüntü veya başka bir "
"parametre ile de geçebilir."

#: src/ch05-03-method-syntax.md:41
msgid ""
"There is no direct link between a type and a trait. Only the type of the "
"`self` parameter of a method defines the type from which this method can be "
"called. That means, it is technically possible to define methods on multiple "
"types in a same trait (mixing `Rectangle` and `Circle` methods, for "
"example). But **this is not a recommended practice** as it can lead to "
"confusion."
msgstr ""
"Bir tür ve bir özellik arasında doğrudan bir bağlantı yoktur. Sadece bir "
"yöntemin self parametresi türü, bu yöntemin adlandırılabileceği türü "
"tanımlar. Bu, aynı özellikte birden fazla türdeki yöntemleri tanımlamak "
"teknik olarak mümkün olduğu anlamına gelir (örneğin Rectangle ve Circle "
"yöntemlerini karıştırmak). Ancak ** Bu, karışıklığa yol açabileceği için "
"önerilen bir uygulama değildir**."

#: src/ch05-03-method-syntax.md:43
msgid ""
"The main reason for using methods instead of functions, in addition to "
"providing method syntax, is for organization. We’ve put all the things we "
"can do with an instance of a type in one `impl` block rather than making "
"future users of our code search for capabilities of `Rectangle` in various "
"places in the library we provide."
msgstr ""
"Fonksiyonlar yerine yöntemler kullanmanın temel nedeni, yöntem sözdizimi "
"sağlamanın yanı sıra, organizasyon içindir. Sunduğumuz kütüphanede çeşitli "
"yerlerde Rectangle kod arama yeteneklerinin gelecekteki kullanıcılarını "
"yapmak yerine, bir impl bloğunda bir tür örneğiyle yapabileceğimiz her şeyi "
"koyduk."

#: src/ch05-03-method-syntax.md:45
msgid "The `generate_trait` Attribute"
msgstr "genate_trait Özniteliği"

#: src/ch05-03-method-syntax.md:47
msgid ""
"If you are familiar with Rust, you may find Cairo's approach confusing "
"because methods cannot be defined directly on types. Instead, you must "
"define a [trait](./ch08-02-traits-in-cairo.md) and an implementation of this "
"trait associated with the type for which the method is intended. However, "
"defining a trait and then implementing it to define methods on a specific "
"type is verbose, and unnecessary: the trait itself will not be reused."
msgstr ""
"Rust'a aşinaysanız, Kahire'nin yaklaşımını kafa karıştırıcı bulabilirsiniz, "
"çünkü yöntemler doğrudan türler üzerinde tanımlanamaz. Bunun yerine, bir "
"[trait] (./ch08-02-traits-in-cairo.md) ve bu özelliğin, yöntemin amaçlandığı "
"türle ilişkili bir uygulamasını tanımlamanız gerekir. Bununla birlikte, bir "
"özelliği tanımlamak ve belirli bir türdeki yöntemleri tanımlamak için "
"uygulamak fiilidir ve gereksizdir: özelliğin kendisi yeniden "
"kullanılmayacaktır."

#: src/ch05-03-method-syntax.md:50
msgid ""
"So, to avoid defining useless traits, Cairo provides the `#[generate_trait]` "
"attribute to add above a trait implementation, which tells to the compiler "
"to generate the corresponding trait definition for you, and let's you focus "
"on the implementation only. Both approaches are equivalent, but it's "
"considered a best practice to not explicitly define traits in this case."
msgstr ""
"Bu nedenle, işe yaramaz özellikleri tanımlamaktan kaçınmak için, Kahire, bir "
"özellik uygulamasının üzerine eklemek için #[genate_trait] özniteliğini "
"sağlar, bu da derleyiciye sizin için karşılık gelen özellik tanımını "
"üretmesini söyler ve sadece uygulamaya odaklanalım. Her iki yaklaşım da "
"eşdeğerdir, ancak bu durumda özellikleri açıkça tanımlamamak için en iyi "
"uygulama olarak kabul edilir."

#: src/ch05-03-method-syntax.md:52
msgid "The previous example can also be written as follows:"
msgstr "Bir önceki örnek de şu şekilde yazılabilir:"

#: src/ch05-03-method-syntax.md:75
msgid ""
"Let's use this `#[generate_trait]` in the following chapters to make our "
"code cleaner."
msgstr ""
"#[genate_trait] kodumuzu daha temiz hale getirmek için sonraki bölümlerde "
"kullanalım."

#: src/ch05-03-method-syntax.md:77
msgid "Snapshots and References"
msgstr "Snapshots ve Referanslar"

#: src/ch05-03-method-syntax.md:79
msgid ""
"As the `area` method does not modify the calling instance, `self` is "
"declared as a snapshot of a `Rectangle` instance with the `@` snapshot "
"operator. But, of course, we can also define some methods receiving a "
"mutable reference of this instance, to be able to modify it."
msgstr ""
"area yöntemi çağrı örneğini değiştirmediği için self,  snapshot operatörü "
"ile bir Rectangle örneğinin anlık görüntüsü olarak ilan edilir. Ancak, tabii "
"ki, bu örnekte değiştirilebilen bir referans alan bazı yöntemleri de "
"tanımlayabiliriz."

#: src/ch05-03-method-syntax.md:81
msgid ""
"Let's write a new method `scale` which resizes a rectangle of a `factor` "
"given as parameter:"
msgstr ""
"Parametre olarak verilen bir \"faktör\"ün dikdörtgenini yeniden "
"boyutlandıran yeni bir yöntem scale yazalım:"

#: src/ch05-03-method-syntax.md:98
msgid "\"The new size is (width: {}, height: {})\""
msgstr "\"Yeni boyut (genişlik:, yükseklik: )\""

#: src/ch05-03-method-syntax.md:102
msgid ""
"It is also possible to define a method which takes ownership of the instance "
"by using just `self` as the first parameter but it is rare. This technique "
"is usually used when the method transforms `self` into something else and "
"you want to prevent the caller from using the original instance after the "
"transformation."
msgstr ""
"İlk parametre olarak sadece self kullanarak örneğin mülkiyetini alan bir "
"yöntemi tanımlamak da mümkündür, ancak nadirdir. Bu teknik genellikle yöntem "
"self'yi başka bir şeye dönüştürdüğünde ve dönüşümden sonra arayanın orijinal "
"örneği kullanmasını önlemek istediğinizde kullanılır."

#: src/ch05-03-method-syntax.md:104
msgid ""
"Look at the [Understanding Ownership](ch04-00-understanding-ownership.md) "
"chapter for more details about these important notions."
msgstr ""
"Bu önemli kavramlar hakkında daha fazla ayrıntı için [Anlayışlı Sahiplik] "
"(ch04-00-anlayışlı sahiplik.md) bölümüne bakın."

#: src/ch05-03-method-syntax.md:106
msgid "Methods with Several Parameters"
msgstr "Çeşitli Parametrelerle Yöntemler"

#: src/ch05-03-method-syntax.md:108
msgid ""
"Let’s practice using methods by implementing another method on the "
"`Rectangle` struct. This time we want to write the method `can_hold` which "
"accepts another instance of `Rectangle` and returns `true` if this rectangle "
"can fit completely within self; otherwise, it should return false."
msgstr ""
"Rectangle yapısı üzerinde başka bir yöntem uygulayarak yöntemleri "
"uygulayalım. Bu sefer Rectangle'ın başka bir örneğini kabul eden ve true "
"döndüren can_hold yöntemini yazmak istiyoruz; aksi takdirde, yanlış "
"dönmelidir."

#: src/ch05-03-method-syntax.md:132
msgid "\"Can rect1 hold rect2? {}\""
msgstr "\"Rekt1 rekt2'yi tutabilir mi?\""

#: src/ch05-03-method-syntax.md:133
msgid "\"Can rect1 hold rect3? {}\""
msgstr "\"Rekt1 rekt3'ü tutabilir mi? \""

#: src/ch05-03-method-syntax.md:137
msgid "Here, we expect that `rect1` can hold `rect2` but not `rect3`."
msgstr ""
"Burada, rect1'in rect2'yi tutabileceğini, ancak rect3'yi tutamayacağını "
"bekliyoruz."

#: src/ch05-03-method-syntax.md:139
msgid "Associated functions"
msgstr "İlişkili fonksiyonlar"

#: src/ch05-03-method-syntax.md:141
msgid ""
"We call _associated functions_ all functions that are defined inside an "
"`impl` block that are associated to a specific type. While this is not "
"enforced by the compiler, it is a good practice to keep associated functions "
"related to the same type in the same `impl` block - for example, all "
"functions related to `Rectangle` will be grouped in the same `impl` block "
"for `RectangleTrait`."
msgstr ""
"Belirli bir tiple ilişkili bir impl bloğu içinde tanımlanan tüm "
"fonksiyonlara _ilişkili fonksiyonlar_ diyoruz. Bu, derleyici tarafından "
"uygulanmazken, aynı impl bloğunda aynı tiple ilgili işlevlerin tutulması iyi "
"bir uygulamadır - örneğin, Rectangle ile ilgili tüm işlevler RectangleTrai "
"için aynı impl bloğunda gruplandırılacaktır."

#: src/ch05-03-method-syntax.md:143
msgid ""
"Methods are a special kind of associated function, but we can also define "
"associated functions that don’t have `self` as their first parameter (and "
"thus are not methods) because they don’t need an instance of the type to "
"work with, but are still associated with that type."
msgstr ""
"Yöntemler özel bir tür ilişkili fonksiyondur, ancak kendine sahip olmayan "
"ilişkili işlevleri de ilk parametreleri olarak tanımlayabiliriz (ve bu "
"nedenle yöntemler değildir) çünkü çalışmak için türün bir örneğine ihtiyaç "
"duymazlar, ancak yine de bu türle ilişkilidirler."

#: src/ch05-03-method-syntax.md:145
msgid ""
"Associated functions that aren’t methods are often used for constructors "
"that will return a new instance of the type. These are often called `new`, "
"but `new` isn’t a special name and isn’t built into the language. For "
"example, we could choose to provide an associated function named `square` "
"that would have one dimension parameter and use that as both width and "
"height, thus making it easier to create a square `Rectangle` rather than "
"having to specify the same value twice:"
msgstr ""
"Yöntem olmayan ilişkili işlevler genellikle türün yeni bir örneğini "
"döndürecek konstrüktörler için kullanılır. Bunlar genellikle new olarak "
"adlandırılır, ancak new özel bir ad değildir ve dile yerleşik değildir. "
"Örneğin, bir boyut parametresine sahip olacak ve aynı genişlik ve yükseklik "
"yerine iki kez aynı değeri kullanacak olan square adlı ilişkili bir işlev "
"sağlamayı seçebiliriz: böylece kare Rectangle'ı oluşturmayı kolaylaştırır"

#: src/ch05-03-method-syntax.md:153
msgid ""
"Let's create the function `new` which creates a `Rectangle` from a `width` "
"and a `height`, `square` which creates a square `Rectangle` from a `size` "
"and `avg` which computes the average of two `Rectangle` instances:"
msgstr ""
"Bir width'den bir Rectangle ve bir height, square'den bir kare Rectangle "
"oluşturan bir new ve avg'den iki Rectangle örneğinin ortalamasını hesaplayan "
"New fonksiyonunu oluşturalım:"

#: src/ch05-03-method-syntax.md:182
msgid "\"The average Rectangle of {:?} and {:?} is {:?}\""
msgstr "\":? ve :?'nin ortalama dikdörtgeni :?'dir.\""

#: src/ch05-03-method-syntax.md:190
msgid ""
"To call the `square` associated function, we use the `::` syntax with the "
"struct name; `let sq = Rectangle::square(3);` is an example. This function "
"is namespaced by the struct: the `::` syntax is used for both associated "
"functions and namespaces created by modules. We’ll discuss modules in "
"[Chapter 7](./ch07-02-defining-modules-to-control-scope.md)."
msgstr ""
"square ilişkili fonksiyonu aramak için : struct adı ile sözdizimi; let sq = "
"Dikdörtgen:::square(3); bir örnektir. Bu fonksiyon, struct tarafından "
"aralıklı isimlerdir: :: sözdizimi, modüller tarafından oluşturulan hem "
"ilişkili işlevler hem de ad uzayları için kullanılır. [Bölüm 7](./ch07-02-"
"defind-modul)'de modülleri tartışacağız."

#: src/ch05-03-method-syntax.md:196
msgid ""
"Note that the `avg` function could also be written as a method with `self` "
"as the first rectangle. In this case, instead of using the method with "
"`RectangleTrait::avg(@rect1, @rect2)`, it would be called with `rect1."
"avg(rect2)`."
msgstr ""
"avg fonksiyonunun ilk dikdörtgen olarak self ile de bir yöntem olarak "
"yazılabileceğini unutmayın. Bu durumda, RectangleTrait::avg(@retct1, @ret2) "
"metodunu kullanmak yerine rect1.avg(rect2) ile çağrılacaktır."

#: src/ch05-03-method-syntax.md:198
msgid "Multiple Traits and `impl` Blocks"
msgstr "Birden fazla özellik ve impl Blokları"

#: src/ch05-03-method-syntax.md:200
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For "
"example, the following code is equivalent to the code shown in the _Methods "
"with several parameters_ section, which has each method in its own `trait` "
"and `impl` blocks."
msgstr ""
"Her strüktün birden fazla trait ve impl bloklarına sahip olmasına izin "
"verilir. Örneğin, aşağıdaki kod, kendi trait ve impl bloklarında her bir "
"yönteme sahip olan birkaç parametre_ bölümü olan _Method'larda gösterilen "
"koda eşdeğerdir."

#: src/ch05-03-method-syntax.md:219
msgid ""
"There’s no strong reason to separate these methods into multiple `trait` and "
"`impl` blocks here, but this is valid syntax."
msgstr ""
"Bu yöntemleri burada çoklu trait ve impl bloklarına ayırmak için güçlü bir "
"neden yoktur, ancak bu geçerli bir sözdizimidir."

#: src/ch05-03-method-syntax.md:222
msgid "{{#quiz ../quizzes/ch05-03-method-syntax.toml}}"
msgstr "#quiz../quizzes/ch05-03-method-syntax.toml"

#: src/ch06-00-enums-and-pattern-matching.md
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. "
"Enums allow you to define a type by enumerating its possible _variants_. "
"First, we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called "
"`Option`, which expresses that a value can be either something or nothing. "
"Finally, we’ll look at how pattern matching in the `match` expression makes "
"it easy to run different code for different values of an enum."
msgstr ""
"Bu bölümde, _enums_ olarak da adlandırılan _enumerations_'a bakacağız. "
"Enumlar, olası _variants_'ını numaralandırarak bir türü tanımlamanıza izin "
"verir. İlk olarak, bir enum'un veri ile birlikte anlamı nasıl "
"kodlayabileceğini göstermek için bir enum tanımlayacağız ve kullanacağız. "
"Daha sonra, bir değerin bir şey veya hiçbir şey olabileceğini ifade eden "
"Option olarak adlandırılan özellikle farklı bir enum'u keşfedeceğiz."

#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type "
"that consists of a fixed set of named values, called _variants_. Enums are "
"useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""
"Enums, \"enumerations\" kelimesinin kısaltması, _variants_ olarak "
"adlandırılan sabit bir dizi adlandırılmış değerden oluşan özel bir veri "
"türünü tanımlamanın bir yoludur. Enums, her değerin ayrı olduğu ve belirli "
"bir anlamı olduğu ilgili değerlerin bir koleksiyonunu temsil etmek için "
"kullanışlıdır."

#: src/ch06-01-enums.md:5
msgid "Enum Variants and Values"
msgstr "Enum Çeşitleri ve Değerleri"

#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr "İşte bir enum'un basit bir örneği:"

#: src/ch06-01-enums.md:19
msgid ""
"In this example, we've defined an enum called `Direction` with four "
"variants: `North`, `East`, `South`, and `West`. The naming convention is to "
"use PascalCase for enum variants. Each variant represents a distinct value "
"of the `Direction` type. In this particular example, variants don't have any "
"associated value. One variant can be instantiated using this syntax:"
msgstr ""
"Bu örnekte, Direction adlı bir enum'u dört varyantla tanımladık: North, "
"East, South ve West. Adlandırma kuralı, PascalCase'i enum varyantları için "
"kullanmaktır. Her varyant, Direction tipinin farklı bir değerini temsil "
"eder. Bu özel örnekte, varyantların herhangi bir ilişkili değeri yoktur. Bir "
"varyant, bu sözdisyonu kullanarak hazırlanabilir:"

#: src/ch06-01-enums.md:36
msgid ""
"Now let's imagine that our variants have associated values, that store the "
"exact degree of the direction. We can define a new `Direction` enum:"
msgstr ""
"Şimdi varyantlarımızın, yönün tam derecesini depolayan ilişkili değerlere "
"sahip olduğunu varsayalım. Yeni bir Direction enum tanımlayabiliriz:"

#: src/ch06-01-enums.md:52
msgid "and instantiate it as follows:"
msgstr "ve şu şekilde anons edin:"

#: src/ch06-01-enums.md:68
msgid ""
"In this code, each variant is associated with a `u128` value, representing "
"the direction in degrees. In the next example, we will see that it is also "
"possible to associate different data types with each variant."
msgstr ""
"Bu kodda, her varyant, derece yönünü temsil eden bir u128 değeri ile "
"ilişkilidir. Bir sonraki örnekte, farklı veri türlerini her varyantla "
"ilişkilendirmenin de mümkün olduğunu göreceğiz."

#: src/ch06-01-enums.md:70
msgid ""
"It's easy to write code that acts differently depending on the variant of an "
"enum instance, in this example to run specific code according to a "
"direction. You can learn more about it in the [Match Control Flow Construct]"
"(./ch06-02-the-match-control-flow-construct.md) section."
msgstr ""
"Bir enum örneğinin varyantına bağlı olarak farklı davranan kod yazmak "
"kolaydır, bu örnekte belirli kodu bir yöne göre çalıştırmak için. [Match "
"Control Flow Construct](./ch06-02-the-match-control-flow-construct.md) "
"bölümünde bu konuda daha fazla bilgi edinebilirsiniz."

#: src/ch06-01-enums.md:74
msgid "Enums Combined with Custom Types"
msgstr "Özel Tiplerle Birleştirilmiş Enumlar"

#: src/ch06-01-enums.md:76
msgid ""
"Enums can also be used to store more interesting custom data associated with "
"each variant. For example:"
msgstr ""
"Enumlar, her varyantla ilişkili daha ilginç özel verileri depolamak için de "
"kullanılabilir. Örneğin:"

#: src/ch06-01-enums.md:87
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo`, and "
"`Move`, all with different types:"
msgstr ""
"Bu örnekte, Message enum'un üç varyantı vardır: Quit, Echo ve Move, hepsi "
"farklı tiptedir:"

#: src/ch06-01-enums.md:89
msgid "`Quit` doesn't have any associated value."
msgstr "Quit'nin herhangi bir ilişkili değeri yoktur."

#: src/ch06-01-enums.md:90
msgid "`Echo` is a single `felt252`."
msgstr "Echo tek bir felt252 dir."

#: src/ch06-01-enums.md:91
msgid "`Move` is a tuple of two `u128` values."
msgstr "Move iki u128 değerinden oluşur."

#: src/ch06-01-enums.md:93
msgid ""
"You could even use a Struct or another enum you defined inside one of your "
"enum variants."
msgstr ""
"Enum varyantlarınızdan birinin içinde tanımladığınız bir Struct veya başka "
"bir enum bile kullanabilirsiniz."

#: src/ch06-01-enums.md:95
msgid "Trait Implementations for Enums"
msgstr "Enumlar için Trait Uygulamaları"

#: src/ch06-01-enums.md:97
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. "
"This allows you to define methods and behaviors associated with the enum. "
"Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""
"Kahire'de, özellikleri tanımlayabilir ve bunları özel enumlarınız için "
"uygulayabilirsiniz. Bu, enum ile ilişkili yöntemleri ve davranışları "
"tanımlamanızı sağlar. İşte bir özelliği tanımlamanın ve önceki Message enum "
"için uygulamanın bir örneği:"

#: src/ch06-01-enums.md:107 src/ch06-01-enums.md:133
msgid "\"quitting\""
msgstr "\"tavsiye\""

#: src/ch06-01-enums.md:108 src/ch06-01-enums.md:134
msgid "\"echoing {}\""
msgstr "\"Echoing \""

#: src/ch06-01-enums.md:109 src/ch06-01-enums.md:135
msgid "\"moving from {} to {}\""
msgstr "\"'dan 'ya geçiş\""

#: src/ch06-01-enums.md:115
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here "
"is how it could be used to process a Quit message:"
msgstr ""
"Bu örnekte, Message için Processing özelliğini uyguladık. İşte bir Çıkış "
"iletisini işlemek için nasıl kullanılabileceği:"

#: src/ch06-01-enums.md:147
msgid "Running this code would print `quitting`."
msgstr "Bu kodu çalıştırmak quitting yazdırır."

#: src/ch06-01-enums.md:149
msgid "The `Option` Enum and Its Advantages"
msgstr "Seçenek Enum ve Avantajları"

#: src/ch06-01-enums.md:151
msgid ""
"The `Option` enum is a standard Cairo enum that represents the concept of an "
"optional value. It has two variants: `Some: T` and `None`. `Some: T` "
"indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr ""
"Option enum, isteğe bağlı bir değer kavramını temsil eden standart bir "
"Kahire enumudur. İki varyantı vardır: Some: T ve None. Some: T, T tipinin "
"bir değeri olduğunu belirtirken, None bir değerin yokluğunu temsil eder."

#: src/ch06-01-enums.md:160
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent "
"the possibility of a value being absent, making your code more expressive "
"and easier to reason about. Using `Option` can also help prevent bugs caused "
"by using uninitialized or unexpected `null` values."
msgstr ""
"Option enum, bir değerin eksik olma olasılığını açıkça temsil etmenize izin "
"verdiği için yararlıdır, kodunuzu daha etkileyici ve daha kolay akla "
"getirir. Option kullanmak, başlatılmamış veya beklenmedik null değerlerinin "
"kullanılmasının neden olduğu hataların önlenmesine de yardımcı olabilir."

#: src/ch06-01-enums.md:162
msgid ""
"To give you an example, here is a function which returns the index of the "
"first element of an array with a given value, or `None` if the element is "
"not present."
msgstr ""
"Size bir örnek vermek gerekirse, burada bir dizinin ilk elemanının endeksini "
"belirli bir değerle döndüren bir fonksiyon var, ya da eğer eleman yoksa None."

#: src/ch06-01-enums.md:164
msgid "We are demonstrating two approaches for the above function:"
msgstr "Yukarıdaki fonksiyon için iki yaklaşım gösteriyoruz:"

#: src/ch06-01-enums.md:166
msgid "Recursive approach with `find_value_recursive`."
msgstr "find_value_recursive ile tekrarlayıcı yaklaşım."

#: src/ch06-01-enums.md:167
msgid "Iterative approach with `find_value_iterative`."
msgstr "find_value_iterative ile iteratif yaklaşım."

#: src/ch06-01-enums.md:199
msgid ""
"Enums can be useful in many situations, especially when using the `match` "
"flow construct that we just used. We will describe it in the next section."
msgstr ""
"Enumlar birçok durumda yararlı olabilir, özellikle de yeni kullandığımız "
"match akış yapısını kullanırken. Bir sonraki bölümde açıklayacağız."

#: src/ch06-01-enums.md:201
msgid ""
"Other enums are used very often, such as the `Result` enum, allowing to "
"handle errors gracefully. We will explain the `Result` enum in detail in the "
"[\"Error Handling\"](./ch09-02-recoverable-errors.md#the-result-enum) "
"chapter."
msgstr ""
"Diğer enumlar çok sık kullanılır, örneğin Result enum, hataları zarifçe "
"işlemeye izin verir. Result enum'u [\"Hata Taşıma\"] (./ch09-02-geri "
"kazanılabilir-hatalar.md#the-result-enum) bölümünde ayrıntılı olarak "
"açıklayacağız."

#: src/ch06-01-enums.md:203
msgid "{{#quiz ../quizzes/ch06-01-enums.toml}}"
msgstr "#quiz../quizzes/ch06-01-enums.toml"

#: src/ch06-02-the-match-control-flow-construct.md:3
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of "
"`match` comes from the expressiveness of the patterns and the fact that the "
"compiler confirms that all possible cases are handled."
msgstr ""
"Kahire, bir dizi örüntüye karşı bir değer karşılaştırmasına ve ardından "
"hangi örüntünün eşleştiğine göre kod çalıştırmaya izin veren match adlı son "
"derece güçlü bir kontrol akışı yapısına sahiptir. Desenler, gerçek "
"değerlerden, değişken isimlerden, joker kartlarından ve daha birçok şeyden "
"oluşabilir. match'nin gücü, kalıpların ifade edilmesinden ve derleyicinin "
"olası tüm vakaların ele alındığını doğruladığı gerçeğinden gelir."

#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Think of a `match` expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the "
"value “fits”, the value falls into the associated code block to be used "
"during execution."
msgstr ""
"Bir match ifadesini bir madeni para sayma makinesi gibi düşünün: madeni "
"paralar, üzerinde çeşitli büyüklükte delikler bulunan bir parçadan aşağı "
"doğru kayar ve her madeni para, karşılaştığı ilk delikten düşer. Aynı "
"şekilde, değerler bir maçta her bir desenden geçer ve ilk desende değer "
"\"uygun\" olur, değer, yürütme sırasında kullanılacak ilişkili kod bloğuna "
"düşer."

#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Speaking of coins, let’s use them as an example using `match`! We can write "
"a function that takes an unknown US coin and, in a similar way as the "
"counting machine, determines which coin it is and returns its value in "
"cents, as shown in Listing 6-1."
msgstr ""
"Madeni paralardan bahsetmişken, bunları match kullanarak bir örnek olarak "
"kullanalım! Bilinmeyen bir ABD madeni parayı alan bir fonksiyon yazabilir ve "
"sayma makinesine benzer bir şekilde, hangi madeni para olduğunu "
"belirleyebilir ve değerini 6-1 Listeleme'de gösterildiği gibi sent cinsinden "
"döndürür."

#: src/ch06-02-the-match-control-flow-construct.md:27
msgid ""
"<span class=\"caption\">Listing 6-1: An enum and a `match` expression that "
"has the variants of the enum as its patterns</span>"
msgstr ""
"span class=\"caption\">Listing 6-1: Enum ve match desenleri olarak enum "
"varyantlarına sahip bir ifade/span>"

#: src/ch06-02-the-match-control-flow-construct.md:29
msgid ""
"Let’s break down the `match` expression in the `value_in_cents` function. "
"First, we list the `match` keyword followed by an expression, which in this "
"case is the value `coin`. This seems very similar to a conditional "
"expression used with the `if` statement, but there’s a big difference: with "
"`if`, the condition needs to evaluate to a boolean value, but here it can be "
"any type. The type of `coin` in this example is the `Coin` enum that we "
"defined on the first line."
msgstr ""
"value_in_cents fonksiyonundaki match ifadesini parçalayalım. İlk olarak, bu "
"durumda coin değeri olan bir ifadeyi takip eden match anahtar kelimesini "
"listeliyoruz. Bu, if ifadesiyle kullanılan koşullu bir ifadeye çok benzer "
"görünüyor, ancak büyük bir fark var: if tipiyle, bu durumun herhangi bir "
"boole değeri için değerlendirilmesi gerekiyor, ancak burada olabilir."

#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with "
"a comma."
msgstr ""
"Sonraki match kollarıdır. Bir kolun iki parçası vardır: bir kalıp ve bazı "
"kod. Buradaki ilk kolda Coin::Penny ve daha sonra => operatörü, deseni ve "
"çalıştırılacak kodu ayırır. Bu durumda kod sadece 1 değeridir. Her kol bir "
"virgül ile bir sonrakinden ayrılır."

#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in the order they are given. If a pattern "
"matches the value, the code associated with that pattern is executed. If "
"that pattern doesn’t match the value, execution continues to the next arm, "
"much as in a coin-sorting machine. We can have as many arms as we need: in "
"the above example, our `match` has four arms."
msgstr ""
"match ifadesi çalıştırıldığında, elde edilen değeri, verilen sırayla, her "
"kolun modeline göre karşılaştırır. Bir kalıp değerle eşleşirse, bu kalıpla "
"ilişkili kod yürütülür. Bu kalıp değerle eşleşmiyorsa, yürütme, bir madeni "
"para makinesinde olduğu gibi bir sonraki kola kadar devam eder. İhtiyacımız "
"olan kadar kola sahip olabiliriz: yukarıdaki örnekte, match dört kola "
"sahiptir."

#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire match expression."
msgstr ""
"Her kolla ilişkili kod bir ifadedir ve eşleşen koldaki ifadenin sonuç "
"değeri, tüm eşleşme ifadesi için iade edilen değerdir."

#: src/ch06-02-the-match-control-flow-construct.md:37
msgid ""
"We don’t typically use curly brackets if the `match` arm code is short, as "
"it is in our example where each arm just returns a value. If you want to run "
"multiple lines of code in a `match` arm, you must use curly brackets, with a "
"comma following the arm. For example, the following code prints “Lucky "
"penny!” every time the method is called with a `Coin::Penny`, but still "
"returns the last value of the block, `1`:"
msgstr ""
"match kol kodunun kısa olması durumunda, her kolun sadece bir değer "
"döndürdüğü örneğimizde olduğu gibi, tipik olarak kıvırcık parantez "
"kullanmıyoruz. Bir match kolunda birden fazla kod satırı çalıştırmak "
"istiyorsanız, kolu takip eden bir virgül ile kıvırcık parantez "
"kullanmalısınız. Örneğin, aşağıdaki kod \"Lucky penny!\" Coin:Penny değeri "
"ile her çağrıldığında, yine de son olarak gelir."

#: src/ch06-02-the-match-control-flow-construct.md:43
msgid "\"Lucky penny!\""
msgstr "\"Şanslı kuruş!\""

#: src/ch06-02-the-match-control-flow-construct.md:53
msgid "Patterns That Bind to Values"
msgstr "Değerlere Bağlanan Desenler"

#: src/ch06-02-the-match-control-flow-construct.md:55
msgid ""
"Another useful feature of `match` arms is that they can bind to the parts of "
"the values that match the pattern. This is how we can extract values out of "
"enum variants."
msgstr ""
"match kollarının bir diğer yararlı özelliği, desene uyan değerlerin "
"parçalarına bağlanabilmeleridir. Enum varyantlarından değerleri bu şekilde "
"çıkarabiliriz."

#: src/ch06-02-the-match-control-flow-construct.md:57
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. "
"From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information "
"to our `enum` by changing the `Quarter` variant to include a `UsState` value "
"stored inside it, which we’ve done in Listing 6-2."
msgstr ""
"Örnek olarak, enum varyantlarımızdan birini değiştirerek veriyi içinde "
"tutalım. 1999'dan 2008'e kadar, Amerika Birleşik Devletleri, bir taraftaki "
"50 eyaletin her biri için farklı tasarımlara sahip çeyrekleri basmıştır. "
"Başka hiçbir madeni para devlet tasarımlarına sahip değildir, bu yüzden "
"sadece çeyrekler bu ekstra değere sahiptir. Bu bilgileri enum varyantına "
"Quarter değerini değiştirerek UsState değerini içinde depolayarak "
"ekleyebiliriz, ki bunu 6'de yaptık."

#: src/ch06-02-the-match-control-flow-construct.md:61
msgid "// Debug so we can inspect the state in a minute\n"
msgstr "// Hata ayıklama, böylece bir dakika içinde devleti inceleyebiliriz.\n"

#: src/ch06-02-the-match-control-flow-construct.md:76
msgid ""
"<span class=\"caption\">Listing 6-2: A `Coin` enum in which the `Quarter` "
"variant also holds a `UsState` value</span>"
msgstr ""
"span class=\"caption\">Listing 6-2: A Coin enum Quarter varyantının da bir "
"UsState değeri taşıdığı/span>"

#: src/ch06-02-the-match-control-flow-construct.md:78
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of "
"the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""
"Bir arkadaşın 50 eyalet çeyreğinin tamamını toplamaya çalıştığını "
"varsayalım. Bozuk para türüne göre gevşek değişikliğimizi sıralarken, her "
"çeyrekle ilişkili devletin adını da çağıracağız, böylece arkadaşımızın sahip "
"olmadığı bir durumsa, koleksiyonlarına ekleyebilirler."

#: src/ch06-02-the-match-control-flow-construct.md:80
msgid ""
"In the `match` expression for this code, we add a variable called `state` to "
"the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that "
"quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""
"Bu kod için match ifadesinde, Coin::Quarter varyantının değerlerine uyan "
"modele state adı verilen bir değişken ekliyoruz. Bir Coin::Quarter "
"eşleştiğinde, state değişkeni o çeyreğin durumunun değerine bağlanacaktır. O "
"zaman state'i o kol için kodda kullanabiliriz, böylece:"

#: src/ch06-02-the-match-control-flow-construct.md:89
msgid "\"State quarter from {:?}!\""
msgstr "\" :?'den eyalet çeyreği!\""

#: src/ch06-02-the-match-control-flow-construct.md:96
msgid ""
"Because `state` is an `UsState` enum which implements the `Debug` trait, we "
"can print `state` value with `println!` macro."
msgstr ""
"state, Debug özelliğini uygulayan bir UsState enum olduğundan, state "
"değerini println! makrosuyla yazdırabiliriz."

#: src/ch06-02-the-match-control-flow-construct.md:98
msgid ""
"Note: `{:?}` is a special formatting syntax that allows to print a debug "
"form of the parameter passed to the `println!` macro. You can find more "
"information about it in [Appendix C](./appendix-03-derivable-traits."
"html#debug-for-printing-and-debugging)."
msgstr ""
"Not: :?, println! makrosuna aktarılan parametrenin hata ayıklama formunun "
"yazdırılmasına izin veren özel bir biçimlendirme sözdizimidir. [Ek C](./"
"appendix-03-türevlenebilir-traits.html#debug-for-printing-and-debugging] "
"bölümünde bu konuda daha fazla bilgi bulabilirsiniz."

#: src/ch06-02-the-match-control-flow-construct.md:100
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` "
"would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with "
"each of the match arms, none of them match until we reach `Coin::"
"Quarter(state)`. At that point, the binding for `state` will be the value "
"`UsState::Alaska`. We can then use that binding in `println!` macro, thus "
"getting the inner state value out of the `Coin` enum variant for `Quarter`."
msgstr ""
"value_in_cents(Coin:Quarter(UsState:Alaska) olarak adlandırsaydık, coin "
"Coin::Quarter(UsState:Alaska) olurdu. Bu değeri maç kollarının her biriyle "
"karşılaştırdığımızda, hiçbiri Coin:Quarter(state) değerine ulaşana kadar "
"eşleşmez. Bu noktada, Coin:Quarter(state) için bağlayıcı olacaktır."

#: src/ch06-02-the-match-control-flow-construct.md:104
msgid "Matching with `Option<T>`"
msgstr "OptionT> ile eşleşiyor"

#: src/ch06-02-the-match-control-flow-construct.md:106
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same."
msgstr ""
"Önceki bölümde, OptionT> kullanırken Some durumundan iç T değerini almak "
"istedik; Coin enum ile yaptığımız gibi OptionT> kullanarak da işleyebiliriz! "
"Paraları karşılaştırmak yerine, OptionT> ifadesinin varyantlarını "
"karşılaştıracağız, ancak match ifadesinin çalışma şekli aynı kalır."

#: src/ch06-02-the-match-control-flow-construct.md:108
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if "
"there’s a value inside, adds `1` to that value. If there is no value inside, "
"the function should return the `None` value and not attempt to perform any "
"operations."
msgstr ""
"Bir Optionu8> alan bir fonksiyon yazmak istediğimizi varsayalım ve içinde "
"bir değer varsa, bu değere 1 ekler. İçinde bir değer yoksa, fonksiyon None "
"değerini iade etmeli ve herhangi bir işlem gerçekleştirmeye çalışmamalıdır."

#: src/ch06-02-the-match-control-flow-construct.md:110
msgid ""
"This function is very easy to write, thanks to `match`, and will look like "
"Listing 6-3."
msgstr ""
"Bu fonksiyonun match sayesinde yazılması çok kolaydır ve Listeleme 6-3'e "
"benzeyecektir."

#: src/ch06-02-the-match-control-flow-construct.md:127
msgid ""
"<span class=\"caption\">Listing 6-3: A function that uses a `match` "
"expression on an `Option<u8>`</span>"
msgstr ""
"span class=\"caption\">Listing 6-3: Bir Optionu8> üzerinde match ifadesini "
"kullanan bir fonksiyon/span>"

#: src/ch06-02-the-match-control-flow-construct.md:129
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call "
"`plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each `match` arm:"
msgstr ""
"plus_one'un ilk icrasını daha ayrıntılı olarak inceleyelim. plus_one(5) "
"dediğimizde, plus_one'un gövdesindeki x değişkeni Some(5) değerine sahip "
"olacaktır. Bunu her match koluyla karşılaştırırız:"

#: src/ch06-02-the-match-control-flow-construct.md:135
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! "
"We have the same variant. The `val` binds to the value contained in `Option::"
"Some`, so `val` takes the value `5`. The code in the `match` arm is then "
"executed, so we add `1` to the value of `val` and create a new `Option::"
"Some` value with our total `6` inside. Because the first arm matched, no "
"other arms are compared."
msgstr ""
"Option::Some(5) değeri Option::Some(val) kalıbına uyuyor mu? Aynı varyanta "
"sahibiz. Option:Some içinde bulunan değere bağlanır, bu yüzden val değeri 5 "
"alır. Çünkü match kolundaki kod daha sonra çalıştırılır, bu nedenle 1 "
"değerini  ile yeni bir değer oluştururuz."

#: src/ch06-02-the-match-control-flow-construct.md:137
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where "
"`x` is `Option::None`. We enter the `match` and compare to the first arm:"
msgstr ""
"Şimdi x'nin Option::None olduğu ana fonksiyonumuzda plus_one'un ikinci "
"çağrısını ele alalım. match'ye giriyoruz ve ilk kolla karşılaştırıyoruz:"

#: src/ch06-02-the-match-control-flow-construct.md:143
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so "
"we continue to the next arm:"
msgstr ""
"Option::Some(val) değeri Option::None kalıbına uymuyor, bu yüzden bir "
"sonraki kola devam ediyoruz:"

#: src/ch06-02-the-match-control-flow-construct.md:149
msgid ""
"It matches! There’s no value to add to, so the matching construct ends and "
"returns the `Option::None` value on the right side of `=>`."
msgstr ""
"Eşleşiyor! Eklenecek bir değer yok, bu yüzden eşleşen yapı sona eriyor ve "
"Option::None değerini =>'nin sağ tarafında döndürüyor."

#: src/ch06-02-the-match-control-flow-construct.md:151
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Cairo code: `match` against an enum, bind a variable to the "
"data inside, and then execute code based on it. It’s a bit tricky at first, "
"but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""
"match ve enums'u birleştirmek birçok durumda yararlıdır. Bu şablonu Kahire "
"kodunda çok göreceksiniz: match bir enum'a karşı, bir değişkeni içerideki "
"verilere bağlayın ve ardından buna göre kod çalıştırın. İlk başta biraz zor, "
"ancak bir kez alıştıktan sonra, tüm dillerde olmasını dilersiniz. Sürekli "
"olarak bir kullanıcı favorisi."

#: src/ch06-02-the-match-control-flow-construct.md:153
msgid "Matches Are Exhaustive"
msgstr "Maçlar Tükeniyor"

#: src/ch06-02-the-match-control-flow-construct.md:155
msgid ""
"There’s one other aspect of `match` we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr ""
"match'nin tartışmamız gereken bir başka yönü daha var: kolların kalıpları "
"tüm olasılıkları kapsamalıdır. plus_one fonksiyonumuzun bir hataya sahip "
"olan ve derlemeyecek olan bu sürümünü düşünün:"

#: src/ch06-02-the-match-control-flow-construct.md:165
msgid ""
"We didn’t handle the `None` case, so this code will cause a bug. Luckily, "
"it’s a bug Cairo knows how to catch. If we try to compile this code, we’ll "
"get this error:"
msgstr ""
"None davasını ele almadık, bu yüzden bu kod bir hataya neden olacak. Neyse "
"ki, Kahire'nin nasıl yakalayacağını bildiği bir hata. Bu kodu derlemeye "
"çalışırsak, şu hatayı alacağız:"

#: src/ch06-02-the-match-control-flow-construct.md:181
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the [billion-dollar mistake](https://en."
"wikipedia.org/wiki/Null_pointer#History) discussed earlier impossible."
msgstr ""
"Kahire, mümkün olan her davayı kapsamadığımızı biliyor ve hatta hangi kalıbı "
"unuttuğumuzu bile biliyor! Kahire'deki maçlar kapsamlıdır: kodun geçerli "
"olması için her türlü olasılığı tüketmeliyiz. Özellikle OptionT> durumunda, "
"Kahire None davasını açıkça ele almayı unutmamızı engellediğinde, bizi daha "
"önce null olduğunda bir değere sahip olduğumuzu varsaymaktan korur, böylece "
"[milyar dolarlık hata]."

#: src/ch06-02-the-match-control-flow-construct.md:185
msgid "Catch-all with the `_` Placeholder"
msgstr "_ Yer tutucusu ile her şeyi yakala"

#: src/ch06-02-the-match-control-flow-construct.md:187
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. `_` is a special pattern "
"that matches any value and does not bind to that value. You can use it by "
"simply adding a new arm with `_` as the pattern for the last arm of the "
"`match` expression."
msgstr ""
"Enumları kullanarak, birkaç belirli değer için de özel eylemler yapabiliriz, "
"ancak diğer tüm değerler için bir varsayılan eylemde bulunuruz. _, herhangi "
"bir değerle eşleşen ve bu değere bağlanmayan özel bir kalıptır. match "
"ifadesinin son kolu için kalıp olarak _ ile yeni bir kol ekleyerek "
"kullanabilirsiniz."

#: src/ch06-02-the-match-control-flow-construct.md:191
msgid ""
"Imagine we have a vending machine that only accepts Dime coins. We want to "
"have a function that processes inserted coins and returns `true` only if the "
"coin is accepted."
msgstr ""
"Sadece Dime paralarını kabul eden bir otomatımız olduğunu hayal edin. "
"Takılan paraları işleyen ve sadece para kabul edilirse true döndüren bir "
"fonksiyona sahip olmak istiyoruz."

#: src/ch06-02-the-match-control-flow-construct.md:194
msgid "Here's a `vending_machine_accept` function that implements this logic:"
msgstr "İşte bu mantığı uygulayan bir  otomat_makine_kabul fonksiyonu:"

#: src/ch06-02-the-match-control-flow-construct.md:205
msgid ""
"This example also meets the exhaustiveness requirement because we’re "
"explicitly ignoring all other values in the last arm; we haven’t forgotten "
"anything."
msgstr ""
"Bu örnek aynı zamanda kapsamlılık gereksinimini de karşılar, çünkü son "
"koldaki diğer tüm değerleri açıkça görmezden geliyoruz; hiçbir şeyi "
"unutmadık."

#: src/ch06-02-the-match-control-flow-construct.md:207
msgid ""
"There's no catch-all pattern in Cairo that allows you to use the value of "
"the pattern."
msgstr ""
"Kahire'de desenin değerini kullanmanıza izin veren her şeyi yakalayan bir "
"model yok."

#: src/ch06-02-the-match-control-flow-construct.md:213
msgid "Multiple Patterns with the `|` Operator"
msgstr "Operatörü ile Çoklu Desenler"

#: src/ch06-02-the-match-control-flow-construct.md:215
msgid ""
"In `match` expressions, you can match multiple patterns using the `|` "
"syntax, which is the pattern _or_ operator."
msgstr ""
"match ifadelerinde,  sözdizimini kullanarak birden fazla örüntü "
"eşleştirebilirsiniz, bu örüntü _or_ operatörüdür."

#: src/ch06-02-the-match-control-flow-construct.md:217
msgid ""
"For example, in the following code we modified the `vending_machine_accept` "
"function to accept both `Dime` and `Quarter` coins in a single arm:"
msgstr ""
"Örneğin, aşağıdaki kodda,  otomat_makine_kabul işlevini hem Dime hem de "
"Quarter paralarını tek bir kolda kabul etmek için değiştirdik:"

#: src/ch06-02-the-match-control-flow-construct.md:228
msgid "Matching Tuples"
msgstr "Eşleşen Tuples"

#: src/ch06-02-the-match-control-flow-construct.md:230
msgid "It is possible to match tuples. Let's introduce a new `DayType` enum:"
msgstr "Tuples eşleştirmek mümkündür. Yeni bir DayType enum tanıtalım:"

#: src/ch06-02-the-match-control-flow-construct.md:242
msgid ""
"Now, let's suppose that our vending machine accepts any coin on weekdays, "
"but only accepts quarters and dimes on weekends and holidays. We can modify "
"the `vending_machine_accept` function to accept a tuple of a `Coin` and a "
"`Weekday` and return `true` only if the given coin is accepted on the "
"specified day:"
msgstr ""
"Şimdi, otomatımızın hafta içi herhangi bir parayı kabul ettiğini varsayalım, "
"ancak hafta sonları ve tatillerde sadece çeyreklik ve kuruşları kabul "
"ediyoruz.  otomat_machine_accept işlevini, bir Coin ve Weekday'in bir "
"tutamını kabul etmek için değiştirebilir ve true'yi yalnızca verilen para "
"belirtilen günde kabul edilirse geri verebiliriz:"

#: src/ch06-02-the-match-control-flow-construct.md:255
msgid ""
"Writing `(_, _)` for the last arm of a tuple matching pattern might feel "
"superfluous. Hence, we can use the `_ =>` syntax if we want, for example, "
"that our vending machine only accepts quarters on weekdays:"
msgstr ""
"(_, _) bir tuple eşleme deseninin son kolu için yazmak gereksiz "
"hissedebilir. Bu nedenle, _> sözdizimini, örneğin, otomatımızın hafta içi "
"yalnızca çeyrekleri kabul etmesini istersek kullanabiliriz:"

#: src/ch06-02-the-match-control-flow-construct.md:266
msgid "Matching `felt252` and Integer Variables"
msgstr "Eşleştirme felt252 ve Integer Değişkenleri"

#: src/ch06-02-the-match-control-flow-construct.md:268
msgid ""
"You can also match `felt252` and integer variables. This is useful when you "
"want to match against a range of values. However, there are some "
"restrictions:"
msgstr ""
"Ayrıca felt252 ve tamsayı değişkenlerini de eşleştirebilirsiniz. Bu, bir "
"dizi değerle eşleştirmek istediğinizde kullanışlıdır. Ancak, bazı "
"kısıtlamalar vardır:"

#: src/ch06-02-the-match-control-flow-construct.md:271
msgid ""
"Only integers that fit into a single `felt252` are supported (i.e. `u256` is "
"not supported)."
msgstr ""
"Sadece tek bir felt252 ye uyan tamsayılar desteklenir (yani u256 "
"desteklenmez)."

#: src/ch06-02-the-match-control-flow-construct.md:272
msgid "The first arm must be 0."
msgstr "İlk kol 0 olmalıdır."

#: src/ch06-02-the-match-control-flow-construct.md:273
msgid "Each arm must cover a sequential segment, contiguously with other arms."
msgstr ""
"Her kol, diğer kollarla uyumlu olarak sıralı bir segmenti kaplamalıdır."

#: src/ch06-02-the-match-control-flow-construct.md:275
msgid ""
"Imagine we’re implementing a game where you roll a six-sided die to get a "
"number between 0 and 5. If you have 0, 1 or 2 you win. If you have 3, you "
"can roll again. For all other values you lose."
msgstr ""
"Diyelim ki, 0 ile 5 arasında bir sayı elde etmek için altı taraflı bir kalıp "
"yuvarladığınız bir oyun uyguluyoruz. Eğer 0, 1 veya 2 varsa kazanırsınız. "
"3'ünüz varsa, tekrar yuvarlayabilirsiniz. Diğer tüm değerler için "
"kaybedersiniz."

#: src/ch06-02-the-match-control-flow-construct.md:278
msgid "Here's a match that implements that logic:"
msgstr "İşte bu mantığı uygulayan bir eşleşme:"

#: src/ch06-02-the-match-control-flow-construct.md:283
msgid "\"you won!\""
msgstr "\"Sen kazandın!\""

#: src/ch06-02-the-match-control-flow-construct.md:284
msgid "\"you can roll again!\""
msgstr "\"Tekrar yuvarlanabilirsin!\""

#: src/ch06-02-the-match-control-flow-construct.md:285
msgid "\"you lost...\""
msgstr "\"kaybettin...\""

#: src/ch06-02-the-match-control-flow-construct.md:290
msgid "{{#quiz ../quizzes/ch06-02-match.toml}}"
msgstr "#quiz../quizzes/ch06-02-match.toml"

#: src/ch06-02-the-match-control-flow-construct.md:292
msgid ""
"These restrictions are planned to be relaxed in future versions of Cairo."
msgstr ""
"Bu kısıtlamaların Kahire'nin gelecekteki versiyonlarında gevşetilmesi "
"planlanmaktadır."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:3
msgid "`if let`"
msgstr "eğer izin verirse"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:5
msgid ""
"The `if let` syntax lets you combine `if` and `let` into a less verbose way "
"to handle values that match one pattern while ignoring the rest. Consider "
"the program in Listing 6-4 that matches on an `Option::Some<u8>` value in "
"the `config_max` variable but only wants to execute code if the value is "
"`Option::Some` variant."
msgstr ""
"if let sözdizimi, if ve let'yi, gerisini göz ardı ederken tek bir kalıpla "
"eşleşen değerleri ele almak için daha az fiili bir şekilde birleştirmenizi "
"sağlar. Option::Someu8> config_max değişkenindeki değerle eşleşen 6-4 "
"listelemedeki programı düşünün, ancak değer Option:Some varyantıysa sadece "
"kodu çalıştırmak ister."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:11
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:33
msgid "\"The maximum is configured to be {}\""
msgstr "\"Maksimum  olacak şekilde yapılandırıldı\""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:17
msgid ""
"<span class=\"caption\">Listing 6-4: A `match` that only cares about "
"executing code when the value is `Option::Some`</span>"
msgstr ""
"span class=\"caption\">Listing 6-4: A match sadece değer Option::Some/span> "
"olduğunda kodu çalıştırmayı önemseyen bir match"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:20
msgid ""
"If the value is `Option::Some`, we print out the value in the `Option::Some` "
"variant by binding the value to the variable `max` in the pattern. We don’t "
"want to do anything with the `None` value. To satisfy the `match` "
"expression, we have to add `_ => ()` after processing just one variant, "
"which is annoying boilerplate code to add."
msgstr ""
"Eğer değer Option::Some ise, Option::Some varyantındaki değeri max "
"değişkenine bağlayarak yazdırırız. None değeri ile bir şey yapmak "
"istemiyoruz. match ifadesini karşılamak için, eklemek için can sıkıcı kazan "
"plakası kodu olan sadece bir varyantı işledikten sonra _> () eklemek "
"zorundayız."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:26
msgid ""
"Instead, we could write this in a shorter way using `if let`. The following "
"code behaves the same as the `match` in Listing 6-4:"
msgstr ""
"Bunun yerine, bunu if let kullanarak daha kısa bir şekilde yazabiliriz. "
"Aşağıdaki kod, Listeleme 6-4'teki match ile aynı şekilde davranır:"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:39
msgid ""
"The syntax `if let` takes a pattern and an expression separated by an equal "
"sign. It works the same way as a `match`, where the expression is given to "
"the `match` and the pattern is its first arm. In this case, the pattern is "
"`Option::Some(max)`, and `max` binds to the value inside `Option::Some`. We "
"can then use `max` in the body of the `if let` block in the same way we used "
"`max` in the corresponding `match` arm. The code in the `if let` block isn’t "
"run if the value doesn’t match the pattern."
msgstr ""
"Sözdizimi if let eşit bir işaretle ayrılmış bir kalıp ve bir ifade alır. "
"İfadenin match'ye verildiği ve desenin ilk kolu olduğu bir match ile aynı "
"şekilde çalışır. Bu durumda, kalıp Option:Some(max) ve max'ın içindeki "
"değere bağlanır. Option:Some."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:47
msgid ""
"Using `if let` means less typing, less indentation, and less boilerplate "
"code. However, you lose the exhaustive checking that `match` enforces. "
"Choosing between `match` and `if let` depends on what you’re doing in your "
"particular situation and whether gaining conciseness is an appropriate trade-"
"off for losing exhaustive checking."
msgstr ""
"if let kullanmak, daha az yazma, daha az girinti ve daha az kazan plakası "
"kodu anlamına gelir. Bununla birlikte, match uygulamasının uyguladığı "
"kapsamlı denetimi kaybedersiniz. match ve if let arasında seçim yapmak, özel "
"durumunuzda ne yaptığınıza ve özlük kazanmanın kapsamlı kontrolü kaybetmek "
"için uygun bir takas olup olmadığına bağlıdır."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:53
msgid ""
"In other words, you can think of `if let` as syntactic sugar for a `match` "
"that runs code when the value matches one pattern and then ignores all other "
"values."
msgstr ""
"Başka bir deyişle, değer bir kalıpla eşleştiğinde kod çalıştıran ve daha "
"sonra diğer tüm değerleri göz ardı eden bir match için if let'i syntactic "
"şeker olarak düşünebilirsiniz."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:56
msgid ""
"We can include an `else` with an `if let`. The block of code that goes with "
"`else` is the same as the block of code that would go with the `_` case in "
"the `match` expression. Recall the `Coin` enum definition in Listing 6-2, "
"where the `Quarter` variant also held a `UsState` value. If we wanted to "
"count all non-quarter coins we see while also announcing the state of the "
"quarters, we could do that with a `match` expression, like this:"
msgstr ""
"Bir else let ile bir else ekleyebiliriz. else ile birlikte gelen kod bloğu, "
"match ifadesinde _ durumu ile gidecek kod bloğu ile aynıdır. Quarter "
"ifadesinin de bir UsState değeri tuttuğu Listeleme 6-2'deki Coin enum "
"tanımını hatırlayın."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:76
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:97
msgid "\"You got a quarter!\""
msgstr "\"Bir çeyrekliğin var!\""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:82
msgid "Or we could use an `if let` and `else` expression, like this:"
msgstr "Ya da şöyle bir if let ve else ifadesi kullanabiliriz:"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:101
#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:120
#: src/ch11-08-printing.md:59 src/ch11-08-printing.md:112
#: src/ch11-08-printing.md:130 src/ch11-08-printing.md:156
msgid "\"{}\""
msgstr "\"\""

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:106
msgid ""
"If you have a situation in which your program has logic that is too verbose "
"to express using `match`, remember that `if let` is in your Cairo toolbox as "
"well."
msgstr ""
"Programınızın match kullanarak ifade etmek için çok fiili olan bir mantığın "
"olduğu bir durumunuz varsa, if let'in de Kahire araç kutunuzda olduğunu "
"unutmayın."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:109
msgid "`while let`"
msgstr "bu arada"

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:111
msgid ""
"The `while let` syntax is similar to the `if let` syntax, but it allows you "
"to loop over a collection of values and execute a block of code for each "
"value that matches a specified pattern. In the case below, the pattern is "
"`Option::Some(x)`, which matches any `Some` variant of the `Option` enum."
msgstr ""
"while let sözdizimi, if let sözdizimine benzer, ancak bir değer koleksiyonu "
"üzerinde döngü kurmanıza ve belirli bir kalıpla eşleşen her değer için bir "
"kod bloğu çalıştırmanıza izin verir. Aşağıdaki durumda, kalıp Option:"
"Some(x), Option enum'un herhangi bir Some varyantıyla eşleşir."

#: src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:124
msgid ""
"Using `while let` provides a more concise and idiomatic way of writing this "
"loop compared to a traditional `while` loop with explicit pattern matching "
"or handling of the `Option` type. However, as with `if let`, you lose the "
"exhaustive checking that a `match` expression provides, so you need to be "
"careful to handle any remaining cases outside the `while let` loop if "
"necessary."
msgstr ""
"while let kullanmak, bu döngüyü geleneksel bir while döngüsü ile Option "
"tipinin açık desen eşleşmesi veya işlenmesi ile karşılaştırıldığında daha "
"özlü ve deyimsel bir yol sağlar. Bununla birlikte, if let ile olduğu gibi, "
"bir match ifadesinin sağladığı kapsamlı denetimi kaybedersiniz, bu nedenle "
"gerekirse while let döngüsü dışındaki kalan durumları ele almaya dikkat "
"etmeniz gerekir."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"As you write large programs, organizing your code will become increasingly "
"important. By grouping related functionality and separating code with "
"distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""
"Büyük programlar yazarken, kodunuzu düzenlemek giderek daha önemli hale "
"gelecektir. İlgili işlevselliği gruplandırarak ve kodu farklı özelliklerle "
"ayırarak, belirli bir özelliği uygulayan kodu nerede bulacağınızı ve bir "
"özelliğin nasıl çalıştığını değiştirmek için nereye gideceğinizi açıklığa "
"kavuşturacaksınız."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"The programs we’ve written so far have been in one module in one file. As a "
"project grows, you should organize code by splitting it into multiple "
"modules and then multiple files. As a package grows, you can extract parts "
"into separate crates that become external dependencies. This chapter covers "
"all these techniques."
msgstr ""
"Şimdiye kadar yazdığımız programlar tek bir dosyada tek bir modülde "
"olmuştur. Bir proje büyüdükçe, birden fazla modüle ve daha sonra birden "
"fazla dosyaya bölerek kod düzenlemelisiniz. Bir paket büyüdükçe, dış "
"bağımlılık haline gelen ayrı sandıklara parça çıkarabilirsiniz. Bu bölüm tüm "
"bu teknikleri kapsar."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse code at a higher level: once you’ve implemented an operation, other "
"code can call your code without having to know how the implementation works."
msgstr ""
"Ayrıca, kodu daha yüksek bir seviyede yeniden kullanmanıza izin veren "
"uygulama ayrıntılarını kapsülleme konusunu tartışacağız: bir işlemi "
"uyguladıktan sonra, diğer kod, uygulamanın nasıl çalıştığını bilmek zorunda "
"kalmadan kodunuzu arayabilir."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a set of names that are defined as “in scope”. When reading, writing, and "
"compiling code, programmers and compilers need to know whether a particular "
"name at a particular spot refers to a variable, function, struct, enum, "
"module, constant, or other item and what that item means. You can create "
"scopes and change which names are in or out of scope. You can’t have two "
"items with the same name in the same scope."
msgstr ""
"İlgili bir kavram kapsamdır: kodun yazıldığı iç içe geçmiş bağlam, "
"\"kapsamlı\" olarak tanımlanan bir dizi isme sahiptir. Kodu okurken, "
"yazarken ve derlerken, programcıların ve derleyicilerin belirli bir "
"noktadaki belirli bir ismin bir değişken, işlev, yapı, enum, modül, sabit "
"veya başka bir öğeye atıfta bulunup bulunmadığını ve aynı öğenin ne anlama "
"geldiğini bilmeleri gerekir. İki başlıkta veya dışında bulunan kapsamları ve "
"değişiklikleri oluşturabilirsiniz."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"Cairo has a number of features that allow you to manage your code’s "
"organization. These features, sometimes collectively referred to as the "
"_module system_, include:"
msgstr ""
"Kahire, kodunuzun organizasyonunu yönetmenize izin veren bir dizi özelliğe "
"sahiptir. Bazen toplu olarak _module system_ olarak adlandırılan bu "
"özellikler şunları içerir:"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Packages:** A Scarb feature that lets you build, test, and share crates."
msgstr ""
"**Paketler: ** Sandıkları inşa etmenizi, test etmenizi ve paylaşmanızı "
"sağlayan bir Scarb özelliği."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Crates:** A tree of modules that corresponds to a single compilation unit. "
"It has a root directory, and a root module defined at the _lib.cairo_ file "
"under this directory."
msgstr ""
"**Crates:** Tek bir derleme birimine karşılık gelen bir modül ağacı. Bu "
"dizinin altında bir kök dizini ve _lib.cairo_ dosyasında tanımlanan bir kök "
"modülü vardır."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Modules** and **use:** Let you control the organization and scope of items."
msgstr ""
"**Modüller** ve **kullanım:** Öğelerin organizasyonunu ve kapsamını kontrol "
"etmenize izin verin."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"**Paths:** A way of naming an item, such as a struct, function, or module."
msgstr ""
"** Paths:** Bir öğeyi adlandırmanın bir yolu, bir yapı, fonksiyon veya modül "
"gibi."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and explain how to use them to manage scope. By the end, you should have a "
"solid understanding of the module system and be able to work with scopes "
"like a pro!"
msgstr ""
"Bu bölümde, tüm bu özellikleri ele alacağız, nasıl etkileşime girdiklerini "
"tartışacağız ve kapsamı yönetmek için nasıl kullanacaklarını açıklayacağız. "
"Sonunda, modül sistemini sağlam bir şekilde anlamalı ve bir profesyonel gibi "
"kapsamlarla çalışabilmelisiniz!"

#: src/ch07-01-packages-and-crates.md:3
msgid "What is a Crate?"
msgstr "Crate nedir?"

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is a subset of a package that is used in the actual Cairo "
"compilation. This includes:"
msgstr ""
"Bir sandık, gerçek Kahire derlemesinde kullanılan bir paketin alt kümesidir. "
"Bu şunları içerir:"

#: src/ch07-01-packages-and-crates.md:7
msgid ""
"The package source code, identified by the package name and the crate root, "
"which is the main entry point of the package."
msgstr ""
"Paketin ana giriş noktası olan paket adı ve sandık kökü ile tanımlanan paket "
"kaynak kodu."

#: src/ch07-01-packages-and-crates.md:8
msgid ""
"A subset of the package metadata that identifies crate-level settings of the "
"Cairo compiler, for example, the `edition` field in the _Scarb.toml_ file."
msgstr ""
"Kahire derleyicisinin sandık düzeyindeki ayarlarını tanımlayan paket meta "
"verilerinin bir alt kümesi, örneğin _Scarb.toml_ dosyasındaki edition alanı."

#: src/ch07-01-packages-and-crates.md:10
msgid ""
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as will be discussed in the subsequent "
"sections."
msgstr ""
"Sandıklar modüller içerebilir ve modüller, sonraki bölümlerde tartışılacağı "
"gibi sandıkla derlenen diğer dosyalarda tanımlanabilir."

#: src/ch07-01-packages-and-crates.md:12
msgid "What is the Crate Root?"
msgstr "Crate Kökü Nedir?"

#: src/ch07-01-packages-and-crates.md:14
msgid ""
"The crate root is the _lib.cairo_ source file that the Cairo compiler starts "
"from and makes up the root module of your crate. We’ll explain modules in "
"depth in the [\"Defining Modules to Control Scope\"](./ch07-02-defining-"
"modules-to-control-scope.md) chapter."
msgstr ""
"Kasa kökü, Kahire derleyicisinin başladığı ve sandığınızın kök modülünü "
"oluşturduğu _lib.cairo_ kaynak dosyasıdır. Modülleri [\"Defining Modules to "
"Control Scope\"](./ch07-02-defining-modules-to-control-scope.md) bölümünde "
"derinlemesine açıklayacağız."

#: src/ch07-01-packages-and-crates.md:18
msgid "What is a Package?"
msgstr "Paket nedir?"

#: src/ch07-01-packages-and-crates.md:20
msgid "A Cairo package is a directory (or equivalent) containing:"
msgstr ""
"Bir Kahire paketi, aşağıdakileri içeren bir dizin (veya eşdeğeri) 'dir:"

#: src/ch07-01-packages-and-crates.md:22
msgid "A _Scarb.toml_ manifest file with a `[package]` section."
msgstr "[package] bölümü olan bir _Scarb.toml_ manifest dosyası."

#: src/ch07-01-packages-and-crates.md:23
msgid "Associated source code."
msgstr "Bağlantılı kaynak kodu."

#: src/ch07-01-packages-and-crates.md:25
msgid ""
"This definition implies that a package might contain other packages, with a "
"corresponding _Scarb.toml_ file for each package."
msgstr ""
"Bu tanım, bir paketin her paket için karşılık gelen bir _Scarb.toml_ dosyası "
"içeren başka paketler içerebileceğini ima eder."

#: src/ch07-01-packages-and-crates.md:27
msgid "Creating a Package with Scarb"
msgstr "Scarb ile Paket Oluşturma"

#: src/ch07-01-packages-and-crates.md:29
msgid ""
"You can create a new Cairo package using the Scarb command-line tool. To "
"create a new package, run the following command:"
msgstr ""
"Scarb komut satırı aracını kullanarak yeni bir Kahire paketi "
"oluşturabilirsiniz. Yeni bir paket oluşturmak için aşağıdaki komutu "
"çalıştırın:"

#: src/ch07-01-packages-and-crates.md:35
msgid ""
"This command will generate a new package directory named _my_package_ with "
"the following structure:"
msgstr ""
"Bu komut, aşağıdaki yapıya sahip _my_package_ adında yeni bir paket dizini "
"oluşturacaktır:"

#: src/ch07-01-packages-and-crates.md:44
msgid ""
"_src/_ is the main directory where all the Cairo source files for the "
"package will be stored."
msgstr ""
"_src/_, paket için tüm Kahire kaynak dosyalarının saklanacağı ana dizindir."

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"_lib.cairo_ is the default root module of the crate, which is also the main "
"entry point of the package."
msgstr ""
"_lib.cairo_, aynı zamanda paketin ana giriş noktası olan sandığın varsayılan "
"kök modülüdür."

#: src/ch07-01-packages-and-crates.md:46
msgid ""
"_Scarb.toml_ is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, "
"version, and authors. You can find documentation about it on the [Scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""
"_Scarb.toml_, paket için bağımlılıklar, paket adı, sürüm ve yazarlar gibi "
"metadata ve yapılandırma seçenekleri içeren paket manifesto dosyasıdır. "
"[Scarb referansı] (https://docs.swmansion.com/scarb/docs/reference/manifest."
"html) üzerinde bu konuda belge bulabilirsiniz."

#: src/ch07-01-packages-and-crates.md:48
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"edition = \"2023_11\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"toml [package] name = \"my_package\" version = \"0.1.0\" edition = "
"\"2023_11\" [bağımlılar] # foo =  path = \"vendor/foo\""

#: src/ch07-01-packages-and-crates.md:58
msgid ""
"As you develop your package, you may want to organize your code into "
"multiple Cairo source files. You can do this by creating additional _.cairo_ "
"files within the _src_ directory or its subdirectories."
msgstr ""
"Paketinizi geliştirirken, kodunuzu birden fazla Kahire kaynak dosyasına "
"düzenlemek isteyebilirsiniz. Bunu _src_ dizini veya alt dizinleri içinde ek "
"_.cairo_ dosyaları oluşturarak yapabilirsiniz."

#: src/ch07-01-packages-and-crates.md:60
msgid "{{#quiz ../quizzes/ch07-01-packages-crates.toml}}"
msgstr "#quiz../quizzes/ch07-01-packages-crates.toml"

#: src/ch07-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system, namely _paths_ that allow you to name items and the `use` keyword "
"that brings a path into scope."
msgstr ""
"Bu bölümde, modüller ve modül sisteminin diğer parçaları hakkında, öğeleri "
"adlandırmanıza izin veren _paths_ ve kapsam içine bir yol getiren use "
"anahtar kelimesi hakkında konuşacağız."

#: src/ch07-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when "
"you’re organizing your code in the future. Then we’ll explain each of the "
"rules in detail."
msgstr ""
"İlk olarak, gelecekte kodunuzu düzenlerken kolay referans için bir kurallar "
"listesi ile başlayacağız. Daha sonra kuralların her birini ayrıntılı olarak "
"açıklayacağız."

#: src/ch07-02-defining-modules-to-control-scope.md:11
msgid "Modules Cheat Sheet"
msgstr "Modüller Hile Sayfası"

#: src/ch07-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` "
"keyword work in the compiler, and how most developers organize their code. "
"We’ll be going through examples of each of these rules throughout this "
"chapter, but this is a great place to refer to as a reminder of how modules "
"work. You can create a new Scarb project with `scarb new backyard` to follow "
"along."
msgstr ""
"Burada modüllerin, yolların ve use anahtar kelimesinin derleyicide nasıl "
"çalıştığına ve çoğu geliştiricinin kodlarını nasıl düzenlediğine dair hızlı "
"bir referans sunuyoruz. Bu bölüm boyunca bu kuralların her birinin "
"örneklerinden geçiyor olacağız, ancak burası modüllerin nasıl çalıştığının "
"bir hatırlatıcısı olarak başvurmak için harika bir yerdir. Takip etmek için "
"scarb yeni arka bahçe ile yeni bir Scarb projesi oluşturabilirsiniz."

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first "
"looks in the crate root file (_src/lib.cairo_) for code to compile."
msgstr ""
"** Sandık kökünden başla **: Bir sandık derlerken derleyici önce kodun "
"derlenmesi için sandık kök dosyasına (_src/lib.cairo_) bakar."

#: src/ch07-02-defining-modules-to-control-scope.md:21
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; "
"say, you declare a “garden” module with `mod garden;`. The compiler will "
"look for the module’s code in these places:"
msgstr ""
"**Declaring modes**: Sandık kök dosyasında yeni modüller beyan "
"edebilirsiniz; örneğin, mod garden; ile bir \"bahçe\" modülü beyan "
"edersiniz. Derleyici modülün kodunu şu yerlerde arayacaktır:"

#: src/ch07-02-defining-modules-to-control-scope.md:25
msgid ""
"Inline, within curly brackets that replace the semicolon following `mod "
"garden`."
msgstr ""
"Inline, mod garden'i takip eden virgülün yerini alan kıvırcık parantez "
"içinde."

#: src/ch07-02-defining-modules-to-control-scope.md:28
msgid "// crate root file (src/lib.cairo)\n"
msgstr "// kasa kök dosyası (src/lib.cairo)\n"

#: src/ch07-02-defining-modules-to-control-scope.md:30
msgid "// code defining the garden module goes here\n"
msgstr "// bahçe modülünü tanımlayan kod buraya gider\n"

#: src/ch07-02-defining-modules-to-control-scope.md:34
msgid "In the file _src/garden.cairo_."
msgstr "_src/garden.cairo_ dosyasında."

#: src/ch07-02-defining-modules-to-control-scope.md:36
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can "
"declare submodules. For example, you might declare `mod vegetables;` in _src/"
"garden.cairo_. The compiler will look for the submodule’s code within the "
"directory named for the parent module in these places:"
msgstr ""
"** Alt modüller **: Sandık kökünden başka herhangi bir dosyada alt modüller "
"beyan edebilirsiniz. Örneğin, mod sebzeleri; _src/garden.cairo_ içinde beyan "
"edebilirsiniz. Derleyici, alt modülün kodunu bu yerlerde ana modül için "
"adlandırılmış dizin içinde arayacaktır:"

#: src/ch07-02-defining-modules-to-control-scope.md:41
msgid ""
"Inline, directly following `mod vegetables`, within curly brackets instead "
"of the semicolon."
msgstr ""
"Sıralı, doğrudan takip eden mod sebzeler, virgül yerine kıvırcık parantez "
"içinde."

#: src/ch07-02-defining-modules-to-control-scope.md:45
msgid "// src/garden.cairo file\n"
msgstr "// src/garden.cairo dosyası\n"

#: src/ch07-02-defining-modules-to-control-scope.md:47
msgid "// code defining the vegetables submodule goes here\n"
msgstr "// sebze alt modülünü tanımlayan kod buraya gider\n"

#: src/ch07-02-defining-modules-to-control-scope.md:51
msgid "In the file _src/garden/vegetables.cairo_."
msgstr "_src/garden/vegetables.cairo_ dosyasında."

#: src/ch07-02-defining-modules-to-control-scope.md:53
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can "
"refer to code in that module from anywhere else in that same crate, using "
"the path to the code. For example, an `Asparagus` type in the `vegetables` "
"submodule would be found at `backyard::garden::vegetables::Asparagus`."
msgstr ""
"** Modüllerde kodlanacak yollar**: Bir modül sandığınızın bir parçası "
"olduğunda, koda giden yolu kullanarak, o modüldeki kodu aynı sandıktaki "
"herhangi bir yerden belirtebilirsiniz. Örneğin, gettables alt modülündeki "
"bir Asparagus tipi backyard:: garden:::gettables:Asparagus adresinde bulunur."

#: src/ch07-02-defining-modules-to-control-scope.md:57
msgid ""
"**Private vs public**: Code within a module is private from its parent "
"modules by default. This means that it may only be accessed by the current "
"module and its descendants. To make a module public, declare it with `pub "
"mod` instead of `mod`. To make items within a public module public as well, "
"use `pub` before their declarations. Cairo also provides the `pub(crate)` "
"keyword, allowing an item or module to be only visible within the crate in "
"which the definition is included."
msgstr ""
"** Kamuya karşı özel**: Bir modül içindeki kod varsayılan olarak ana "
"modüllerinden özeldir. Bu, yalnızca mevcut modül ve onun soyundan gelenler "
"tarafından erişilebileceği anlamına gelir. Bir modülü kamuya açık hale "
"getirmek için, mod yerine pub mod ile ilan edin. Kamuya açık bir modül "
"içindeki öğeleri kamuya açık hale getirmek için, beyanlarından önce pub "
"kullanın. Kahire ayrıca, yalnızca sandık içinde bir öğe veya modüle izin "
"veren pub(krate) anahtar kelimesini de sağlar."

#: src/ch07-02-defining-modules-to-control-scope.md:59
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to items to reduce repetition of long paths. In any scope that can refer to "
"`backyard::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use backyard::garden::vegetables::Asparagus;` and from then on you only "
"need to write `Asparagus` to make use of that type in the scope."
msgstr ""
"** use anahtar kelimesi **: Bir kapsam dahilinde, use anahtar kelimesi, uzun "
"yolların tekrarını azaltmak için öğelere kısayollar oluşturur. backyard::"
"garden::vegetables::Asparagus'a atıfta bulunabilecek herhangi bir kapsamda, "
"use arka bahçesi:garden:::getables:::::Asparagus; ile bir kısayol "
"oluşturabilirsiniz ve o andan itibaren yalnızca As'ı yazmanız gerekir."

#: src/ch07-02-defining-modules-to-control-scope.md:65
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The "
"crate’s directory, also named `backyard`, contains these files and "
"directories:"
msgstr ""
"Burada bu kuralları gösteren backyard adlı bir sandık oluşturuyoruz. "
"backyard olarak da adlandırılan sandığın dizini şu dosyaları ve dizinleri "
"içerir:"

#: src/ch07-02-defining-modules-to-control-scope.md:78
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr "Bu durumda sandık kök dosyası _src/lib.cairo_'dir ve şunları içerir:"

#: src/ch07-02-defining-modules-to-control-scope.md:88
msgid "\"I'm growing {:?}!\""
msgstr "\"Büyüyorum :?!\""

#: src/ch07-02-defining-modules-to-control-scope.md:92
msgid ""
"The `pub mod garden;` line imports the `garden` module. Using `pub` to make "
"`garden` publicly accessible, or `pub(crate)` if you really want to make "
"`garden` only available for your crate, is optional to run our program here, "
"as the `main` function resides in the same module as `pub mod garden;` "
"declaration. Nevertheless, not declaring `garden` as `pub` will make it not "
"accessible from any other package. This line tells the compiler to include "
"the code it finds in _src/garden.cairo_, which is:"
msgstr ""
"pub mod bahce; line, garden modülünü ithal eder. pub'yi kamuya açık hale "
"getirmek için pub veya pub(crate) kullanmak, garden'i yalnızca kasanız için "
"kullanılabilir hale getirmek istiyorsanız, main işlevinin diğer pub mod "
"bahçesi ile aynı modülde yer aldığı gibi, burada da programımızı çalıştırmak "
"isteğe bağlıdır."

#: src/ch07-02-defining-modules-to-control-scope.md:95
msgid "<span class=\"filename\">Filename: src/garden.cairo</span>"
msgstr "span class=\"filename\">Dosya adı: src/garden.cairo/span>"

#: src/ch07-02-defining-modules-to-control-scope.md:101
msgid ""
"Here, `pub mod vegetables;` means the code in _src/garden/vegetables."
"cairo_ is included too. That code is:"
msgstr ""
"Burada, pub mod sebzeleri; _src/garden/vegetables.cairo_ içindeki kodu da "
"içerir. Bu kod:"

#: src/ch07-02-defining-modules-to-control-scope.md:108
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us bring the `Asparagus` "
"type into scope, so we can use it in the `main` function."
msgstr ""
"use garden::vegetables::Asparagus; satırı Asparagus tipini kapsam içine "
"sokmamıza izin verir, böylece main işlevinde kullanabiliriz."

#: src/ch07-02-defining-modules-to-control-scope.md:111
msgid ""
"Now let’s get into the details of these rules and demonstrate them in action!"
msgstr ""
"Şimdi bu kuralların ayrıntılarına girelim ve bunları eylemde gösterelim!"

#: src/ch07-02-defining-modules-to-control-scope.md:113
msgid "Grouping Related Code in Modules"
msgstr "Modüllerde İlgili Kodu Gruplama"

#: src/ch07-02-defining-modules-to-control-scope.md:115
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse. Modules also allow us to control the privacy of items, because code "
"within a module is private by default. Private items are internal "
"implementation details not available for outside use. We can choose to make "
"modules and the items within them public, which exposes them to allow "
"external code to use and depend on them."
msgstr ""
"_Modüller_ okunabilirlik ve kolay yeniden kullanım için bir sandık içinde "
"kod düzenlememize izin verin. Modüller ayrıca öğelerin gizliliğini kontrol "
"etmemize izin verir, çünkü bir modül içindeki kod varsayılan olarak özeldir. "
"Özel öğeler, harici kullanım için mevcut olmayan dahili uygulama "
"ayrıntılarıdır. Modülleri ve bunların içindeki öğeleri halka açık hale "
"getirmeyi seçebiliriz, bu da harici kodun kullanılmasına izin verir ve "
"bunlara bağlıdır."

#: src/ch07-02-defining-modules-to-control-scope.md:121
msgid ""
"As an example, let’s write a library crate that provides the functionality "
"of a restaurant. We’ll define the signatures of functions but leave their "
"bodies empty to concentrate on the organization of the code, rather than the "
"implementation of a restaurant."
msgstr ""
"Örnek olarak, bir restoranın işlevselliğini sağlayan bir kütüphane kasası "
"yazalım. Fonksiyonların imzalarını tanımlayacağız, ancak vücutlarını bir "
"restoranın uygulanmasından ziyade kodun organizasyonuna konsantre olmak için "
"boş bırakacağız."

#: src/ch07-02-defining-modules-to-control-scope.md:126
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as "
"_front of house_ and others as _back of house_. Front of house is where "
"customers are; this encompasses where the hosts seat customers, servers take "
"orders and payment, and bartenders make drinks. Back of house is where the "
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do "
"administrative work."
msgstr ""
"Restoran endüstrisinde, bir restoranın bazı kısımları _ house_ ve diğerleri "
"_back of house_ olarak adlandırılır. Evin ön tarafı müşterilerin olduğu "
"yerdir; bu, ev sahibi koltuk müşterilerinin, sunucuların sipariş ve ödeme "
"aldığı ve barmenlerin içki yaptığı yerleri kapsar. Evin arkası, şeflerin ve "
"aşçıların mutfakta çalıştığı, bulaşık makinelerinin temizlendiği ve "
"yöneticilerin idari işler yaptığı yerdir."

#: src/ch07-02-defining-modules-to-control-scope.md:133
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested modules. Create a new package named _restaurant_ by running `scarb "
"new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to "
"define some modules and function signatures. Here’s the front of house "
"section:"
msgstr ""
"Sandıklarımızı bu şekilde yapılandırmak için işlevlerini iç içe modüller "
"halinde düzenleyebiliriz. scarb new restaurant çalıştırarak _restaurant_ "
"adında yeni bir paket oluşturun; daha sonra bazı modülleri ve işlev "
"imzalarını tanımlamak için 7-1 numaralı Listeleme kodunu _src/lib.cairo_ "
"içine girin. İşte ev bölümünün ön kısmı:"

#: src/ch07-02-defining-modules-to-control-scope.md:157
msgid ""
"<span class=\"caption\">Listing 7-1: A `front_of_house` module containing "
"other modules that then contain functions</span>"
msgstr ""
"span class=\"caption\">Liste 7-1: Daha sonra işlevleri içeren diğer "
"modülleri içeren bir front_of_house modülü/span>"

#: src/ch07-02-defining-modules-to-control-scope.md:159
msgid ""
"We define a module with the `mod` keyword followed by the name of the module "
"(in this case, `front_of_house`). The body of the module then goes inside "
"curly brackets. Inside modules, we can place other modules, as in this case "
"with the modules `hosting` and `serving`. Modules can also hold definitions "
"for other items, such as structs, enums, constants, traits, and functions."
msgstr ""
"mod anahtar kelimesi ile modülün adını takip eden bir modül tanımlıyoruz (bu "
"durumda, front_of_house). Modülün gövdesi daha sonra kıvırcık parantezlerin "
"içine girer. Modüllerin içine, bu durumda hosting ve serving modüllerinde "
"olduğu gibi başka modüller yerleştirebiliriz. Modüller ayrıca structs, "
"enums, sabit fonksiyonlar, özellikler gibi diğer öğeler için de tanım "
"tutabilir."

#: src/ch07-02-defining-modules-to-control-scope.md:165
msgid ""
"By using modules, we can group related definitions together and name why "
"they’re related. Programmers using this code can navigate the code based on "
"the groups rather than having to read through all the definitions, making it "
"easier to find the definitions relevant to them. Programmers adding new "
"functionality to this code would know where to place the code to keep the "
"program organized."
msgstr ""
"Modülleri kullanarak, ilgili tanımları bir araya getirebilir ve neden "
"ilişkili olduklarını adlandırabiliriz. Bu kodu kullanan programcılar, tüm "
"tanımları okumak yerine koda dayalı olarak gezinebilir, bu da ilgili "
"tanımları bulmayı kolaylaştırır. Bu koda yeni işlevsellik ekleyen "
"programcılar, programı düzenli tutmak için kodu nereye yerleştireceklerini "
"bilirler."

#: src/ch07-02-defining-modules-to-control-scope.md:171
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The "
"reason for this name is that the content of this file forms a module named "
"after the crate name at the root of the crate’s module structure, known as "
"the _module tree_."
msgstr ""
"Daha önce, _src/lib.cairo_ 'nın sandık kökü olarak adlandırıldığını "
"söylemiştik. Bu ismin nedeni, bu dosyanın içeriğinin, sandığa ait modül "
"yapısının kökündeki sandığa adını veren ve _module tree_ olarak bilinen bir "
"modül oluşturmasıdır."

#: src/ch07-02-defining-modules-to-control-scope.md:174
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr "Listeleme 7-2, Listeleme 7-1'deki yapı için modül ağacını gösterir."

#: src/ch07-02-defining-modules-to-control-scope.md:188
msgid ""
"<span class=\"caption\">Listing 7-2: The module tree for the code in Listing "
"7-1</span>"
msgstr ""
"span class=\"caption\">Liste 7-2: Listelemede kod için modül ağacı 7-1/span>"

#: src/ch07-02-defining-modules-to-control-scope.md:190
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example, `hosting` nests inside `front_of_house`. The tree also shows that "
"some modules are _siblings_ to each other, meaning they’re defined in the "
"same module; `hosting` and `serving` are siblings defined within "
"`front_of_house`. If module A is contained inside module B, we say that "
"module A is the _child_ of module B and that module B is the _parent_ of "
"module A. Notice that the entire module tree is rooted under the explicit "
"name of the crate _restaurant_."
msgstr ""
"Bu ağaç, bazı modüllerin birbirlerinin içinde nasıl yuvalandığını gösterir; "
"örneğin, hosting yuvaları front_of_house içinde. Ağaç ayrıca bazı modüllerin "
"_siblings_ olduğunu gösterir, yani aynı modülde tanımlanırlar; hosting ve "
"serving, front_of_house modülünün içinde tanımlanan kardeşlerdir. Eğer A "
"modülü B modülünün içinde yer alıyorsa, o modülün A modülü olduğunu söyleriz."

#: src/ch07-02-defining-modules-to-control-scope.md:198
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your "
"computer; this is a very apt comparison! Just like directories in a "
"filesystem, you use modules to organize your code. And just like files in a "
"directory, we need a way to find our modules."
msgstr ""
"Modül ağacı size bilgisayarınızdaki dosya sisteminin dizin ağacını "
"hatırlatabilir; bu çok uygun bir karşılaştırmadır! Tıpkı bir dosya "
"sistemindeki dizinler gibi, kodunuzu düzenlemek için modüller kullanırsınız. "
"Ve tıpkı bir dizindeki dosyalar gibi, modüllerimizi bulmak için bir yola "
"ihtiyacımız var."

#: src/ch07-02-defining-modules-to-control-scope.md:203
msgid "{{#quiz ../quizzes/ch07-02-defining-modules-to-control-scope.toml}}"
msgstr "#quiz../quizzes/ch07-02-defining-modules-to-control-scope.toml"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr ""
"Kahire'ye bir modül ağacında bir öğeyi nerede bulabileceğimizi göstermek "
"için, bir dosya sisteminde gezinirken bir yol kullandığımız gibi bir yol "
"kullanırız. Bir işlevi aramak için, yolunu bilmemiz gerekir."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr "Bir yol iki şekilde olabilir:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"An _absolute path_ is the full path starting from a crate root. The absolute "
"path begins with the crate name."
msgstr ""
"Bir _mutlak yol_ bir sandık kökünden başlayan tam yoldur. Mutlak yol sandık "
"adı ile başlar."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:8
msgid "A _relative path_ starts from the current module."
msgstr "Bir _relative path_ geçerli modülden başlar."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:10
msgid ""
"Both absolute and relative paths are followed by one or more identifiers "
"separated by double colons (`::`)."
msgstr ""
"Hem mutlak hem de göreceli yollar, çift kolonlarla (:) ayrılmış bir veya "
"daha fazla tanımlayıcı tarafından takip edilir."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:12
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the "
"restaurant we used in the last chapter. We have a crate named _restaurant_ "
"in which we have a module named `front_of_house` that contains a module "
"named `hosting`. The `hosting` module contains a function named "
"`add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr ""
"Bu nosyonu örneklemek için son bölümde kullandığımız restoran için 7-1 "
"listeleme örneğimizi geri alalım.  hosting adlı bir modül içeren "
"front_of_house adlı bir modülümüz var. hosting modülü add_to_waitlist "
"işlevini add_to_waitlist işlevinden çağırmak istiyoruz."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:35
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:100
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:126
msgid "// Absolute path\n"
msgstr "// Mutlak yol\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:38
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:103
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:129
msgid "// Relative path\n"
msgstr "// Bağıl yol\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:43
msgid ""
"<span class=\"caption\">Listing 7-3: Calling the `add_to_waitlist` function "
"using absolute and relative paths</span>"
msgstr ""
"span class=\"caption\">Liste 7-3: Mutlak ve göreceli yolları kullanarak "
"add_to_waitlist işlevini aramak/span>"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:45
msgid ""
"The `eat_at_restaurant` function is part of our library's public API, so we "
"mark it with the `pub` keyword. We’ll go into more detail about `pub` in "
"the [\"Exposing Paths with the `pub` Keyword\"](./ch07-03-paths-for-"
"referring-to-an-item-in-the-module-tree.md#exposing-paths-with-the-pub-"
"keyword) section."
msgstr ""
"eat_at_restaurant işlevi kütüphanemizin genel API'sinin bir parçasıdır, bu "
"yüzden pub anahtar kelimesi ile işaretliyoruz. pub hakkında daha fazla "
"ayrıntıya gireceğiz pub Anahtar Kelime ile Yollar   pub Anahtar Kelime ile "
"Yollar"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:47
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function "
"is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute "
"paths start from the crate root, which you need to refer to by using the "
"crate name. You can imagine a filesystem with the same structure: we’d "
"specify the path _/front_of_house/hosting/add_to_waitlist_ to run the "
"_add_to_waitlist_ program; using the crate name to start from the crate root "
"is like using a slash (`/`) to start from the filesystem root in your shell."
msgstr ""
"eat_at_restaurant'daki add_to_waitlist fonksiyonunu ilk kez çağırdığımızda, "
"mutlak bir yol kullanırız. add_to_waitlist işlevi, eat_at_restaurant ile "
"aynı sandıkta tanımlanır. Kahire'de, mutlak yollar, sandık adını kullanarak "
"başvurmanız gereken sandık kökünden başlar. Aynı yapıya sahip bir dosya "
"sistemi hayal edebilirsiniz:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:51
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path "
"starts with `front_of_house`, the name of the module defined at the same "
"level of the module tree as `eat_at_restaurant`. Here the filesystem "
"equivalent would be using the path _./front_of_house/hosting/"
"add_to_waitlist_. Starting with a module name means that the path is "
"relative to the current module."
msgstr ""
"add_to_waitlist dediğimiz ikinci seferde göreli bir yol kullanırız. "
"add_to_waitlist olarak tanımlanan modül ağacının adı olan front_of_house ile "
"başlar. Burada dosya sistemi eşdeğeri yolu kullanıyor olacaktır _./"
"front_of_house/hosting/add_to_waitlist_. Bir modülle başlamak, bu yol "
"göreceli yol anlamına gelir."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:53
msgid ""
"Let’s try to compile Listing 7-3 and find out why it won’t compile yet! We "
"get the following error:"
msgstr ""
"Listeleme 7-3'ü derlemeye çalışalım ve neden henüz derlemeyeceğini "
"öğrenelim! Aşağıdaki hatayı alıyoruz:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:78
msgid ""
"The error messages say that module `hosting` and the `add_to_waitlist` "
"function are not visible. In other words, we have the correct paths for the "
"`hosting` module and the `add_to_waitlist` function, but Cairo won’t let us "
"use them because it doesn’t have access to them. In Cairo, all items "
"(functions, methods, structs, enums, modules, and constants) are private to "
"parent modules by default. If you want to make an item like a function or "
"struct private, you put it in a module."
msgstr ""
"Hata mesajları, hosting modülünün ve add_to_waitlist fonksiyonunun görünür "
"olmadığını söylüyor. Başka bir deyişle, hosting modülü ve add_to_waitlist "
"işlevi için doğru yollara sahibiz, ancak Kahire bunları kullanmamıza izin "
"vermiyor çünkü bunlara erişiminiz yok. Kahire'de, tüm öğeler (fonksiyonlar, "
"yöntemler, yapılar, enumlar, modüller) özel bir işlev, modüller ve modüller "
"olarak kullanılır."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:80
msgid ""
"Items in a parent module can’t use the private items inside child modules, "
"but items in child modules can use the items in their ancestor modules. This "
"is because child modules wrap and hide their implementation details, but the "
"child modules can see the context in which they’re defined. To continue with "
"our metaphor, think of the privacy rules as being like the back office of a "
"restaurant: what goes on in there is private to restaurant customers, but "
"office managers can see and do everything in the restaurant they operate."
msgstr ""
"Bir ana modüldeki öğeler, çocuk modüllerindeki özel öğeleri kullanamaz, "
"ancak çocuk modüllerindeki öğeler öğeleri ata modüllerinde kullanabilir. "
"Bunun nedeni, çocuk modüllerinin uygulama ayrıntılarını sarması ve "
"gizlemesidir, ancak çocuk modülleri tanımlandığı bağlamı görebilir. "
"Metaforumuza devam etmek için gizlilik kurallarını bir restoranın arka ofisi "
"gibi düşünün: Orada olup bitenler restoran müşterilerine özeldir, ancak ofis "
"yöneticileri her şeyi görebilir ve restoranda her şeyi yapabilir."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:82
msgid ""
"Cairo chose to have the module system function this way so that hiding inner "
"implementation details is the default. That way, you know which parts of the "
"inner code you can change without breaking outer code. However, Cairo does "
"give you the option to expose inner parts of child modules’ code to outer "
"ancestor modules by using the `pub` keyword to make an item public."
msgstr ""
"Kahire, modül sisteminin bu şekilde çalışmasını seçti, böylece iç uygulama "
"ayrıntılarını gizlemek varsayılandır. Bu şekilde, dış kodu kırmadan iç kodun "
"hangi bölümlerini değiştirebileceğinizi bilirsiniz. Bununla birlikte, "
"Kahire, bir öğeyi kamuya açık hale getirmek için pub anahtar kelimesini "
"kullanarak çocuk modüllerinin kodunun iç kısımlarını dış ata modüllerine "
"maruz bırakma seçeneği sunar."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:86
msgid "Exposing Paths with the `pub` Keyword"
msgstr "pub Anahtar Kelime ile Patikaları Açığa Çıkarma"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:88
msgid ""
"Let’s return to the previous error that told us the `hosting` module and the "
"`add_to_waitlist` function are not visible. We want the `eat_at_restaurant` "
"function in the parent module to have access to the `add_to_waitlist` "
"function in the child module, so we mark the `hosting` module with the `pub` "
"keyword, as shown in Listing 7-4."
msgstr ""
"hosting modülü ve add_to_waitlist fonksiyonunu bize söyleyen önceki hataya "
"geri dönelim. Ana modüldeki eat_at_restaurant fonksiyonunun çocuk "
"modülündeki add_to_waitlist işlevine erişmesini istiyoruz, bu nedenle "
"hosting modülünü Liste 7-4'te gösterildiği gibi pub anahtar kelimesi ile "
"işaretliyoruz."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:108
msgid ""
"<span class=\"caption\">Listing 7-4: Declaring the `hosting` module as `pub` "
"to use it from `eat_at_restaurant`</span>"
msgstr ""
"span class=\"caption\">Liste 7-4: eat_at_restaurant/span> 'den kullanmak "
"için hosting modülünü pub olarak ilan etmek"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:110
msgid "Unfortunately, the code in Listing 7-4 still results in an error."
msgstr "Ne yazık ki, Listeleme 7-4'teki kod hala bir hata ile sonuçlanır."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:112
msgid ""
"What happened? Adding the `pub` keyword in front of `mod hosting;` makes the "
"module public. With this change, if we can access `front_of_house`, we can "
"access `hosting`. But the contents of `hosting` are still private; making "
"the module public doesn’t make its contents public. The `pub` keyword on a "
"module only lets code in its ancestor modules refer to it, not access its "
"inner code. Because modules are containers, there’s not much we can do by "
"only making the module public; we need to go further and choose to make one "
"or more of the items within the module public as well."
msgstr ""
"Ne oldu? pub anahtar kelimesini mod hosting;  modülü kamuya açık hale "
"getirir. Bu değişiklikle front_of_house'a erişebilirsek hosting'e "
"erişebiliriz. Ancak hosting'nin içeriği hala özeldir; modülün kamuya açık "
"hale getirilmesi yalnızca içeriğini kamuya açık hale getirmez. Bir modüldeki "
"pub anahtar kelimesi, yalnızca ata modüllerindeki kodun kendisine hitap "
"etmesine izin vermediğinden dolayı, iç koduna erişemez."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:114
msgid ""
"Let’s also make the `add_to_waitlist` function public by adding the `pub` "
"keyword before its definition, as in Listing 7-5."
msgstr ""
"Ayrıca add_to_waitlist fonksiyonunu, Listeleme 7-5'te olduğu gibi, "
"tanımından önce pub anahtar kelimesini ekleyerek halka açık hale getirelim."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:127
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:130
msgid "// ✅ Compiles\n"
msgstr "//  Derlemeler\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:134
msgid ""
"<span class=\"caption\">Listing 7-5: Declaring the `hosting` module as `pub` "
"to use it from `eat_at_restaurant`</span>"
msgstr ""
"span class=\"caption\">Liste 7-5: eat_at_restaurant/span> 'den kullanmak "
"için hosting modülünü pub olarak ilan etmek"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:136
msgid ""
"Now the code will compile! To see why adding the `pub` keyword lets us use "
"these paths in `add_to_waitlist` with respect to the privacy rules, let’s "
"look at the absolute and the relative paths."
msgstr ""
"Şimdi kod derlenecek! pub anahtar kelimesini eklemenin neden bu yolları "
"gizlilik kurallarına göre add_to_waitlist içinde kullanmamızı sağladığını "
"görmek için, mutlak ve göreceli yollara bakalım."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:138
msgid ""
"In the absolute path, we start with the crate root, the root of our crate’s "
"module tree. The `front_of_house` module is defined in the crate root. While "
"`front_of_house` isn’t public, because the `eat_at_restaurant` function is "
"defined in the same module as `front_of_house` (that is, `front_of_house` "
"and `eat_at_restaurant` are siblings), we can refer to `front_of_house` from "
"`eat_at_restaurant`. Next is the `hosting` module marked with `pub`. We can "
"access the parent module of `hosting`, so we can access `hosting` itself. "
"Finally, the `add_to_waitlist` function is marked with `pub` and we can "
"access its parent module, so this function call works!"
msgstr ""
"Mutlak yolda, sandık ağacımızın kökü olan sandık köküyle başlıyoruz. Bu "
"front_of_house modülü sandık kökünde tanımlanmaktadır. front_of_house modülü "
"halka açık değilken, eat_at_restaurant işlevi front_of_house ile aynı "
"modülde tanımlanmaktadır."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:140
msgid ""
"In the relative path, the logic is the same as the absolute path except for "
"the first step: rather than starting from the crate root, the path starts "
"from `front_of_house`. The `front_of_house` module is defined within the "
"same module as `eat_at_restaurant`, so the relative path starting from the "
"module in which `eat_at_restaurant` is defined works. Then, because "
"`hosting` and `add_to_waitlist` are marked with `pub`, the rest of the path "
"works, and this function call is valid!"
msgstr ""
"Göreceli yolda mantık, ilk adım hariç mutlak yol ile aynıdır: sandık "
"kökünden başlamak yerine, yol front_of_house'dan başlar. front_of_house "
"modülü, eat_at_restaurant ile aynı modül içinde tanımlanır, bu nedenle "
"eat_at_restaurant'ın bulunduğu modülden başlayan bağıl yol, "
"eat_restaurant'ın tanımlı çalışmalarıdır ve host işlevi olduğundan,"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:142
msgid "{{#quiz ../quizzes/ch07-03-paths-in-module-tree-1.toml}}"
msgstr "#quiz../quizzes/ch07-03-paths-in-module-tree-1.toml"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:144
msgid "Starting Relative Paths with `super`"
msgstr "super ile Bağıl Yollar Başlatma"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:146
msgid ""
"We can construct relative paths that begin in the parent module, rather than "
"the current module or the crate root, by using `super` at the start of the "
"path. This is like starting a filesystem path with the `..` syntax. Using "
"`super` allows us to reference an item that we know is in the parent module, "
"which can make rearranging the module tree easier when the module is closely "
"related to the parent, but the parent might be moved elsewhere in the module "
"tree someday."
msgstr ""
"Ana modülde başlayan göreli yolları, mevcut modül veya sandık kökü yerine, "
"yolun başlangıcında süper kullanarak inşa edebiliriz. Bu,. sözdizimi ile bir "
"dosya sistemi yolu başlatmaya benzer. süper kullanmak, modül ağacının ana "
"modülde olduğunu bildiğimiz bir öğeye referans vermemizi sağlar, bu da modül "
"ana modülle yakından ilişkili olduğunda modül ağacını yeniden düzenlemeyi "
"kolaylaştırabilir, ancak ana modül bir gün başka bir yere taşınabilir."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:148
msgid ""
"Consider the code in Listing 7-6 that models the situation in which a chef "
"fixes an incorrect order and personally brings it out to the customer. The "
"function `fix_incorrect_order` defined in the `back_of_house` module calls "
"the function `deliver_order` defined in the parent module by specifying the "
"path to `deliver_order` starting with `super`:"
msgstr ""
"Listeleme 7-6'da bir şefin yanlış bir düzeni düzelttiği ve şahsen müşteriye "
"getirdiği durumu modelleyen kodu düşünün. back_of_house modülünde tanımlanan "
"fix_incorrect_order işlevi, ana modülde tanımlanan deliver_order "
"fonksiyonunu super ile başlayan deliver_order yolunu belirterek çağırır:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:165
msgid ""
"<span class=\"caption\">Listing 7-6: Calling a function using a relative "
"path starting with `super`</span>"
msgstr ""
"span class=\"caption\">Liste 7-6: super/span> ile başlayan göreceli bir yol "
"kullanarak bir işlevi çağırmak"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:167
msgid ""
"Here you can see directly that you access a parent's module easily using "
"`super`, which wasn't the case previously. Note that the `back_of_house` is "
"kept private, as external users are not supposed to interact with the back "
"of house directly."
msgstr ""
"Burada doğrudan bir ebeveyn modülüne daha önce böyle olmayan super "
"kullanarak kolayca eriştiğinizi görebilirsiniz. Dış kullanıcıların doğrudan "
"evin arkasıyla etkileşime girmemesi gerektiği için back_of_house'un gizli "
"tutulduğunu unutmayın."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:170
msgid "Making Structs and Enums Public"
msgstr "Yapıtları ve Enumları Kamulaştırma"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:172
msgid ""
"We can also use `pub` to designate structs and enums as public, but there "
"are a few extra details to consider when using `pub` with structs and enums."
msgstr ""
"Ayrıca pub'yi struct'ları ve enum'ları kamuya açık olarak belirlemek için de "
"kullanabiliriz, ancak pub'yi struct'lar ve enum'larla kullanırken dikkate "
"alınması gereken birkaç ekstra ayrıntı vardır."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:174
msgid ""
"If we use `pub` before a struct definition, we make the struct public, but "
"the struct’s fields will still be private. We can make each field public or "
"not on a case-by-case basis."
msgstr ""
"Bir yapısal tanımdan önce pub kullanırsak, yapıyı halka açık hale getiririz, "
"ancak yapının alanları hala özel olacaktır. Her alanı duruma göre kamuya "
"açık hale getirebiliriz veya olmayabiliriz."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:175
msgid ""
"In contrast, if we make an enum public, all of its variants are then public. "
"We only need the `pub` before the `enum` keyword."
msgstr ""
"Buna karşılık, bir enum halka açık hale getirirsek, tüm varyantları halka "
"açıktır. enum anahtar kelimesinden önce sadece pub'ya ihtiyacımız var."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:177
msgid ""
"There’s one more situation involving `pub` that we haven’t covered, and that "
"is our last module system feature: the `use` keyword. We’ll cover `use` by "
"itself first, and then we’ll show how to combine `pub` and `use`."
msgstr ""
"pub'nin kapsamadığı bir durum daha var ve bu bizim son modül sistem "
"özelliğimiz: use anahtar kelimesi. Önce use'yi tek başına ele alacağız ve "
"daha sonra pub ve use'yi nasıl birleştireceğimizi göstereceğiz."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:179
msgid "{{#quiz ../quizzes/ch07-03-paths-in-module-tree-2.toml}}"
msgstr "#quiz../quizzes/ch07-03-paths-in-module-tree-2.toml"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can "
"create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr ""
"Fonksiyonları aramak için yollar yazmak zorunda kalmak rahatsız edici ve "
"tekrarlayan hissedebilir. Neyse ki, bu işlemi basitleştirmenin bir yolu var: "
"use anahtar kelimesi ile bir kez bir yola kısayol oluşturabilir ve daha "
"sonra kapsamdaki diğer her yerde daha kısa adı kullanabiliriz."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 7-7, we bring the `restaurant::front_of_house::hosting` module "
"into the scope of the `eat_at_restaurant` function so we only have to "
"specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in "
"`eat_at_restaurant`."
msgstr ""
"Listeleme 7-7'de restaurant::front_of_house::hosting modülünü "
"eat_at_restaurant işlevinin kapsamına getiriyoruz, bu nedenle sadece "
"add_to_waitlist fonksiyonunu eat_at_restaurant olarak adlandırmak için "
"hosting::add_to_waitlist fonksiyonunu belirtmemiz gerekiyor."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:13
msgid ""
"// Assuming \"front_of_house\" module is contained in a crate called "
"\"restaurant\", as mentioned in the section \"Defining Modules to Control "
"Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in "
"the use statement\n"
msgstr ""
"// \"Prens_of_house\" modülünün \"Restaurant\" olarak adlandırılan bir "
"sandıkta bulunduğunu varsayarsak, \"Defining Modules to Control Scope\" "
"bölümünde belirtildiği gibi // Yol aynı sandıkta oluşturulursa, kullanım "
"ifadesinde \"restaurant\" isteğe bağlıdır.\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:25
msgid "// ✅ Shorter path\n"
msgstr "//  Daha kısa yol\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid ""
"<span class=\"caption\">Listing 7-7: Bringing a module into scope with "
"`use`</span>"
msgstr ""
"span class=\"caption\">Liste 7-7: use/span> ile bir modülün kapsamına "
"alınması"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:31
msgid ""
"Adding `use` and a path in a scope is similar to creating a symbolic link in "
"the filesystem. By adding `use restaurant::front_of_house::hosting;` in the "
"crate root, `hosting` is now a valid name in that scope, just as though the "
"`hosting` module had been defined in the crate root."
msgstr ""
"Bir kapsamda use ve bir yol eklemek, dosya sisteminde sembolik bir bağlantı "
"oluşturmaya benzer. use restoran::front_of_house::hosting; sandık kökünde, "
"hosting, tıpkı hosting modülü sandık kökünde tanımlanmış gibi, artık bu "
"kapsamda geçerli bir isimdir."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:33
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-8 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile:"
msgstr ""
"use'un yalnızca use'nin gerçekleştiği belirli kapsam için kısayol "
"oluşturduğunu unutmayın. Listeleme 7-8, eat_at_restaurant işlevini customer "
"adlı yeni bir çocuk modülüne taşır, bu da use ifadesinden farklı bir "
"kapsamdır, bu nedenle işlev gövdesi derlenmez:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:54
msgid ""
"<span class=\"caption\">Listing 7-8: A `use` statement only applies in the "
"scope it’s in.</span>"
msgstr ""
"span class=\"caption\">Listing 7-8: A use ifadesi yalnızca içinde bulunduğu "
"kapsamda geçerlidir./span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr ""
"Derleyici hatası, kısayolun artık müşteri modülü içinde geçerli olmadığını "
"gösterir:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:75
msgid "Creating Idiomatic `use` Paths"
msgstr "Idiomatic use Paths Oluşturma"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
msgid ""
"In Listing 7-7, you might have wondered why we specified `use restaurant::"
"front_of_house::hosting` and then called `hosting::add_to_waitlist` in "
"`eat_at_restaurant` rather than specifying the `use` path all the way out to "
"the `add_to_waitlist` function to achieve the same result, as in Listing 7-9."
msgstr ""
"Listeleme 7-7'de, neden use restoran::front_of_house::hosting belirttiğimizi "
"ve daha sonra hosting::add_to_waitlist olarak adlandırılan "
"eat_at_restaurant'da use_to_waitlist yolunu listeleme 7-9'da olduğu gibi "
"aynı sonucu elde etmek için neden add_to_waitlist işlevini belirlediğimizi "
"merak etmiş olabilirsiniz."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:97
msgid ""
"<span class=\"caption\">Listing 7-9: Bringing the `add_to_waitlist` function "
"into scope with `use`, which is unidiomatic</span>"
msgstr ""
"span class=\"caption\">Listeleme 7-9: add_to_waitlist fonksiyonunu use ile "
"kapsamına sokmak, unidiomatic/span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:99
msgid ""
"Although both Listing 7-7 and 7-9 accomplish the same task, Listing 7-7 is "
"the idiomatic way to bring a function into scope with `use`. Bringing the "
"function’s parent module into scope with `use` means we have to specify the "
"parent module when calling the function. Specifying the parent module when "
"calling the function makes it clear that the function isn’t locally defined "
"while still minimizing repetition of the full path. The code in Listing 7-9 "
"is unclear as to where `add_to_waitlist` is defined."
msgstr ""
"Her iki Listeleme 7-7 ve 7-9 aynı görevi yerine getirse de, Listeleme 7-7, "
"use ile bir işlevi kapsam içine getirmenin deyimsel yoludur. Fonksiyonun ana "
"modülünü use ile kapsam içine getirmek, işlevi çağırırken ana modülü "
"belirtmemiz gerektiği anlamına gelir. Fonksiyonu çağırırken ana modülün "
"belirtilmesi, tam yolun tekrarını en aza indirirken fonksiyonun yerel olarak "
"tanımlanmadığını açıkça gösterir. Liste 7-9'daki koddur."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:107
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items "
"with `use`, it’s idiomatic to specify the full path. Listing 7-10 shows the "
"idiomatic way to bring the core library’s `BitSize` trait into the scope, "
"allowing to call `bits` method to retrieve the size in bits of a type."
msgstr ""
"Öte yandan, use ile structs, enums, özellikler ve diğer öğeleri getirirken, "
"tam yolu belirtmek deyimseldir. 7-10 listelemek, çekirdek kütüphanesinin "
"BitSize özelliğini kapsam içine getirmenin deyimsel yolunu gösterir ve bits "
"yöntemini bir türdeki bitleri almak için çağırmaya izin verir."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:114
msgid "\"A u8 variable has {} bits\""
msgstr "\"Bir u8 değişkeni  bitlere sahiptir\""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"<span class=\"caption\">Listing 7-10: Bringing `BitSize` trait into scope in "
"an idiomatic way</span>"
msgstr ""
"span class=\"caption\">Liste 7-10: BitSize özelliğini sıradan bir şekilde "
"kapsamak/span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:120
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has emerged in the Rust community, and folks have gotten used to reading and "
"writing Rust code this way. As Cairo shares many idioms with Rust, we follow "
"this convention as well."
msgstr ""
"Bu deyimin arkasında güçlü bir neden yoktur: sadece Rust topluluğunda ortaya "
"çıkan kongredir ve millet Rust kodunu bu şekilde okumaya ve yazmaya "
"alışmıştır. Kahire Rust ile birçok deyimi paylaşırken, bu kongreyi de takip "
"ediyoruz."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:124
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Cairo doesn’t allow that."
msgstr ""
"Bu deyimin istisnası, aynı isme sahip iki öğeyi use ifadeleri ile kapsam "
"içine getiriyorsak, çünkü Kahire buna izin vermez."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid "Providing New Names with the `as` Keyword"
msgstr "as Anahtar Kelime ile Yeni İsimler Sağlamak"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:129
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: after the path, we can specify `as` and "
"a new local name, or _alias_, for the type. Listing 7-11 shows how you can "
"rename an import with `as`:"
msgstr ""
"use ile aynı adı taşıyan iki türü aynı kapsamda getirme sorununa başka bir "
"çözüm var: Yoldan sonra, as ve yeni bir yerel ad veya _alias_'yi tür için "
"belirtebiliriz. Listeleme 7-11, bir içe aktarmayı as ile nasıl yeniden "
"adlandırabileceğinizi gösterir:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:139
msgid "// ArrayTrait was renamed to Arr\n"
msgstr "// ArrayTrait, Arr olarak yeniden adlandırıldı\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:144
msgid ""
"<span class=\"caption\">Listing 7-11: Renaming a trait when it’s brought "
"into scope with the `as` keyword</span>"
msgstr ""
"span class=\"caption\">Liste 7-11: as anahtar kelimesi/span> ile kapsam "
"içine getirildiğinde bir özelliği yeniden adlandırmak"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:146
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now "
"access the trait's methods with the `Arr` identifier."
msgstr ""
"Burada ArrayTrait takma adıyla Arr'yi devreye soktuk. Artık Arr "
"tanımlayıcısı ile özelliğin yöntemlerine erişebiliriz."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:148
msgid "Importing Multiple Items from the Same Module"
msgstr "Aynı Modülden Birden Fazla Öğe İçe Aktarılıyor"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:150
msgid ""
"When you want to import multiple items (like functions, structs or enums) "
"from the same module in Cairo, you can use curly braces `{}` to list all of "
"the items that you want to import. This helps to keep your code clean and "
"easy to read by avoiding a long list of individual `use` statements."
msgstr ""
"Kahire'deki aynı modülden birden fazla öğeyi (fonksiyonlar, yapılar veya "
"enumlar gibi) içe aktarmak istediğinizde, içe aktarmak istediğiniz tüm "
"öğeleri listelemek için kıvırcık diş tellerini kullanabilirsiniz. Bu, "
"kodunuzu uzun bir bireysel use ifadesi listesinden kaçınarak temiz ve "
"okunması kolay tutmaya yardımcı olur."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:155
msgid ""
"The general syntax for importing multiple items from the same module is:"
msgstr "Aynı modülden birden fazla öğeyi içe aktarmak için genel sözdizimi:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:161
msgid ""
"Here is an example where we import three structures from the same module:"
msgstr "İşte aynı modülden üç yapıyı içe aktardığımız bir örnek:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:164
msgid ""
"// Assuming we have a module called `shapes` with the structures `Square`, "
"`Circle`, and `Triangle`.\n"
msgstr ""
"// Square, Circle ve Triangle yapılarıyla shapes adında bir modülümüz "
"olduğunu varsayarsak.\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:182
msgid ""
"// We can import the structures `Square`, `Circle`, and `Triangle` from the "
"`shapes` module like this:\n"
msgstr ""
"// Square, Circle ve Triangle yapılarını shapes modülünden şu şekilde içe "
"aktarabiliriz:\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:185
msgid ""
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
msgstr ""
"// Şimdi kodumuzda Square, Circle ve Triangle'ı doğrudan kullanabiliriz.\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:190
#: src/ch17-01-general-recommendations.md:143
#: src/ch17-01-general-recommendations.md:148
msgid "// ...\n"
msgstr "//...\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:195
msgid ""
"<span class=\"caption\">Listing 7-12: Importing multiple items from the same "
"module</span>"
msgstr ""
"span class=\"caption\">Liste 7-12: Aynı modülden birden fazla öğe içe "
"aktarılıyor/span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:197
msgid "Re-exporting Names in Module Files"
msgstr "Modül Dosyalarında İsimleri Yeniden Aktarma"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:199
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in the new scope can be imported as if it had been defined in that code’s "
"scope. This technique is called _re-exporting_ because we’re bringing an "
"item into scope, but also making that item available for others to bring "
"into their scope, with the `pub` keyword."
msgstr ""
"use anahtar kelimesi ile bir adı kapsadığımızda, yeni kapsamda mevcut olan "
"isim, o kodun kapsam içinde tanımlanmış gibi içe aktarılabilir. Bu teknik "
"_re-ihracat_ olarak adlandırılır, çünkü bir öğeyi kapsam içine getiriyoruz, "
"aynı zamanda bu öğeyi başkalarının kapsamına sokması için de kullanılabilir "
"hale getiriyoruz, pub anahtar kelimesi ile."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:204
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the "
"restaurant example:"
msgstr ""
"Örneğin, restoran örneğinde add_to_waitlist işlevini yeniden aktaralım:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:222
msgid ""
"<span class=\"caption\">Listing 7-13: Making a name available for any code "
"to use from a new scope with `pub use`</span>"
msgstr ""
"span class=\"caption\">Liste 7-13: pub kullanımı/span> ile yeni bir "
"kapsamdan kullanılacak herhangi bir kod için bir isim yapmak"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path `restaurant::front_of_house::hosting::"
"add_to_waitlist()`. Now that this `pub use` has re-exported the `hosting` "
"module from the root module, external code can now use the path `restaurant::"
"hosting::add_to_waitlist()` instead."
msgstr ""
"Bu değişiklikten önce, dış kodun restaurant::front_of_house::hosting::"
"add_to_waitlist() yolunu kullanarak add_to_waitlist işlevini çağırması "
"gerekir. Şimdi bu pub kullanımı hosting modülünü kök modülden yeniden dışa "
"aktardığına göre, dış kod artık restaurant:hosting_wait() yolunu "
"kullanabilir."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:229
msgid ""
"Re-exporting is useful when the internal structure of your code is different "
"from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `pub use`, we can write our code with one structure but expose a "
"different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library."
msgstr ""
"Kodunuzun iç yapısı, kodunuzu arayan programcıların etki alanı hakkında "
"nasıl düşüneceğinden farklı olduğunda yeniden dışa aktarma yararlıdır. "
"Örneğin, bu restoran metaforunda, restoranı işleten insanlar \"evin ön "
"yüzü\" ve \"evin arkası\" hakkında düşünürler. Ancak bir restoranı ziyaret "
"eden müşteriler muhtemelen restoranın bölümlerini bu terimlerle düşünmezler. "
"pub kullanımı ile kodumuzu tek bir yapı ile yazabiliriz, ancak kütüphaneyi "
"iyi bir şekilde işlerken farklı bir yapıyı ortaya koyabiliriz."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:238
msgid "Using External Packages in Cairo with Scarb"
msgstr "Kahire'de Harici Paketleri Scarb ile Kullanmak"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:240
msgid ""
"You might need to use external packages to leverage the functionality "
"provided by the community. Scarb allows you to use dependencies by cloning "
"packages from their Git repositories. To use an external package in your "
"project with Scarb, simply declare the Git repository URL of the dependency "
"you want to add in a dedicated `[dependencies]` section in your _Scarb.toml_ "
"configuration file. Note that the URL might correspond to the main branch, "
"or any specific commit, branch or tag. For this, you will have to pass an "
"extra `rev`, `branch`, or `tag` field, respectively. For example, the "
"following code imports the main branch of _alexandria_math_ crate from "
"_alexandria_ package:"
msgstr ""
"Topluluk tarafından sağlanan işlevsellikten yararlanmak için sırasıyla "
"harici paketler kullanmanız gerekebilir. Scarb, Git depolarından paketleri "
"klonlayarak bağımlılıkları kullanmanıza izin verir. Projenizde Scarb ile "
"harici bir paket kullanmak için, _Scarb.toml_ yapılandırma dosyanızda özel "
"bir [bağımsızlıklar] ana etiketinde eklemek istediğiniz bağımlılığın Git "
"depo URL'sini beyan edin."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:244
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:251
msgid "\"https://github.com/keep-starknet-strange/alexandria.git\""
msgstr ""
"\"https://github.com/keep-starknet-strange/alexandria.git\" (İngilizce)."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:247
msgid ""
"while the following code imports a specific branch (which is deprecated and "
"should not be used):"
msgstr ""
"Aşağıdaki kod belirli bir dalı içe aktarırken (eskimiştir ve "
"kullanılmamalıdır):"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:251
msgid "\"cairo-v2.3.0-rc0\""
msgstr "\"cairo-v2.3.0-rc0\""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:254
msgid ""
"If you want to import multiple packages in your project, you need to create "
"only one `[dependencies]` section and list all the desired packages beneath "
"it. You can also specify development dependencies by declaring a `[dev-"
"dependencies]` section."
msgstr ""
"Projenizde birden fazla paket almak istiyorsanız, yalnızca bir [bağımlılar] "
"bölümü oluşturmanız ve altındaki tüm istenen paketleri listelemeniz gerekir. "
"Bir [dev-bağımlılar] bölümü ilan ederek geliştirme bağımlılıklarını da "
"belirtebilirsiniz."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:256
msgid ""
"After that, simply run `scarb build` to fetch all external dependencies and "
"compile your package with all the dependencies included."
msgstr ""
"Bundan sonra, tüm harici bağımlılıkları almak ve paketinizi dahil edilen tüm "
"bağımlılıklarla derlemek için scarb build'yi çalıştırın."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:258
msgid ""
"Note that it is also possible to add dependencies with the `scarb add` "
"command, which will automatically edit the _Scarb.toml_ file for you. For "
"development dependencies, just use the `scarb add --dev` command."
msgstr ""
"Sizin için _Scarb.toml_ dosyasını otomatik olarak düzenleyecek olan scarb "
"add komutuyla bağımlılıklar eklemenin de mümkün olduğunu unutmayın. "
"Geliştirme bağımlılıkları için, sadece scarb add --dev komutunu kullanın."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:260
msgid ""
"To remove a dependency, simply remove the corresponding line from your "
"_Scarb.toml_ file, or use the `scarb rm` command."
msgstr ""
"Bir bağımlılığı kaldırmak için, ilgili satırı _Scarb.toml_ dosyanızdan "
"kaldırmanız veya scarb rm komutunu kullanmanız yeterlidir."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:262
msgid "{{#quiz ../quizzes/ch07-04-bringing-paths-into-scope.toml}}"
msgstr "#quiz../quizzes/ch07-04-bring-paths-into-scope.toml"

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file. When modules get large, you might want to move their definitions to a "
"separate file to make the code easier to navigate."
msgstr ""
"Şimdiye kadar, bu bölümdeki tüm örnekler tek bir dosyada birden fazla modül "
"tanımladı. Modüller genişlediğinde, kodun gezinmesini kolaylaştırmak için "
"tanımlarını ayrı bir dosyaya taşımak isteyebilirsiniz."

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-7 that had multiple "
"restaurant modules. We’ll extract modules into files instead of having all "
"the modules defined in the crate root file. In this case, the crate root "
"file is _src/lib.cairo_."
msgstr ""
"Örneğin, birden fazla restoran modülüne sahip olan Listeleme 7-7'deki koddan "
"başlayalım. Modülleri, sandık kök dosyasında tanımlanan tüm modüllere sahip "
"olmak yerine dosyalara çıkaracağız. Bu durumda, sandık kök dosyası _src/lib."
"cairo_'dur."

#: src/ch07-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the "
"code inside the curly brackets for the `front_of_house` module, leaving only "
"the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the "
"code shown in Listing 7-14. Note that this won’t compile until we create the "
"_src/front_of_house.cairo_ file."
msgstr ""
"İlk olarak, front_of_house modülünü kendi dosyasına çıkaracağız. "
"front_of_house modülü için kıvırcık parantez içindeki kodu çıkarın, sadece "
"mod front_of_house; deklarasyonu bırakın, böylece _src/lib.cairo_ Listeleme "
"7-14'te gösterilen kodu içerir. Bunun _src/front_of_house dosyasını "
"oluşturmadan derlemeyeceğini unutmayın."

#: src/ch07-05-separating-modules-into-different-files.md:30
msgid ""
"<span class=\"caption\">Listing 7-14: Declaring the `front_of_house` module "
"whose body will be in _src/front_of_house.cairo_</span>"
msgstr ""
"span class=\"caption\">Liste 7-14: Vücudu _src/front_of_house.cairo_/span> "
"olacak olan front_of_house modülünü ilan etmek"

#: src/ch07-05-separating-modules-into-different-files.md:32
msgid ""
"Next, place the code that was in the curly brackets into a new file named "
"_src/front_of_house.cairo_, as shown in Listing 7-15. The compiler knows to "
"look in this file because it came across the module declaration in the crate "
"root with the name `front_of_house`."
msgstr ""
"Daha sonra, kıvırcık parantez içindeki kodu Listeleme 7-15'te gösterildiği "
"gibi _src/front_of_house.cairo_ adlı yeni bir dosyaya yerleştirin. Derleyici "
"bu dosyaya bakmayı biliyor çünkü front_of_house adı ile sandık kökündeki "
"modül deklarasyonuna rastladı."

#: src/ch07-05-separating-modules-into-different-files.md:37
#: src/ch07-05-separating-modules-into-different-files.md:63
msgid "<span class=\"filename\">Filename: src/front_of_house.cairo</span>"
msgstr "span class=\"filename\">Dosya adı: src/front_of_house.cairo/span>"

#: src/ch07-05-separating-modules-into-different-files.md:45
msgid ""
"<span class=\"caption\">Listing 7-15: Definitions inside the "
"`front_of_house` module in _src/front_of_house.cairo_</span>"
msgstr ""
"span class=\"caption\">Liste 7-15: _src/front_of_house.cairo_/span>'daki "
"front_of_house modülündeki tanımlar"

#: src/ch07-05-separating-modules-into-different-files.md:47
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your module tree. Once the compiler knows the file is part of the project "
"(and knows where in the module tree the code resides because of where you’ve "
"put the `mod` statement), other files in your project should refer to the "
"loaded file’s code using a path to where it was declared, as covered in the "
"[\"Paths for Referring to an Item in the Module Tree\"](./ch07-03-paths-for-"
"referring-to-an-item-in-the-module-tree.md) chapter. In other words, `mod` "
"is _not_ an “include” operation that you may have seen in other programming "
"languages."
msgstr ""
"Modül ağacınızda sadece bir mod deklarasyonu _once_ kullanarak bir dosya "
"yüklemeniz gerektiğini unutmayın. Derleyici, dosyanın projenin bir parçası "
"olduğunu bildiğinde (ve modül ağacında kodun nerede olduğunu bildiğinde, mod "
"ifadesini koyduğunuz için) projenizdeki diğer dosyalar, yüklenilen dosyanın "
"koduna [\"Paths for Refering\" bölümünde belirtildiği gibi bir yol "
"kullanarak başvurmalıdır."

#: src/ch07-05-separating-modules-into-different-files.md:55
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit different because `hosting` is a child module of `front_of_house`, not "
"of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case _src/"
"front_of_house/_."
msgstr ""
"Daha sonra, hosting modülünü kendi dosyasına çıkaracağız. İşlem biraz farklı "
"çünkü hosting, kök modülün değil, front_of_house'un bir çocuk modülü. "
"hosting dosyasını, modül ağacında ataları için adlandırılacak yeni bir "
"dizine yerleştireceğiz, bu durumda _src/front_of_house/_."

#: src/ch07-05-separating-modules-into-different-files.md:60
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain "
"only the declaration of the `hosting` module:"
msgstr ""
"hosting'yi hareket ettirmeye başlamak için, sadece hosting modülünün "
"bildirimini içerecek şekilde _src/front_of_house.cairo_ değerini "
"değiştiririz:"

#: src/ch07-05-separating-modules-into-different-files.md:69
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ "
"to contain the definitions made in the `hosting` module:"
msgstr ""
"Ardından, hosting modülünde yapılan tanımları içeren bir _src/"
"front_of_house_ dizini ve bir _hosting.cairo_ dosyası oluştururuz:"

#: src/ch07-05-separating-modules-into-different-files.md:72
msgid ""
"<span class=\"filename\">Filename: src/front_of_house/hosting.cairo</span>"
msgstr ""
"span class=\"filename\">Dosya adı: src/front_of_house/hosting.cairo/span>"

#: src/ch07-05-separating-modules-into-different-files.md:78
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would "
"expect the _hosting.cairo_ code to be in a `hosting` module declared in the "
"crate root, and not declared as a child of the `front_of_house` module. The "
"compiler’s rules for which files to check for which modules’ code means the "
"directories and files more closely match the module tree."
msgstr ""
"Bunun yerine _src_ dizinine _hosting.cairo_ koyarsak, derleyici, _hosting."
"cairo_ kodunun sandık kökünde ilan edilen ve front_of_house modülünün çocuğu "
"olarak ilan edilmeyen bir hosting modülünde olmasını bekler. Derleyicinin "
"kuralları, hangi modüllerin kodunun dizinler ve dosyaların modül ağacına "
"daha yakın olduğu anlamına gelir."

#: src/ch07-05-separating-modules-into-different-files.md:84
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains the same. The function calls in `eat_at_restaurant` will work "
"without any modification, even though the definitions live in different "
"files. This technique lets you move modules to new files as they grow in "
"size."
msgstr ""
"Her modülün kodunu ayrı bir dosyaya taşıdık ve modül ağacı aynı kaldı. "
"eat_at_restaurant'daki işlev çağrıları, tanımların farklı dosyalarda "
"yaşamasına rağmen herhangi bir değişiklik yapmadan çalışacaktır. Bu teknik, "
"modülleri boyut olarak büyüdükçe yeni dosyalara taşımanızı sağlar."

#: src/ch07-05-separating-modules-into-different-files.md:89
msgid ""
"Note that the `use restaurant::front_of_house::hosting;` statement in _src/"
"lib.cairo_ also hasn’t changed, nor does `use` have any impact on what files "
"are compiled as part of the crate. The `mod` keyword declares modules, and "
"Cairo looks in a file with the same name as the module for the code that "
"goes into that module."
msgstr ""
"use restoran::front_of_house::hosting; ifade _src/lib.cairo_ de değişmedi, "
"ne de use kutunun bir parçası olarak hangi dosyaların derlendiği üzerinde "
"herhangi bir etkiye sahip değil. mod anahtar kelimesi modüller ilan eder ve "
"Kahire bu modüle giren kodun modülü ile aynı adı taşıyan bir dosyaya bakar."

#: src/ch07-05-separating-modules-into-different-files.md:99
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules "
"so you can refer to items defined in one module from another module. You can "
"do this by specifying absolute or relative paths. These paths can be brought "
"into scope with a `use` statement so you can use a shorter path for multiple "
"uses of the item in that scope. Module code is **private** by default."
msgstr ""
"Kahire, bir paketi birden fazla sandık ve bir sandığı modüllere bölmenizi "
"sağlar, böylece bir modülde tanımlanan öğelere başka bir modülden "
"başvurabilirsiniz. Bunu mutlak veya göreceli yollar belirleyerek "
"yapabilirsiniz. Bu yollar, bu kapsamda öğenin birden fazla kullanımı için "
"daha kısa bir yol kullanabilmeniz için bir use ifadesi ile kapsam içine "
"getirilebilir. Modül kodu varsayılan olarak **private ** 'dir."

#: src/ch07-05-separating-modules-into-different-files.md:105
msgid "{{#quiz ../quizzes/ch07-05-separate-modules.toml}}"
msgstr "#quiz../quizzes/ch07-05-separate-modules.toml"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Cairo, one such tool is generics: abstract stand-"
"ins for concrete types or other properties. We can express the behavior of "
"generics or how they relate to other generics without knowing what will be "
"in their place when compiling and running the code."
msgstr ""
"Her programlama dili, kavramların çoğaltılmasını etkili bir şekilde ele "
"almak için araçlara sahiptir. Kahire'de, bu tür araçlardan biri jeneriktir: "
"beton türleri veya diğer özellikler için soyut stand-in'ler. Jeneriklerin "
"davranışlarını veya kodu derleyip çalıştırırken yerinde ne olacağını "
"bilmeden diğer jeneriklerle nasıl ilişki kurduklarını ifade edebiliriz."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Functions can take parameters of some generic type, instead of a concrete "
"type like `u32` or `bool`, in the same way a function takes parameters with "
"unknown values to run the same code on multiple concrete values. In fact, "
"we’ve already used generics in [Chapter 6](./ch06-01-enums.html#the-option-"
"enum-and-its-advantages) with `Option<T>`."
msgstr ""
"Fonksiyonlar, bazı jenerik tiplerin parametrelerini alabilir, u32 veya bool "
"gibi somut bir tür yerine, aynı şekilde bir fonksiyon birden fazla beton "
"değer üzerinde aynı kodu çalıştırmak için bilinmeyen değerlere sahip "
"parametreleri alır. Aslında, [Bölüm 6](./ch06-01-enums.html#the-option-enum-"
"and-its-advantages> ile jenerikleri zaten kullandık."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"In this chapter, you’ll explore how to define your own types, functions, and "
"traits with generics."
msgstr ""
"Bu bölümde, kendi türlerinizi, işlevlerinizi ve özelliklerinizi jeneriklerle "
"nasıl tanımlayacağınızı keşfedeceksiniz."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication. Upon compilation, the "
"compiler creates a new definition for each concrete type that replaces a "
"generic type, reducing development time for the programmer, but code "
"duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which "
"will cause contract size to increment."
msgstr ""
"Jenerikler, kod çoğaltma işlemini kaldırmak için belirli türleri birden "
"fazla türü temsil eden bir yer tutucu ile değiştirmemize izin verir. "
"Derleyici derleme üzerine, genel bir türün yerini alan her bir beton türü "
"için yeni bir tanım oluşturur, programcı için geliştirme süresini azaltır, "
"ancak derleme düzeyinde kod çoğaltma hala mevcuttur. Starknet sözleşmeleri "
"yazıyorsanız ve sözleşme boyutunun artmasına neden olacak birden fazla tür "
"için bir genel kullanıyorsanız bu önemli olabilir."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You "
"can combine traits with generic types to constrain a generic type to accept "
"only those types that have a particular behavior, as opposed to just any "
"type."
msgstr ""
"Daha sonra, davranışı genel bir şekilde tanımlamak için özelliklerin nasıl "
"kullanılacağını öğreneceksiniz. Sadece herhangi bir türün aksine, yalnızca "
"belirli bir davranışa sahip olan türleri kabul etmek için genel tiplerle "
"özellikleri birleştirebilirsiniz."

#: src/ch08-00-generic-types-and-traits.md
msgid "Removing Duplication by Extracting a Function"
msgstr "Bir Fonksiyon Çıkartarak Çoğaltmanın Kaldırılması"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication. Before diving into "
"generics syntax, let’s first look at how to remove duplication in a way that "
"doesn’t involve generic types by extracting a function that replaces "
"specific values with a placeholder that represents multiple values. Then "
"we’ll apply the same technique to extract a generic function! By learning "
"how to identify duplicated code that can be extracted into a function, "
"you'll start to recognize instances where generics can be used to reduce "
"duplication."
msgstr ""
"Jenerikler, kod çoğaltmasını kaldırmak için belirli türleri birden fazla "
"türü temsil eden bir yer tutucu ile değiştirmemize izin verir. Jenerik "
"sözdizimine dalmadan önce, belirli değerleri birden fazla değeri temsil eden "
"bir yer tutucu ile değiştiren bir işlev çıkararak, çoğaltmayı içermeyen bir "
"şekilde çoğaltmanın nasıl kaldırılacağına bakalım. Daha sonra genel bir "
"işlevi çıkarmak için aynı tekniği uygulayacağız! Bir fonksiyona "
"indirilebilecek kopyalanmış kodun nasıl tanımlanacağını öğrenerek, bir "
"fonksiyona indirgeyebilirsiniz."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We begin with a short program that finds the largest number in an array of "
"`u8`:"
msgstr "u8 dizisinde en büyük sayıyı bulan kısa bir programla başlıyoruz:"

#: src/ch08-00-generic-types-and-traits.md
msgid "\"The largest number is {}\""
msgstr "\"En büyük sayı \""

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We store an array of `u8` in the variable `number_list` and extract the "
"first number in the array in a variable named `largest`. We then iterate "
"through all the numbers in the array, and if the current number is greater "
"than the number stored in `largest`, we update the value of `largest`. "
"However, if the current number is less than or equal to the largest number "
"seen so far, the variable doesn’t change, and the code moves on to the next "
"number in the list. After considering all the numbers in the array, "
"`largest` should contain the largest number, which in this case is 100."
msgstr ""
"u8 dizisini number_list değişkeninde depolarız ve dizideki ilk sayıyı en "
"büyük adlı bir değişkende çıkarırız. Daha sonra dizideki tüm sayıları "
"yineleriz ve en büyük dizisinde depolanan sayıdan daha büyükse, en büyük "
"dizinin değerini güncelleriz. Ancak, şu anki sayı şu ana kadar görülen en "
"büyük sayıdan küçük veya eşitse, değişkenin değişmemesi gerekir."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"We've now been tasked with finding the largest number in two different "
"arrays of numbers. To do so, we can choose to duplicate the previous code "
"and use the same logic at two different places in the program, as follows:"
msgstr ""
"Şimdi iki farklı sayı dizisinde en büyük sayıyı bulmakla görevlendirildik. "
"Bunu yapmak için, önceki kodu çoğaltmayı ve aynı mantığı programın iki "
"farklı yerinde kullanmayı seçebiliriz, aşağıdaki gibi:"

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Although this code works, duplicating code is tedious and error-prone. We "
"also have to remember to update the code in multiple places when we want to "
"change it."
msgstr ""
"Bu kod işe yarasa da, kodu kopyalamak sıkıcı ve hataya eğilimlidir. "
"Değiştirmek istediğimizde kodu birden fazla yerde güncellemeyi de "
"unutmamalıyız."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"To eliminate this duplication, we’ll create an abstraction by defining a "
"function that operates on any array of `u8` passed in a parameter. This "
"solution makes our code clearer and lets us express the concept of finding "
"the largest number in an array abstractly."
msgstr ""
"Bu ikilemeyi ortadan kaldırmak için, herhangi bir parametrede geçen u8 "
"dizisinde çalışan bir fonksiyon tanımlayarak bir soyutlama oluşturacağız. Bu "
"çözüm, kodumuzu daha net hale getirir ve bir dizideki en büyük sayıyı bulma "
"kavramını soyut olarak ifade etmemizi sağlar."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"To do that, we extract the code that finds the largest number into a "
"function named `largest`. Then we call the function to find the largest "
"number in the two arrays. We could also use the function on any other array "
"of `u8` values we might have in the future."
msgstr ""
"Bunu yapmak için, en büyük sayıyı en büyük adlı bir fonksiyona bulan kodu "
"çıkarırız. Sonra fonksiyonu iki dizideki en büyük sayıyı bulmak için "
"çağırırız. Fonksiyonu gelecekte sahip olabileceğimiz başka herhangi bir u8 "
"değeri dizisinde de kullanabiliriz."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"The largest function has a parameter called `number_list`, passed by "
"reference, which represents any concrete array of `u8` values we might pass "
"into the function. As a result, when we call the function, the code runs on "
"the specific values that we pass in."
msgstr ""
"En büyük fonksiyon, referansla geçen number_list adlı bir parametreye "
"sahiptir, bu da fonksiyona geçebileceğimiz herhangi bir u8 değer dizisini "
"temsil eder. Sonuç olarak, fonksiyonu çağırdığımızda, kod içinde geçtiğimiz "
"belirli değerler üzerinde çalışır."

#: src/ch08-00-generic-types-and-traits.md
msgid "In summary, here are the steps we took to change the code:"
msgstr "Özetle, kodu değiştirmek için attığımız adımlar şunlardır:"

#: src/ch08-00-generic-types-and-traits.md
msgid "Identify duplicate code."
msgstr "Kopya kodu tanımla."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Extract the duplicate code into the body of the function and specify the "
"inputs and return values of that code in the function signature."
msgstr ""
"Kopya kodu fonksiyonun gövdesine çıkarın ve bu kodun girdilerini ve dönüş "
"değerlerini fonksiyon imzasında belirtin."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Update the two instances of duplicated code to call the function instead."
msgstr ""
"Bunun yerine işlevi aramak için iki çoğaltılmış kod örneğini güncelleyin."

#: src/ch08-00-generic-types-and-traits.md
msgid ""
"Next, we’ll use these same steps with generics to reduce code duplication. "
"In the same way that the function body can operate on an abstract `Array<T>` "
"instead of specific `u8` values, generics allow code to operate on abstract "
"types."
msgstr ""
"Daha sonra, kod çoğaltmasını azaltmak için bu aynı adımları jeneriklerle "
"kullanacağız. Fonksiyon gövdesinin belirli u8 değerleri yerine soyut bir "
"ArrayT> üzerinde çalışabilmesi gibi, jenerikler de kodun soyut türlerde "
"çalışmasına izin verir."

#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs "
"and functions, which we can then use with many different concrete data "
"types. In Cairo, we can use generics when defining functions, structs, "
"enums, traits, implementations and methods. In this chapter, we are going to "
"take a look at how to effectively use generic types with all of them."
msgstr ""
"Daha sonra birçok farklı beton veri türü ile kullanabileceğimiz yapı ve "
"fonksiyonlar gibi ürün beyanları için tanımlamalar oluşturmak için "
"jenerikleri kullanıyoruz. Kahire'de, fonksiyonları, yapıları, enumları, "
"özellikleri, uygulamaları ve yöntemleri tanımlarken jenerikleri "
"kullanabiliriz. Bu bölümde, jenerik tiplerin hepsiyle nasıl etkili bir "
"şekilde kullanılacağına bir göz atacağız."

#: src/ch08-01-generic-data-types.md:5
msgid ""
"Generics allow us to write reusable code that works with many types, thus "
"avoiding code duplication, while enhancing code maintainability."
msgstr ""
"Jenerikler, birçok türle çalışan yeniden kullanılabilir kod yazmamıza izin "
"verir, böylece kod çoğaltılmasından kaçınırken, kod bakımını artırır."

#: src/ch08-01-generic-data-types.md:7
msgid "Generic Functions"
msgstr "Genel Fonksiyonlar"

#: src/ch08-01-generic-data-types.md:9
msgid ""
"Making a function generic means it can operate on different types, avoiding "
"the need for multiple, type-specific implementations. This leads to "
"significant code reduction and increases the flexibility of the code."
msgstr ""
"Bir fonksiyon jenerik yapmak, farklı türlerde çalışabileceği anlamına gelir, "
"çoklu, tipe özgü uygulamalara ihtiyaç duyulmaz. Bu, önemli bir kod "
"azalmasına yol açar ve kodun esnekliğini arttırır."

#: src/ch08-01-generic-data-types.md:11
msgid ""
"When defining a function that uses generics, we place the generics in the "
"function signature, where we would usually specify the data types of the "
"parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If "
"we need to perform this operation for lists of different types, then we "
"would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr ""
"Jenerikleri kullanan bir fonksiyon tanımlarken, jenerikleri genellikle "
"parametrenin veri türlerini ve dönüş değerini belirleyeceğimiz işlev "
"imzasına yerleştiririz. Örneğin, iki Array öğesi verilen, en büyük olanı "
"döndürecek bir işlev oluşturmak istediğimizi hayal edin. Bu işlemi farklı "
"türlerdeki listeler için gerçekleştirmemiz gerekirse, her seferinde işlevi "
"yeniden tanımlamamız gerekir. Neyse ki, jenerikleri kullanarak işlevi "
"uygulayabilir ve diğer görevlere geçebiliriz."

#: src/ch08-01-generic-data-types.md:14
msgid "// Specify generic type T between the angulars\n"
msgstr "// Açısallar arasında genel tip T belirtin\n"

#: src/ch08-01-generic-data-types.md:27
msgid ""
"// There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
msgstr ""
"// T'nin beton türünü belirtmeye gerek yoktur çünkü // derleyici tarafından "
"çıkarımlanır\n"

#: src/ch08-01-generic-data-types.md:33
msgid ""
"The `largest_list` function compares two lists of the same type and returns "
"the one with more elements and drops the other. If you compile the previous "
"code, you will notice that it will fail with an error saying that there are "
"no traits defined for dropping an array of a generic type. This happens "
"because the compiler has no way to guarantee that an `Array<T>` is droppable "
"when executing the `main` function. In order to drop an array of `T`, the "
"compiler must first know how to drop `T`. This can be fixed by specifying in "
"the function signature of `largest_list` that `T` must implement the `Drop` "
"trait. The correct function definition of `largest_list` is as follows:"
msgstr ""
"biggest_list işlevi, aynı türdeki iki listeyi karşılaştırır ve birini daha "
"fazla elemanla döndürür ve diğerini düşürür. Önceki kodu derlerseniz, bir "
"jenerik türün dizisini düşürmek için tanımlanmış hiçbir özellik olmadığını "
"söyleyerek bir hata ile başarısız olacağını fark edeceksiniz. Bu, "
"derleyicinin ArrayT> dizininin çalıştırılması sırasında main fonksiyonunun "
"nasıl düzeltileceğini garanti etmenin bir yolu olmadığı için olur."

#: src/ch08-01-generic-data-types.md:45
msgid ""
"The new `largest_list` function includes in its definition the requirement "
"that whatever generic type is placed there, it must be droppable. This is "
"what we call _trait bounds_. The `main` function remains unchanged, the "
"compiler is smart enough to deduce which concrete type is being used and if "
"it implements the `Drop` trait."
msgstr ""
"Yeni en büyük_list işlevi tanımında, hangi jenerik tip oraya yerleştirilirse "
"yerleştirilsin, bırakılabilir olması zorunluluğunu içerir. Buna _trait "
"limits_ diyoruz. main fonksiyonu değişmeden kalır, derleyici hangi beton "
"tipinin kullanıldığını ve Drop özelliğini uygularsa uygulayacak kadar "
"akıllıdır."

#: src/ch08-01-generic-data-types.md:47
msgid "Constraints for Generic Types"
msgstr "Genel Tipler için Kısıtlamalar"

#: src/ch08-01-generic-data-types.md:49
msgid ""
"When defining generic types, it is useful to have information about them. "
"Knowing which traits a generic type implements allows us to use it more "
"effectively in a function's logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this "
"previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compiler's requirements, we can also add constraints to benefit our function "
"logic."
msgstr ""
"Jenerik tipleri tanımlarken, onlar hakkında bilgi sahibi olmak yararlıdır. "
"Jenerik tip uygulamalarının hangi özellikleri olduğunu bilmek, fonksiyonla "
"birlikte kullanılabilecek jenerik tipleri kısıtlama pahasına bir fonksiyonun "
"mantığında daha etkili bir şekilde kullanmamızı sağlar. Best_list'in jenerik "
"argümanlarının bir parçası olarak TDrop uygulamasını ekleyerek daha önce "
"bunun bir örneğini gördük. Fonksiyon kısıtlamalarını karşılamak için TDrop "
"eklenirken, derleyici gereksinimlerimizi de ekleyebiliriz."

#: src/ch08-01-generic-data-types.md:51
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, to "
"find the smallest element among them. Initially, we know that for an element "
"of type `T` to be comparable, it must implement the `PartialOrd` trait. The "
"resulting function would be:"
msgstr ""
"Bazı jenerik tip T elemanlarının bir listesi göz önüne alındığında, "
"aralarında en küçük elemanı bulmak istediğimizi düşünün. Başlangıçta, T tipi "
"bir elemanın karşılaştırılabilir olması için PartialOrd özelliğini "
"uygulaması gerektiğini biliyoruz. Ortaya çıkan işlev:"

#: src/ch08-01-generic-data-types.md:54
msgid ""
"// Given a list of T get the smallest one\n"
"// The PartialOrd trait implements comparison operations for T\n"
msgstr ""
"// T'nin bir listesi verildiğinde en küçük olanı elde edin // Parsiyel Ord "
"özelliği, T için karşılaştırma işlemlerini uygular\n"

#: src/ch08-01-generic-data-types.md:57
msgid ""
"// This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
msgstr ""
"// Bu, yineleme yoluyla en küçük elemanı temsil eder // Desnap (*) "
"operatörünü kullandığımıza dikkat edin\n"

#: src/ch08-01-generic-data-types.md:61
msgid "// The index we will use to move through the list\n"
msgstr "// Listede gezinmek için kullanacağımız indeks\n"

#: src/ch08-01-generic-data-types.md:64
msgid "// Iterate through the whole list storing the smallest\n"
msgstr "// En küçükleri depolayan tüm liste boyunca yinele\n"

#: src/ch08-01-generic-data-types.md:79
msgid ""
"// We need to specify that we are passing a snapshot of `list` as an "
"argument\n"
msgstr ""
"// list'nin bir anlık görüntüsünü bir argüman olarak aktardığımızı "
"belirtmemiz gerekir.\n"

#: src/ch08-01-generic-data-types.md:85
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and "
"returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so "
"we are not required to implement the `Drop` trait for `T` as well. Why does "
"it not compile then?"
msgstr ""
"smallest_element işlevi, PartialOrd özelliğini uygulayan, bir ArrayT> "
"görüntüsünü parametre olarak alan ve en küçük elemanın bir kopyasını "
"döndüren jenerik bir T tipini kullanır. Parametre ArrayT> türü olduğu için, "
"neden yürütmenin sonunda bırakmamız gerekmez ve bu nedenle Drop özelliğini "
"derlememiz gerekmez?"

#: src/ch08-01-generic-data-types.md:87
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element, "
"and unless `PartialOrd` is implemented for `@T` we need to desnap the "
"element using `*`. The `*` operation requires a copy from `@T` to `T`, which "
"means that `T` needs to implement the `Copy` trait. After copying an element "
"of type `@T` to `T`, there are now variables with type `T` that need to be "
"dropped, requiring `T` to implement the `Drop` trait as well. We must then "
"add both `Drop` and `Copy` traits implementation for the function to be "
"correct. After updating the `smallest_element` function the resulting code "
"would be:"
msgstr ""
"list üzerinde indekslenirken, değer endeksli elemanın bir çırpıda sonuçlanır "
"ve PartialOrd T için uygulanmadığı sürece, * fonksiyonunu kullanarak öğeyi "
"çözmemiz gerekir. T'den T'ye bir kopya gerekir, bu da T'nin Copy özelliğinin "
"uygulanması gerektiği anlamına gelir."

#: src/ch08-01-generic-data-types.md:108
msgid "Anonymous Generic Implementation Parameter (`+` Operator)"
msgstr "Anonim Genel Uygulama Parametresi (+ Operatörü)"

#: src/ch08-01-generic-data-types.md:110
msgid ""
"Until now, we have always specified a name for each implementation of the "
"required generic trait: `TPartialOrd` for `PartialOrd<T>`, `TDrop` for "
"`Drop<T>`, and `TCopy` for `Copy<T>`."
msgstr ""
"Şimdiye kadar, gerekli genel özelliğin her bir uygulaması için her zaman bir "
"isim belirledik: PartialOrdT> için TPartialOrd, Drop için Drop, CopyT> için "
"TCopy."

#: src/ch08-01-generic-data-types.md:112
msgid ""
"However, most of the time, we don't use the implementation in the function "
"body; we only use it as a constraint. In these cases, we can use the `+` "
"operator to specify that the generic type must implement a trait without "
"naming the implementation. This is referred to as an _anonymous generic "
"implementation parameter_."
msgstr ""
"Bununla birlikte, çoğu zaman, uygulamayı işlev gövdesinde kullanmıyoruz; "
"sadece bir kısıtlama olarak kullanıyoruz. Bu durumlarda, + operatörünü, "
"jenerik tipin uygulamayı adlandırmadan bir özellik uygulaması gerektiğini "
"belirtmek için kullanabiliriz. Bu, _anonim jenerik uygulama parametresi_ "
"olarak adlandırılır."

#: src/ch08-01-generic-data-types.md:114
msgid ""
"For example, `+PartialOrd<T>` is equivalent to `impl TPartialOrd: "
"PartialOrd<T>`."
msgstr ""
"Örneğin, +PartialOrdT>, impl TPartialOrd: ParsiyelOrdT> ile eşdeğerdir."

#: src/ch08-01-generic-data-types.md:116
msgid "We can rewrite the `smallest_element` function signature as follows:"
msgstr ""
"smallest_element fonksiyon imzasını aşağıdaki gibi yeniden yazabiliriz:"

#: src/ch08-01-generic-data-types.md:134
msgid "Structs"
msgstr "Structs"

#: src/ch08-01-generic-data-types.md:136
msgid ""
"We can also define structs to use a generic type parameter for one or more "
"fields using the `<>` syntax, similar to function definitions. First, we "
"declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct "
"definition where we would otherwise specify concrete data types. The next "
"code example shows the definition `Wallet<T>` which has a `balance` field of "
"type `T`."
msgstr ""
"Fonksiyon tanımlarına benzer şekilde > sözdizimi kullanılarak bir veya daha "
"fazla alan için jenerik tip parametresi kullanmak üzere de structları "
"tanımlayabiliriz. İlk olarak, struct'un adından hemen sonra açı "
"parantezlerinin içindeki tip parametresinin adını beyan ederiz. Daha sonra "
"struct tanımındaki jenerik tipi, aksi takdirde somut veri türlerini "
"belirteceğimiz şekilde kullanırız. Bir sonraki kod örneği, WalletT>  "
"dengesinin tanımını gösterir."

#: src/ch08-01-generic-data-types.md:149
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically. "
"It is equivalent to writing the following code:"
msgstr ""
"Yukarıdaki kod, Wallet türü için Drop özelliğini otomatik olarak türetir. "
"Aşağıdaki kodu yazmakla eşdeğerdir:"

#: src/ch08-01-generic-data-types.md:163
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and "
"instead define our own `WalletDrop` implementation. Notice that we must "
"define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying "
"that the struct `Wallet<T>` is droppable as long as `T` is also droppable."
msgstr ""
"Drop makrosunu Wallet uygulamasının uygulanması için kullanmaktan "
"kaçınıyoruz ve bunun yerine kendi WalletDrop uygulamamızı tanımlamalıyız. "
"Fonksiyonlar gibi, WalletDrop için ek bir jenerik türü tanımlamamız "
"gerektiğine dikkat edin, T'nin Drop özelliğini de uyguladığını söylüyoruz. "
"Temel olarak WalletT> yapısının da çıkarılabilir olduğunu söylüyoruz."

#: src/ch08-01-generic-data-types.md:165
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and "
"we want that field to be different than `T` but generic as well, we can "
"simply add another generic type between the `<>`:"
msgstr ""
"Son olarak, Wallet adresini temsil eden bir alan eklemek istersek ve bu "
"alanın T'den farklı olmasını istersek, aynı zamanda jenerik de, > arasında "
"başka bir genel tür ekleyebiliriz:"

#: src/ch08-01-generic-data-types.md:179
msgid ""
"We add to the `Wallet` struct definition a new generic type `U` and then "
"assign this type to the new field member `address`. Notice that the `derive` "
"attribute for the `Drop` trait works for `U` as well."
msgstr ""
"Wallet struct tanımına yeni bir jenerik tip U ekliyoruz ve daha sonra bu "
"türü yeni alan üyesi address'e atıyoruz. Drop özelliği için derive "
"özniteliğinin U için de işe yaradığına dikkat edin."

#: src/ch08-01-generic-data-types.md:183
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. For example the `Option<T>` enum provided by the Cairo core "
"library:"
msgstr ""
"Yapıtlarla yaptığımız gibi, varyantlarında genel veri türlerini tutmak için "
"enumları tanımlayabiliriz. Örneğin, Kahire çekirdek kütüphanesi tarafından "
"sağlanan OptionT> enum:"

#: src/ch08-01-generic-data-types.md:192
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: "
"`Some`, which holds one value of type `T` and `None` that doesn't hold any "
"value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic "
"type `T` we can use this abstraction with any type."
msgstr ""
"OptionT> enum bir T tipi üzerinde jeneriktir ve iki varyantı vardır: Some, "
"herhangi bir değer taşımayan bir T ve None tipini tutar. OptionT> enum'u "
"kullanarak, isteğe bağlı bir değerin soyut kavramını ifade etmemiz mümkündür "
"ve değerin jenerik bir T tipine sahip olması nedeniyle bu soyutlamayı "
"herhangi bir türle kullanabiliriz."

#: src/ch08-01-generic-data-types.md:194
msgid ""
"Enums can use multiple generic types as well, like the definition of the "
"`Result<T, E>` enum that the core library provides:"
msgstr ""
"Enumlar, çekirdek kütüphanesinin sağladığı ResultT, E> enum tanımı gibi "
"birden fazla jenerik türü de kullanabilir:"

#: src/ch08-01-generic-data-types.md:203 src/ch09-02-recoverable-errors.md:16
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two "
"variants: `Ok` which holds the value of type `T` and `Err` which holds the "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (by returning a value "
"of type `T`) or fail (by returning a value of type `E`)."
msgstr ""
"ResultT, E> enum, T ve E olmak üzere iki genel tipe ve iki varyanta "
"sahiptir: Ok, T ve Err tipinin değerini tutar. Bu tanım, Result enum tipini "
"başarılı olabilecek herhangi bir yerde kullanmayı kolaylaştırır (bir T "
"değeri döndürerek)."

#: src/ch08-01-generic-data-types.md:205
msgid "Generic Methods"
msgstr "Genel Yöntemler"

#: src/ch08-01-generic-data-types.md:207
msgid ""
"We can implement methods on structs and enums, and use the generic types in "
"their definitions, too. Using our previous definition of `Wallet<T>` struct, "
"we define a `balance` method for it:"
msgstr ""
"Yapılar ve enumlar üzerinde yöntemler uygulayabilir ve tanımlarında da "
"jenerik tipleri kullanabiliriz. WalletT> yapıtının önceki tanımını "
"kullanarak, bunun için bir balans yöntemi tanımlarız:"

#: src/ch08-01-generic-data-types.md:231
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which "
"defines a method that returns the value of the field `balance` from "
"`Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. "
"Note that you need to include a generic type in both definitions of the "
"trait and the implementation."
msgstr ""
"İlk olarak WalletTraitT> özelliğini, Wallet'den balance alanının değerini "
"döndüren bir yöntemi tanımlayan genel bir T tipi kullanarak tanımlıyoruz. "
"Daha sonra WalletImplT>'deki özellik için bir uygulama veriyoruz. Her iki "
"özellik tanımına ve uygulamaya jenerik bir tür eklemeniz gerektiğini "
"unutmayın."

#: src/ch08-01-generic-data-types.md:233
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only for `Wallet<u128>` "
"instances rather than `Wallet<T>`. In the code example, we define an "
"implementation for wallets which have a concrete type of `u128` for the "
"`balance` field."
msgstr ""
"Tür üzerinde yöntemler tanımlarken genel tiplere ilişkin kısıtlamaları da "
"belirtebiliriz. Örneğin, Walletu128> yerine WalletT> örnekleri için "
"yöntemler uygulayabiliriz. Kod örneğinde, balance alanı için somut bir u128 "
"tipine sahip cüzdanlar için bir uygulama tanımlarız."

#: src/ch08-01-generic-data-types.md:240
msgid "/// Generic trait for wallets\n"
msgstr "/// Cüzdanlar için genel özellik\n"

#: src/ch08-01-generic-data-types.md:251
msgid "/// Trait for wallets of type u128\n"
msgstr "/// u128 tipi cüzdanlar için trait\n"

#: src/ch08-01-generic-data-types.md:272
msgid ""
"The new method `receive` increments the size of `balance` of any instance of "
"a `Wallet<u128>`. Notice that we changed the `main` function making `w` a "
"mutable variable in order for it to be able to update its balance. If we "
"were to change the initialization of `w` by changing the type of `balance` "
"the previous code wouldn't compile."
msgstr ""
"Yeni yöntem alıcı, bir Walletu128>'nin herhangi bir örneğinin balance "
"boyutunu artırır. main fonksiyonunu, w dengesini güncelleyebilmesi için w "
"değişkeni yaparak değiştirdiğimize dikkat edin. w'nin başlangıçını "
"değiştirerek önceki kodun derlenmeyeceği şekilde değiştirirsek."

#: src/ch08-01-generic-data-types.md:274
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. "
"Using the past implementation from `Wallet<U, V>` we are going to define a "
"trait that picks two wallets of different generic types and creates a new "
"one with a generic type of each. First, let's rewrite the struct definition:"
msgstr ""
"Kahire, jenerik özelliklerin içindeki jenerik yöntemleri tanımlamamıza da "
"olanak tanır. WalletU, V> geçmiş uygulamasını kullanarak, farklı jenerik "
"türlerden iki cüzdan seçen ve her birinin jenerik tipi olan yeni bir cüzdan "
"oluşturan bir özellik tanımlayacağız. İlk olarak, yapı tanımını yeniden "
"yazalım:"

#: src/ch08-01-generic-data-types.md:283
msgid ""
"Next, we are going to naively define the mixup trait and implementation:"
msgstr ""
"Daha sonra, mixup özelliğini ve uygulamasını saf bir şekilde tanımlayacağız:"

#: src/ch08-01-generic-data-types.md:286
msgid "// This does not compile!\n"
msgstr "// Bu derlenmiyor!\n"

#: src/ch08-01-generic-data-types.md:299
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` "
"method which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` "
"creates a new `Wallet<T1, U2>`. As `mixup` signature specifies, both `self` "
"and `other` are getting dropped at the end of the function, which is why "
"this code does not compile. If you have been following from the start until "
"now you would know that we must add a requirement for all the generic types "
"specifying that they will implement the `Drop` trait for the compiler to "
"know how to drop instances of `Wallet<T, U>`. The updated implementation is "
"as follows:"
msgstr ""
"WalletT1, U1> ile bir özellik oluşturuyoruz. WalletT1, U1> ve WalletT2, U2> "
"bir özellik örneği verilen WalletT1, U1>, WalletT1, U2> için yeni bir "
"WalletT1, U1> işaretinin neden mixupkendini ve diğerini oluşturmadığını "
"belirten bir özellik oluşturuyor."

#: src/ch08-01-generic-data-types.md:317
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` "
"declaration. Then we do the same for `T2` and `U2`, this time as part of "
"`mixup` signature. We can now try the `mixup` function:"
msgstr ""
"T1 ve U1 için gereksinimleri WalletMixImpl bildiriminde bırakılabilir olarak "
"ekliyoruz. Daha sonra T2 ve U2 için aynı şeyi yapıyoruz, bu sefer mixup "
"imzasının bir parçası olarak. Artık mixup işlevini deneyebiliriz:"

#: src/ch08-01-generic-data-types.md:331
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, "
"u8>` instance."
msgstr ""
"Önce iki örnek oluşturuyoruz: biri Walletbool, u128> ve diğeri "
"Walletfelt252, u8>. Sonra mixup diyoruz ve yeni bir Walletbool, u8> örneği "
"oluşturuyoruz."

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"A trait defines a set of methods that can be implemented by a type. These "
"methods can be called on instances of the type when this trait is "
"implemented. A trait combined with a generic type defines functionality a "
"particular type has and can share with other types. We can use traits to "
"define shared behavior in an abstract way. We can use _trait bounds_ to "
"specify that a generic type can be any type that has certain behavior."
msgstr ""
"Bir özellik, bir tür tarafından uygulanabilecek bir dizi yöntemi tanımlar. "
"Bu yöntemler, bu özellik uygulandığında türün örneklerine çağrılabilir. "
"Jenerik bir türle birleştirilen bir özellik, belirli bir türün sahip olduğu "
"ve diğer türlerle paylaşabileceği işlevselliği tanımlar. Paylaşılan "
"davranışı soyut bir şekilde tanımlamak için özellikler kullanabiliriz. "
"Jenerik bir türün belirli bir davranışa sahip herhangi bir tür olabileceğini "
"belirtmek için _trait sınırlarını kullanabiliriz."

#: src/ch08-02-traits-in-cairo.md:7
msgid ""
"Note: Traits are similar to a feature often called interfaces in other "
"languages, although with some differences."
msgstr ""
"Not: Bazı farklılıklar olsa da, özellikler genellikle diğer dillerde "
"arayüzler olarak adlandırılan bir özelliğe benzer."

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"While traits can be written to not accept generic types, they are most "
"useful when used with generic types. We already covered generics in the "
"[previous chapter](./ch08-01-generic-data-types.md), and we will use them in "
"this chapter to demonstrate how traits can be used to define shared behavior "
"for generic types."
msgstr ""
"Özellikler, jenerik tipleri kabul etmemek için yazılabilirken, jenerik "
"tiplerle birlikte kullanıldığında en yararlıdırlar. [önceki bölüm](./ch08-01-"
"generic-data-types.md) 'deki jenerikleri zaten ele aldık ve bu bölümde, "
"özelliklerin jenerik tipler için paylaşılan davranışı tanımlamak için nasıl "
"kullanılabileceğini göstermek için bunları kullanacağız."

#: src/ch08-02-traits-in-cairo.md:13
msgid "Defining a Trait"
msgstr "Bir Trait'i Tanımlamak"

#: src/ch08-02-traits-in-cairo.md:15
msgid ""
"A type’s behavior consists of the methods we can call on that type. "
"Different types share the same behavior if we can call the same methods on "
"all of those types. Trait definitions are a way to group method signatures "
"together to define a set of behaviors necessary to accomplish some purpose."
msgstr ""
"Bir türün davranışı, bu tür üzerinde çağırabileceğimiz yöntemlerden oluşur. "
"Bu türlerin hepsinde aynı yöntemleri çağırabilirsek, farklı türler aynı "
"davranışı paylaşır. Trait tanımları, bir amaca ulaşmak için gerekli bir dizi "
"davranışı tanımlamak için yöntem imzalarını birlikte gruplamanın bir yoludur."

#: src/ch08-02-traits-in-cairo.md:17
msgid ""
"For example, let’s say we have a struct `NewsArticle` that holds a news "
"story in a particular location. We can define a trait `Summary` that "
"describes the behavior of something that can summarize the `NewsArticle` "
"type."
msgstr ""
"Örneğin, belirli bir yerde bir haber öyküsü tutan bir NewsArticle yapımız "
"olduğunu varsayalım. NewsArticle tipini özetleyebilecek bir şeyin "
"davranışını tanımlayan bir Summary özelliğini tanımlayabiliriz."

#: src/ch08-02-traits-in-cairo.md:34
msgid "\"{:?} by {:?} ({:?})\""
msgstr "\":? by :? (:)\""

#: src/ch08-02-traits-in-cairo.md:41
msgid ""
"Here, we declare a trait using the `trait` keyword and then the trait’s "
"name, which is `Summary` in this case. We’ve also declared the trait as "
"`pub` so that crates depending on this crate can make use of this trait too, "
"as we’ll see in a few examples."
msgstr ""
"Burada, trait anahtar kelimesini ve daha sonra bu durumda Summary olan "
"özelliğin adını kullanarak bir özellik beyan ediyoruz. Ayrıca bu özelliği "
"pub olarak ilan ettik, böylece bu kasaya bağlı sandıklar da birkaç örnekte "
"göreceğimiz gibi bu özelliği kullanabilir."

#: src/ch08-02-traits-in-cairo.md:44
msgid ""
"Inside the curly brackets, we declare the method signatures that describe "
"the behaviors of the types that implement this trait, which in this case is "
"`fn summarize(self: @NewsArticle) -> ByteArray;`. After the method "
"signature, instead of providing an implementation within curly brackets, we "
"use a semicolon."
msgstr ""
"Kıvırcık parantez içinde, bu özelliği uygulayan türlerin davranışlarını "
"tanımlayan yöntem imzalarını beyan ediyoruz, bu durumda bu fn özeti (kendi: "
"@NewsArticle) -> ByteArray;. Yöntem imzasından sonra, kıvırcık parantez "
"içinde bir uygulama sağlamak yerine, bir noktalı virgül kullanıyoruz."

#: src/ch08-02-traits-in-cairo.md:46
msgid ""
"Note: the `ByteArray` type is the type used to represent strings in Cairo."
msgstr ""
"Not: ByteArray tipi Kahire'deki dizeleri temsil etmek için kullanılan tiptir."

#: src/ch08-02-traits-in-cairo.md:48
msgid ""
"As the trait is not generic, the `self` parameter is not generic either and "
"is of type `@NewsArticle`. This means that the `summarize` method can only "
"be called on instances of `NewsArticle`."
msgstr ""
"Bu özellik genel olmadığından, self parametresi de genel değildir ve "
"NewsArticle tipindedir. Bu, summarize yönteminin yalnızca NewsArticle "
"örneklerinde çağrılabileceği anlamına gelir."

#: src/ch08-02-traits-in-cairo.md:50
msgid ""
"Now, consider that we want to make a media aggregator library crate named "
"_aggregator_ that can display summaries of data that might be stored in a "
"`NewsArticle` or `Tweet` instance. To do this, we need a summary from each "
"type, and we’ll request that summary by calling a summarize method on an "
"instance of that type. By defining the `Summary` trait on generic type `T`, "
"we can implement the `summarize` method on any type we want to be able to "
"summarize."
msgstr ""
"Şimdi, bir NewsArticle veya Tweet örneğinde saklanabilecek veri özetlerini "
"görüntüleyebilecek _aggregator_ adlı bir medya agregator kütüphane sandığı "
"yapmak istediğimizi düşünün. Bunu yapmak için her türden bir özete "
"ihtiyacımız var ve bu tür bir örneği özetleyerek bu özeti isteyeceğiz.  "
"Summary özelliğini jenerik tip üzerinde uygulayabiliriz"

#: src/ch08-02-traits-in-cairo.md:68 src/ch08-02-traits-in-cairo.md:145
#: src/ch08-02-traits-in-cairo.md:222
msgid "\"{} by {} ({})\""
msgstr "\" by  ()\""

#: src/ch08-02-traits-in-cairo.md:82 src/ch08-02-traits-in-cairo.md:159
#: src/ch08-02-traits-in-cairo.md:236
msgid "\"{}: {}\""
msgstr "\":\""

#: src/ch08-02-traits-in-cairo.md:91 src/ch08-02-traits-in-cairo.md:168
#: src/ch08-02-traits-in-cairo.md:245
msgid "\"Cairo has become the most popular language for developers\""
msgstr "\"Cairo geliştiriciler için en popüler dil haline geldi\""

#: src/ch08-02-traits-in-cairo.md:92 src/ch08-02-traits-in-cairo.md:169
#: src/ch08-02-traits-in-cairo.md:246
msgid "\"Worldwide\""
msgstr "\"Dünya çapında\""

#: src/ch08-02-traits-in-cairo.md:93 src/ch08-02-traits-in-cairo.md:170
#: src/ch08-02-traits-in-cairo.md:247
msgid "\"Cairo Digger\""
msgstr "\"Cairo Digger\""

#: src/ch08-02-traits-in-cairo.md:94 src/ch08-02-traits-in-cairo.md:171
#: src/ch08-02-traits-in-cairo.md:248
msgid "\"Cairo is a new programming language for zero-knowledge proofs\""
msgstr "\"Cairo sıfır bilgi kanıtları için yeni bir programlama dilidir\""

#: src/ch08-02-traits-in-cairo.md:98 src/ch08-02-traits-in-cairo.md:175
#: src/ch08-02-traits-in-cairo.md:252
msgid "\"EliBenSasson\""
msgstr "\"EliBenSasson\""

#: src/ch08-02-traits-in-cairo.md:99 src/ch08-02-traits-in-cairo.md:176
#: src/ch08-02-traits-in-cairo.md:253
msgid ""
"\"Crypto is full of short-term maximizing projects. \\n @Starknet and "
"@StarkWareLtd are about long-term vision maximization.\""
msgstr ""
"\"Crypto kısa vadeli maksimize projelerle doludur. n @Starknet ve @Starkhare "
"Ltd.Şti uzun vadeli vizyon maksimize etme ile ilgilidir.\""

#: src/ch08-02-traits-in-cairo.md:102 src/ch08-02-traits-in-cairo.md:179
#: src/ch08-02-traits-in-cairo.md:256
msgid "// Tweet instantiation\n"
msgstr "// Tweet Ansiklopedisi\n"

#: src/ch08-02-traits-in-cairo.md:104 src/ch08-02-traits-in-cairo.md:181
#: src/ch08-02-traits-in-cairo.md:258
msgid "\"New article available! {}\""
msgstr "\"Yeni makale mevcut!\""

#: src/ch08-02-traits-in-cairo.md:105 src/ch08-02-traits-in-cairo.md:182
#: src/ch08-02-traits-in-cairo.md:259
msgid "\"New tweet! {}\""
msgstr "\"Yeni tweet! \""

#: src/ch08-02-traits-in-cairo.md:111
msgid ""
"<span class=\"caption\">A `Summary` trait that consists of the behavior "
"provided by a `summarize` method</span>"
msgstr ""
"span class=\"caption\">Bir summary yönteminin sağladığı davranıştan oluşan "
"bir summary özelliği/span>"

#: src/ch08-02-traits-in-cairo.md:113
msgid ""
"Each type implementing this trait must provide its own custom behavior for "
"the body of the method. The compiler will enforce that any type that "
"implements the `Summary` trait will have the method `summarize` defined with "
"this signature exactly."
msgstr ""
"Bu özelliği uygulayan her tür, yöntemin gövdesi için kendi özel davranışını "
"sağlamalıdır. Derleyici, Summmary özelliğini uygulayan herhangi bir türün, "
"bu imzayla tam olarak tanımlanan summarize yöntemine sahip olmasını "
"sağlayacaktır."

#: src/ch08-02-traits-in-cairo.md:115
msgid ""
"A trait can have multiple methods in its body: the method signatures are "
"listed one per line and each line ends in a semicolon."
msgstr ""
"Bir özelliğin vücudunda birden fazla yöntem olabilir: yöntem imzaları satır "
"başına bir tane listelenir ve her bir çizgi bir noktalı virgülde biter."

#: src/ch08-02-traits-in-cairo.md:117
msgid "Implementing a Trait on a Type"
msgstr "Bir Tür Üzerinde Bir Trait Uygulamak"

#: src/ch08-02-traits-in-cairo.md:119
msgid ""
"Now that we’ve defined the desired signatures of the `Summary` trait’s "
"methods, we can implement it on the types in our media aggregator. The "
"following code shows an implementation of the `Summary` trait on the "
"`NewsArticle` struct that uses the headline, the author, and the location to "
"create the return value of `summarize`. For the `Tweet` struct, we define "
"`summarize` as the username followed by the entire text of the tweet, "
"assuming that tweet content is already limited to 280 characters."
msgstr ""
"Şimdi Summary özelliğinin yöntemlerinin istenen imzalarını tanımladığımıza "
"göre, bunu medya toplayıcımızdaki türler üzerinde uygulayabiliriz. Aşağıdaki "
"kod, NewsArticle yapısındaki Summary özelliğinin zaten başlığı kullanan bir "
"uygulamasını gösterir, yazar, ve summarize'in geri dönüş değerini oluşturmak "
"için konum, summarize'in tüm kullanıcı adıdır."

#: src/ch08-02-traits-in-cairo.md:188
msgid ""
"Implementing a trait on a type is similar to implementing regular methods. "
"The difference is that after `impl`, we put a name for the implementation, "
"then use the `of` keyword, and then specify the name of the trait we are "
"writing the implementation for. If the implementation is for a generic type, "
"we place the generic type name in the angle brackets after the trait name."
msgstr ""
"Bir tür üzerinde bir özellik uygulamak, düzenli yöntemlerin uygulanmasına "
"benzer. Fark, impl'den sonra, uygulama için bir isim koymamız, daha sonra of "
"anahtar kelimesini kullanmamız ve daha sonra uygulama için yazdığımız "
"özelliğin adını belirtmemizdir. Uygulama genel bir tür içinse, genel tip "
"adını özellik adından sonraki açı parantezlerine yerleştiririz."

#: src/ch08-02-traits-in-cairo.md:193
msgid ""
"Note that for the trait method to be accessible, there must be an "
"implementation of that trait visible from the scope where the method is "
"called. If the trait is `pub` and the implementation is not, and the "
"implementation is not visible in the scope where the trait method is called, "
"this will cause a compilation error."
msgstr ""
"Bu özellik yönteminin erişilebilir olması için, bu özelliğin yöntemin "
"çağrıldığı kapsamdan görünür bir uygulaması olması gerektiğini unutmayın. "
"Eğer özellik pub ise ve uygulama değilse ve uygulama özellik yönteminin "
"çağrıldığı kapsamda görünmezse, bu bir derleme hatasına neden olacaktır."

#: src/ch08-02-traits-in-cairo.md:195
msgid ""
"Within the `impl` block, we put the method signatures that the trait "
"definition has defined. Instead of adding a semicolon after each signature, "
"we use curly brackets and fill in the method body with the specific behavior "
"that we want the methods of the trait to have for the particular type."
msgstr ""
"impl bloğu içinde, özellik tanımının tanımladığı yöntem imzalarını koyarız. "
"Her imzadan sonra bir virgül eklemek yerine, kıvırcık parantezler kullanır "
"ve özellik metotlarının belirli tip için sahip olmasını istediğimiz özel "
"davranışla yöntem gövdesini doldururuz."

#: src/ch08-02-traits-in-cairo.md:200
msgid ""
"Now that the library has implemented the `Summary` trait on `NewsArticle` "
"and `Tweet`, users of the crate can call the trait methods on instances of "
"`NewsArticle` and `Tweet` in the same way we call regular methods. The only "
"difference is that the user must bring the trait into scope as well as the "
"types. Here’s an example of how a crate could use our `aggregator` crate:"
msgstr ""
"Artık kütüphane NewsArticle ve Tweet üzerinde Summary özelliğini "
"uyguladığına göre, kasa kullanıcıları, NewsArticle ve Tweet örneklerindeki "
"özellik yöntemlerini düzenli yöntemler olarak adlandırdığımız şekilde "
"arayabilirler. Tek fark, kullanıcının özelliğin yanı sıra türleri de kapsam "
"içine getirmesi gerektiğidir. İşte bir kasanın aggr sandığımızı nasıl "
"kullanabileceğinin bir örneği:"

#: src/ch08-02-traits-in-cairo.md:265
msgid "This code prints the following:"
msgstr "Bu kod aşağıdakileri yazdırır:"

#: src/ch08-02-traits-in-cairo.md:279
msgid ""
"Other crates that depend on the _aggregator_ crate can also bring the "
"`Summary` trait into scope to implement `Summary` on their own types."
msgstr ""
"_aggregator_ sandığına bağlı olan diğer sandıklar, Summary özelliğini kendi "
"türlerinde uygulamak için de kapsam içine getirebilir."

#: src/ch08-02-traits-in-cairo.md:304
msgid "Managing and Using External Trait"
msgstr "Dış Trait'i Yönetmek ve Kullanmak"

#: src/ch08-02-traits-in-cairo.md:306
msgid ""
"To use traits methods, you need to make sure the correct traits/"
"implementation(s) are imported. In some cases you might need to import not "
"only the trait but also the implementation if they are declared in separate "
"modules. If `CircleGeometry` implementation was in a separate module/file "
"named _circle_, then to define `boundary` method on `Circle` struct, we'd "
"need to import `ShapeGeometry` trait in the _circle_ module."
msgstr ""
"Özellikler yöntemlerini kullanmak için, doğru özelliklerin/uygulamaların/"
"uygulamaların içe aktarıldığından emin olmanız gerekir. Bazı durumlarda, "
"yalnızca özelliği değil, aynı zamanda ayrı modüllerde beyan edilirse "
"uygulamayı da içe aktarmanız gerekebilir. Eğer CircleGeometri uygulaması "
"ayrı bir modülde/dosyada _circle_ olarak adlandırılmışsa, Circle struct "
"üzerinde boundary yöntemini tanımlamak için circle_Geometri'yi içe "
"aktarmamız gerekir."

#: src/ch08-02-traits-in-cairo.md:309
msgid ""
"If the code was organized into modules like this, where the implementation "
"of a trait was defined in a different module than the trait itself, "
"explicitly importing the relevant trait or implementation is required."
msgstr ""
"Kod, bir özelliğin uygulanmasının özelliğin kendisinden farklı bir modülde "
"tanımlandığı bu gibi modüller halinde düzenlenmişse, ilgili özelliğin veya "
"uygulamanın açıkça içe aktarılması gerekir."

#: src/ch08-02-traits-in-cairo.md:312
msgid ""
"// Here T is an alias type which will be provided during implementation\n"
msgstr "// Burada T, uygulama sırasında sağlanacak bir takma ad türüdür.\n"

#: src/ch08-02-traits-in-cairo.md:319
msgid ""
"// Importing ShapeGeometry is required to implement this trait for "
"Rectangle\n"
msgstr ""
"// Dikdörtgen için bu özelliği uygulamak için ShapeGeometri ithal edilmesi "
"gereklidir\n"

#: src/ch08-02-traits-in-cairo.md:328
msgid ""
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"    // to implement the trait for that type\n"
msgstr ""
"// Uygulama DikdörtgenGeometrisi Rectangle> // bu tür için özelliği "
"uygulamak için geçer\n"

#: src/ch08-02-traits-in-cairo.md:341
msgid ""
"// Importing ShapeGeometry is required to implement this trait for Circle\n"
msgstr ""
"// Çember için bu özelliği uygulamak için ShapeGeometri'yi ithal etmek "
"gerekir\n"

#: src/ch08-02-traits-in-cairo.md:349
msgid ""
"// Implementation CircleGeometry passes in <Circle>\n"
"    // to implement the imported trait for that type\n"
msgstr ""
"// Uygulama ÇemberiGeometrisi, bu tür için ithal edilen özelliği uygulamak "
"için Circle> // geçer\n"

#: src/ch08-02-traits-in-cairo.md:366
msgid "\"Rectangle area: {}\""
msgstr "\"Dikdörtgen alanı: \""

#: src/ch08-02-traits-in-cairo.md:366
msgid "//35\n"
msgstr "//35\n"

#: src/ch08-02-traits-in-cairo.md:367
msgid "\"Rectangle boundary: {}\""
msgstr "\"Yükseliş sınırı: \""

#: src/ch08-02-traits-in-cairo.md:367
msgid "//24\n"
msgstr "//24\n"

#: src/ch08-02-traits-in-cairo.md:370
msgid "\"Circle area: {}\""
msgstr "\"Daire alanı: \""

#: src/ch08-02-traits-in-cairo.md:370
msgid "//78\n"
msgstr "//78\n"

#: src/ch08-02-traits-in-cairo.md:371
msgid "\"Circle boundary: {}\""
msgstr "\"Daire sınırı: \""

#: src/ch08-02-traits-in-cairo.md:371
msgid "//31\n"
msgstr "//31\n"

#: src/ch08-02-traits-in-cairo.md:375
msgid ""
"Note that in this example, `CircleGeometry` and `RectangleGeometry` "
"implementations don't need to be declared as `pub`. Indeed, `ShapeGeometry` "
"trait, which is public, is used to print the result in the `main` function. "
"The compiler will find the appropriate implementation for the "
"`ShapeGeometry` public trait, regardless of the implementation visibility."
msgstr ""
"Bu örnekte, CircleGeometri ve RectangleGeometri uygulamalarının pub olarak "
"ilan edilmesine gerek olmadığını unutmayın. Gerçekten de, ShapeGeometri "
"özelliği, main işlevindeki sonucu yazdırmak için kullanılır. Derleyici, "
"uygulama görünürlüğüne bakılmaksızın ShapeGeometri kamusal özelliği için "
"uygun uygulamayı bulacaktır."

#: src/ch08-02-traits-in-cairo.md:377
msgid "Impl Aliases"
msgstr "Impl Aliases"

#: src/ch08-02-traits-in-cairo.md:379
msgid ""
"Implementations can be aliased when imported. This is most useful when you "
"want to instantiate generic implementations with concrete types. For "
"example, let's say we define a trait `Two` that is used to return the value "
"`2` for a type `T`. We can write a trivial generic implementation of `Two` "
"for all types that implement the `One` trait, simply by adding twice the "
"value of `one` and returning it. However, in our public API, we may only "
"want to expose the `Two` implementation for the `u8` and `u128` types."
msgstr ""
"İthal edildiğinde uygulamalar takma adla adlandırılabilir. Bu, genel "
"uygulamaları somut tiplerle anlık hale getirmek istediğinizde en "
"kullanışlıdır. Örneğin, bir T türü için 2 değerini döndürmek için kullanılan "
"bir Two özelliğini tanımladığımızı varsayalım. Two'nun önemsiz bir genel "
"uygulamasını yazabiliriz. One özelliğini uygulayan tüm türler için, sadece "
"One özelliğini iki kez ekleyerek ve döndürerek."

#: src/ch08-02-traits-in-cairo.md:400
msgid ""
"<span class=\"caption\"> Listing 8-1: Using impl aliases to instantiate "
"generic impls with concrete types</span>"
msgstr ""
"span class=\"caption\"> Listeleme 8-1: Genel implleri somut tiplerle anlık "
"hale getirmek için impl takma adlarının kullanılması/span>"

#: src/ch08-02-traits-in-cairo.md:402
msgid ""
"We can define the generic implementation in a private module, use an impl "
"alias to instantiate the generic implementation for these two concrete "
"types, and make these two implementations public, while keeping the generic "
"implementation private and unexposed. This way, we can avoid code "
"duplication using the generic implementation, while keeping the public API "
"clean and simple."
msgstr ""
"Genel uygulamayı özel bir modülde tanımlayabilir, bu iki beton türü için "
"genel uygulamayı anlık hale getirmek için bir impl takma adı kullanabilir ve "
"bu iki uygulamayı kamuya açık hale getirebilir, genel uygulamayı özel ve "
"teşhir edilmeden tutabiliriz. Bu şekilde, genel uygulamayı kullanarak kod "
"çoğaltılmasını önleyebilir, kamu API'sini temiz ve basit tutarken."

#: src/ch08-02-traits-in-cairo.md:404
msgid "Negative Impls"
msgstr "Negatif İmpls"

#: src/ch08-02-traits-in-cairo.md:406
msgid ""
"Note: This is still an experimental feature and can only be used if "
"`experimental-features = [\"negative_impls\"]` is enabled in your _Scarb."
"toml_ file, under the `[package]` section."
msgstr ""
"Not: Bu hala deneysel bir özelliktir ve yalnızca [package] bölümünün "
"altındaki _Scarb.toml_ dosyanızda experimental-features = "
"[\"negatif_impls\"] etkinleştirildiğinde kullanılabilir."

#: src/ch08-02-traits-in-cairo.md:408
msgid ""
"Negative implementations, also known as negative traits or negative bounds, "
"are a mechanism that allows you to express that a type does not implement a "
"certain trait when defining the implementation of a trait over a generic "
"type. Negative impls enable you to write implementations that are applicable "
"only when another implementation does not exist in the current scope."
msgstr ""
"Negatif özellikler veya negatif sınırlar olarak da bilinen negatif "
"uygulamalar, bir türün bir özelliğin genel bir tür üzerinde uygulanmasını "
"tanımlarken belirli bir özelliği uygulamadığını ifade etmenizi sağlayan bir "
"mekanizmadır. Negatif impls, yalnızca mevcut kapsamda başka bir uygulama "
"bulunmadığında uygulanabilir uygulamaları yazmanızı sağlar."

#: src/ch08-02-traits-in-cairo.md:410
msgid ""
"For example, let's say we have a trait `Producer` and a trait `Consumer`, "
"and we want to define a generic behavior where all types implement the "
"`Consumer` trait by default. However, we want to ensure that no type can be "
"both a `Consumer` and a `Producer`. We can use negative impls to express "
"this restriction."
msgstr ""
"Örneğin, bir Producer ve bir Consumer özelliğimiz olduğunu varsayalım ve her "
"türün varsayılan olarak Consumer özelliğini uyguladığı genel bir davranış "
"tanımlamak istiyoruz. Ancak, hiçbir türün hem Consumer hem de Producer "
"olmasını sağlamak istiyoruz. Bu kısıtlamayı ifade etmek için negatif impls "
"kullanabiliriz."

#: src/ch08-02-traits-in-cairo.md:412
msgid ""
"In Listing 8-2, we define a `ProducerType` that implements the `Producer` "
"trait, and two other types, `AnotherType` and `AThirdType`, which do not "
"implement the `Producer` trait. We then use negative impls to create a "
"default implementation of the `Consumer` trait for all types that do not "
"implement the `Producer` trait."
msgstr ""
"Listeleme 8-2'de, Producer özelliğini uygulayan bir ProducerType ve Producer "
"özelliğini uygulamayan AnotherType ve AThirdType diğer iki türü tanımlarız. "
"Daha sonra Producer özelliğini uygulamayan tüm türler için Consumer "
"özelliğinin varsayılan bir uygulamasını oluşturmak için negatif impls "
"kullanırız."

#: src/ch08-02-traits-in-cairo.md:440
msgid "\"{:?} consumed value: {}\""
msgstr "\":? tüketilen değer: \""

#: src/ch08-02-traits-in-cairo.md:450
msgid ""
"// producer.consumer(production); Invalid: ProducerType does not implement "
"Consumer\n"
msgstr ""
"// producer.consumer(production); Geçersiz: ProducerType Tüketiciyi "
"uygulamaz\n"

#: src/ch08-02-traits-in-cairo.md:456
msgid ""
"<span class=\"caption\"> Listing 8-2: Using negative impls to enforce that a "
"type cannot implement both `Producer` and `Consumer` traits simultaneously</"
"span>"
msgstr ""
"span class=\"caption\"> Listeleme 8-2: Bir türün hem Producer hem de "
"Consumer özelliklerini aynı anda uygulayamayacağını zorlamak için negatif "
"impls kullanmak/span>"

#: src/ch08-02-traits-in-cairo.md:458
msgid ""
"In the `main` function, we create instances of `ProducerType`, "
"`AnotherType`, and `AThirdType`. We then call the `produce` method on the "
"`producer` instance and pass the result to the `consume` method on the "
"`another_type` and `third_type` instances. Finally, we try to call the "
"`consume` method on the `producer` instance, which results in a compile-time "
"error because `ProducerType` does not implement the `Consumer` trait."
msgstr ""
"main fonksiyonunda, ProducerType, AnotherType ve A ThirdType örneklerini "
"oluştururuz. Daha sonra produce metodunu producer örneğinde çağırırız ve "
"sonucu another_type ve third_type örnekleri üzerinde consume metoduna "
"aktarırız. Son olarak, consume metodunu producer olarak çağırmaya çalışırız."

#: src/ch08-02-traits-in-cairo.md:460
msgid "{{#quiz ../quizzes/ch08-02-traits.toml}}"
msgstr "#quiz../quizzes/ch08-02-traits.toml"

#: src/ch09-00-error-handling.md
msgid "Error handling"
msgstr "Hata işleme"

#: src/ch09-00-error-handling.md
msgid ""
"In this chapter, we will explore various error handling techniques provided "
"by Cairo, which not only allow you to address potential issues in your code, "
"but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as "
"pattern matching with the `Result` enum, using the `?` operator for more "
"ergonomic error propagation, and employing the `unwrap` or `expect` methods "
"for handling recoverable errors, you'll gain a deeper understanding of "
"Cairo's error handling features. These concepts are crucial for building "
"robust applications that can effectively handle unexpected situations, "
"ensuring your code is ready for production."
msgstr ""
"Bu bölümde, Kahire tarafından sağlanan çeşitli hata işleme tekniklerini "
"inceleyeceğiz, bu da kodunuzdaki potansiyel sorunları ele almanızı "
"sağlamakla kalmaz, aynı zamanda uyarlanabilir ve bakımlı programlar "
"oluşturmayı kolaylaştırır. Hataları yönetmek için Result enum ile eşleşen "
"desen gibi farklı yaklaşımları inceleyerek, daha ergonomik hata yayılımı "
"için? operatörünü kullanarak ve  unwrap veya expect yöntemlerini kullanarak."

#: src/ch09-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with `panic`"
msgstr "panic ile düzeltilemeyen hatalar"

#: src/ch09-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in "
"runtime errors. While the `panic` function from the core library doesn't "
"provide a resolution for these errors, it does acknowledge their occurrence "
"and terminates the program. There are two primary ways that a panic can be "
"triggered in Cairo: inadvertently, through actions causing the code to panic "
"(e.g., accessing an array beyond its bounds), or deliberately, by invoking "
"the `panic` function."
msgstr ""
"Kahire'de program yürütme sırasında beklenmedik sorunlar ortaya çıkabilir, "
"bu da çalışma zamanı hatalarıyla sonuçlanır. Çekirdek kütüphaneden gelen "
"panic işlevi bu hatalar için bir çözüm sağlamazken, bu hataların meydana "
"geldiğini kabul eder ve programı sonlandırır. Kahire'de bir paniğin "
"tetiklenebilmesinin iki ana yolu vardır: yanlışlıkla, kodun paniğe neden "
"olan eylemlerle (örneğin, sınırlarının ötesinde bir diziye erişme) veya "
"kasıtlı olarak, panic işlevini çağırarak."

#: src/ch09-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The "
"`panic` function takes an array as an argument, which can be used to provide "
"an error message and performs an unwind process where all variables are "
"dropped and dictionaries squashed to ensure the soundness of the program to "
"safely terminate the execution."
msgstr ""
"Bir panik meydana geldiğinde, programın ani bir şekilde sonlandırılmasına "
"yol açar. panic işlevi, bir hata mesajı sağlamak için kullanılabilen ve tüm "
"değişkenlerin bırakıldığı bir gevşeme işlemi gerçekleştiren bir argüman "
"olarak bir dizi alır ve programın yürütmeyi güvenli bir şekilde "
"sonlandırmasını sağlamak için sözlükler ezilir."

#: src/ch09-01-unrecoverable-errors-with-panic.md:7
msgid ""
"Here is how we can call `panic` from inside a program and return the error "
"code `2`:"
msgstr ""
"Bir programın içinden panic'yi nasıl çağırabiliriz ve hata kodunu 2 "
"döndürebiliriz:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:18
#: src/ch09-01-unrecoverable-errors-with-panic.md:58
msgid "\"This line isn't reached\""
msgstr "\"Bu çizgiye ulaşılamadı\""

#: src/ch09-01-unrecoverable-errors-with-panic.md:22
msgid "Running the program will produce the following output:"
msgstr "Programın çalıştırılması aşağıdaki çıktıyı üretecektir:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:33
msgid ""
"As you can notice in the output, the call to `println!` macro is never "
"reached, as the program terminates after encountering the `panic` statement."
msgstr ""
"Çıktıda fark edebileceğiniz gibi, println! makrosuna yapılan çağrıya asla "
"ulaşılmaz, çünkü program panic ifadesiyle karşılaştıktan sonra sona erer."

#: src/ch09-01-unrecoverable-errors-with-panic.md:35
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use "
"the `panic_with_felt252` function. This function serves as an abstraction of "
"the array-defining process and is often preferred due to its clearer and "
"more concise expression of intent. By using `panic_with_felt252`, developers "
"can panic in a one-liner by providing a `felt252` error message as an "
"argument, making the code more readable and maintainable."
msgstr ""
"Kahire'de panik için alternatif ve daha deyimsel bir yaklaşım, "
"panic_with_felt252 fonksiyonunu kullanmak olacaktır. Bu işlev, dizi "
"tanımlama işleminin bir soyutlaması olarak işlev görür ve daha net ve daha "
"özlü niyet ifadesi nedeniyle sıklıkla tercih edilir. panic_with_felt252 "
"kullanarak, geliştiriciler bir felt252 hata mesajı okunabilir argümanı "
"sağlayarak tek satırda panikleyebilirler."

#: src/ch09-01-unrecoverable-errors-with-panic.md:37
msgid "Let's consider an example:"
msgstr "Bir örnek düşünelim:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:47
msgid ""
"Executing this program will yield the same error message as before. In that "
"case, if there is no need for an array and multiple values to be returned "
"within the error, `panic_with_felt252` is a more succinct alternative."
msgstr ""
"Bu programın çalıştırılması daha önce olduğu gibi aynı hata iletisini "
"verecektir. Bu durumda, bir dizi ve birden fazla değerin hata içinde "
"döndürülmesine gerek yoksa, panic_with_felt252 daha kısa bir alternatiftir."

#: src/ch09-01-unrecoverable-errors-with-panic.md:49 src/ch11-05-macros.md:29
msgid "`panic!` Macro"
msgstr "panic! Makro"

#: src/ch09-01-unrecoverable-errors-with-panic.md:51
msgid ""
"`panic!` macro can be really helpful. The previous example returning the "
"error code `2` shows how convenient `panic!` macro is. There is no need to "
"create an array and pass it as an argument like with the `panic` function."
msgstr ""
"panic! makrosu gerçekten yardımcı olabilir. 2 hata kodunu döndüren önceki "
"örnek, panic! makrosunun ne kadar kullanışlı olduğunu gösterir. Bir dizi "
"oluşturmaya ve panic fonksiyonunda olduğu gibi bir argüman olarak geçirmeye "
"gerek yoktur."

#: src/ch09-01-unrecoverable-errors-with-panic.md:56
msgid "\"2\""
msgstr "\"2\""

#: src/ch09-01-unrecoverable-errors-with-panic.md:62
msgid ""
"Unlike the `panic_with_felt252` function, using `panic!` allows the input, "
"which is ultimately the panic error, to be a literal longer than 31 bytes. "
"This is because `panic!` takes a string as a parameter. For example, the "
"following line of code will successfully compile:"
msgstr ""
"panic_with_felt252 işlevinden farklı olarak, panic! kullanarak, sonuçta "
"panik hatası olan girdinin 31 bayttan daha uzun olmasını sağlar. Bunun "
"nedeni, panic! bir dizeyi parametre olarak almasıdır. Örneğin, aşağıdaki kod "
"satırı başarıyla derleyecektir:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:65
msgid "\"the error for panic! macro is not limited to 31 characters anymore\""
msgstr "\"Panik hatası! makro artık 31 karakterle sınırlı değil\""

#: src/ch09-01-unrecoverable-errors-with-panic.md:68
msgid "`nopanic` Notation"
msgstr "nopanic Notasyonu"

#: src/ch09-01-unrecoverable-errors-with-panic.md:70
msgid ""
"You can use the `nopanic` notation to indicate that a function will never "
"panic. Only `nopanic` functions can be called in a function annotated as "
"`nopanic`."
msgstr ""
"nopanic notasyonunu bir fonksiyonun asla paniklemeyeceğini belirtmek için "
"kullanabilirsiniz. Sadece nopanic fonksiyonları nopanic olarak belirtilen "
"bir fonksiyonda çağrılabilir."

#: src/ch09-01-unrecoverable-errors-with-panic.md:80
msgid ""
"This function will always return `42` and is guaranteed to never panic. "
"Conversely, the following function is not guaranteed to never panic:"
msgstr ""
"Bu fonksiyon her zaman 42  geri dönecektir ve asla panik yapmaması garanti "
"edilir. Tersine, aşağıdaki fonksiyonun asla paniklememesi garanti edilmez:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:88
msgid ""
"If you try to compile this function that includes code that may panic, you "
"will get the following error:"
msgstr ""
"Panikleyebilecek kod içeren bu işlevi derlemeye çalışırsanız, aşağıdaki "
"hatayı alırsınız:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:108
msgid ""
"Note that there are two functions that may panic here, `assert` and equality "
"with `==`. We usually don't use `assert` function in practice and use "
"`assert!` macro instead. We will discuss `assert!` macro in more detail in "
"the [Testing Cairo Programs](./ch10-01-how-to-write-tests.md#checking-"
"results-with-the-assert-macro) chapter."
msgstr ""
"Burada panikleyebilecek iki fonksiyon olduğunu unutmayın, assert ve == ile "
"eşitlik. Genellikle pratikte assert işlevini kullanmayız ve bunun yerine "
"assert! makrosunu kullanırız. [Testing Cairo Programs](./ch10-01-how-to-"
"write-tests.md#checking-results-the-the-the-the-the-"

#: src/ch09-01-unrecoverable-errors-with-panic.md:112
msgid "`panic_with` Attribute"
msgstr "panic_with Öznitelik"

#: src/ch09-01-unrecoverable-errors-with-panic.md:114
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an "
"`Option` or `Result`. This attribute takes two arguments, which are the data "
"that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will "
"panic if the function returns `None` or `Err`, with the given data as the "
"panic error."
msgstr ""
"panic_with özniteliğini, bir Option veya Result döndüren bir işlevi "
"işaretlemek için kullanabilirsiniz. Bu öznitelik, panik nedeni olarak geçen "
"veriler ve bir sarma işlevinin adı olan iki argüman alır. Fonksiyon, panik "
"hatası olarak verilen verilerle None veya Err döndürdüğünde paniklenecek "
"olan açıklamalı işleviniz için bir ambalaj oluşturacaktır."

#: src/ch09-01-unrecoverable-errors-with-panic.md:116
#: src/appendix-03-derivable-traits.md:38
msgid "Example:"
msgstr "Örnek:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:129
msgid "// this returns None\n"
msgstr "// bu None değerini gönderir\n"

#: src/ch09-01-unrecoverable-errors-with-panic.md:130
msgid "// this panics with 'value is 0'\n"
msgstr "// bu 'değer 0' ile panikler\n"

#: src/ch09-01-unrecoverable-errors-with-panic.md:134
msgid "{{#quiz ../quizzes/ch09-01-unrecoverable-errors-with-panic.toml}}"
msgstr "#quiz../quizzes/ch09-01-unrecoverable-errors-with-panic.toml"

#: src/ch09-02-recoverable-errors.md:1
msgid "Recoverable Errors with `Result`"
msgstr "Result ile Kurtarılabilir Hatalar"

#: src/ch09-02-recoverable-errors.md:3
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to add two large integers "
"and the operation overflows because the sum exceeds the maximum "
"representable value, you might want to return an error or a wrapped result "
"instead of causing undefined behavior or terminating the process."
msgstr ""
"Çoğu hata, programın tamamen durmasını gerektirecek kadar ciddi değildir. "
"Bazen, bir işlev başarısız olduğunda, kolayca yorumlayabileceğiniz ve "
"yanıtlayabileceğiniz bir nedenden dolayıdır. Örneğin, iki büyük tamsayı "
"eklemeye çalışırsanız ve işlem, toplamın maksimum temsil edilebilir değeri "
"aştığı için taşarsa, tanımsız davranışa neden olmak veya süreci sonlandırmak "
"yerine bir hata veya sarılmış bir sonuç döndürmek isteyebilirsiniz."

#: src/ch09-02-recoverable-errors.md:5
msgid "The `Result` Enum"
msgstr "Result Enum"

#: src/ch09-02-recoverable-errors.md:7
msgid ""
"Recall from [Generic data types](./ch08-01-generic-data-types.md#enums) "
"section in Chapter 8 that the `Result` enum is defined as having two "
"variants, `Ok` and `Err`, as follows:"
msgstr ""
"Bölüm 8'deki [Generic data types](./ch08-01-generic-data-types.md#enums) "
"bölümünden Result enum'un aşağıdaki gibi iki varyanta sahip olduğu "
"tanımlanmaktadır:"

#: src/ch09-02-recoverable-errors.md:20
msgid "The `ResultTrait`"
msgstr "ResultTrait"

#: src/ch09-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>` "
"enum, such as unwrapping values, checking whether the `Result` is `Ok` or "
"`Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr ""
"ResultTrait özelliği, ResultT, E> enum ile çalışmak için Result'nin Ok veya "
"Err olup olmadığını kontrol etmek ve özel bir mesajla paniklemek gibi "
"yöntemler sağlar. ResultTraitImpl uygulaması bu yöntemlerin mantığını "
"tanımlar."

#: src/ch09-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to "
"extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` "
"variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior "
"when the `Result` is in the `Err` variant. The `expect` method allows you to "
"provide a custom error message (as a `felt252` value) that will be used when "
"panicking, giving you more control and context over the panic. On the other "
"hand, the `unwrap` method panics with a default error message, providing "
"less information about the cause of the panic."
msgstr ""
"Expect ve unwrap yöntemleri, her ikisi de T tipinin değerini ResultT, E> Ok "
"varyantında olduğunda eldeki bir hatadan çıkarmaya çalıştıklarında "
"benzerdir. Result, Ok(x) ise, her iki yöntem de x değerini döndürür. Ancak, "
"iki yöntem arasındaki anahtar fark, davranışlarında yatar."

#: src/ch09-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` methods have the exact opposite behavior. "
"If the `Result` is `Err(x)`, both methods return the value `x`. However, the "
"key difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control "
"and context over the panic. On the other hand, the `unwrap_err` method "
"panics with a default error message, providing less information about the "
"cause of the panic."
msgstr ""
"expect_err ve unwrap_err yöntemleri tam tersi bir davranışa sahiptir. Result "
"hatası Err(x) ise, her iki yöntem de x değerini döndürür. Bununla birlikte, "
"iki yöntem arasındaki temel fark Result::Ok() diğer bir hata olduğunda "
"expect_err yöntemi özel bir hata iletisi vermenizi sağlar."

#: src/ch09-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the "
"first four methods signatures. This syntax represents generic type "
"constraints in the Cairo language, as seen in the previous chapter. These "
"constraints indicate that the associated functions require an implementation "
"of the `Drop` trait for the generic types `T` and `E`, respectively."
msgstr ""
"Dikkatli bir okuyucu, ilk dört yöntem imzasında +DropT> ve +DropE> "
"özelliklerini fark etmiş olabilir. Bu sözdizimi, önceki bölümde görüldüğü "
"gibi Kahire dilindeki genel tip kısıtlamaları temsil eder. Bu kısıtlamalar, "
"ilişkili işlevlerin sırasıyla T ve E jenerik tipleri için Drop özelliğinin "
"uygulanmasını gerektirdiğini göstermektedir."

#: src/ch09-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by "
"the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr ""
"Son olarak, is_ok ve is_err yöntemleri, bir Result enum değerinin varyantını "
"kontrol etmek için ResultTrait özelliği tarafından sağlanan yardımcı "
"işlevlerdir."

#: src/ch09-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the "
"`Result` is the `Ok` variant, meaning the operation was successful. If the "
"`Result` is the `Err` variant, it returns `false`."
msgstr ""
"is_ok bir ResultT, E> değerinin anlık görüntüsünü alır ve true değerini "
"gönderir Result Ok varyantıysa, işlem başarılı demektir. Result Err "
"varyantıysa, false değerini döndürür."

#: src/ch09-02-recoverable-errors.md:49
msgid ""
"`is_err` takes a snapshot of a `Result<T, E>` value and returns `true` if "
"the `Result` is the `Err` variant, meaning the operation encountered an "
"error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr ""
"is_err bir ResultT, E> değerinin anlık görüntüsünü alır ve true değerini "
"gönderir Result Err varyantı ise, işlem bir hatayla karşılaştı demektir. "
"Result Ok varyantıysa, false değerini döndürür."

#: src/ch09-02-recoverable-errors.md:51
msgid ""
"These methods are helpful when you want to check the success or failure of "
"an operation without consuming the `Result` value, allowing you to perform "
"additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr ""
"Bu yöntemler, bir işlemin başarısını veya başarısızlığını Result değerini "
"tüketmeden kontrol etmek istediğinizde, ek işlemleri gerçekleştirmenize veya "
"açmadan varyantı temel alarak kararlar vermenize izin verdiğinizde "
"yararlıdır."

#: src/ch09-02-recoverable-errors.md:53
msgid ""
"You can find the implementation of the `ResultTrait` [here](https://github."
"com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr ""
"ResultTrait [burada](https://github.com/starkware-libs/cairo/blob/main/"
"corelib/src/result.cairo#L20) uygulamasının uygulanmasını bulabilirsiniz."

#: src/ch09-02-recoverable-errors.md:55
msgid ""
"It is always easier to understand with examples. Have a look at this "
"function signature:"
msgstr ""
"Örneklerle anlamak her zaman daha kolaydır. Bu fonksiyon imzasına bir göz "
"atın:"

#: src/ch09-02-recoverable-errors.md:61
msgid ""
"It takes two `u128` integers, `a` and `b`, and returns a `Result<u128, "
"u128>` where the `Ok` variant holds the sum if the addition does not "
"overflow, and the `Err` variant holds the overflowed value if the addition "
"does overflow."
msgstr ""
"İki u128 tamsayısı, a ve b alır ve Resultu128, u128> eki taşmazsa Ok "
"varyantı toplamı tutar ve Err varyantı, ekleme taşarsa taşan değeri tutar."

#: src/ch09-02-recoverable-errors.md:63
msgid "Now, we can use this function elsewhere. For instance:"
msgstr "Şimdi, bu işlevi başka bir yerde kullanabiliriz. Örneğin:"

#: src/ch09-02-recoverable-errors.md:75
msgid ""
"Here, it accepts two `u128` integers, `a` and `b`, and returns an "
"`Option<u128>`. It uses the `Result` returned by `u128_overflowing_add` to "
"determine the success or failure of the addition operation. The `match` "
"expression checks the `Result` from `u128_overflowing_add`. If the result is "
"`Ok(r)`, it returns `Option::Some(r)` containing the sum. If the result is "
"`Err(r)`, it returns `Option::None` to indicate that the operation has "
"failed due to overflow. The function does not panic in case of an overflow."
msgstr ""
"Burada, iki u128 tamsayısını, a ve b kabul eder ve bir Optionu128> döndürür. "
"Ek işlemin başarısını veya başarısızlığını belirlemek için "
"u128_overflowing_add tarafından döndürülen Result işaretini kullanır. match "
"ifadesi Result değerini u128_overflowing_add'den alır."

#: src/ch09-02-recoverable-errors.md:77
msgid "Let's take another example:"
msgstr "Başka bir örnek ele alalım:"

#: src/ch09-02-recoverable-errors.md:88
msgid ""
"In this example, the `parse_u8` function takes a `felt252` and tries to "
"convert it into a `u8` integer using the `try_into` method. If successful, "
"it returns `Result::Ok(value)`, otherwise it returns `Result::Err('Invalid "
"integer')`."
msgstr ""
"Bu örnekte, parse_u8 fonksiyonu bir felt252 alır ve try_into yöntemini "
"kullanarak u8 tamsayısına dönüştürmeye çalışır. Başarılı olursa, Result::"
"Ok(value) değerini döndürür, aksi takdirde Result:Err('Invalid tamsayı') "
"değerini gönderir."

#: src/ch09-02-recoverable-errors.md:90
msgid "Our two test cases are:"
msgstr "İki test vakamız şunlardır:"

#: src/ch09-02-recoverable-errors.md:107
msgid "// should not panic\n"
msgstr "// panik yapmamalı\n"

#: src/ch09-02-recoverable-errors.md:115
msgid "// should panic\n"
msgstr "// paniğe kapılmalı\n"

#: src/ch09-02-recoverable-errors.md:123
msgid ""
"Don't worry about the `#[cfg(test)]` attribute for now. We'll explain in "
"more detail its meaning in the next [Testing Cairo Programs](./ch10-01-how-"
"to-write-tests.md) chapter."
msgstr ""
"Şimdilik #[cfg(test)] özniteliği için endişelenmeyin. Bir sonraki [Testing "
"Cairo Programs](./ch10-01-how-to-write-tests.md) bölümünde anlamını daha "
"ayrıntılı olarak açıklayacağız."

#: src/ch09-02-recoverable-errors.md:125
msgid ""
"`#[test]` attribute means the function is a test function, and "
"`#[should_panic]` attribute means this test will pass if the test execution "
"panics."
msgstr ""
"#[test] özniteliği, fonksiyonun bir test fonksiyonu olduğu anlamına gelir ve "
"#[should_panic] özniteliği, test yürütmesi paniklediğinde bu testin geçeceği "
"anlamına gelir."

#: src/ch09-02-recoverable-errors.md:127
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the "
"`unwrap` method not to panic. The second test function attempts to convert a "
"value that is out of the `u8` range, expecting the `unwrap` method to panic "
"with the error message `Invalid integer`."
msgstr ""
"İlki, felt252'den u8'ye geçerli bir dönüşümü test eder, unwrap yönteminin "
"paniklememesini bekler. İkinci test fonksiyonu, u8 aralığının dışında olan "
"bir değeri dönüştürmeye çalışır, unwrap yönteminin Geçersiz tamsayı hata "
"mesajıyla panik yapmasını bekler."

#: src/ch09-02-recoverable-errors.md:132
msgid "The `?` Operator"
msgstr "? Operatörü"

#: src/ch09-02-recoverable-errors.md:134
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator "
"is used for more idiomatic and concise error handling. When you use the `?` "
"operator on a `Result` or `Option` type, it will do the following:"
msgstr ""
"Konuşacağımız son operatör? operatörüdür.? operatörü daha basit ve özlü hata "
"işleme için kullanılır. Result veya Option tipinde? operatörünü "
"kullandığınızda, aşağıdakileri yapacaktır:"

#: src/ch09-02-recoverable-errors.md:136
msgid ""
"If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the "
"inner value `x` directly."
msgstr ""
"Eğer değer Result::Ok(x) veya Option::Some(x) ise, x iç değerini doğrudan "
"döndürür."

#: src/ch09-02-recoverable-errors.md:137
msgid ""
"If the value is `Result::Err(e)` or `Option::None`, it will propagate the "
"error or `None` by immediately returning from the function."
msgstr ""
"Eğer değer Result::Err(e) veya Option::None ise, fonksiyondan hemen geri "
"dönerek hatayı ya da None'u yayar."

#: src/ch09-02-recoverable-errors.md:139
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let "
"the calling function deal with them."
msgstr ""
"? operatörü, hataları dolaylı olarak ele almak ve arama işlevinin bunlarla "
"ilgilenmesine izin vermek istediğinizde kullanışlıdır."

#: src/ch09-02-recoverable-errors.md:146 src/ch09-02-recoverable-errors.md:166
msgid "// DO SOMETHING\n"
msgstr "// BİR ŞEY YAP\n"

#: src/ch09-02-recoverable-errors.md:152
msgid ""
"We can see that `do_something_with_parse_u8` function takes a `felt252` "
"value as input and calls `parse_u8` function. The `?` operator is used to "
"propagate the error, if any, or unwrap the successful value."
msgstr ""
"do_something_with_parse_u8 fonksiyonunun girdi olarak felt252 değerini "
"aldığını ve parse_u8 fonksiyonunu çağırdığını görebiliriz.? operatörü, varsa "
"hatayı yaymak veya başarılı değeri açmak için kullanılır."

#: src/ch09-02-recoverable-errors.md:154
msgid "And with a little test case:"
msgstr "Ve küçük bir test davasıyla:"

#: src/ch09-02-recoverable-errors.md:178
msgid "\"Result: {}\""
msgstr "\"Sonuç: \""

#: src/ch09-02-recoverable-errors.md:179
msgid "\"Error: {}\""
msgstr "\"Hata: \""

#: src/ch09-02-recoverable-errors.md:186
msgid "The console will print the error `Invalid Integer`."
msgstr "Konsol Invalid Integer hatasını yazdıracaktır."

#: src/ch09-02-recoverable-errors.md:190
msgid ""
"We saw that recoverable errors can be handled in Cairo using the `Result` "
"enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is "
"generic, with types `T` and `E` representing the successful and error "
"values, respectively. The `ResultTrait` provides methods for working with "
"`Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or "
"`Err`, and panicking with custom messages."
msgstr ""
"Geri kazanılabilir hataların Kahire'de iki varyantı olan Result enum'u "
"kullanarak ele alınabileceğini gördük: Ok ve Err. ResultT, E> enum, "
"sırasıyla başarılı ve hata değerlerini temsil eden T ve E türleri ile "
"geneldir. ResultTrait, Result gibi çalışma yöntemleri sunar."

#: src/ch09-02-recoverable-errors.md:192
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use "
"pattern matching to handle the success or failure of an operation. The `?` "
"operator can be used to implicitly handle errors by propagating the error or "
"unwrapping the successful value. This allows for more concise and clear "
"error handling, where the caller is responsible for managing errors raised "
"by the called function."
msgstr ""
"Geri kazanılabilir hataları işlemek için, bir işlev bir Result tipini "
"döndürebilir ve bir işlemin başarısını veya başarısızlığını ele almak için "
"kalıp eşlemesini kullanabilir.? operatörü, hatayı yayarak veya başarılı "
"değeri çözerek hataları dolaylı olarak ele almak için kullanılabilir. Bu, "
"arayan kişinin çağrılan işlev tarafından yükseltilen hataları yönetmekten "
"sorumlu olduğu daha özlü ve net hata işleme sağlar."

#: src/ch09-02-recoverable-errors.md:194
msgid "{{#quiz ../quizzes/ch09-02-error-handling-result.toml}}"
msgstr "#quiz../quizzes/ch09-02-error-handling-result.toml"

#: src/ch10-00-testing-cairo-programs.md
msgid ""
"Correctness in our programs is the extent to which our code does what we "
"intend it to do. Cairo is designed with a high degree of concern about the "
"correctness of programs, but correctness is complex and not easy to prove. "
"Cairo's linear type system shoulders a huge part of this burden, but the "
"type system cannot catch everything. As such, Cairo includes support for "
"writing tests."
msgstr ""
"Programlarımızda doğruluk, kodumuzun yapmayı amaçladığımız şeyi ne ölçüde "
"yaptığıdır. Kahire, programların doğruluğu konusunda yüksek derecede "
"endişeyle tasarlanmıştır, ancak doğruluk karmaşık ve kanıtlanması kolay "
"değildir. Kahire'nin doğrusal tip sistemi bu yükün büyük bir bölümünü taşır, "
"ancak tip sistemi her şeyi yakalayamaz. Bu nedenle Kahire, yazma testleri "
"için destek içerir."

#: src/ch10-00-testing-cairo-programs.md
msgid ""
"Testing is a complex skill: although we can’t cover every detail about how "
"to write good tests in one chapter, we’ll discuss the mechanics of Cairo's "
"testing facilities. We’ll talk about the annotations and macros available to "
"you when writing your tests, the default behavior and options provided for "
"running your tests, and how to organize tests into unit tests and "
"integration tests."
msgstr ""
"Test etmek karmaşık bir beceridir: Bir bölümde iyi testlerin nasıl "
"yazılacağına dair her ayrıntıyı karşılayamasak da, Kahire'nin test "
"tesislerinin mekaniğini tartışacağız. Testlerinizi yazarken "
"kullanabileceğiniz açıklamalardan ve makrolardan, testlerinizi yürütmek için "
"sağlanan varsayılan davranış ve seçeneklerden ve testlerin birim testlere ve "
"entegrasyon testlerine nasıl organize edileceğinden bahsedeceğiz."

#: src/ch10-01-how-to-write-tests.md:3 src/ch10-01-how-to-write-tests.md:17
msgid "The Anatomy of a Test Function"
msgstr "Bir Test Fonksiyonunun Anatomisi"

#: src/ch10-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these "
"three actions:"
msgstr ""
"Testler, test olmayan kodun beklenen şekilde çalıştığını doğrulayan Kahire "
"fonksiyonlarıdır. Test fonksiyonlarının gövdeleri tipik olarak şu üç işlemi "
"gerçekleştirir:"

#: src/ch10-01-how-to-write-tests.md:7
msgid "Set up any needed data or state."
msgstr "Gerekli herhangi bir veriyi veya durumu ayarlayın."

#: src/ch10-01-how-to-write-tests.md:8
msgid "Run the code you want to test."
msgstr "Test etmek istediğiniz kodu çalıştırın."

#: src/ch10-01-how-to-write-tests.md:9
msgid "Assert the results are what you expect."
msgstr "Sonuçların beklediğiniz gibi olduğunu varsayın."

#: src/ch10-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides for writing tests that take these "
"actions, which include:"
msgstr ""
"Kahire'nin şu eylemleri yapan yazma testleri için sağladığı özelliklere "
"bakalım:"

#: src/ch10-01-how-to-write-tests.md:13
msgid "`#[test]` attribute."
msgstr "#[test] özniteliği."

#: src/ch10-01-how-to-write-tests.md:14
msgid ""
"`assert!`, `assert_eq!`, `assert_ne!`, `assert_lt!`, `assert_le!`, "
"`assert_gt!` and `assert_ge!` macros."
msgstr ""
"assert!, assert_eq!, assert_ne!, assert_lt!, assert_le!, assert_gt! ve "
"assert_ge! makroları."

#: src/ch10-01-how-to-write-tests.md:15
msgid "`#[should_panic]` attribute."
msgstr "#[should_panic] özniteliği."

#: src/ch10-01-how-to-write-tests.md:19
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the "
"`#[test]` attribute. Attributes are metadata about pieces of Cairo code; one "
"example is the `#[derive()]` attribute we used with structs in [Chapter 5]"
"(ch05-01-defining-and-instantiating-structs.md). To change a function into a "
"test function, add `#[test]` on the line before `fn`. When you run your "
"tests with the `scarb cairo-test` command, Scarb runs Cairo's test runner "
"binary that runs the annotated functions and reports on whether each test "
"function passes or fails."
msgstr ""
"En basit haliyle, Kahire'deki bir test, #[test] özniteliği ile belirtilen "
"bir fonksiyondur. Öznitelikler, Kahire kodunun parçaları hakkında meta "
"verilerdir; bir örnek, [Bölüm 5] (ch05-01-defining-and-strastistating-"
"structs.md) 'deki structs ile birlikte kullandığımız #[derive()] "
"özniteliğidir. Bir fonksiyona değiştirildiğinde"

#: src/ch10-01-how-to-write-tests.md:21
msgid ""
"Let's create a new project called _adder_ using Scarb with the command "
"`scarb new adder`:"
msgstr ""
"Scarb'ı scarb new adder komutuyla kullanarak _adder_ adlı yeni bir proje "
"oluşturalım:"

#: src/ch10-01-how-to-write-tests.md:30
msgid ""
"In _lib.cairo_, let's remove the existing content and add a `tests` module "
"containing the first test, as shown in Listing 10-1."
msgstr ""
"_lib.cairo_'da, mevcut içeriği kaldıralım ve Listeleme 10-1'de gösterildiği "
"gibi ilk testi içeren bir tests modülü ekleyelim."

#: src/ch10-01-how-to-write-tests.md:51
msgid "<span class=\"caption\">Listing 10-1: A simple test function</span>"
msgstr "span class=\"caption\">Listing 10-1: Basit bir test fonksiyonu/span>"

#: src/ch10-01-how-to-write-tests.md:53
msgid ""
"Note the `#[test]` annotation: this attribute indicates this is a test "
"function, so the test runner knows to treat this function as a test. We "
"might also have non-test functions to help set up common scenarios or "
"perform common operations, so we always need to indicate which functions are "
"tests."
msgstr ""
"#[test] eknotasyonuna dikkat edin: bu öznitelik bunun bir test fonksiyonu "
"olduğunu gösterir, bu nedenle test koşucusu bu işlevi bir test olarak ele "
"almayı bilir. Ayrıca, ortak senaryolar kurmaya veya ortak işlemleri "
"gerçekleştirmeye yardımcı olmak için test dışı işlevlere de sahip "
"olabiliriz, bu nedenle her zaman hangi işlevlerin test olduğunu belirtmemiz "
"gerekir."

#: src/ch10-01-how-to-write-tests.md:55
msgid ""
"We use the `#[cfg(test)]` attribute for the `tests` module, so that the "
"compiler knows the code it contains needs to be compiled only when running "
"tests. This is actually not an option: if you put a simple test with the "
"`#[test]` attribute in a _lib.cairo_ file, it will not compile. We will talk "
"more about the `#[cfg(test)]` attribute in the next [Testing Organization]"
"(ch10-02-test-organization.md) section."
msgstr ""
"#[cfg(test)] özniteliğini tests modülü için kullanıyoruz, böylece derleyici "
"içerdiği kodun yalnızca testler yapılırken derlenmesi gerektiğini biliyor. "
"Bu aslında bir seçenek değil: #[test] özniteliğini bir _lib.cairo_ dosyasına "
"koyarsanız, derlemez. #[cfg(test) özniteliği hakkında daha fazla konuşacağız."

#: src/ch10-01-how-to-write-tests.md:57
msgid ""
"The example function body uses the `assert!` macro, which contains the "
"result of adding 2 and 2, which equals 4. This assertion serves as an "
"example of the format for a typical test. We'll explain in more detail how "
"`assert!` works later in this chapter. Let’s run it to see that this test "
"passes."
msgstr ""
"Örnek fonksiyon gövdesi, 2 ve 2 ekleme sonucunu içeren assert! makrosunu "
"kullanır, bu da 4'e eşittir. Bu iddia, tipik bir test için formatın bir "
"örneği olarak hizmet eder. assert!'nin bu bölümde daha sonra nasıl "
"çalıştığını daha ayrıntılı olarak açıklayacağız. Bu testin geçtiğini görmek "
"için çalıştıralım."

#: src/ch10-01-how-to-write-tests.md:59
msgid ""
"The `scarb cairo-test` command runs all tests found in our project, and "
"shows the following output:"
msgstr ""
"scarb cairo-test komutu projemizde bulunan tüm testleri çalıştırır ve "
"aşağıdaki çıktıyı gösterir:"

#: src/ch10-01-how-to-write-tests.md:69
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 "
"test`. The next line shows the name of the test function, called `it_works`, "
"and that the result of running that test is `ok`. The test runner also "
"provides an estimation of the gas consumption. The overall summary `test "
"result: ok.` means that all the tests passed, and the portion that reads `1 "
"passed; 0 failed` totals the number of tests that passed or failed."
msgstr ""
"scarb cairo-test derlendi ve testi çalıştırdı.  running 1 test çizgisini "
"görüyoruz. Bir sonraki satır it_works denilen test fonksiyonunun adını "
"gösterir ve bu testin sonucunun ok olduğunu gösterir. Test koşucusu ayrıca "
"gaz tüketiminin bir tahminini de sağlar. Genel özet test sonucu: Tamam. tüm "
"testlerin geçtiği ve 0'ın geçtiği anlamına gelir;"

#: src/ch10-01-how-to-write-tests.md:71
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically "
"Requested](#ignoring-some-tests-unless-specifically-requested) section later "
"in this chapter. Because we haven’t done that here, the summary shows `0 "
"ignored`. We can also pass an argument to the `scarb cairo-test` command to "
"run only a test whose name matches a string; this is called filtering and "
"we’ll cover that in the [Running Single Tests](#running-single-tests) "
"section. Since we haven’t filtered the tests being run, the end of the "
"summary shows `0 filtered out`."
msgstr ""
"Belirli bir örnekte çalışmaması için bir testi görmezden gelinmiş olarak "
"işaretlemek mümkündür; Bu bölümde daha sonra [Belirli İstenmedikçe Bazı "
"Testleri Görmezden Gelmek](#ignoring-some-tests-unless-specificly-requested) "
"bölümünde bunu ele alacağız. Çünkü burada sadece bunu yapmadık, özet 0 "
"görmezden gelindi. Ayrıca scar'a bir argüman aktarabiliriz."

#: src/ch10-01-how-to-write-tests.md:73
msgid ""
"Let’s start to customize the test to our own needs. First change the name of "
"the `it_works` function to a different name, such as `exploration`, like so:"
msgstr ""
"Testi kendi ihtiyaçlarımıza göre özelleştirmeye başlayalım. Önce it_works "
"fonksiyonunun adını exploration gibi farklı bir isimle değiştirin:"

#: src/ch10-01-how-to-write-tests.md:83
msgid ""
"Then run `scarb cairo-test` again. The output now shows `exploration` "
"instead of `it_works`:"
msgstr ""
"Sonra scarb cairo-test tekrar çalıştır. Çıktı şimdi it_works yerine "
"exploration gösterir:"

#: src/ch10-01-how-to-write-tests.md:93
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a "
"new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. Enter the new test as a function named `another`, "
"so your _src/lib.cairo_ file looks like in Listing 10-2."
msgstr ""
"Şimdi başka bir test ekleyeceğiz, ancak bu sefer başarısız olan bir test "
"yapacağız! Test fonksiyonundaki bir şey paniklediğinde testler başarısız "
"olur. Her test yeni bir iplikte çalıştırılır ve ana iplik bir test ipliğinin "
"öldüğünü gördüğünde, test başarısız olarak işaretlenir. Yeni testi another "
"adlı bir işlev olarak girin, böylece _src/lib.cairo_ dosyanız Listeleme "
"10-2'deki gibi görünür."

#: src/ch10-01-how-to-write-tests.md:109
msgid "\"Make this test fail\""
msgstr "\"Bu testi başarısız kıl\""

#: src/ch10-01-how-to-write-tests.md:115
msgid ""
"<span class=\"caption\">Listing 10-2: Adding a second test in _lib.cairo_ "
"that will fail</span>"
msgstr ""
"span class=\"caption\">Listeleme 10-2: Başarısız olacak _lib.cairo_'da "
"ikinci bir test ekleme/span>"

#: src/ch10-01-how-to-write-tests.md:117
msgid "Run `scarb cairo-test` and you will see the following output:"
msgstr "scarb cairo-test 'i çalıştırın ve aşağıdaki çıktıyı göreceksiniz:"

#: src/ch10-01-how-to-write-tests.md:119
#, fuzzy
msgid ""
"```shell\n"
"$ scarb cairo-test \n"
"     Running cairo-test listing_08_03\n"
"   Compiling test(listings/ch10-testing-cairo-programs/listing_10_02/Scarb."
"toml)\n"
"    Finished release target(s) in 1 second\n"
"testing listing_08_03 ...\n"
"running 2 tests\n"
"test listing_08_03::tests::exploration ... ok (gas usage est.: 127300)\n"
"test listing_08_03::tests::another ... fail (gas usage est.: 24810)\n"
"failures:\n"
"   listing_08_03::tests::another - Panicked with \"Make this test fail\".\n"
"\n"
"\n"
"```"
msgstr ""
"shell $ scarb cairo-test listing_08_03 Compiling test(listings/ch10-testing-"
"cairo-programs/listing_10_02/Scarb.toml) 1 saniye içinde serbest bırakma "
"hedefi(ler) listing_08_03:Make 2 tests test listing_08_03:tests:"
"exploration... ok (gaz kullanımı est.08_40)"

#: src/ch10-01-how-to-write-tests.md:134
msgid ""
"Instead of `ok`, the line `adder::another` shows `fail`. A new section "
"appears between the individual results and the summary. It displays the "
"detailed reason for each test failure. In this case, we get the details that "
"`another` failed because it panicked with `\"Make this test fail\"` error."
msgstr ""
"ok yerine, adder::another satırı fail gösterir. Bireysel sonuçlar ve özet "
"arasında yeni bir bölüm görünür. Her test hatasının ayrıntılı nedenini "
"gösterir. Bu durumda, \"Bu testin başarısız olmasını sağla\" hatası ile "
"paniklediği için another başarısız olduğu ayrıntılarını alırız."

#: src/ch10-01-how-to-write-tests.md:136
msgid ""
"The summary line is displayed at the end: overall, our test result is "
"`FAILED`. We had one test pass and one test fail."
msgstr ""
"Özet satırı sonunda görüntülenir: genel olarak, bizim test sonucu FAILED. "
"Biz bir test geçiş ve bir test başarısız vardı."

#: src/ch10-01-how-to-write-tests.md:138
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, "
"let’s look at some functions that are useful in tests."
msgstr ""
"Test sonuçlarının farklı senaryolarda nasıl göründüğünü gördüğünüze göre, "
"testlerde yararlı olan bazı işlevlere bakalım."

#: src/ch10-01-how-to-write-tests.md:140
msgid "Checking Results with the `assert!` Macro"
msgstr "Sonuçları assert! Makro ile kontrol etmek"

#: src/ch10-01-how-to-write-tests.md:142
msgid ""
"The `assert!` macro, provided by Cairo, is useful when you want to ensure "
"that some condition in a test evaluates to `true`. We give the `assert!` "
"macro the first argument that evaluates to a boolean. If the value is "
"`true`, nothing happens and the test passes. If the value is `false`, the "
"`assert!` macro calls `panic()` to cause the test to fail with a message we "
"defined as the second argument. Using the `assert!` macro helps us check "
"that our code is functioning in the way we intended."
msgstr ""
"Kahire tarafından sağlanan assert! makrosu, bir testteki bazı durumların "
"true olarak değerlendirilmesini sağlamak istediğinizde yararlıdır. assert! "
"makrosuna bir boolean'a değer veren ilk argümanı veriyoruz. Eğer değer true "
"ise, hiçbir şey olmaz ve test geçer. Eğer değer false ise, assert! makrosu "
"panic() olarak adlandırılır."

#: src/ch10-01-how-to-write-tests.md:144
msgid ""
"Remember in [Chapter 5](./ch05-03-method-syntax.md), we used a `Rectangle` "
"struct and a `can_hold` method, which are repeated here in Listing 10-3. "
"Let’s put this code in the _src/lib.cairo_ file, then write some tests for "
"it using the `assert!` macro."
msgstr ""
"Hatırlayın [Bölüm 5](./ch05-03-method-syntax.md), burada Listeleme 10-3'te "
"tekrarlanan bir Rectangle struct ve can_hold yöntemini kullandık. Bu kodu "
"_src/lib.cairo_ dosyasına koyalım, ardından assert! makrosunu kullanarak "
"bazı testler yapalım."

#: src/ch10-01-how-to-write-tests.md:166
msgid ""
"<span class=\"caption\">Listing 10-3: Using the `Rectangle` struct and its "
"`can_hold` method from Chapter 5</span>"
msgstr ""
"span class=\"caption\">Listeleme 10-3: Rectangle yapısını ve can_hold "
"yöntemini Bölüm 5/span> kullanarak"

#: src/ch10-01-how-to-write-tests.md:168
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case "
"for the `assert!` macro. We can write a test that exercises the `can_hold` "
"method by creating a `Rectangle` instance that has a width of `8` and a "
"height of `7` and asserting that it can hold another `Rectangle` instance "
"that has a width of `5` and a height of `1`."
msgstr ""
"can_hold yöntemi bir bool döndürür, bu da assert! makrosu için mükemmel bir "
"kullanım durumu olduğu anlamına gelir. can_hold yöntemini, 8 genişliğinde ve "
"7 yüksekliğinde bir 7 yüksekliğe sahip bir Rectangle örneği oluşturarak ve 5 "
"genişliğinde başka bir Rectangle örneğini tutabileceğini öne sürerek bir "
"test yazabiliriz."

#: src/ch10-01-how-to-write-tests.md:197 src/ch10-01-how-to-write-tests.md:210
#: src/ch10-01-how-to-write-tests.md:257 src/ch10-01-how-to-write-tests.md:270
msgid "\"rectangle cannot hold\""
msgstr "\"Rectangle dayanamaz\""

#: src/ch10-01-how-to-write-tests.md:216
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the `assert!` macro and "
"passed it the result of calling `larger.can_hold(@smaller)`. This expression "
"is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""
"Testimize büyük_can_hold_small adını verdik ve ihtiyacımız olan iki "
"Rectangle örneğini oluşturduk. Sonra assert! makrosunu çağırdık ve büyüker."
"can_hold(@small) aramasının sonucunu geçtik. Bu ifadenin true dönmesi "
"gerekiyor, yani testimiz geçmelidir. Hadi öğrenelim!"

#: src/ch10-01-how-to-write-tests.md:226
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr ""
"Geçer! Bu sefer daha küçük bir dikdörtgenin daha büyük bir dikdörtgeni "
"tutamayacağını öne süren başka bir test ekleyelim:"

#: src/ch10-01-how-to-write-tests.md:276
msgid ""
"<span class=\"caption\">Listing 10-4: Adding another test in _lib.cairo_ "
"that will pass</span>"
msgstr ""
"span class=\"caption\">Listing 10-4: Geçecek olan _lib.cairo_'da başka bir "
"test ekleme/span>"

#: src/ch10-01-how-to-write-tests.md:278
msgid ""
"Because the correct result of the `can_hold` method, in this case, is "
"`false`, we need to negate that result before we pass it to the `assert!` "
"macro. As a result, our test will pass if `can_hold` returns `false`:"
msgstr ""
"can_hold yönteminin doğru sonucu bu durumda false olduğundan, assert! "
"makrosuna geçmeden önce bu sonucu reddetmeliyiz. Sonuç olarak, can_hold "
"false döndürürse testimiz geçecektir:"

#: src/ch10-01-how-to-write-tests.md:294
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the `>` sign with a `<` sign when it compares "
"the widths:"
msgstr ""
"Geçen iki test! Şimdi kodumuzda bir hata tanıttığımızda test sonuçlarımıza "
"ne olduğunu görelim. can_hold yönteminin uygulanmasını, > işaretini, "
"genişlikleri karşılaştırdığında bir  işaretiyle değiştirerek değiştireceğiz:"

#: src/ch10-01-how-to-write-tests.md:304
msgid "Running the tests now produces the following:"
msgstr "Testleri çalıştırmak şimdi aşağıdakileri üretir:"

#: src/ch10-01-how-to-write-tests.md:306
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 2 tests\n"
"test adder::tests::larger_can_hold_smaller ... fail (gas usage est.: 57610)\n"
"test adder::tests::smaller_cannot_hold_larger ... ok (gas usage est.: "
"55140)\n"
"failures:\n"
"   adder::larger_can_hold_smaller - Panicked with \"rectangle cannot "
"hold\".\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"shell $ scarb cairo-test test adder... running 2 tests test adder::tests::"
"larger_can_hold_smaller... failure (gaz kullanımı est.: 57610) test adder::"
"tests:::smaller_cannot_hold_larger... ok (gaz kullanımı est.: 55140) "
"başarısız: adder:lar_can_hold_small_small - Panick hold"

#: src/ch10-01-how-to-write-tests.md:318
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false` (`8` "
"is not less than `5`) in the `larger_can_hold_smaller` test. Notice that the "
"`smaller_cannot_hold_larger` test still passes: to make this test fail, the "
"height comparison should also be modified in `can_hold` method, replacing "
"the `>` sign with a `<` sign."
msgstr ""
"Testlerimiz hatayı yakaladı! büyüker.width 8 ve küçük.width 5 olduğu için, "
"can_hold'deki genişliklerin karşılaştırılması false (8 yükseklik 5'den küçük "
"değildir) büyük_can_hold_small testinde de değiştirilmelidir. "
"küçük_connot_blager testinin hala geçmesi gerektiğine dikkat edin:"

#: src/ch10-01-how-to-write-tests.md:322
msgid "Testing Equality and Comparisons with the `assert_xx!` Macros"
msgstr "Eşitliği ve Karşılaştırmaları assert_xx! Makrolarla Test Etmek"

#: src/ch10-01-how-to-write-tests.md:324
msgid "`assert_eq!` and `assert_ne!` Macros"
msgstr "assert_eq! ve assert_ne! Makrolar"

#: src/ch10-01-how-to-write-tests.md:326
msgid ""
"A common way to verify functionality is to test for equality between the "
"result of the code under test and the value you expect the code to return. "
"You could do this using the `assert!` macro and passing it an expression "
"using the `==` operator. However, this is such a common test that the "
"standard library provides a pair of macros — `assert_eq!` and `assert_ne!` — "
"to perform this test more conveniently. These macros compare two arguments "
"for equality or inequality, respectively. They’ll also print the two values "
"if the assertion fails, which makes it easier to see _why_ the test failed; "
"conversely, the `assert!` macro only indicates that it got a `false` value "
"for the `==` expression, without printing the values that led to the `false` "
"value."
msgstr ""
"İşlevselliği doğrulamanın yaygın bir yolu, test altındaki kodun sonucu ile "
"kodun geri dönmesini beklediğiniz değer arasındaki eşitliği test etmektir. "
"Bunu assert! makrosunu kullanarak yapabilir ve sadece == operatörünü "
"kullanarak bir ifadeyi iletebilirsiniz. Ancak, standart kütüphanenin bu iki "
"testi daha uygun bir şekilde yerine getirmek için bir çift makroyu - "
"assert_eq! ve assert_ne'yi de sağlamasının nedeni budur."

#: src/ch10-01-how-to-write-tests.md:337
msgid ""
"In Listing 10-5, we write a function named `add_two` that adds `2` to its "
"parameter, then we test this function using `assert_eq!` and `assert_ne!` "
"macros."
msgstr ""
"Listeleme 10-5'te, parametresine 2 ekleyen add_two adlı bir fonksiyon "
"yazıyoruz, sonra bu fonksiyonu assert_eq! ve assert_ne! makrolarını "
"kullanarak test ediyoruz."

#: src/ch10-01-how-to-write-tests.md:363
msgid ""
"<span class=\"caption\">Listing 10-5: Testing the function `add_two` using "
"`assert_eq!` and `assert_ne!` macros</span>"
msgstr ""
"span class=\"caption\">Liste 10-5: asert_eq! ve asert_ne! makrolarını "
"kullanarak add_two işlevini test etmek/span>"

#: src/ch10-01-how-to-write-tests.md:365
msgid "Let’s check that it passes!"
msgstr "Geçip geçmediğini kontrol edelim!"

#: src/ch10-01-how-to-write-tests.md:376
msgid ""
"In the `it_adds_two` test, we pass `4` as argument to `assert_eq!` macro, "
"which is equal to the result of calling `add_two(2)`. The line for this test "
"is `test adder::tests::it_adds_two ... ok`, and the `ok` text indicates that "
"our test passed."
msgstr ""
"it_adds_two testinde, assert_eq! makrosuna argüman olarak add_two(2) "
"diyoruz. Bu testin satırı test adder:::tests:::it_adds_two... ok ve ok metni "
"testimizin geçtiğini gösterir."

#: src/ch10-01-how-to-write-tests.md:379
msgid ""
"In the `wrong_check` test, we pass `0` as argument to `assert_ne!` macro, "
"which is not equal to the result of calling `add_two(2)`. Tests that use the "
"`assert_ne!` macro will pass if the two values we give it are _not_ equal "
"and fail if they’re equal. This macro is most useful for cases when we’re "
"not sure what a value _will_ be, but we know what the value definitely "
"_shouldn’t_ be. For example, if we’re testing a function that is guaranteed "
"to change its input in some way, but how the input is changed depends on the "
"day of the week that we run our tests, the best thing to assert might be "
"that the output of the function is not equal to the input."
msgstr ""
"wrong_check testinde, asert_ne! argümanı olarak assert_ne! makrosunu "
"geçeriz. Bu, add_two(2) çağrısının sonucuna eşit değildir. assert_ne! "
"makrosunu kullanan testler, verdiğimiz iki değerin kesinlikle _a eşit "
"olmadığını ve bir değerin ne olduğundan emin olmadığımız durumlarda geçer."

#: src/ch10-01-how-to-write-tests.md:388
msgid ""
"Let’s introduce a bug into our code to see what `assert_eq!` looks like when "
"it fails. Change the implementation of the `add_two` function to instead add "
"`3`:"
msgstr ""
"assert_eq! başarısız olduğunda neye benzediğini görmek için kodumuza bir "
"hata tanıtalım. Bunun yerine add_two fonksiyonunun uygulanmasını 3 eklemek "
"için değiştirin:"

#: src/ch10-01-how-to-write-tests.md:397
msgid "Run the tests again:"
msgstr "Testleri tekrar yapın:"

#: src/ch10-01-how-to-write-tests.md:399
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 2 tests\n"
"test adder::tests::wrong_check ... ok (gas usage est.: 132000)\n"
"test adder::tests::it_adds_two ... fail (gas usage est.: 166800)\n"
"failures:\n"
"   adder::tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` "
"failed.\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"shell $ scarb cairo-test test adder... running 2 tests test adder::tests:: "
"wrong_check... ok (gaz kullanımı est.: 132000) test adder:::tests::"
"it_adds_two... failure (gaz kullanımı est.: 166800) failure: adder:tests:"
"it_adds_two - Panicked with \"addtion 4\"."

#: src/ch10-01-how-to-write-tests.md:413
msgid ""
"Our test caught the bug! The `it_adds_two` test failed with the following "
"message: ``Panicked with \"assertion `4 == add_two(2)` failed``. It tells us "
"that the assertion that failed was `` \"assertion `left == right` failed`` "
"and the `left` and `right` values are printed on the next lines as `left: "
"left_value` and `right: right_value`. This helps us start debugging: the "
"`left` argument was `4` but the `right` argument, where we had `add_two(2)`, "
"was `5`. You can imagine that this would be especially helpful when we have "
"a lot of tests going on."
msgstr ""
"Testimiz hatayı yakaladı! it_adds_two testi aşağıdaki mesajla başarısız "
"oldu: Panicked with \"assertion 4 == add_two(2) failed\". Başarısız olan "
"iddianın  \"assertion left == right failed ve left ve right değerlerinin bir "
"sonraki satırlara left: left_valuve  olarak basılabileceğini söyler."

#: src/ch10-01-how-to-write-tests.md:421
msgid ""
"Note that in some languages and test frameworks, the parameters for equality "
"assertion functions are called `expected` and `actual`, and the order in "
"which we specify the arguments matters. However, in Cairo, they’re called "
"`left` and `right`, and the order in which we specify the value we expect "
"and the value the code produces doesn’t matter. We could write the assertion "
"in this test as `assert_eq!(add_two(2), 4)`, which would result in the same "
"failure message that displays `` assertion failed: `(left == right)` ``."
msgstr ""
"Bazı dillerde ve test çerçevelerinde, eşitlik iddia işlevleri için "
"parametrelere beklenen ve actual denir ve argümanları belirttiğimiz sıra "
"önemlidir. Bununla birlikte, Kahire'de, left ve right olarak adlandırılırlar "
"ve beklediğimiz değeri ve kodun ürettiği değeri belirttiğimiz sıranın bir "
"önemi yoktur. Bu testte iddiayı add_e olarak yazabiliriz."

#: src/ch10-01-how-to-write-tests.md:429
msgid ""
"Here is a simple example comparing two structs, showing how to use "
"`assert_eq!` and `assert_ne!` macros:"
msgstr ""
"assert_eq! ve assert_ne! makrolarının nasıl kullanılacağını gösteren iki "
"yapıtı karşılaştıran basit bir örnek:"

#: src/ch10-01-how-to-write-tests.md:446
msgid "\"{:?},{:?} should be equal\""
msgstr "\":,: eşit olmalı\""

#: src/ch10-01-how-to-write-tests.md:448
msgid "\"{:?},{:?} should not be equal\""
msgstr "\":,: eşit olmamalı\""

#: src/ch10-01-how-to-write-tests.md:452
msgid ""
"Under the surface, `assert_eq!` and `assert_ne!` macros use the operators "
"`==` and `!=`, respectively. They both take snapshots of values as "
"arguments. When the assertions fail, these macros print their arguments "
"using debug formatting (`{:?}` syntax), which means the values being "
"compared must implement `PartialEq` and `Debug` traits. All primitive types "
"and most of the core library types implement these traits. For structs and "
"enums that you define yourself, you’ll need to implement `PartialEq` to "
"assert equality of those types. You’ll also need to implement `Debug` to "
"print the values when the assertion fails. Because both traits are "
"derivable, this is usually as straightforward as adding the `#[derive(Drop, "
"Debug, PartialEq)]` annotation to your struct or enum definition. See "
"[Appendix C](./appendix-03-derivable-traits.md) for more details about these "
"and other derivable traits."
msgstr ""
"Yüzeyin altında, assert_eq! ve assert_ne! makroları, sırasıyla bu [==] ve!= "
"tarayıcı özelliklerini kullanmak için bu iki değerin anlık görüntülerini "
"argüman olarak alır. İddialar başarısız olduğunda, bu makrolar argümanlarını "
"hata ayıklama biçimlendirmesi (: sözdizimi) kullanarak yazdırır, bu da "
"karşılaştırılan değerlerin PartialEq ve  Hata ayıklama özellikleri uygulamak "
"zorunda olduğu anlamına gelir."

#: src/ch10-01-how-to-write-tests.md:463
msgid "`assert_lt!`, `assert_le!`, `assert_gt!` and `assert_ge!` Macros"
msgstr "assert_lt!, assert_le!, assert_gt! ve assert_ge! Makrolar"

#: src/ch10-01-how-to-write-tests.md:465
msgid "Comparisons in tests can be done using the `assert_xx!` macros:"
msgstr ""
"Testlerdeki karşılaştırmalar assert_xx! makroları kullanılarak yapılabilir:"

#: src/ch10-01-how-to-write-tests.md:467
msgid ""
"`assert_lt!` checks if a given value is lower than another value, and "
"reverts otherwise."
msgstr ""
"assert_lt! belirli bir değerin başka bir değerden daha düşük olup olmadığını "
"kontrol eder ve aksi takdirde geri döner."

#: src/ch10-01-how-to-write-tests.md:468
msgid ""
"`assert_le!` checks if a given value is lower or equal than another value, "
"and reverts otherwise."
msgstr ""
"assert_le! belirli bir değerin başka bir değerden daha düşük veya eşit olup "
"olmadığını kontrol eder ve aksi takdirde geri döner."

#: src/ch10-01-how-to-write-tests.md:469
msgid ""
"`assert_gt!` checks if a given value is greater than another value, and "
"reverts otherwise."
msgstr ""
"assert_gt! belirli bir değerin başka bir değerden büyük olup olmadığını "
"kontrol eder ve aksi takdirde geri döner."

#: src/ch10-01-how-to-write-tests.md:470
msgid ""
"`assert_ge!` checks if a given value is greater or equal than another value, "
"and reverts otherwise."
msgstr ""
"assert_ge! belirli bir değerin başka bir değerden daha büyük veya eşit olup "
"olmadığını kontrol eder ve aksi takdirde geri döner."

#: src/ch10-01-how-to-write-tests.md:472
msgid "Listing 10-6 demonstrates how to use these macros:"
msgstr "Listeleme 10-6, bu makroların nasıl kullanılacağını gösterir:"

#: src/ch10-01-how-to-write-tests.md:510
msgid "\"{:?},{:?} should be lower or equal\""
msgstr "\":,: daha düşük veya eşit olmalıdır\""

#: src/ch10-01-how-to-write-tests.md:515
msgid ""
"<span class=\"caption\">Listing 10-6: Example of tests that use the "
"`assert_xx!` macros for comparisons</span>"
msgstr ""
"span class=\"caption\">Liste 10-6: Karşılaştırmalar için assert_xx! "
"makrolarını kullanan testlerin örneği/span>"

#: src/ch10-01-how-to-write-tests.md:517
msgid ""
"In this example, we roll a `Dice` struct multiple times and compare the "
"results. We need to manually implement the `PartialOrd` trait for our struct "
"so that we can compare `Dice` instances with `lt`, `le`, `gt` and `ge` "
"functions, which are used by `assert_lt!`, `assert_le!`, `assert_gt!` and "
"`assert_ge!` macros, respectively. We also need to derive the `Copy` trait "
"on our `Dice` struct to use the instantiated structs multiple times, as the "
"comparison functions take ownership of the variables."
msgstr ""
"Bu örnekte, sırasıyla bir Dice struct'ı birden fazla kez yuvarlayıp "
"sonuçları karşılaştırıyoruz. Dice örneklerini lt, le, gt ve ge "
"fonksiyonlarıyla karşılaştırabilmemiz için PartialOrd özelliğini manuel "
"olarak uygulamamız gerekiyor! assert_lt!, assert_leg tarafından kullanılan "
"Dice,       ,"

#: src/ch10-01-how-to-write-tests.md:519
msgid "Adding Custom Failure Messages"
msgstr "Özel Hata Mesajları Ekleme"

#: src/ch10-01-how-to-write-tests.md:521
msgid ""
"You can also add a custom message to be printed with the failure message as "
"optional arguments to `assert!`, `assert_eq!`, and `assert_ne!` macros. Any "
"arguments specified after the required arguments are passed along to the "
"`format!` macro (discussed in the [Printing](./ch11-08-printing."
"md#formatting) chapter), so you can pass a format string that contains `{}` "
"placeholders and values to go in those placeholders. Custom messages are "
"useful for documenting what an assertion means; when a test fails, you’ll "
"have a better idea of what the problem is with the code."
msgstr ""
"Ayrıca assert!, assert_eq!, ve assert_ne! makrolarına isteğe bağlı "
"argümanlar olarak hata mesajı ile basılacak özel bir mesaj ekleyebilirsiniz. "
"Gerekli argümanlardan sonra belirtilen herhangi bir argüman format! makrosu "
"([Yazdırma] için özel bir kod kullanılırken, bu satırları kullanabilirsiniz."

#: src/ch10-01-how-to-write-tests.md:529
msgid ""
"Let’s add a custom failure message composed of a format string with a "
"placeholder filled in with the actual value we got from the `add_two` "
"function:"
msgstr ""
"add_two işlevinden aldığımız gerçek değerle dolu bir yer tutucuya sahip bir "
"format dizgesinden oluşan özel bir başarısızlık mesajı ekleyelim:"

#: src/ch10-01-how-to-write-tests.md:536
msgid "\"Expected {}, got add_two(2)={}\""
msgstr "\"Beklenen, add_two(2)=\""

#: src/ch10-01-how-to-write-tests.md:540
msgid "Now when we run the test, we’ll get a more informative error message:"
msgstr ""
"Şimdi testi çalıştırdığımızda, daha bilgilendirici bir hata mesajı alacağız:"

#: src/ch10-01-how-to-write-tests.md:542
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder ...\n"
"running 1 test\n"
"test adder::tests::it_adds_two ... fail (gas usage est.: 590230)\n"
"failures:\n"
"   adder::tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` "
"failed: Expected 4, got add_two(2)=5\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"shell $ scarb cairo-test test adder... çalışan 1 test adder::tests::"
"it_adds_two... başarısız (gaz kullanımı est.: 590230) başarısız::tests:::"
"it_adds_two - Panicked with \"asertion 4 == add_two(2); başarısız oldu: "
"Beklenen 4, alındı add_two(2)=5 4: add_two(2)\"."

#: src/ch10-01-how-to-write-tests.md:555
msgid ""
"We can see the value we actually got in the test output, which would help us "
"debug what happened instead of what we were expecting to happen."
msgstr ""
"Test çıktısında gerçekten aldığımız değeri görebiliriz, bu da olmasını "
"beklediğimiz şey yerine olanları hata ayıklamamıza yardımcı olur."

#: src/ch10-01-how-to-write-tests.md:560
msgid "Checking for panics with `should_panic`"
msgstr "should_panic ile panik olup olmadığını kontrol edin"

#: src/ch10-01-how-to-write-tests.md:562
msgid ""
"In addition to checking return values, it’s important to check that our code "
"handles error conditions as we expect. For example, consider the `Guess` "
"type in Listing 10-7:"
msgstr ""
"İade değerlerini kontrol etmenin yanı sıra, kodumuzun hata koşullarını "
"beklediğimiz gibi ele alıp almadığını kontrol etmek önemlidir. Örneğin, "
"Listeleme 10-7'deki Guess tipini göz önünde bulundurun:"

#: src/ch10-01-how-to-write-tests.md:579 src/ch10-01-how-to-write-tests.md:631
msgid "\"Guess must be >= 1 and <= 100\""
msgstr "\"Guess olmalıdır>= 1 ve = 100\""

#: src/ch10-01-how-to-write-tests.md:587
msgid ""
"<span class=\"caption\">Listing 10-7: `Guess` struct and its `new` method</"
"span>"
msgstr ""
"span class=\"caption\">Listing 10-7: Guess struct and its new method/span>"

#: src/ch10-01-how-to-write-tests.md:589
msgid ""
"Other code that uses `Guess` depends on the guarantee that `Guess` instances "
"will contain only values between `1` and `100`. We can write a test that "
"ensures that attempting to create a `Guess` instance with a value outside "
"that range panics."
msgstr ""
"Guess kullanan diğer kodlar, Guess örneklerinin yalnızca 1 ve 100 arasındaki "
"değerleri içereceği garantisine bağlıdır. Guess örneğini, bu aralığın "
"dışında bir değerle oluşturmaya çalışmanın paniklemesini sağlayan bir test "
"yazabiliriz."

#: src/ch10-01-how-to-write-tests.md:591
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr ""
"Bunu test fonksiyonumuza should_panic özniteliğini ekleyerek yapıyoruz. "
"Fonksiyonun içindeki kod paniklediğinde test geçer; fonksiyon içindeki kod "
"paniklemezse test başarısız olur."

#: src/ch10-01-how-to-write-tests.md:606
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result to see that "
"this test passes:"
msgstr ""
"#[should_panic] özniteliğini #[test] özniteliğinden sonra ve geçerli olduğu "
"test fonksiyonundan önce yerleştiriyoruz. Bu testin geçtiğini görmek için "
"sonuca bakalım:"

#: src/ch10-01-how-to-write-tests.md:616
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the `new` function will panic if the value is greater than `100`:"
msgstr ""
"İyi görünüyor! Şimdi, değeri 100'den büyükse new işlevinin panikleyeceği "
"koşulu kaldırarak kodumuzda bir hata tanıtalım:"

#: src/ch10-01-how-to-write-tests.md:641
msgid "When we run the test, it will fail:"
msgstr "Testi çalıştırdığımızda, başarısız olacak:"

#: src/ch10-01-how-to-write-tests.md:654
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]` attribute. "
"The failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""
"Bu durumda çok yardımcı bir mesaj almıyoruz, ancak test fonksiyonuna "
"baktığımızda, #[should_panic] özniteliği ile not edildiğini görüyoruz. Elde "
"ettiğimiz hata, test fonksiyonundaki kodun panik yaratmadığı anlamına gelir."

#: src/ch10-01-how-to-write-tests.md:656
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional "
"`expected` parameter to the `#[should_panic]` attribute. The test harness "
"will make sure that the failure message contains the provided text. For "
"example, consider the modified code for `GuessImpl` in Listing 10-8 where "
"the `new` function panics with different messages depending on whether the "
"value is too small or too large:"
msgstr ""
"should_panic kullanan testler kesin değildir. Test, beklediğimizden farklı "
"bir nedenden dolayı paniklese bile bir should_panic testi geçer. "
"should_panic testlerini daha kesin hale getirmek için, #[should_panic] "
"özniteliğine isteğe bağlı bir expected parametresi ekleyebiliriz. Test koşum "
"takımı, hata mesajının verilen metni içerdiğinden emin olacaktır."

#: src/ch10-01-how-to-write-tests.md:673 src/ch10-01-how-to-write-tests.md:708
msgid "\"Guess must be >= 1\""
msgstr "\"Guess should be>=1\" (İngilizce)."

#: src/ch10-01-how-to-write-tests.md:675 src/ch10-01-how-to-write-tests.md:687
#: src/ch10-01-how-to-write-tests.md:706 src/ch10-01-how-to-write-tests.md:720
msgid "\"Guess must be <= 100\""
msgstr "\"Guess olmalı = 100\""

#: src/ch10-01-how-to-write-tests.md:696
msgid ""
"<span class=\"caption\">Listing 10-8: `new` implementation that panics with "
"different error messages</span>"
msgstr ""
"span class=\"caption\">Listing 10-8: new uygulaması farklı hata mesajları "
"ile panik yapar/span>"

#: src/ch10-01-how-to-write-tests.md:698
msgid ""
"The test will pass because the value we put in the `should_panic` "
"attribute’s `expected` parameter is the string that the `Guess::new` method "
"panics with. We need to specify the entire panic message that we expect."
msgstr ""
"Test geçecek çünkü should_panic özniteliğinin expected parametresine "
"koyduğumuz değer, Guess::new yönteminin paniklediği dizgedir. Beklediğimiz "
"tüm panik mesajını belirtmemiz gerekiyor."

#: src/ch10-01-how-to-write-tests.md:700
msgid ""
"To see what happens when a `should_panic` test with an expected message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the `if value < 1` and the `else if value > 100` blocks:"
msgstr ""
"Beklenen bir mesajla should_panic testi başarısız olduğunda ne olduğunu "
"görmek için, if değeri  1 ve else değeri> 100 bloklarının gövdelerini "
"değiştirerek kodumuza bir hata daha tanıtalım:"

#: src/ch10-01-how-to-write-tests.md:727
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr "Bu kez should_panic testini çalıştırdığımızda, başarısız olacaktır:"

#: src/ch10-01-how-to-write-tests.md:729
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing guess ...\n"
"running 1 test\n"
"test guess::tests::greater_than_100 ... fail (gas usage est.: 26690)\n"
"failures:\n"
"   guess::tests::greater_than_100 - Panicked with \"Guess must be >= 1\".\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"shell $ scarb cairo-test test tahmin... çalışan 1 test tahmin::tests::"
"greater_than_100... başarısız (gaz kullanımı est.: 26690) başarısızlıklar: "
"tahmin:::tests:::greater_than_100 - Panicked with \"Guess should be>= 1\". "
"Hata: test sonucu: FAILED. 0 geçti; 1 başarısız oldu; 0 görmezden gelindi"

#: src/ch10-01-how-to-write-tests.md:739
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string. The "
"panic message that we did get in this case was `Guess must be >= 1`. Now we "
"can start figuring out where our bug is!"
msgstr ""
"Başarısızlık mesajı, bu testin gerçekten de beklediğimiz gibi panik "
"yaptığını, ancak panik mesajının beklenen dizeyi içermediğini gösterir. Bu "
"durumda aldığımız panik mesajı Guess should be>=1 idi. Şimdi hatamızın "
"nerede olduğunu anlamaya başlayabiliriz!"

#: src/ch10-01-how-to-write-tests.md:741
msgid "Running Single Tests"
msgstr "Tekli Testleri Çalıştırmak"

#: src/ch10-01-how-to-write-tests.md:743
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working "
"on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing `scarb "
"cairo-test` an option `-f` (for \"filter\"), followed by the name of the "
"test you want to run as an argument."
msgstr ""
"Bazen, tam bir test paketini çalıştırmak uzun zaman alabilir. Belirli bir "
"alanda kod üzerinde çalışıyorsanız, yalnızca bu kodla ilgili testleri "
"çalıştırmak isteyebilirsiniz. scarb cairo-test bir seçeneği -f (filtre için) "
"geçerek hangi testlerin yapılacağını seçebilirsiniz, ardından bir argüman "
"olarak çalıştırmak istediğiniz testin adı."

#: src/ch10-01-how-to-write-tests.md:745
msgid ""
"To demonstrate how to run a single test, we’ll first create two test "
"functions, as shown in Listing 10-9, and choose which ones to run."
msgstr ""
"Tek bir testin nasıl yürütüleceğini göstermek için, önce Listeleme 10-9'da "
"gösterildiği gibi iki test fonksiyonu oluşturacağız ve hangilerinin "
"çalıştırılacağını seçeceğiz."

#: src/ch10-01-how-to-write-tests.md:761
msgid "\"result is not 5\""
msgstr "\"Sonuç 5 değil\""

#: src/ch10-01-how-to-write-tests.md:766
msgid ""
"<span class=\"caption\">Listing 10-9: Two tests with two different names</"
"span>"
msgstr "span class=\"caption\">Liste 10-9: İki farklı isimle iki test/span>"

#: src/ch10-01-how-to-write-tests.md:768
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that "
"test using the `-f` flag:"
msgstr ""
"Herhangi bir test fonksiyonunun adını -f bayrağını kullanarak sadece bu "
"testi çalıştırmak için cairo-test'ye geçebiliriz:"

#: src/ch10-01-how-to-write-tests.md:778
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t "
"match that name. The test output lets us know we had one more test that "
"didn’t run by displaying `1 filtered out;` at the end."
msgstr ""
"Sadece add_two_and_two adı ile yapılan test koştu; diğer test bu isimle "
"eşleşmedi. Test çıktısı, 1 filtrelenmiş olarak görüntülenerek çalışmayan bir "
"test daha olduğunu bize bildirir; sonunda."

#: src/ch10-01-how-to-write-tests.md:780
msgid ""
"We can also specify part of a test name, and any test whose name contains "
"that value will be run."
msgstr ""
"Ayrıca bir test adının bir kısmını belirtebiliriz ve bu değeri içeren "
"herhangi bir test çalıştırılacaktır."

#: src/ch10-01-how-to-write-tests.md:782
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr "Özellikle İstenmedikçe Bazı Testleri Görmezden Gelmek"

#: src/ch10-01-how-to-write-tests.md:784
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you "
"might want to exclude them during most runs of `scarb cairo-test`. Rather "
"than listing as arguments all tests you do want to run, you can instead "
"annotate the time-consuming tests using the `#[ignore]` attribute to exclude "
"them, as shown here:"
msgstr ""
"Bazen birkaç spesifik testin uygulanması çok zaman alabilir, bu nedenle "
"scarb cairo-test'nin çoğu çalışması sırasında bunları dışlamak "
"isteyebilirsiniz. Çalışmak istediğiniz tüm testleri argüman olarak "
"listelemek yerine, #[ignore] özniteliğini kullanarak zaman alıcı testleri "
"not edebilirsiniz, burada gösterildiği gibi:"

#: src/ch10-01-how-to-write-tests.md:803
msgid "// code that takes an hour to run\n"
msgstr "// çalıştırmak için bir saat süren kod\n"

#: src/ch10-01-how-to-write-tests.md:808
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""
"#[test]'den sonra #[ignore] çizgisini dışlamak istediğimiz teste ekleriz. "
"Şimdi testlerimizi çalıştırdığımızda it_works çalışır, ancak pensive_test "
"çalışmaz:"

#: src/ch10-01-how-to-write-tests.md:819
msgid "The `expensive_test` function is listed as ignored."
msgstr "pensive_test işlevi göz ardı edilmiş olarak listelenir."

#: src/ch10-01-how-to-write-tests.md:821
msgid ""
"When you’re at a point where it makes sense to check the results of the "
"ignored tests and you have time to wait for the results, you can run `scarb "
"cairo-test --include-ignored` to run all tests, whether they’re ignored or "
"not."
msgstr ""
"Görmezden gelinen testlerin sonuçlarını kontrol etmenin mantıklı olduğu bir "
"noktadaysanız ve sonuçları beklemek için zamanınız olduğunda, göz ardı "
"edilip edilmediklerine bakılmaksızın tüm testleri çalıştırmak için scarb "
"cairo-testi -ignored - çalıştırabilirsiniz."

#: src/ch10-01-how-to-write-tests.md:823
msgid "Testing Recursive Functions or Loops"
msgstr "Özyinelemeli Fonksiyonları veya Döngüleri Test Etmek"

#: src/ch10-01-how-to-write-tests.md:825
msgid ""
"When testing recursive functions or loops, the test is instantiated by "
"default with a maximum amount of gas that it can consume. This prevents "
"running infinite loops or consuming too much gas, and can help you benchmark "
"the efficiency of your implementations. This value is assumed reasonably "
"large enough, but you can override it by adding the "
"`#[available_gas(<Number>)]` attribute to the test function. The following "
"example shows how to use it:"
msgstr ""
"Özyinelemeli fonksiyonları veya döngüleri test ederken, test varsayılan "
"olarak tüketebileceği maksimum miktarda gaz ile hızlandırılır. Bu, sonsuz "
"döngülerin çalıştırılmasını veya çok fazla gaz tüketmenizi önler ve "
"uygulamalarınızın verimliliğini ölçmenize yardımcı olabilir. Bu değer "
"yeterince büyük kabul edilir, ancak test fonksiyonuna "
"#[kullanılabilir_gazlar(Number>]]] özniteliğini ekleyerek geçersiz "
"kılabilirsiniz. Aşağıdaki örnek nasıl kullanılacağını gösterir:"

#: src/ch10-01-how-to-write-tests.md:846
msgid "\"result is not 55\""
msgstr "\"Cevap 55 değil\""

#: src/ch10-01-how-to-write-tests.md:851
msgid "Benchmarking the Gas Usage of a Specific Operation"
msgstr "Belirli Bir Operasyonun Gaz Kullanımının Karşılaştırılması"

#: src/ch10-01-how-to-write-tests.md:853
msgid ""
"When you want to benchmark the gas usage of a specific operation, you can "
"use the following pattern in your test function."
msgstr ""
"Belirli bir operasyonun gaz kullanımını kıyaslamak istediğinizde, test "
"fonksiyonunuzda aşağıdaki deseni kullanabilirsiniz."

#: src/ch10-01-how-to-write-tests.md:858 src/ch10-01-how-to-write-tests.md:885
msgid "/// code we want to bench.\n"
msgstr "/// kodu biz bank istiyoruz.\n"

#: src/ch10-01-how-to-write-tests.md:859
msgid "\"{}\\n\""
msgstr "\"n\""

#: src/ch10-01-how-to-write-tests.md:862
msgid ""
"The following example shows how to use it to test the gas function of the "
"`sum_n` function above."
msgstr ""
"Aşağıdaki örnek, yukarıdaki sum_n fonksiyonunun gaz fonksiyonunu test etmek "
"için nasıl kullanılacağını gösterir."

#: src/ch10-01-how-to-write-tests.md:887
msgid "\"consumed gas: {}\\n\""
msgstr "\"tüketimli gaz: n\""

#: src/ch10-01-how-to-write-tests.md:892
msgid ""
"The value printed when running `scarb cairo-test` is the amount of gas that "
"was consumed by the benchmarked operation."
msgstr ""
"scarb cairo-test çalıştırılırken basılan değer, karşılaştırmalı işlem "
"tarafından tüketilen gaz miktarıdır."

#: src/ch10-01-how-to-write-tests.md:904
msgid ""
"Here, the gas usage of the `sum_n` function is `80690` (decimal "
"representation of the hex number). The total amount consumed by the test is "
"slightly higher at `140100`, due to some extra steps required to run the "
"entire test function."
msgstr ""
"Burada, sum_n fonksiyonunun gaz kullanımı 80690'dir (onaltılık sayının "
"onaltılık gösterimi). Test tarafından tüketilen toplam miktar, tüm test "
"fonksiyonunu çalıştırmak için gereken bazı ekstra adımlar nedeniyle "
"140100'de biraz daha yüksektir."

#: src/ch10-01-how-to-write-tests.md:906
msgid "{{#quiz ../quizzes/ch10-01-how_to_write_tests.toml}}"
msgstr "#quiz../quizzes/ch10-01-how_to_write_tests.toml"

#: src/ch10-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and "
"integration tests. Unit tests are small and more focused, testing one module "
"in isolation at a time, and can test private functions. Integration tests "
"use your code in the same way any other external code would, using only the "
"public interface and potentially exercising multiple modules per test."
msgstr ""
"İki ana kategori açısından testleri düşüneceğiz: birim testleri ve "
"entegrasyon testleri. Birim testleri küçük ve daha odaklıdır, bir modülü bir "
"kerede izolasyonda test eder ve özel işlevleri test edebilir. Entegrasyon "
"testleri, kodunuzu yalnızca ortak arayüzü kullanarak ve potansiyel olarak "
"test başına birden fazla modülü kullanarak diğer harici kodlarla aynı "
"şekilde kullanır."

#: src/ch10-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr ""
"Her iki tür testi de yazmak, kütüphanenizin parçalarının onlardan "
"beklediğinizi ayrı ve birlikte yapmasını sağlamak için önemlidir."

#: src/ch10-02-test-organization.md:7
msgid "Unit Tests"
msgstr "Birim Testleri"

#: src/ch10-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the "
"rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the `src` directory in each file with the "
"code that they’re testing."
msgstr ""
"Birim testlerinin amacı, kodun nerede olduğunu ve beklendiği gibi "
"çalışmadığını hızlı bir şekilde belirlemek için kodun geri kalanından izole "
"edilmiş olarak her bir birimi test etmektir. Test ettikleri kodla her "
"dosyadaki src dizinine birim testleri koyacaksınız."

#: src/ch10-02-test-organization.md:11
msgid ""
"The convention is to create a module named `tests` in each file to contain "
"the test functions and to annotate the module with `#[cfg(test)]` attribute."
msgstr ""
"Kongre, her dosyada test fonksiyonlarını içerecek ve modülü #[cfg(test)]] "
"özniteliği ile anons edecek tests adında bir modül oluşturmaktır."

#: src/ch10-02-test-organization.md:13
msgid "The Tests Module and `#[cfg(test)]`"
msgstr "Test Modülü ve #[cfg(test)]"

#: src/ch10-02-test-organization.md:15
#, fuzzy
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and "
"run the test code only when you run `scarb test`, not when you run `scarb "
"build`. This saves compile time when you only want to build the project and "
"saves space in the resulting compiled artifact because the tests are not "
"included. You’ll see that because integration tests go in a different "
"directory, they don’t need the `#[cfg(test)]` annotation. However, because "
"unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to "
"specify that they shouldn’t be included in the compiled result."
msgstr ""
"#[cfg(test)] test modülündeki açıklama, Kahire'ye test kodunu yalnızca scarb "
"cairo-test çalıştırdığınızda derlemesini ve çalıştırmasını söyler, scarb "
"cairo-run çalıştırdığınızda değil. Bu, yalnızca kütüphaneyi inşa etmek "
"istediğinizde derleme süresi tasarrufu sağlar ve sonuçta derlenen eserde yer "
"tasarrufu sağlar, çünkü testler dahil değildir. Entegrasyon testlerinin "
"farklı bir dizinde gitmemesi gerektiğini göreceksiniz."

#: src/ch10-02-test-organization.md:17
#, fuzzy
msgid ""
"Recall that when we created the new `adder` project in the first section of "
"this chapter, we wrote this first test:"
msgstr ""
"Bu bölümün ilk bölümünde yeni _adder_ projesini yarattığımızda şu ilk testi "
"yazdığımızı hatırlayın:"

#: src/ch10-02-test-organization.md:36
#, fuzzy
msgid ""
"The attribute `cfg` stands for _configuration_ and tells Cairo that the "
"following item should only be included given a certain configuration option. "
"In this case, the configuration option is `test`, which is provided by Cairo "
"for compiling and running tests. By using the `cfg` attribute, Cairo "
"compiles our test code only if we actively run the tests with `scarb test`. "
"This includes any helper functions that might be within this module, in "
"addition to the functions annotated with `#[test]`."
msgstr ""
"cfg özniteliği yapılandırma anlamına gelir ve Kahire'ye aşağıdaki öğeye "
"yalnızca belirli bir yapılandırma seçeneğinin verilmesi gerektiğini söyler. "
"Bu durumda, yapılandırma seçeneği test'dir, bu da Kahire tarafından "
"testlerin derlenmesi ve çalıştırılması için sağlanır. cfg özniteliğini "
"kullanarak, Kahire test kodumuzu yalnızca scarbiro-test ile aktif olarak "
"çalıştırırsak derler. Bu, bu modül içinde eklenebilecek herhangi bir "
"yardımcı işlevi içerir."

#: src/ch10-02-test-organization.md:38
#, fuzzy
msgid "Testing Private Functions"
msgstr "3. Özel Fonksiyonlar"

#: src/ch10-02-test-organization.md:40
msgid ""
"There’s debate within the testing community about whether or not private "
"functions should be tested directly, and other languages make it difficult "
"or impossible to test private functions. Regardless of which testing "
"ideology you adhere to, Cairo's privacy rules do allow you to test private "
"functions. Consider the code below with the private function "
"`internal_adder`."
msgstr ""

#: src/ch10-02-test-organization.md:42 src/ch10-02-test-organization.md:178
msgid "<span class=\"caption\">Filename: src/lib.cairo</span>"
msgstr "span class=\"caption\">Dosya adı: src/lib.cairo/span>"

#: src/ch10-02-test-organization.md:64
#, fuzzy
msgid ""
"<span class=\"caption\">Listing 10-10: Testing a private function</span>"
msgstr "span class=\"caption\">Listing 10-1: Basit bir test fonksiyonu/span>"

#: src/ch10-02-test-organization.md:66
msgid ""
"Note that the `internal_adder` function is not marked as `pub`. Tests are "
"just Cairo code, and the tests module is just another module. As we "
"discussed in the [\"Paths for Referring to an Item in the Module Tree\"]"
"(ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md) section, "
"items in child modules can use the items in their ancestor modules. In this "
"test, we bring the `tests` module’s parent `internal_adder` into scope with "
"`use super::internal_adder;` and then the test can call `internal_adder`. If "
"you don’t think private functions should be tested, there’s nothing in Cairo "
"that will compel you to do so."
msgstr ""

#: src/ch10-02-test-organization.md:68
msgid "Integration Tests"
msgstr "Entegrasyon Testleri"

#: src/ch10-02-test-organization.md:70
#, fuzzy
msgid ""
"Integration tests use your library in the same way any other code would. "
"Their purpose is to test whether many parts of your library work together "
"correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is "
"important as well. To create integration tests, you first need a _tests_ "
"directory."
msgstr ""
"Entegrasyon testleri kütüphanenizi diğer kodlarla aynı şekilde kullanır. "
"Amaçları, kütüphanenizin birçok bölümünün birlikte doğru çalışıp "
"çalışmadığını test etmektir. Kendi başlarına doğru çalışan kod birimleri "
"entegre edildiğinde sorun yaşayabilir, bu nedenle entegre kodun test kapsamı "
"da önemlidir. Entegrasyon testleri oluşturmak için önce bir tests dizinine "
"ihtiyacınız vardır."

#: src/ch10-02-test-organization.md:72
msgid "The _tests_ Directory"
msgstr "_tests_ Dizini"

#: src/ch10-02-test-organization.md:74
msgid ""
"We create a _tests_ directory at the top level of our project directory, "
"next to _src_. Scarb knows to look for integration test files in this "
"directory. We can then make as many test files as we want, and Scarb will "
"compile each of the files as an individual crate."
msgstr ""

#: src/ch10-02-test-organization.md:76
msgid ""
"Let’s create an integration test. With the code in Listing 10-10 still in "
"the _src/lib.cairo_ file, make a _tests_ directory, and create a new file "
"named _tests/integration_test.cairo_. Your directory structure should look "
"like this:"
msgstr ""

#: src/ch10-02-test-organization.md:89
#, fuzzy
msgid ""
"Enter the code in Listing 10-11 into the _tests/integration_test.cairo_ file:"
msgstr ""
"Son olarak, bu kodu _src/tests/entegrasyon_tests.cairo_ dosyasına girin:"

#: src/ch10-02-test-organization.md:91 src/ch10-02-test-organization.md:167
#, fuzzy
msgid "<span class=\"caption\">Filename: tests/integration_tests.cairo</span>"
msgstr ""
"span class=\"caption\">Dosya adı: src/tests/integrasyon_tests.cairo/span>"

#: src/ch10-02-test-organization.md:102
#, fuzzy
msgid ""
"<span class=\"caption\">Listing 10-11: An integration test of a function in "
"the `adder` crate</span>"
msgstr "span class=\"caption\">Listing 10-1: Basit bir test fonksiyonu/span>"

#: src/ch10-02-test-organization.md:104
#, fuzzy
msgid ""
"Each file in the `tests` directory is a separate crate, so we need to bring "
"our library into each test crate’s scope. For that reason we add `use adder::"
"add_two` at the top of the code, which we didn’t need in the unit tests."
msgstr ""
"Test edilmiş fonksiyonlarımızı her test dosyası kapsamına getirmemiz "
"gerekiyor. Bu nedenle, birim testlerinde ihtiyaç duymadığımız kodun üst "
"kısmına use adder:::it_adds_two ekliyoruz."

#: src/ch10-02-test-organization.md:106
msgid ""
"We don’t need to annotate any code in _tests/integration_test.cairo_ with "
"`#[cfg(test)]`. Scarb treats the tests directory specially and compiles "
"files in this directory only when we run `scarb test`. Run `scarb test` now:"
msgstr ""

#: src/ch10-02-test-organization.md:124
msgid ""
"The two sections of output include the unit tests and the integration tests. "
"Note that if any test in a section fails, the following sections will not be "
"run. For example, if a unit test fails, there won’t be any output for "
"integration tests because those tests will only be run if all unit tests are "
"passing."
msgstr ""

#: src/ch10-02-test-organization.md:126
msgid ""
"The first displayed section is for the integration tests. Each integration "
"test file has its own section, so if we add more files in the _tests_ "
"directory, there will be more integration test sections."
msgstr ""

#: src/ch10-02-test-organization.md:129
msgid ""
"The second displayed section is the same as we’ve been seeing: one line for "
"each unit test (one named add that we added just above) and then a summary "
"line for the unit tests."
msgstr ""

#: src/ch10-02-test-organization.md:131
msgid ""
"We can still run a particular integration test function by specifying the "
"test function’s name as an argument of the option -f to `scarb test` like "
"for instance `scarb test -f integration_tests::internal`. To run all the "
"tests in a particular integration test file, we use the same option of "
"`scarb test` but using only the name of the file."
msgstr ""

#: src/ch10-02-test-organization.md:133
#, fuzzy
msgid ""
"Then, to run all of our integration tests, we can just add a filter to only "
"run tests whose path contains _integration_tests_."
msgstr ""
"Ardından, tüm entegrasyon testlerimizi çalıştırmak için, sadece yolu "
"\"entegrasyon_testleri\" içeren testleri çalıştırmak için bir filtre "
"ekleyebiliriz."

#: src/ch10-02-test-organization.md:151
msgid ""
"We see that in the second section for the unit tests, 1 has been filtered "
"out because it is not in the _integration_tests_ file."
msgstr ""

#: src/ch10-02-test-organization.md:153
#, fuzzy
msgid "Submodules in Integration Tests"
msgstr "Entegrasyon Testleri"

#: src/ch10-02-test-organization.md:155
msgid ""
"As you add more integration tests, you might want to make more files in the "
"_tests_ directory to help organize them; for example, you can group the test "
"functions by the functionality they’re testing. As mentioned earlier, each "
"file in the tests directory is compiled as its own separate crate, which is "
"useful for creating separate scopes to more closely imitate the way end "
"users will be using your crate. However, this means files in the tests "
"directory don’t share the same behavior as files in _src_ do, as you learned "
"in Chapter 7 regarding how to separate code into modules and files."
msgstr ""

#: src/ch10-02-test-organization.md:157
msgid ""
"The different behavior of tests directory files is most noticeable when you "
"have a set of helper functions to use in multiple integration test files and "
"you try to follow the steps in the [Separating Modules into Different Files]"
"(ch07-05-separating-modules-into-different-files.md) section of Chapter 7 to "
"extract them into a common module. For example, if we create _tests/common."
"cairo_ and place a function named `setup` in it, we can add some code to "
"`setup` that we want to call from multiple test functions in multiple test "
"files:"
msgstr ""

#: src/ch10-02-test-organization.md:159
#, fuzzy
msgid "<span class=\"caption\">Filename: tests/common.cairo</span>"
msgstr "span class=\"caption\">Dosya adı: src/tests.cairo/span>"

#: src/ch10-02-test-organization.md:163
msgid "\"Setting up tests...\""
msgstr ""

#: src/ch10-02-test-organization.md:174
msgid "\"internal_adder failed\""
msgstr "\"internal_adder başarısız oldu\""

#: src/ch10-02-test-organization.md:194
msgid ""
"When we run the tests with `scarb test`, we’ll see a new section in the test "
"output for the _common.cairo_ file, even though this file doesn’t contain "
"any test functions nor did we call the setup function from anywhere:"
msgstr ""

#: src/ch10-02-test-organization.md:218
msgid ""
"To avoid systematically getting a section for each file of the _tests_ "
"folder, we also have the option of making the `tests/` directory behave like "
"a regular crate, by adding a `tests/lib.cairo` file. In that case, the "
"`tests` directory will no longer compile as one crate per file, but as one "
"crate for the whole directory."
msgstr ""

#: src/ch10-02-test-organization.md:220
msgid "Let's create this _tests/lib.cairo_ file :"
msgstr ""

#: src/ch10-02-test-organization.md:222
#, fuzzy
msgid "<span class=\"caption\">Filename: tests/lib.cairo</span>"
msgstr "span class=\"caption\">Dosya adı: src/lib.cairo/span>"

#: src/ch10-02-test-organization.md:229
#, fuzzy
msgid "The project directory will now look like this :"
msgstr "Senaryonun tamamı şöyle görünürdü:"

#: src/ch10-02-test-organization.md:243
msgid "When we run the `scarb test` command again, here is the output :"
msgstr ""

#: src/ch10-02-test-organization.md:263
msgid ""
"This way, only the test functions will be tested and the `setup` function "
"can be imported without being tested."
msgstr ""

#: src/ch10-02-test-organization.md:267
msgid ""
"Cairo's testing features provide a way to specify how code should function "
"to ensure it continues to work as you expect, even as you make changes. Unit "
"tests exercise different parts of a library separately and can test private "
"implementation details. Integration tests check that many parts of the "
"library work together correctly, and they use the library’s public API to "
"test the code in the same way external code will use it. Even though Cairo's "
"type system and ownership rules help prevent some kinds of bugs, tests are "
"still important to reduce logic bugs having to do with how your code is "
"expected to behave."
msgstr ""

#: src/ch10-02-test-organization.md:269
msgid "{{#quiz ../quizzes/ch10-02-testing-organization.toml}}"
msgstr "#quiz../quizzes/ch10-02-testing-organization.toml"

#: src/ch11-00-advanced-features.md
msgid "Advanced Features"
msgstr "Gelişmiş Özellikler"

#: src/ch11-00-advanced-features.md
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr ""
"Şimdi Kahire'nin sunduğu daha gelişmiş özellikler hakkında bilgi verelim."

#: src/ch11-01-custom-data-structures.md:3
msgid ""
"When you first start programming in Cairo, you'll likely want to use arrays "
"(`Array<T>`) to store collections of data. However, you will quickly realize "
"that arrays have one big limitation - the data stored in them is immutable. "
"Once you append a value to an array, you can't modify it."
msgstr ""
"Kahire'de programlamaya ilk başladığınızda, büyük olasılıkla veri "
"koleksiyonlarını depolamak için diziler (ArrayT>) kullanmak isteyeceksiniz. "
"Bununla birlikte, dizilerin büyük bir sınırlamaya sahip olduğunu çabucak "
"fark edeceksiniz - içlerinde depolanan veriler değiştirilemez. Bir diziye "
"bir değer ekledikten sonra, bunu değiştiremezsiniz."

#: src/ch11-01-custom-data-structures.md:8
msgid ""
"This can be frustrating when you want to use a mutable data structure. For "
"example, say you're making a game where the players have a level, and they "
"can level up. You might try to store the level of the players in an array:"
msgstr ""
"Değiştirilebilir bir veri yapısı kullanmak istediğinizde bu sinir bozucu "
"olabilir. Örneğin, oyuncuların bir seviyeye sahip olduğu bir oyun "
"yaptığınızı ve seviye atlayabildiklerini varsayalım. Oyuncuların seviyesini "
"bir dizide saklamayı deneyebilirsiniz:"

#: src/ch11-01-custom-data-structures.md:16
msgid ""
"But then you realize you can't increase the level at a specific index once "
"it's set. If a player dies, you cannot remove it from the array unless he "
"happens to be in the first position."
msgstr ""
"Ancak daha sonra belirli bir indekste seviyeyi ayarlandıktan sonra "
"artıramayacağınızı fark edersiniz. Bir oyuncu ölürse, ilk pozisyonda "
"olmadığı sürece diziden çıkaramazsınız."

#: src/ch11-01-custom-data-structures.md:20
msgid ""
"Fortunately, Cairo provides a handy built-in [dictionary type](./ch03-02-"
"dictionaries.md) called `Felt252Dict<T>` that allows us to simulate the "
"behavior of mutable data structures. Let's first explore how to create a "
"struct that contains, among others, a `Felt252Dict<T>`."
msgstr ""
"Neyse ki, Kahire, değiştirilebilir veri yapılarının davranışını simüle "
"etmemizi sağlayan Felt252DictT> adlı kullanışlı bir yerleşik [dictionary "
"type] (./ch03-02-dictionaries.md) sağlar. İlk olarak, diğerlerinin yanı "
"sıra, bir Felt252DictT> içeren bir yapı oluşturmayı araştıralım."

#: src/ch11-01-custom-data-structures.md:23
msgid ""
"Note: Several concepts used in this chapter were already presented earlier "
"in the book. We recommend checking out the following chapters if you need to "
"revise them: [Structs](ch05-00-using-structs-to-structure-related-data.md), "
"[Methods](./ch05-03-method-syntax.md), [Generic types](./ch08-00-generic-"
"types-and-traits.md), [Traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"Not: Bu bölümde kullanılan çeşitli kavramlar daha önce kitapta sunulmuştur. "
"Yeniden gözden geçirmeniz gerekiyorsa aşağıdaki bölümleri kontrol etmenizi "
"tavsiye ederiz: [Yapılar] (ch05-00-kullanım-yapı-yapı-bağlantılı-data.md), "
"[Methods] (./ch05-03-method-syntax.md), [Generic types] (./ch08-00genic-tr."

#: src/ch11-01-custom-data-structures.md:29
msgid "Dictionaries as Struct Members"
msgstr "Struct Üyeleri Olarak Sözlükler"

#: src/ch11-01-custom-data-structures.md:31
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly "
"interacting with them may not be entirely seamless. Let's try implementing a "
"custom _user database_ that will allow us to add users and query them. We "
"will need to define a struct to represent the new type and a trait to define "
"its functionality:"
msgstr ""
"Kahire'de sözlükleri yapısal üyeler olarak tanımlamak mümkündür, ancak "
"onlarla doğru bir şekilde etkileşimde bulunmak tamamen sorunsuz olmayabilir. "
"Kullanıcıları eklememize ve sorgulamamıza izin verecek özel bir _user "
"database_ uygulamasını deneyelim. Yeni türü ve işlevselliğini tanımlamak "
"için bir özelliği temsil edecek bir yapı tanımlamamız gerekecek:"

#: src/ch11-01-custom-data-structures.md:46
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic "
"over the balances of the users, giving major flexibility to whoever uses our "
"data type. Its two members are:"
msgstr ""
"Yeni türümüz UserDatabaseT> kullanıcıların bir veritabanını temsil eder. "
"Kullanıcıların dengeleri üzerinde geneldir ve veri türümüzü kullananlara "
"büyük esneklik sağlar. İki üyesi:"

#: src/ch11-01-custom-data-structures.md:48
msgid "`users_updates`, the number of users updates in the dictionary."
msgstr "users_updates, sözlükteki kullanıcı güncellemelerinin sayısı."

#: src/ch11-01-custom-data-structures.md:49
msgid "`balances`, a mapping of each user to its balance."
msgstr "balances, her kullanıcının dengesine bir haritalama."

#: src/ch11-01-custom-data-structures.md:51
msgid ""
"The database core functionality is defined by `UserDatabaseTrait`. The "
"following methods are defined:"
msgstr ""
"Veritabanı çekirdek işlevselliği UserDatabaseTrait tarafından tanımlanır. "
"Aşağıdaki yöntemler tanımlanmıştır:"

#: src/ch11-01-custom-data-structures.md:53
msgid "`new` for easily creating new `UserDatabase` types."
msgstr "new kolayca yeni UserDatabase türleri oluşturmak için."

#: src/ch11-01-custom-data-structures.md:54
msgid "`update_user` to update the balance of users in the database."
msgstr "update_user veritabanındaki kullanıcıların dengesini güncellemek için."

#: src/ch11-01-custom-data-structures.md:55
msgid "`get_balance` to find user's balance in the database."
msgstr "get_balance kullanıcı dengesini veritabanında bulmak için."

#: src/ch11-01-custom-data-structures.md:57
msgid ""
"The only remaining step is to implement each of the methods in "
"`UserDatabaseTrait`, but since we are working with [Generic types](./ch08-00-"
"generic-types-and-traits.md) we also need to correctly establish the "
"requirements of `T` so it can be a valid `Felt252Dict<T>` value type:"
msgstr ""
"Geriye kalan tek adım, UserDatabaseTrait'deki yöntemlerin her birini "
"uygulamaktır, ancak [Generic types](./ch08-00-generic-types-and-traits.md) "
"ile çalıştığımız için, T'nin gereksinimlerini doğru bir şekilde belirlememiz "
"gerekir, böylece geçerli bir Felt252DictT> değer türü olabilir:"

#: src/ch11-01-custom-data-structures.md:59
msgid ""
"`T` should implement the `Copy<T>` since it's required for getting values "
"from a `Felt252Dict<T>`."
msgstr ""
"T, CopyT> değerini bir Felt252DictT>'den almak için gerekli olduğu için "
"uygulamalıdır."

#: src/ch11-01-custom-data-structures.md:60
msgid ""
"All value types of a dictionary implement the `Felt252DictValue<T>`, our "
"generic type should do as well."
msgstr ""
"Bir sözlüğün tüm değer türleri Felt252DictValueT>'yi uygular, jenerik "
"türümüz de bunu yapmalıdır."

#: src/ch11-01-custom-data-structures.md:61
msgid ""
"To insert values, `Felt252DictTrait<T>` requires all value types to be "
"droppable (implement the `Drop<T>` trait)."
msgstr ""
"Değerleri eklemek için, Felt252DictTraitT> tüm değer türlerinin "
"bırakılabilir olmasını gerektirir (DropT> özelliğini uygulayın)."

#: src/ch11-01-custom-data-structures.md:63
msgid ""
"The implementation, with all restrictions in place, would be as follows:"
msgstr ""
"Uygulama, yürürlükteki tüm kısıtlamalarla birlikte aşağıdaki gibi olacaktır:"

#: src/ch11-01-custom-data-structures.md:67
#: src/ch11-01-custom-data-structures.md:112
msgid "// Creates a database\n"
msgstr "// Bir veritabanı oluşturur\n"

#: src/ch11-01-custom-data-structures.md:72
#: src/ch11-01-custom-data-structures.md:117
msgid "// Get the user's balance\n"
msgstr "// Kullanıcının bakiyesini alın\n"

#: src/ch11-01-custom-data-structures.md:77
#: src/ch11-01-custom-data-structures.md:122
msgid "// Add a user\n"
msgstr "// Bir kullanıcı ekle\n"

#: src/ch11-01-custom-data-structures.md:85
msgid ""
"Our database implementation is almost complete, except for one thing: the "
"compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since "
"it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait. Since "
"it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are "
"forced to implement the `Destruct<T>` trait manually (refer to the "
"[Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for more "
"information). Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` "
"definition won't work because of the use of [Generic types](./ch08-00-"
"generic-types-and-traits.md) in the struct definition. We need to code the "
"`Destruct<T>` trait implementation by ourselves:"
msgstr ""
"Veritabanı uygulamamız neredeyse tamamlandı, tek bir şey hariç: derleyici "
"UserDatabaseT> type(DropT>DrectT> typeDrectT> typeDrectT> typeDructT> "
"typeDructT> kullanmak için gerekli değil, bu yüzden Felt252DictT> bir üye "
"olarak, bu uygulama için zorlanırız."

#: src/ch11-01-custom-data-structures.md:97
msgid ""
"Implementing `Destruct<T>` for `UserDatabase` was our last step to get a "
"fully functional database. We can now try it out:"
msgstr ""
"UserDatabase için DestructT> uygulamasının uygulanması, tamamen işlevsel bir "
"veritabanı elde etmek için son adımımızdı. Artık deneyebilirsiniz:"

#: src/ch11-01-custom-data-structures.md:147
msgid "\"Expected 40\""
msgstr "\"Beklenen 40\""

#: src/ch11-01-custom-data-structures.md:148
msgid "\"Expected 0\""
msgstr "\"Beklenen 0\""

#: src/ch11-01-custom-data-structures.md:156
msgid "Simulating a Dynamic Array with Dicts"
msgstr "Dicts ile Dinamik Dizi Simülasyonu"

#: src/ch11-01-custom-data-structures.md:158
msgid ""
"First, let's think about how we want our mutable dynamic array to behave. "
"What operations should it support?"
msgstr ""
"Öncelikle, değişken dinamik dizimizin nasıl davranmasını istediğimizi "
"düşünelim. Hangi işlemleri desteklemeli?"

#: src/ch11-01-custom-data-structures.md:161
msgid "It should:"
msgstr "Olmalı:"

#: src/ch11-01-custom-data-structures.md:163
msgid "Allow us to append items at the end."
msgstr "Sondaki ögeleri eklememize izin verin."

#: src/ch11-01-custom-data-structures.md:164
msgid "Let us access any item by index."
msgstr "Herhangi bir öğeye index ile erişmemize izin verin."

#: src/ch11-01-custom-data-structures.md:165
msgid "Allow setting the value of an item at a specific index."
msgstr "Bir öğenin değerini belirli bir indekste ayarlamaya izin verin."

#: src/ch11-01-custom-data-structures.md:166
msgid "Return the current length."
msgstr "Mevcut uzunluğu döndürün."

#: src/ch11-01-custom-data-structures.md:168
msgid "We can define this interface in Cairo like:"
msgstr "Bu arayüzü Kahire'de şöyle tanımlayabiliriz:"

#: src/ch11-01-custom-data-structures.md:181
msgid ""
"This provides a blueprint for the implementation of our dynamic array. We "
"named it _Vec_ as it is similar to the `Vec<T>` data structure in Rust."
msgstr ""
"Bu, dinamik dizimizin uygulanması için bir taslak sağlar. Rust'taki VecT> "
"veri yapısına benzediği için _Vec_ olarak adlandırdık."

#: src/ch11-01-custom-data-structures.md:184
msgid "Implementing a Dynamic Array in Cairo"
msgstr "Kahire'de Dinamik Bir Dizinin Uygulanması"

#: src/ch11-01-custom-data-structures.md:186
msgid ""
"To store our data, we'll use a `Felt252Dict<T>` which maps index numbers "
"(felts) to values. We'll also store a separate `len` field to track the "
"length."
msgstr ""
"Verilerimizi depolamak için Felt252DictT> dizini numaralarını (felsefeleri) "
"değerlere eşleyen bir Felt252DictT> kullanacağız. Uzunluğu izlemek için ayrı "
"bir len alanı da depolayacağız."

#: src/ch11-01-custom-data-structures.md:189
msgid ""
"Here is what our struct looks like. We wrap the type `T` inside `Nullable` "
"pointer to allow using any type `T` in our data structure, as explained in "
"the [Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-"
"supported-natively) section:"
msgstr ""
"İşte yapımızın neye benzediği. [Dictionaries](./ch03-02-dictionaries."
"md#dictionaries-of-types-not-supported-natively) bölümünde açıklandığı gibi, "
"veri yapımızda herhangi bir T tipinin kullanılmasına izin vermek için "
"Nulable işaretçisinin içine T tipini sarıyoruz:"

#: src/ch11-01-custom-data-structures.md:200
msgid ""
"Since we again have `Felt252Dict<T>` as a struct member, we need to "
"implement the `Destruct<T>` trait to tell the compiler how to make "
"`NullableVec<T>` go out of scope."
msgstr ""
"Felt252DictT> bir yapısal üye olarak tekrar sahip olduğumuzdan, derleyiciye "
"NulableVecT>'nin kapsam dışına çıkmasını söylemek için DestructT> özelliğini "
"uygulamamız gerekir."

#: src/ch11-01-custom-data-structures.md:210
msgid ""
"The key thing that makes this vector mutable is that we can insert values "
"into the dictionary to set or update values in our data structure. For "
"example, to update a value at a specific index, we do:"
msgstr ""
"Bu vektörü değişken kılan en önemli şey, veri yapımızdaki değerleri "
"ayarlamak veya güncellemek için sözlüğe değerler ekleyebilmemizdir. Örneğin, "
"belirli bir indeksteki bir değeri güncellemek için şunları yaparız:"

#: src/ch11-01-custom-data-structures.md:216
#: src/ch11-01-custom-data-structures.md:245
#: src/ch11-01-custom-data-structures.md:254
msgid "\"Index out of bounds\""
msgstr "\"Sınırların dışında Index\""

#: src/ch11-01-custom-data-structures.md:221
msgid ""
"This overwrites the previously existing value at that index in the "
"dictionary."
msgstr "Bu, sözlüğün o indeksinde daha önce var olan değerin üzerine yazılır."

#: src/ch11-01-custom-data-structures.md:223
msgid ""
"While arrays are immutable, dictionaries provide the flexibility we need for "
"modifiable data structures like vectors."
msgstr ""
"Diziler değiştirilemezken, sözlükler vektörler gibi değiştirilebilir veri "
"yapıları için ihtiyaç duyduğumuz esnekliği sağlar."

#: src/ch11-01-custom-data-structures.md:226
msgid ""
"The implementation of the rest of the interface is straightforward. The "
"implementation of all the methods defined in our interface can be done as "
"follow :"
msgstr ""
"Arayüzün geri kalanının uygulanması basittir. Arayüzümüzde tanımlanan tüm "
"yöntemlerin uygulanması aşağıdaki gibi yapılabilir:"

#: src/ch11-01-custom-data-structures.md:263
msgid ""
"The full implementation of the `Vec` structure can be found in the community-"
"maintained library [Alexandria](https://github.com/keep-starknet-strange/"
"alexandria/tree/main/packages/data_structures/src)."
msgstr ""
"Vec yapısının tam olarak uygulanması topluluk bakımlı kütüphanede "
"bulunabilir [Alexandria](https://github.com/keep-starknet-strange/alexandria/"
"tree/main/packages/data_structures/src)."

#: src/ch11-01-custom-data-structures.md:268
msgid "Simulating a Stack with Dicts"
msgstr "Diktlerle Bir Yığın Simülasyonu"

#: src/ch11-01-custom-data-structures.md:270
msgid ""
"We will now look at a second example and its implementation details: a Stack."
msgstr "Şimdi ikinci bir örneğe ve uygulama detaylarına bakacağız: bir Stack."

#: src/ch11-01-custom-data-structures.md:272
msgid ""
"A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new "
"element and removal of an existing element takes place at the same end, "
"represented as the top of the stack."
msgstr ""
"Stack bir LIFO (Last-In, First-Out) koleksiyonudur. Yeni bir elemanın "
"eklenmesi ve mevcut bir elemanın çıkarılması, yığının üst kısmı olarak "
"temsil edilen aynı uçta gerçekleşir."

#: src/ch11-01-custom-data-structures.md:276
msgid "Let us define what operations we need to create a stack:"
msgstr ""
"Bir yığın oluşturmak için hangi işlemleri yapmamız gerektiğini tanımlayalım:"

#: src/ch11-01-custom-data-structures.md:278
msgid "Push an item to the top of the stack."
msgstr "Bir öğeyi yığının tepesine itin."

#: src/ch11-01-custom-data-structures.md:279
msgid "Pop an item from the top of the stack."
msgstr "Yığının üst kısmından bir parça aç."

#: src/ch11-01-custom-data-structures.md:280
msgid "Check whether there are still any elements in the stack."
msgstr "Yığında hala herhangi bir eleman olup olmadığını kontrol edin."

#: src/ch11-01-custom-data-structures.md:282
msgid "From these specifications we can define the following interface :"
msgstr "Bu özelliklerden aşağıdaki arayüzü tanımlayabiliriz:"

#: src/ch11-01-custom-data-structures.md:292
msgid "Implementing a Mutable Stack in Cairo"
msgstr "Kahire'de Mutable Stack Uygulaması"

#: src/ch11-01-custom-data-structures.md:294
msgid ""
"To create a stack data structure in Cairo, we can again use a "
"`Felt252Dict<T>` to store the values of the stack along with a `usize` field "
"to keep track of the length of the stack to iterate over it."
msgstr ""
"Kahire'de bir yığın veri yapısı oluşturmak için, yığının değerlerini "
"tekrarlamak için yığının uzunluğunu takip etmek için bir usize alanıyla "
"birlikte saklamak için bir Felt252DictT> kullanabiliriz."

#: src/ch11-01-custom-data-structures.md:298
msgid "The Stack struct is defined as:"
msgstr "Stack yapısı şöyle tanımlanır:"

#: src/ch11-01-custom-data-structures.md:307
msgid ""
"Next, let's see how our main functions `push` and `pop` are implemented."
msgstr ""
"Daha sonra, ana fonksiyonlarımızın push ve pop nasıl uygulandığını görelim."

#: src/ch11-01-custom-data-structures.md:330
msgid ""
"The code uses the `insert` and `get` methods to access the values in the "
"`Felt252Dict<T>`. To push an element to the top of the stack, the `push` "
"function inserts the element in the dict at index `len` and increases the "
"`len` field of the stack to keep track of the position of the stack top. To "
"remove a value, the `pop` function decreases the value of `len` to update "
"the position of the stack top and then retrieves the last value at position "
"`len`."
msgstr ""
"Kod, Felt252DictT>'deki değerlere erişmek için insert ve get yöntemlerini "
"kullanır. Bir elemanı yığının tepesine itmek için, push işlevi, len "
"dizinindeki elemanı ekler ve yığının üst kısmının konumunu takip etmek için "
"yığının son len alanını arttırır. Bir değeri kaldırmak için, pop değerinin "
"değerini azaltır."

#: src/ch11-01-custom-data-structures.md:337
msgid ""
"The full implementation of the Stack, along with more data structures that "
"you can use in your code, can be found in the community-maintained "
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/"
"packages/data_structures/src) library, in the \"data_structures\" crate."
msgstr ""
"Stack'in tam olarak uygulanması, kodunuzda kullanabileceğiniz daha fazla "
"veri yapısıyla birlikte, topluluk bakımı [Alexandria](https://github.com/"
"keep-starknet-strange/alexandria/tree/main/packages/data_structures/src) "
"kütüphanesinde, \"data_structures\" kasasında bulunabilir."

#: src/ch11-01-custom-data-structures.md:343
msgid "{{#quiz ../quizzes/ch11-01-custom-structs.toml}}"
msgstr "#quiz../quizzes/ch11-01-custom-structs.toml"

#: src/ch11-01-custom-data-structures.md:347
msgid ""
"Well done! Now you have knowledge of arrays, dictionaries and even custom "
"data structures. While Cairo's memory model is immutable and can make it "
"difficult to implement mutable data structures, we can fortunately use the "
"`Felt252Dict<T>` type to simulate mutable data structures. This allows us to "
"implement a wide range of data structures that are useful for many "
"applications, effectively hiding the complexity of the underlying memory "
"model."
msgstr ""
"Tebrikler! Artık diziler, sözlükler ve hatta özel veri yapıları hakkında "
"bilginiz var. Kahire'nin bellek modeli değiştirilemez ve değiştirilebilen "
"veri yapılarını uygulamayı zorlaştırabilirken, Felt252DictT> türünü "
"değiştirilebilen veri yapılarını simüle etmek için kullanabiliriz. Bu, "
"birçok uygulama için yararlı olan ve altta yatan bellek modelinin "
"karmaşıklığını etkili bir şekilde gizleyen çok çeşitli veri yapılarını "
"uygulamamızı sağlar."

#: src/ch11-02-smart-pointers.md:3
msgid ""
"A pointer is a general concept for a variable that contains a memory "
"address. This address refers to, or “points at,” some other data. While "
"pointers are a powerful feature, they can also be a source of bugs and "
"security vulnerabilities. For example, a pointer can reference an unassigned "
"memory cell, which means that attempting to access the data at that address "
"would cause the program to crash, making it unprovable. To prevent such "
"issues, Cairo uses _Smart Pointers_."
msgstr ""
"Bir işaretçi, bir bellek adresi içeren bir değişken için genel bir "
"kavramdır. Bu adres, diğer bazı verileri ifade eder veya \"noktalar\". "
"İşaretçiler güçlü bir özellik olsa da, aynı zamanda bir hata ve güvenlik "
"açıkları kaynağı olabilir. Örneğin, bir işaretçi atanmamış bir bellek "
"hücresine referans verebilir, bu da bu adresteki verilere erişmeye "
"çalışmanın programın çökmesine neden olacağı anlamına gelir, bu da onu "
"kanıtlanamaz hale getirir. Bu tür sorunları önlemek için Kahire Noktası "
"kullanır _Smart."

#: src/ch11-02-smart-pointers.md:5
msgid ""
"Smart pointers are data structures that act like a pointer, but also have "
"additional metadata and capabilities. The concept of smart pointers isn’t "
"unique to Cairo: smart pointers originated in C++ and exist in other "
"languages like Rust as well. In the specific case of Cairo, smart pointers "
"ensure that memory is not addressed in an unsafe way that could cause a "
"program to be unprovable, by providing a safe way to access memory through "
"strict type checking and ownership rules."
msgstr ""
"Akıllı işaretçiler, bir işaretçi gibi davranan, aynı zamanda ek meta veriler "
"ve yeteneklere sahip veri yapılarıdır. Akıllı işaretçiler kavramı Kahire'ye "
"özgü değildir: akıllı işaretçiler C++ kökenlidir ve Rust gibi diğer dillerde "
"de mevcuttur. Kahire'nin özel durumunda, akıllı işaretçiler, sıkı tip "
"kontrol ve sahiplik kurallarıyla hafızaya güvenli bir şekilde erişmenin "
"güvenli bir yolunu sağlayarak, bir programın kanıtlanamayacak şekilde ele "
"alınmamasını sağlar."

#: src/ch11-02-smart-pointers.md:7
msgid ""
"Though we didn’t call them as such at the time, we’ve already encountered a "
"few smart pointers in this book, including `Felt252Dict<T>` and `Array<T>` "
"in Chapter 3. Both these types count as smart pointers because they own a "
"memory segment and allow you to manipulate it. They also have metadata and "
"extra capabilities or guarantees. Arrays keep track of their current length "
"to ensure that existing elements are not overwritten, and that new elements "
"are only appended to the end."
msgstr ""
"Her ne kadar o zamanlar onları böyle çağırmamış olsak da, bu kitapta "
"Felt252DictT> ve ArrayT> 3. Bölümde de dahil olmak üzere birkaç akıllı "
"işaretçiyle karşılaştık. Her iki tip de bir bellek segmentine sahip "
"oldukları için akıllı işaretçiler olarak sayılır ve bunu manipüle etmenize "
"izin verir. Ayrıca meta veriler ve ekstra yetenekler veya garantiler de "
"vardır. Diziler, mevcut öğelerin üzerinde yazılmamasını sağlamak için mevcut "
"uzunluklarını takip eder."

#: src/ch11-02-smart-pointers.md:9
msgid ""
"The Cairo VM memory is composed by multiple segments that can store data, "
"each identified by a unique index. When you create an array, you allocate a "
"new segment in the memory to store the future elements. The array itself is "
"just a pointer to that segment where the elements are stored."
msgstr ""
"Kahire VM belleği, her biri benzersiz bir endeksle tanımlanan verileri "
"depolayabilen birden fazla segmentten oluşur. Bir dizi oluşturduğunuzda, "
"gelecekteki öğeleri saklamak için bellekte yeni bir segment tahsis "
"edersiniz. Dizinin kendisi, öğelerin depolandığı o segmente sadece bir "
"işaretçidir."

#: src/ch11-02-smart-pointers.md:11
msgid "The `Box<T>` Type to Manipulate Pointers"
msgstr "BoxT> İşaretçileri Manipüle Etme Türü"

#: src/ch11-02-smart-pointers.md:13
msgid ""
"The principal smart pointer type in Cairo is a _box_, denoted as `Box<T>`. "
"Manually defining boxes allow you to store data in a specific memory segment "
"of the Cairo VM called the _boxed segment_. This segment is dedicated to "
"store all boxed values, and what remains in the execution segment is only a "
"pointer to the boxed segment. Whenever you instantiate a new pointer "
"variable of type `Box<T>`, you append the data of type `T` to the boxed "
"segment."
msgstr ""
"Kahire'deki ana akıllı işaretçi türü, BoxT> olarak gösterilen bir _box_'dir. "
"Manuel olarak tanımlayan kutular, verileri Kahire VM'nin _boxed segmenti_ "
"olarak adlandırılan belirli bir bellek segmentinde saklamanıza izin verir. "
"Bu segment, tüm kutulu değerleri depolamaya adanmıştır ve yürütme "
"segmentinde kalan şey, kutulu segmente yalnızca bir işaretçidir. Ne zaman "
"BoxT tipinde yeni bir işaretçik değişkeni hazırlasanız, BoxT>"

#: src/ch11-02-smart-pointers.md:15
msgid ""
"Boxes have very little performance overhead, other than writing their inner "
"values to the boxed segment. But they don’t have many extra capabilities "
"either. You’ll use them most often in these situations:"
msgstr ""
"Kutular, iç değerlerini kutulu segmente yazmaktan başka çok az performans "
"yüküne sahiptir. Ancak çok fazla ekstra kapasiteye de sahip değiller. "
"Bunları en sık bu durumlarda kullanacaksınız:"

#: src/ch11-02-smart-pointers.md:17
msgid ""
"When you have a type whose size can’t be known at compile time and you want "
"to use a value of that type in a context that requires an exact size"
msgstr ""
"Derleme zamanında boyutu bilinemeyen bir türe sahip olduğunuzda ve bu tür "
"bir değeri tam bir boyut gerektiren bir bağlamda kullanmak istediğinizde"

#: src/ch11-02-smart-pointers.md:18
msgid ""
"When you have a large amount of data and you want to transfer ownership but "
"ensure the data won’t be copied when you do so"
msgstr ""
"Büyük miktarda veriniz olduğunda ve sahipliği aktarmak istediğinizde, ancak "
"bunu yaptığınızda verilerin kopyalanmayacağından emin olun."

#: src/ch11-02-smart-pointers.md:20
msgid ""
"We’ll demonstrate the first situation in the [“Enabling Recursive Types with "
"Boxes”](./ch11-02-smart-pointers.md#enabling-recursive-types-with-nullable-"
"boxes) section. In the second case, transferring ownership of a large amount "
"of data can take a long time because the data is copied around in memory. To "
"improve performance in this situation, we can store the large amount of data "
"in the boxed segment using a box type. Then, only the small amount of "
"pointer data is copied around in memory, while the data it references stays "
"in one place on the boxed segment."
msgstr ""
"[\"Kutularla Özyinelemeli Tipleri Etkinleştirmek\"] bölümündeki ilk durumu "
"göstereceğiz.(./ch11-02-smart-pointers.md#enabling-recursive-types-with-"
"nullable-boxes] bölümünde. İkinci durumda, büyük miktarda verinin mülkiyeti "
"bellek etrafında kopyalandığı için, büyük veri miktarını saklayabiliriz."

#: src/ch11-02-smart-pointers.md:25
msgid "Using a `Box<T>` to Store Data in the Boxed Segment"
msgstr "BoxT> Veriyi Kutulu Segmentte Saklamak için"

#: src/ch11-02-smart-pointers.md:27
msgid ""
"Before we discuss the boxed segment storage use cases for `Box<T>`, we’ll "
"cover the syntax and how to interact with values stored within a `Box<T>`."
msgstr ""
"BoxT> için kutulu segment depolama kullanım durumlarını tartışmadan önce, "
"sözdizimini ve bir BoxT> içinde depolanan değerlerle nasıl etkileşim "
"kuracağımızı ele alacağız."

#: src/ch11-02-smart-pointers.md:29
msgid ""
"Listing 11-1 shows how to use a box to store a value in the boxed segment:"
msgstr ""
"Listeleme 11-1 kutulu segmentte bir değeri saklamak için bir kutunun nasıl "
"kullanılacağını gösterir:"

#: src/ch11-02-smart-pointers.md:34
msgid "\"b = {}\""
msgstr "\"b = \""

#: src/ch11-02-smart-pointers.md:38
msgid ""
"<span class=\"caption\">Listing 11-1: Storing a `u128` value in the boxed "
"segment using a box</span>"
msgstr ""
"span class=\"caption\">Liste 11-1: Kutulu segmentte u128 değerini bir kutu "
"kullanarak saklamak/span>"

#: src/ch11-02-smart-pointers.md:40
msgid ""
"We define the variable `b` to have the value of a `Box` that points to the "
"value `5`, which is stored in the boxed segment. This program will print `b "
"= 5`; in this case, we can access the data in the box similar to how we "
"would if this data was simply in the execution memory. Putting a single "
"value in a box isn’t very useful, so you won’t use boxes by themselves in "
"this way very often. Having values like a single `u128` in the execution "
"memory, where they’re stored by default, is more appropriate in the majority "
"of situations. Let’s look at a case where boxes allow us to define types "
"that we wouldn’t be allowed to if we didn’t have boxes."
msgstr ""
"b değişkenini, 5 değerine işaret eden ve kutulu segmentte saklanan bir Box "
"değerine sahip olarak tanımlıyoruz. Bu program b = 5 yazdıracaktır; bu "
"durumda, bu verinin sadece yürütme belleğinde olmasına izin vermediğimiz "
"durumlarda, kutudaki verilere nasıl izin vereceğimize benzer şekilde "
"erişebiliriz. Bir kutuya tek bir değer koymak çok yararlı değildir, bu "
"nedenle kutuları kendi başlarına kullanmayacaksınız."

#: src/ch11-02-smart-pointers.md:42
msgid "Enabling Recursive Types with Nullable Boxes"
msgstr "Nullable Boxes ile Özyinelemeli Türlerin Etkinleştirilmesi"

#: src/ch11-02-smart-pointers.md:46
msgid "Using Boxes to Improve Performance"
msgstr "Performansı artırmak için kutuların kullanılması"

#: src/ch11-02-smart-pointers.md:48
msgid ""
"Passing pointers between functions allows you to reference data without "
"copying the data itself. Using boxes can improve performance as it allows "
"you to pass a pointer to some data from one function to another, without the "
"need to copy the entire data in memory before performing the function call. "
"Instead of having to write `n` values into memory before calling a function, "
"only a single value is written, corresponding to the pointer to the data. If "
"the data stored in the box is very large, the performance improvement can be "
"significant, as you would save `n-1` memory operations before each function "
"call."
msgstr ""
"Fonksiyonlar arasındaki işaretçileri geçmek, verilerin kendisini "
"kopyalamadan veriye referans vermenizi sağlar. Kutuları kullanmak, bir "
"işaretçiyi bir işlevden diğerine, işlev çağrısını gerçekleştirmeden önce tüm "
"verileri bellekte kopyalamanıza gerek kalmadan, bazı verilere aktarmanıza "
"izin verdiği için performansı artırabilir. Bir işlevi çağırmadan önce n "
"değerlerini hafızaya yazmak zorunda kalmak yerine, her bir işleve karşılık "
"gelen tek bir değer yazılır. Kutu-1'de depolanan veriler çok büyükse, "
"performans çok büyük olur."

#: src/ch11-02-smart-pointers.md:50
msgid ""
"Let's take a look at the code in Listing 11-2, which shows two ways of "
"passing data to a function: by value and by pointer."
msgstr ""
"Bir fonksiyona veri aktarmanın iki yolunu gösteren Listeleme 11-2'deki koda "
"bir göz atalım: değere göre ve işaretçiye göre."

#: src/ch11-02-smart-pointers.md:61 src/ch11-02-smart-pointers.md:66
msgid "\"{} is shopping today and bought {} items\""
msgstr "\" bugün alışveriş yapıyor ve  eşya satın alıyor\""

#: src/ch11-02-smart-pointers.md:70
msgid "\"Eli\""
msgstr "\"Eli\""

#: src/ch11-02-smart-pointers.md:73
msgid "\"Uri\""
msgstr "\"Uri\""

#: src/ch11-02-smart-pointers.md:78
msgid ""
"<span class=\"caption\">Listing 11-2: Storing large amounts of data in a box "
"for performance.</span>"
msgstr ""
"span class=\"caption\">Liste 11-2: Performans için büyük miktarda veriyi bir "
"kutuya saklama./span>"

#: src/ch11-02-smart-pointers.md:80
msgid "The `main` function includes 2 function calls:"
msgstr "main işlevi 2 işlev çağrısı içerir:"

#: src/ch11-02-smart-pointers.md:82
msgid "`pass_data` that takes a variable of type `Cart`."
msgstr "pass_data değişken Cart tipini alır."

#: src/ch11-02-smart-pointers.md:83
msgid "`pass_pointer` that takes a pointer of type `Box<Cart>`."
msgstr "pass_pointer türü BoxCart> işaretçisini alır."

#: src/ch11-02-smart-pointers.md:85
msgid ""
"When passing data to a function, the entire data is copied into the last "
"available memory cells right before the function call. Calling `pass_data` "
"will copy all 3 fields of `Cart` to memory, while `pass_pointer` only "
"requires the copy of the `new_box` pointer which is of size 1."
msgstr ""
"Veriyi bir fonksiyona aktarırken, tüm veriler işlev çağrısından hemen önce "
"mevcut olan son bellek hücrelerine kopyalanır. pass_data'yi aramak, Cart'nin "
"tüm 3 alanını belleğe kopyalarken, pass_pointer yalnızca 1 boyutunda olan "
"new_box işaretçisinin kopyasını gerektirir."

#: src/ch11-02-smart-pointers.md:94
msgid ""
"The illustration above demonstrates how the memory behaves in both cases. "
"The first instance of `Cart` is stored in the execution segment, and we need "
"to copy all its fields to memory before calling the `pass_data` function. "
"The second instance of `Cart` is stored in the boxed segment, and the "
"pointer to it is stored in the execution segment. When calling the "
"`pass_pointer` function, only the pointer to the struct is copied to memory "
"right before the function call. In both cases, however, instantiating the "
"struct will store all its values in the execution segment: the boxed segment "
"can only be filled with data taken from the execution segment."
msgstr ""
"Yukarıdaki örnek, belleğin her iki durumda da nasıl davrandığını "
"göstermektedir. Cart'nin ilk örneği yürütme segmentinde saklanır ve "
"pass_data işlevini çağırmadan önce tüm alanlarını hafızaya kopyalamamız "
"gerekir. Cart'nin ikinci örneği kutulu segmentte saklanır ve ona işaret eden "
"kişi her iki yürütme segmentinde de saklanabilir. pass_pointer işlevini "
"çağırırken, yalnızca sağdaki strug işlevine edilir."

#: src/ch11-02-smart-pointers.md:96
msgid "The `Nullable<T>` Type for Dictionaries"
msgstr "NulableT> Sözlükler için Tip"

#: src/ch11-02-smart-pointers.md:98
msgid ""
"`Nullable<T>` is another type of smart pointer that can either point to a "
"value or be `null` in the absence of value. It is defined at the Sierra "
"level. This type is mainly used in dictionaries that contain types that "
"don't implement the `zero_default` method of the `Felt252DictValue<T>` trait "
"(i.e., arrays and structs)."
msgstr ""
"NullableT>, değer yokluğunda bir değere işaret edebilen veya null olabilen "
"başka bir akıllı işaretçi türüdür. Sierra seviyesinde tanımlanır. Bu tür, "
"çoğunlukla Felt252DictValueT> özelliğinin zero_default yöntemini uygulamayan "
"türler içeren sözlüklerde kullanılır (yani, diziler ve yapılar)."

#: src/ch11-02-smart-pointers.md:100
msgid ""
"If we try to access an element that does not exist in a dictionary, the code "
"will fail if the `zero_default` method cannot be called."
msgstr ""
"Bir sözlükte bulunmayan bir öğeye erişmeye çalışırsak, zero_default yöntemi "
"çağrılmazsa kod başarısız olur."

#: src/ch11-02-smart-pointers.md:102
msgid ""
"[Chapter 3.2](/ch03-02-dictionaries.md#dictionaries-of-types-not-supported-"
"natively) about dictionaries thoroughly explains how to store a "
"`Span<felt252>` variable inside a dictionary using the `Nullable<T>` type. "
"Please refer to it for further information."
msgstr ""
"[Bölüm 3.2](/ch03-02-dictionaries.md#dictionaries-of-types-not-supported-"
"natively) sözlükler hakkında bir Spanfelt252> değişkeninin NulableT> tipini "
"kullanarak bir sözlük içinde nasıl saklanacağını ayrıntılı bir şekilde "
"açıklar. Daha fazla bilgi için lütfen buna bakın."

#: src/ch11-02-smart-pointers.md:106
msgid "{{#quiz ../quizzes/ch11-02-smart_pointers.toml}}"
msgstr "#quiz../quizzes/ch11-02-smart_pointers.toml"

#: src/ch11-03-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows "
"the redefinition of standard operators, such as addition (`+`), subtraction "
"(`-`), multiplication (`*`), and division (`/`), to work with user-defined "
"types. This can make the syntax of the code more intuitive, by enabling "
"operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr ""
"Operatör aşırı yüklenmesi, bazı programlama dillerinde, kullanıcı tanımlı "
"türlerle çalışmak için ekleme (+), çıkarma (-), çarpma (*) ve bölme (/) gibi "
"standart operatörlerin yeniden tanımlanmasına izin veren bir özelliktir. Bu, "
"kullanıcı tanımlı türlerdeki işlemlerin ilkel türlerdeki işlemlerle aynı "
"şekilde ifade edilmesini sağlayarak, kodun sözdizimini daha sezgisel hale "
"getirebilir."

#: src/ch11-03-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of "
"specific traits. Each operator has an associated trait, and overloading that "
"operator involves providing an implementation of that trait for a custom "
"type. However, it's essential to use operator overloading judiciously. "
"Misuse can lead to confusion, making the code more difficult to maintain, "
"for example when there is no semantic meaning to the operator being "
"overloaded."
msgstr ""
"Kahire'de, operatör aşırı yüklenmesi belirli özelliklerin uygulanması "
"yoluyla elde edilir. Her operatör ilişkili bir özelliğe sahiptir ve bu "
"operatörün aşırı yüklenmesi, özel bir tür için bu özelliğin uygulanmasını "
"sağlamayı içerir. Bununla birlikte, operatör aşırı yüklenmesini akıllıca "
"kullanmak esastır. Yanlış kullanım, kodun bakımını zorlaştırabilir, örneğin "
"operatörün aşırı yüklenmesinin anlamsal bir anlamı olmadığında."

#: src/ch11-03-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have "
"two data fields, mana and health. Combining two `Potions` should add their "
"respective fields."
msgstr ""
"İki Potions'un birleştirilmesi gereken bir örneği ele alalım. Potions'nin "
"iki veri alanı, mana ve sağlık alanı vardır. İki Potions'un birleştirilmesi, "
"ilgili alanlarını içermelidir."

#: src/ch11-03-operator-overloading.md:26
msgid "// Both potions were combined with the `+` operator.\n"
msgstr "// Her iki iksir de + operatörü ile birleştirildi.\n"

#: src/ch11-03-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type. "
"The add function takes two arguments: `lhs` and `rhs` (left and right-hand "
"side). The function body returns a new `Potion` instance, its field values "
"being a combination of `lhs` and `rhs`."
msgstr ""
"Yukarıdaki kodda, Potion tipi için Add özelliğini uyguluyoruz. Ekleme işlevi "
"iki argüman alır: lhs ve rhs (sol ve sağ taraf). Fonksiyon gövdesi yeni bir "
"Potion örneğini döndürür, alan değerleri lhs ve rhs'nin bir kombinasyonudur."

#: src/ch11-03-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires "
"specification of the concrete type being overloaded. The overloaded generic "
"trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr ""
"Örnekte gösterildiği gibi, bir operatörün aşırı yüklenmesi, beton tipinin "
"aşırı yüklenmesini gerektirir. Aşırı yüklenmiş jenerik özellik AddT>'dir ve "
"AddPotion> ile Potion tipi için somut bir uygulama tanımlarız."

#: src/ch11-03-operator-overloading.md:36
msgid "{{#quiz ../quizzes/ch11-03-operator-overloading.toml}}"
msgstr "#quiz../quizzes/ch11-03-operator-overloading.toml"

#: src/ch11-04-hash.md:1
msgid "Hashes"
msgstr "Haşhaşlar"

#: src/ch11-04-hash.md:3
msgid ""
"At its essence, hashing is a process of converting input data (often called "
"a message) of any length into a fixed-size value, typically referred to as a "
"\"hash.\" This transformation is deterministic, meaning that the same input "
"will always produce the same hash value. Hash functions are a fundamental "
"component in various fields, including data storage, cryptography and data "
"integrity verification. They are very often used when developing smart "
"contracts, especially when working with [Merkle trees](https://en.wikipedia."
"org/wiki/Merkle_tree#Uses)."
msgstr ""
"Özünde, hashing, herhangi bir uzunluktaki girdi verilerini (genellikle mesaj "
"olarak adlandırılır) genellikle \"hash\" olarak adlandırılan sabit boyutlu "
"bir değere dönüştürme işlemidir. Bu dönüşüm deterministiktir, yani aynı "
"girdi her zaman aynı hash değerini üretecektir. Hash fonksiyonları, veri "
"depolama, kriptografi ve veri bütünlüğü doğrulaması dahil olmak üzere "
"çeşitli alanlarda temel bir bileşendir."

#: src/ch11-04-hash.md:5
msgid ""
"In this chapter, we will present the two hash functions implemented natively "
"in the Cairo core library: `Poseidon` and `Pedersen`. We will discuss when "
"and how to use them, and see examples with Cairo programs."
msgstr ""
"Bu bölümde, Kahire çekirdek kütüphanesinde doğal olarak uygulanan iki hash "
"fonksiyonunu sunacağız: Poseidon ve Pedersen. Bunları ne zaman ve nasıl "
"kullanacağımızı tartışacağız ve Kahire programlarıyla örnekler göreceğiz."

#: src/ch11-04-hash.md:9
msgid "Hash Functions in Cairo"
msgstr "Kahire'de Hash Fonksiyonları"

#: src/ch11-04-hash.md:11
msgid ""
"The Cairo core library provides two hash functions: Pedersen and Poseidon."
msgstr ""
"Kahire çekirdek kütüphanesi iki hash işlevi sunar: Pedersen ve Poseidon."

#: src/ch11-04-hash.md:13
msgid ""
"Pedersen hash functions are cryptographic algorithms that rely on [elliptic "
"curve cryptography](https://en.wikipedia.org/wiki/Elliptic-"
"curve_cryptography). These functions perform operations on points along an "
"elliptic curve — essentially, doing math with the locations of these points "
"— which are easy to do in one direction and hard to undo. This one-way "
"difficulty is based on the Elliptic Curve Discrete Logarithm Problem "
"(ECDLP), which is a problem so hard to solve that it ensures the security of "
"the hash function. The difficulty of reversing these operations is what "
"makes the Pedersen hash function secure and reliable for cryptographic "
"purposes."
msgstr ""
"Pedersen hash fonksiyonları, [eliptik eğri kriptografisi](https://en."
"wikipedia.org/wiki/elliptik-curve_cryptography)'ye dayanan kriptografik "
"algoritmalardır. Bu işlevler, eliptik eğri boyunca noktalar üzerinde işlem "
"yapar - esasen, bu noktaların konumlarıyla matematik yapmak - ki bu, tek "
"yönlü bir zorluktur."

#: src/ch11-04-hash.md:15
msgid ""
"Poseidon is a family of hash functions designed to be very efficient as "
"algebraic circuits. Its design is particularly efficient for Zero-Knowledge "
"proof systems, including STARKs (so, Cairo). Poseidon uses a method called a "
"'sponge construction,' which soaks up data and transforms it securely using "
"a process known as the Hades permutation. Cairo's version of Poseidon is "
"based on a three-element state permutation with [specific parameters]"
"(https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt)."
msgstr ""
"Poseidon, cebirsel devreler olarak çok verimli olacak şekilde tasarlanmış "
"bir hash fonksiyonları ailesidir. Tasarımı, STARK'lar (yani Kahire) dahil "
"olmak üzere Sıfır-Bilgi geçirmez sistemler için özellikle etkilidir. "
"Poseidon, verileri ıslatan ve Hades permütasyonu olarak bilinen bir işlem "
"kullanarak güvenli bir şekilde dönüştüren bir'sponge yapısı' adı verilen bir "
"yöntem kullanır. Kahire'nin Poseidon sürümü [spesifik parametrelerle] üç "
"elemanlı bir durum permutasyonuna dayanmaktadır."

#: src/ch11-04-hash.md:20
msgid "When to Use Them?"
msgstr "Onları ne zaman kullanmalıyım?"

#: src/ch11-04-hash.md:22
msgid ""
"Pedersen was the first hash function used on Starknet, and is still used to "
"compute the addresses of variables in storage (for example, `LegacyMap` uses "
"Pedersen to hash the keys of a storage mapping on Starknet). However, as "
"Poseidon is cheaper and faster than Pedersen when working with STARK proofs "
"system, it's now the recommended hash function to use in Cairo programs."
msgstr ""
"Pedersen, Starknet'te kullanılan ilk hash fonksiyonuydu ve depolamadaki "
"değişkenlerin adreslerini hesaplamak için hala kullanılır (örneğin, "
"LegacyMap, Starknet'te bir depolama haritasının anahtarlarını hash etmek "
"için Pedersen'i kullanır). Bununla birlikte, Poseidon, STARK ispat "
"sistemiyle çalışırken Pedersen'den daha ucuz ve daha hızlı olduğu için, "
"şimdi Kahire programlarında kullanılması önerilen hash işlevidir."

#: src/ch11-04-hash.md:26
msgid ""
"The core library makes it easy to work with hashes. The `Hash` trait is "
"implemented for all types that can be converted to `felt252`, including "
"`felt252` itself. For more complex types like structs, deriving `Hash` "
"allows them to be hashed easily using the hash function of your choice - "
"given that all of the struct's fields are themselves hashable. You cannot "
"derive the `Hash` trait on a struct that contains un-hashable values, such "
"as `Array<T>` or `Felt252Dict<T>`, even if `T` itself is hashable."
msgstr ""
"Çekirdek kitaplığı hash'lerle çalışmayı kolaylaştırır. Felt252'nin kendisi "
"de dahil olmak üzere Felt252'ye dönüştürülebilen tüm türler için Felt252 "
"özelliği uygulanır. Yapıtlar gibi daha karmaşık türler için, Hash'ı "
"türetmek, seçtiğiniz hash fonksiyonunu kullanarak kolayca haşhaşlanmalarını "
"sağlar - tüm yapıt alanlarının kendi kendine haslaşamayacağı göz önüne "
"alındığında."

#: src/ch11-04-hash.md:28
msgid ""
"The `Hash` trait is accompanied by the `HashStateTrait` and "
"`HashStateExTrait` that define the basic methods to work with hashes. They "
"allow you to initialize a hash state that will contain the temporary values "
"of the hash after each application of the hash function, update the hash "
"state and finalize it when the computation is completed. `HashStateTrait` "
"and `HashStateExTrait` are defined as follows:"
msgstr ""
"Hash özelliği, hash'lerle çalışmak için temel yöntemleri tanımlayan "
"HashStateTrait ve HashStateExTrait ile birlikte gelir. Hash fonksiyonunun "
"her uygulamasından sonra hash'in geçici değerlerini içerecek bir hash "
"durumunu başlatmanıza, hash durumunu güncellemenize ve hesaplama "
"tamamlandığında sonlandırmanıza izin verirler. HashStateTrait ve HashState "
"aşağıdaki gibidir:"

#: src/ch11-04-hash.md:31
msgid "/// A trait for hash state accumulators.\n"
msgstr "/// Hash state akümülatörleri için bir özellik.\n"

#: src/ch11-04-hash.md:36
msgid "/// Extension trait for hash state accumulators.\n"
msgstr "/// Hash state akümülatörleri için eklenti özelliği.\n"

#: src/ch11-04-hash.md:39 src/ch11-04-hash.md:45
msgid "/// Updates the hash state with the given value.\n"
msgstr "/// Verilen değerle hash durumunu günceller.\n"

#: src/ch11-04-hash.md:42
msgid "/// A trait for values that can be hashed.\n"
msgstr "/// Haşhaşlanabilen değerler için bir özellik.\n"

#: src/ch11-04-hash.md:50
msgid ""
"To use hashes in your code, you must first import the relevant traits and "
"functions. In the following example, we will demonstrate how to hash a "
"struct using both the Pedersen and Poseidon hash functions."
msgstr ""
"Kodunuzda hash'leri kullanmak için öncelikle ilgili özellikleri ve işlevleri "
"içe aktarmanız gerekir. Aşağıdaki örnekte, hem Pedersen hem de Poseidon hash "
"işlevlerini kullanarak bir yapıyı nasıl haşlayacağınızı göstereceğiz."

#: src/ch11-04-hash.md:52
msgid ""
"The first step is to initialize the hash with either `PoseidonTrait::new() -"
"> HashState` or `PedersenTrait::new(base: felt252) -> HashState` depending "
"on which hash function we want to work with. Then the hash state can be "
"updated with the `update(self: HashState, value: felt252) -> HashState` or "
"`update_with(self: S, value: T) -> S` functions as many times as required. "
"Then the function `finalize(self: HashState) -> felt252` is called on the "
"hash state and it returns the value of the hash as a `felt252`."
msgstr ""
"İlk adım, hash değerini PoseidonTrait::new()> HashState veya PedersenTrait::"
"new(base: felt252)> HashState ile birlikte çalışmak istediğimiz hash "
"fonksiyonuna bağlı olarak başlatmaktır. Daha sonra hash durumu, update(self: "
"HashState, value: feel252) ile güncellenebilir."

#: src/ch11-04-hash.md:74
msgid ""
"Pedersen is different from Poseidon, as it starts with a base state. This "
"base state must be of `felt252` type, which forces us to either hash the "
"struct with an arbitrary base state using the `update_with` method, or "
"serialize the struct into an array to loop through all of its fields and "
"hash its elements together."
msgstr ""
"Pedersen, bir temel durumla başladığı gibi Poseidon'dan farklıdır. Bu temel "
"durum,  felt252 tipinde olmalıdır, bu da update_with yöntemini kullanarak "
"struct'u keyfi bir temel durumla ya da struct'u tüm alanları arasında döngü "
"yapmak ve elementlerini birlikte haşlamak için bir diziye seri hale "
"getirmeye zorlar."

#: src/ch11-04-hash.md:76
msgid "Here is a short example of Pedersen hashing:"
msgstr "İşte Pedersen hashing'in kısa bir örneği:"

#: src/ch11-04-hash.md:93
msgid "// hash1 is the result of hashing a struct with a base state of 0\n"
msgstr "// hash1, bir yapıyı 0 baz durumuyla haşlamanın sonucudur.\n"

#: src/ch11-04-hash.md:105
msgid "// hash2 is the result of hashing only the fields of the struct\n"
msgstr "// hash2 sadece struct alanlarının hash edilmesinin sonucudur.\n"

#: src/ch11-04-hash.md:114
msgid "Advanced Hashing: Hashing Arrays with Poseidon"
msgstr "Gelişmiş Hashing: Poseidon ile Hashing Dizileri"

#: src/ch11-04-hash.md:116
msgid ""
"Let us look at an example of hashing a struct that contains a "
"`Span<felt252>`. To hash a `Span<felt252>` or a struct that contains a "
"`Span<felt252>` you can use the built-in function `poseidon_hash_span(mut "
"span: Span<felt252>) -> felt252`. Similarly, you can hash `Array<felt252>` "
"by calling `poseidon_hash_span` on its span."
msgstr ""
"Spanfelt252> içeren bir yapıyı ya da Spanfelt252> içeren bir yapıyı hash "
"etmek için poseidon_hash_span(mut span: Spanfelt252>) yerleşik işlevini "
"kullanabilirsiniz."

#: src/ch11-04-hash.md:119
msgid "First, let us import the following traits and function:"
msgstr "Öncelikle, aşağıdaki özellikleri ve işlevi içe aktaralım:"

#: src/ch11-04-hash.md:127
msgid ""
"Now we define the struct. As you might have noticed, we didn't derive the "
"`Hash` trait. If you attempt to derive the `Hash` trait for this struct, it "
"will result in an error because the structure contains a field that is not "
"hashable."
msgstr ""
"Şimdi yapıyı tanımlıyoruz. Fark etmiş olabileceğiniz gibi, Hash özelliğini "
"türetmedik. Bu yapı için Hash özelliğini türetmeye çalışırsanız, bir hataya "
"neden olur çünkü yapıda hashable olmayan bir alan bulunur."

#: src/ch11-04-hash.md:138
msgid ""
"In this example, we initialized a `HashState` (`hash`), updated it and then "
"called the function `finalize()` on the `HashState` to get the computed hash "
"`hash_felt252`. We used `poseidon_hash_span` on the `Span` of the "
"`Array<felt252>` to compute its hash."
msgstr ""
"Bu örnekte, bir HashState (hash) başlattık, güncelledik ve daha sonra "
"HashState üzerindeki finalize() fonksiyonunu, hash_felt252 hesaplanmış "
"hash'i almak için çağırdık. Arrayfelt252> dosyasının Span'inde "
"poseidon_hash_span kullandık."

#: src/ch11-05-macros.md:3
msgid ""
"The Cairo language has some plugins that allow developers to simplify their "
"code. They are called `inline_macros` and are a way of writing code that "
"generates other code."
msgstr ""
"Kahire dili, geliştiricilerin kodlarını basitleştirmelerine izin veren bazı "
"eklentilere sahiptir. Bunlara inline_macros denir ve başka kodlar oluşturan "
"bir kod yazma yoludur."

#: src/ch11-05-macros.md:5
msgid "`consteval_int!` Macro"
msgstr "consteval_int! Makro"

#: src/ch11-05-macros.md:7
msgid ""
"In some situations, a developer might need to declare a constant that is the "
"result of a computation of integers. To compute a constant expression and "
"use its result at compile time, it is required to use the `consteval_int!` "
"macro."
msgstr ""
"Bazı durumlarda, bir geliştiricinin tamsayıların hesaplanmasının sonucu olan "
"bir sabiti beyan etmesi gerekebilir. Sabit bir ifadeyi hesaplamak ve "
"sonuçlarını derleme zamanında kullanmak için consteval_int! makrosunu "
"kullanması gerekir."

#: src/ch11-05-macros.md:9
msgid "Here is an example of `consteval_int!`:"
msgstr "İşte consteval_int! örneği:"

#: src/ch11-05-macros.md:15
msgid "This will be interpreted as `const a: felt252 = 8;` by the compiler."
msgstr "Bu, derleyici tarafından const a: keçe252 = 8; olarak yorumlanacaktır."

#: src/ch11-05-macros.md:17
msgid "`selector!` Macro"
msgstr "selector! Makro"

#: src/ch11-05-macros.md:19
msgid ""
"See [Entry Point Selector](./ch15-02-contract-dispatchers-library-"
"dispatchers-and-system-calls.md#entry-point-selector)."
msgstr ""
"[Entry Point Selector](./ch15-02-contract-dispatchers-library-dispatchers-"
"and-system-calls.md#entry-point-selector] sayfasına bakın."

#: src/ch11-05-macros.md:21
msgid "`print!` and `println!` Macros"
msgstr "print! ve println! Makrolar"

#: src/ch11-05-macros.md:23
msgid "Please refer to the [Printing](./ch11-08-printing.md) page."
msgstr "Lütfen [Baskı](./ch11-08-printing.md) sayfasına bakın."

#: src/ch11-05-macros.md:27
msgid "Please refer to the [Arrays](./ch03-01-arrays.md) page."
msgstr "Lütfen [Arrays](./ch03-01-arrays.md) sayfasına bakın."

#: src/ch11-05-macros.md:31
msgid ""
"See [Unrecoverable Errors with panic](./ch09-01-unrecoverable-errors-with-"
"panic.html#panic-macro) page."
msgstr ""
"Bakınız [Panikle düzeltilemeyen hatalar](./ch09-01-unrecoverable-errors-with-"
"panic.html#panic-macro) sayfası."

#: src/ch11-05-macros.md:33
msgid "`assert!` and `assert_xx!` Macros"
msgstr "assert! ve assert_xx! Makrolar"

#: src/ch11-05-macros.md:35
msgid "See [How to Write Tests](./ch10-01-how-to-write-tests.md) page."
msgstr ""
"[Testler Nasıl Yazılır](./ch10-01-how-to-write-tests.md) sayfasına bakın."

#: src/ch11-05-macros.md:37
msgid "`format!` Macro"
msgstr "format! Makro"

#: src/ch11-05-macros.md:39
msgid "See [Printing](./ch11-08-printing.html#formatting) page."
msgstr "[Printing](./ch11-08-printing.html#formatting] sayfasına bakın."

#: src/ch11-05-macros.md:41
msgid "`write!` and `writeln!` Macros"
msgstr "write! ve writeln! Makrolar"

#: src/ch11-05-macros.md:43
msgid ""
"See [Printing](./ch11-08-printing.html#printing-custom-data-types) page."
msgstr ""
"[Printing](./ch11-08-printing.html#printing-custom-data-types] sayfasına "
"bakın."

#: src/ch11-05-macros.md:45
msgid "`get_dep_component!`, `get_dep_component_mut` and `component!` Macros"
msgstr "get_dep_component!, get_dep_component_mut ve component! Makrolar"

#: src/ch11-05-macros.md:47
msgid ""
"Please refer to the [Composability and Components](./ch16-02-00-"
"composability-and-components.md) chapter."
msgstr ""
"Lütfen [Komposability and Components](./ch16-02-00-composability-and-"
"components.md) bölümüne bakınız."

#: src/ch11-06-inlining-in-cairo.md:3
msgid ""
"Inlining is a common code optimization technique supported by most "
"compilers. It involves replacing a function call at the call site with the "
"actual code of the called function, eliminating the overhead associated with "
"the function call itself. This can improve performance by reducing the "
"number of instructions executed, but may increase the total size of the "
"program. When you're thinking about whether to inline a function, take into "
"account things like how big it is, what parameters it has, how often it gets "
"called, and how it might affect the size of your compiled code."
msgstr ""
"İnlining, çoğu derleyici tarafından desteklenen ortak bir kod optimizasyonu "
"tekniğidir. Çağrı sitesindeki bir fonksiyon çağrısını, çağrılan fonksiyonun "
"gerçek koduyla değiştirmeyi, fonksiyon çağrısının kendisiyle ilişkili yükü "
"ortadan kaldırmayı içerir. Bu, çalıştırılan talimatların sayısını azaltarak "
"performansı artırabilir, ancak programın toplam boyutunu artırabilir. Bir "
"işlevi satır içine alıp almamayı düşünürken, ne kadar büyük olduğunu, hangi "
"parametrelere sahip olduğunu, ne kadar sık adlandırılabileceğini ve ne kadar "
"sık adlandırılabileceğini göz önünde bulundurun."

#: src/ch11-06-inlining-in-cairo.md:5
msgid "The `inline` Attribute"
msgstr "inline Özniteliği"

#: src/ch11-06-inlining-in-cairo.md:7
msgid ""
"In Cairo, the `inline` attribute suggests whether or not the Sierra code "
"corresponding to the attributed function should be directly injected in the "
"caller function's context, rather than using a `function_call` libfunc to "
"execute that code."
msgstr ""
"Kahire'de, inline özniteliği, atfedilen işleve karşılık gelen Sierra "
"kodunun, bu kodu çalıştırmak için bir function_call libfunc kullanmak "
"yerine, arayanın işlevi bağlamında doğrudan enjekte edilip edilmemesi "
"gerektiğini önerir."

#: src/ch11-06-inlining-in-cairo.md:9
msgid "There are three variants of the `inline` attribute that one can use:"
msgstr "inline özniteliğinin kullanabileceği üç varyantı vardır:"

#: src/ch11-06-inlining-in-cairo.md:11
msgid "`#[inline]` suggests performing an inline expansion."
msgstr "#[inline] satır içi genişleme gerçekleştirmeyi önerir."

#: src/ch11-06-inlining-in-cairo.md:12
msgid ""
"`#[inline(always)]` suggests that an inline expansion should always be "
"performed."
msgstr ""
"#[inline(her zaman)] bir satır içi genişletmenin her zaman yapılması "
"gerektiğini önerir."

#: src/ch11-06-inlining-in-cairo.md:13
msgid ""
"`#[inline(never)]` suggests that an inline expansion should never be "
"performed."
msgstr ""
"#[inline(never)] satır içi genişlemenin asla yapılmaması gerektiğini öne "
"sürer."

#: src/ch11-06-inlining-in-cairo.md:15
msgid ""
"Note: the `inline` attribute in every form is a hint, with no requirements "
"on the language to place a copy of the attributed function in the caller. "
"This means that the attribute may be ignored by the compiler. In practice, "
"`#[inline(always)]` will cause inlining in all but the most exceptional "
"cases."
msgstr ""
"Not: Her formdaki inline özniteliği, dile atfedilen fonksiyonun bir "
"kopyasını arayan kişiye yerleştirmek için bir ipucu değildir. Bu, "
"özniteliğin derleyici tarafından göz ardı edilebileceği anlamına gelir. "
"Pratikte, #[inline(hep)] en istisnai durumlar dışında tümünde inlining'e "
"neden olacaktır."

#: src/ch11-06-inlining-in-cairo.md:17
msgid ""
"Many of the Cairo corelib functions are inlined. User-defined functions may "
"also be annotated with the `inline` attribute. Annoting functions with the "
"`#[inline(always)]` attribute reduces the total number of steps required "
"when calling these attributed functions. Indeed, injecting the Sierra code "
"at the caller site avoids the step-cost involved in calling functions and "
"obtaining their arguments."
msgstr ""
"Kahire corelib işlevlerinin çoğu satır içidir. Kullanıcı tanımlı "
"fonksiyonlar inline özniteliği ile de not edilebilir. #[inline(hep)] "
"özniteliği ile yapılan açıklamalar, bu atfedilen işlevleri çağırırken "
"gereken toplam adım sayısını azaltır. Gerçekten de, arayan siteye Sierra "
"kodunu enjekte etmek, fonksiyonları çağırmak ve argümanlarını elde etmek "
"için gerekli olan adım maliyetinden kaçınır."

#: src/ch11-06-inlining-in-cairo.md:19
msgid ""
"However, inlining can also lead to increased code size. Whenever a function "
"is inlined, the call site contains a copy of the function's Sierra code, "
"potentially leading to duplication of code across the compiled code."
msgstr ""
"Bununla birlikte, astarlama da kod boyutunun artmasına neden olabilir. Bir "
"işlev satır içi olduğunda, çağrı sitesi, fonksiyonun Sierra kodunun bir "
"kopyasını içerir ve potansiyel olarak derlenen kod boyunca kodun "
"çoğaltılmasına yol açar."

#: src/ch11-06-inlining-in-cairo.md:21
msgid ""
"Therefore, inlining should be applied with caution. Using `#[inline]` or "
"`#[inline(always)]` indiscriminately will lead to increased compile time. It "
"is particularly useful to inline small functions, ideally with many "
"arguments. This is because inlining large functions will increase the code "
"length of the program, and handling many arguments will increase the number "
"of steps to execute these functions."
msgstr ""
"Bu nedenle, astarlama dikkatli bir şekilde uygulanmalıdır. #[inline] veya "
"#[inline(hep)]'yi kullanmak, ayrım gözetmeksizin daha fazla derleme süresine "
"yol açacaktır. İdeal olarak birçok argümanla küçük fonksiyonları satır içine "
"almak özellikle yararlıdır. Bunun nedeni, büyük fonksiyonların "
"astarlanmasının programın kod uzunluğunu artıracağı ve birçok argümanın ele "
"alınmasının bu işlevleri yerine getirmek için gereken adımların sayısını "
"artıracağıdır."

#: src/ch11-06-inlining-in-cairo.md:23
msgid ""
"The more frequently a function is called, the more beneficial inlining "
"becomes in terms of performance. By doing so, the number of steps for the "
"execution will be lower, while the code length will not grow that much or "
"might even decrease in terms of total number of instructions."
msgstr ""
"Bir fonksiyon ne kadar sık çağrılırsa, performans açısından o kadar faydalı "
"astarlama olur. Bunu yaparak, yürütme için adım sayısı daha düşük olacak, "
"kod uzunluğu o kadar fazla artmayacak veya toplam talimat sayısı açısından "
"bile azalabilir."

#: src/ch11-06-inlining-in-cairo.md:25
msgid ""
"Inlining is often a tradeoff between number of steps and code length. Use "
"the `inline` attribute cautiously where it is appropriate."
msgstr ""
"İnlining genellikle basamak sayısı ve kod uzunluğu arasında bir takastır. "
"Uygun olduğu yerde inline özniteliğini dikkatli kullanın."

#: src/ch11-06-inlining-in-cairo.md:27
msgid "Inlining Example"
msgstr "Inlining Örnek"

#: src/ch11-06-inlining-in-cairo.md:29
msgid ""
"Let's introduce a short example to illustrate the mechanisms of inlining in "
"Cairo. Listing 11-3 shows a basic program allowing comparison between "
"inlined and non-inlined functions."
msgstr ""
"Kahire'de inlining mekanizmalarını örneklemek için kısa bir örnek verelim. "
"11-3'ü listelemek, inlined ve inlined olmayan fonksiyonlar arasında "
"karşılaştırma yapılmasına izin veren temel bir program göstermektedir."

#: src/ch11-06-inlining-in-cairo.md:47
msgid ""
"<span class=\"caption\">Listing 11-3: A small Cairo program that adds the "
"return value of 2 functions, with one of them being inlined</span>"
msgstr ""
"span class=\"caption\">Liste 11-3: Biri satır içi olmak üzere 2 fonksiyonun "
"dönüş değerini ekleyen küçük bir Kahire programı/span>"

#: src/ch11-06-inlining-in-cairo.md:49
msgid ""
"Let's take a look at the corresponding Sierra code to see how inlining works "
"under the hood:"
msgstr ""
"İnlining'in kaputun altında nasıl çalıştığını görmek için ilgili Sierra "
"koduna bir göz atalım:"

#: src/ch11-06-inlining-in-cairo.md:52 src/ch11-06-inlining-in-cairo.md:215
msgid "// type declarations\n"
msgstr "// tip beyanlar\n"

#: src/ch11-06-inlining-in-cairo.md:54 src/ch11-06-inlining-in-cairo.md:218
msgid "// libfunc declarations\n"
msgstr "// libfunc beyanları\n"

#: src/ch11-06-inlining-in-cairo.md:61 src/ch11-06-inlining-in-cairo.md:226
msgid "// statements\n"
msgstr "// ifadeler\n"

#: src/ch11-06-inlining-in-cairo.md:75 src/ch11-06-inlining-in-cairo.md:238
msgid "// funcs\n"
msgstr "// funcs\n"

#: src/ch11-06-inlining-in-cairo.md:82
msgid "The Sierra file is structured in three parts:"
msgstr "Sierra dosyası üç bölüm halinde yapılandırılmıştır:"

#: src/ch11-06-inlining-in-cairo.md:84
msgid "Type and libfunc declarations."
msgstr "Tür ve libfunc beyanları."

#: src/ch11-06-inlining-in-cairo.md:85
msgid "Statements that constitute the program."
msgstr "Programı oluşturan ifadeler."

#: src/ch11-06-inlining-in-cairo.md:86
msgid "Declaration of the functions of the program."
msgstr "Programın fonksiyonlarının deklarasyonu."

#: src/ch11-06-inlining-in-cairo.md:88
msgid ""
"The Sierra code statements always match the order of function declarations "
"in the Cairo program. Indeed, the declaration of the functions of the "
"program tells us that:"
msgstr ""
"Sierra kod ifadeleri her zaman Kahire programındaki işlev beyanlarının "
"sırasına uyuyor. Gerçekten de, programın işlevlerinin beyanı bize şunları "
"söylüyor:"

#: src/ch11-06-inlining-in-cairo.md:90
msgid "`main` function starts at line 0, and returns a `felt252` on line 5."
msgstr ""
"main fonksiyonu 0 satırından başlar ve 5 satırında bir felt252 döndürür."

#: src/ch11-06-inlining-in-cairo.md:91
msgid "`inlined` function starts at line 6, and returns a `felt252` on line 8."
msgstr ""
"inlined işlevi 6. satırdan başlar ve 8. satırda felt252 değerini döndürür."

#: src/ch11-06-inlining-in-cairo.md:92
msgid ""
"`not_inlined` function starts at line 9, and returns a `felt252` on line 11."
msgstr ""
"not_inlined işlevi 9. satırdan başlar ve 11. satırda bir felt252 döndürür."

#: src/ch11-06-inlining-in-cairo.md:94
msgid ""
"All statements corresponding to the `main` function are located between "
"lines 0 and 5:"
msgstr ""
"main fonksiyonuna karşılık gelen tüm ifadeler 0 ve 5 satırları arasında "
"bulunur."

#: src/ch11-06-inlining-in-cairo.md:105
msgid ""
"The `function_call` libfunc is called on line 0 to execute the `not_inlined` "
"function. This will execute the code from lines 9 to 10 and store the return "
"value in the variable with id `0`."
msgstr ""
"func_call libfunc, not_inlined fonksiyonunu çalıştırmak için 0 satırına "
"çağrılır. Bu, kodu 9'dan 10'a kadar olan satırlardan çalıştıracak ve id 0 "
"ile değişkendeki dönüş değerini depolayacaktır."

#: src/ch11-06-inlining-in-cairo.md:112
msgid ""
"This code uses a single data type, `felt252`. It uses two library functions -"
" `felt_const<2>`, which returns the constant `felt252` 2, "
"and `store_temp<felt252>`, which pushes a constant value to memory. The "
"first line calls the `felt_const<2>` libfunc to create a variable with "
"id `0`. Then, the second line pushes this variable to memory for later use."
msgstr ""
"Bu kod tek bir veri türü kullanır, felt252. felt252 2 sabitini döndüren iki "
"kütüphane işlevi kullanır ve store_tempfelt252> sabit bir değeri hafızaya "
"iter. İlk satır daha sonra felt_const2> libfunc'u id 0 ile bir değişken "
"oluşturmak için çağırır."

#: src/ch11-06-inlining-in-cairo.md:114
msgid ""
"After that, Sierra statements from line 1 to 2 are the actual body of the "
"`inlined` function:"
msgstr ""
"Bundan sonra, 1 ile 2 arasındaki Sierra ifadeleri, inlined fonksiyonunun "
"gerçek gövdesidir:"

#: src/ch11-06-inlining-in-cairo.md:121
msgid ""
"The only difference is that the inlined code will store the `felt252_const` "
"value in a variable with id `1`, because `[0]` refers to a variable "
"previously assigned:"
msgstr ""
"Tek fark, satır içi kodun felt252_const değerini 1 id ile bir değişkende "
"saklamasıdır, çünkü [0] daha önce atanmış bir değişkeni ifade eder:"

#: src/ch11-06-inlining-in-cairo.md:128
msgid ""
"Note: in both cases (inlined or not), the `return` instruction of the "
"function being called is not executed, as this would lead to prematurely end "
"the execution of the `main` function. Instead, return values of `inlined` "
"and `not_inlined` will be added and the result will be returned."
msgstr ""
"Not: Her iki durumda da (inlined olsun ya da olmasın), çağrılan fonksiyonun "
"return talimatı çalıştırılmaz, çünkü bu main fonksiyonunun yürütülmesini "
"erken sona erdirir. Bunun yerine, inlined ve not_inlined geri dönüş "
"değerleri eklenecek ve sonuç iade edilecektir."

#: src/ch11-06-inlining-in-cairo.md:130
msgid ""
"Lines 3 to 5 contain the Sierra statements that will add the values "
"contained in variables with ids `0` and `1`, store the result in memory and "
"return it:"
msgstr ""
"3 ila 5 arasındaki satırlar, 0 ve 1 ile değişkenlerde bulunan değerleri "
"ekleyecek Sierra ifadelerini içerir, sonucu bellekte saklar ve döndürür:"

#: src/ch11-06-inlining-in-cairo.md:138
msgid ""
"Now, let's take a look at the Casm code corresponding to this program to "
"really understand the benefits of inlining."
msgstr ""
"Şimdi, bu programa karşılık gelen Casm koduna bir göz atalım, gerçekten "
"astarlamanın faydalarını anlamak için."

#: src/ch11-06-inlining-in-cairo.md:140
msgid "Casm Code Explanations"
msgstr "Casm Kodu Açıklamaları"

#: src/ch11-06-inlining-in-cairo.md:142
msgid "Here is the Casm code for our previous program example:"
msgstr "İşte önceki program örneğimiz için Casm kodu:"

#: src/ch11-06-inlining-in-cairo.md:158
msgid ""
"Don't hesitate to use [cairovm.codes](https://cairovm.codes/) playground to "
"follow along and see all the execution trace."
msgstr ""
"[cairovm.codes](https://cairovm.codes/) oyun alanını takip etmek ve tüm "
"yürütme izini görmek için kullanmaktan çekinmeyin."

#: src/ch11-06-inlining-in-cairo.md:160
msgid ""
"Each instruction and each argument for any instruction increment the Program "
"Counter (known as PC) by 1. This means that `ret` on line 2 is actually the "
"instruction at `PC = 3`, as the argument `3` corresponds to `PC = 2`."
msgstr ""
"Her talimat ve herhangi bir talimat için her argüman, Program Sayacını (PC "
"olarak bilinir) 1'e yükseltir. Bu,  3  argümanının  PC = 2 'ye karşılık "
"gelmesinden dolayı,  2 satırdaki ret'nin aslında PC = 3 'deki talimat olduğu "
"anlamına gelir."

#: src/ch11-06-inlining-in-cairo.md:162
msgid ""
"The `call` and `ret` instructions allow implementation of a function stack:"
msgstr ""
"call ve ret talimatları bir fonksiyon yığınının uygulanmasına izin verir:"

#: src/ch11-06-inlining-in-cairo.md:164
msgid ""
"`call` instruction acts like a jump instruction, updating the PC to a given "
"value, whether relatively to the current value using `rel` or absolutely "
"using `abs`."
msgstr ""
"call talimatı atlama talimatı gibi davranır, PC'yi belirli bir değere "
"günceller, ister rel kullanarak mevcut değere göre ister abs kullanarak."

#: src/ch11-06-inlining-in-cairo.md:165
msgid ""
"`ret` instruction jumps back right after the `call` instruction and "
"continues the execution of the code."
msgstr ""
"ret talimatı, call talimatından hemen sonra geri atlar ve kodun "
"yürütülmesine devam eder."

#: src/ch11-06-inlining-in-cairo.md:167
msgid ""
"We can now decompose how these instructions are executed to understand what "
"this code does:"
msgstr ""
"Şimdi bu kodun ne yaptığını anlamak için bu talimatların nasıl yürütüldüğünü "
"ayrıştırabiliriz:"

#: src/ch11-06-inlining-in-cairo.md:169
msgid ""
"`call rel 3`: this instruction increments the PC by 3 and executes the "
"instruction at this location, which is `call rel 9` at `PC = 4`."
msgstr ""
"Call rel 3: Bu talimat PC'yi 3'e yükseltir ve PC = 4'de Call rel 9 olan "
"talimatları bu konumda yürütür."

#: src/ch11-06-inlining-in-cairo.md:170
msgid ""
"`call rel 9` increments the PC by 9 and executes the instruction at `PC = "
"13`, which is actually line 9."
msgstr ""
"call rel 9, PC'yi 9 oranında artırır ve talimatı PC = 13'de yürütür, bu da "
"aslında 9. satırdır."

#: src/ch11-06-inlining-in-cairo.md:171
msgid ""
"`[ap + 0] = 2, ap++`: `ap` stands for Allocation Pointer, which points to "
"the first memory cell that has not been used by the program so far. This "
"means we store the value `2` in the next free memory cell indicated by the "
"current value of `ap`, after which we increment `ap` by 1. Then, we go to "
"the next line which is `ret`."
msgstr ""
"[ap + 0] = 2, ap++: ap, şimdiye kadar program tarafından kullanılmayan ilk "
"bellek hücresine işaret eden Allocation Pointer'ı ifade eder. Bu, ap'nin "
"mevcut değeri ile belirtilen bir sonraki ücretsiz bellek hücresinde ap "
"değerini sakladığımız anlamına gelir, ardından ap'yi 1 ile arttırırız. "
"Sonra, ret olan bir sonraki satıra geçeriz."

#: src/ch11-06-inlining-in-cairo.md:172
msgid "`ret`: jumps back to the line after `call rel 9`, so we go to line 4."
msgstr ""
"ret: call rel 9'dan sonra çizgiye geri atlar, böylece 4. çizgiye geçeriz."

#: src/ch11-06-inlining-in-cairo.md:173
msgid ""
"`[ap + 0] = 1, ap++` : we store the value `1` in `[ap]` and we apply `ap++` "
"so that `[ap - 1] = 1`. This means we now have `[ap-1] = 1, [ap-2] = 2` and "
"we go to the next line."
msgstr ""
"[ap + 0] = 1, ap++ : 1 değerini [ap] içinde saklarız ve ap++ uygulamasını "
"uygularız, böylece [ap - 1] = 1 olur. Bu, şimdi [ap-1] = 1, [ap-2] = 2 "
"değerine sahip olduğumuz ve bir sonraki satıra gittiğimiz anlamına gelir."

#: src/ch11-06-inlining-in-cairo.md:174
msgid ""
"`[ap + 0] = [ap + -1] + [ap + -2], ap++`: we sum the values `1` and `2` and "
"store the result in `[ap]`, and we apply `ap++` so the result is `[ap-1] = "
"3, [ap-2] = 1, [ap-3]=2`."
msgstr ""
"[ap + 0] = [ap + -1] + [ap + -2], ap++: 1 ve 2 değerlerini toplamıyoruz ve "
"sonucu [ap] olarak saklıyoruz ve ap++ uygulamasını uyguluyoruz, böylece "
"sonuç [ap-1] = 3, [ap-2] = 1, [ap-3] = 2."

#: src/ch11-06-inlining-in-cairo.md:175
msgid "`ret`: jumps back to the line after `call rel 3`, so we go to line 2."
msgstr ""
"ret: call rel 3'den sonra çizgiye geri atlar, bu yüzden 2. çizgiye geçeriz."

#: src/ch11-06-inlining-in-cairo.md:176
msgid ""
"`ret`: last instruction executed as there is no more `call` instruction "
"where to jump right after. This is the actual return instruction of the "
"Cairo `main` function."
msgstr ""
"ret: artık call talimatı olmadığı için gerçekleştirilen son talimat. Bu, "
"Kahire main fonksiyonunun gerçek dönüş talimatıdır."

#: src/ch11-06-inlining-in-cairo.md:178
msgid "To summarize:"
msgstr "Özetlemek gerekirse:"

#: src/ch11-06-inlining-in-cairo.md:180
msgid ""
"`call rel 3` corresponds to the `main` function, which is obviously not "
"inlined."
msgstr "call rel 3, açıkça satır içi olmayan main işlevine karşılık gelir."

#: src/ch11-06-inlining-in-cairo.md:181
msgid ""
"`call rel 9` triggers the call the `not_inlined` function, which returns `2` "
"and stores it at the final location `[ap-3]`."
msgstr ""
"call rel 9, 2 döndüren ve [ap-3] son konumda depolayan not_inlined "
"fonksiyonunun çağrısını tetikler."

#: src/ch11-06-inlining-in-cairo.md:182
msgid ""
"The line 4 is the inlined code of the `inlined` function, which returns `1` "
"and stores it at the final location `[ap-2]`. We clearly see that there is "
"no `call` instruction in this case, because the body of the function is "
"inserted and directly executed."
msgstr ""
"4. satır, 1 döndüren ve [ap-2] son konumda depolayan inlined fonksiyonunun "
"satır içi kodudur. Bu durumda call talimatının olmadığını açıkça görüyoruz, "
"çünkü fonksiyonun gövdesi takılı ve doğrudan çalıştırılıyor."

#: src/ch11-06-inlining-in-cairo.md:183
msgid ""
"After that, the sum is computed and we ultimately go back to the line 2 "
"which contains the final `ret` instruction that returns the sum, "
"corresponding to the return value of the `main` function."
msgstr ""
"Bundan sonra, toplam hesaplanır ve sonuçta main fonksiyonunun dönüş değerine "
"karşılık gelen toplamı döndüren son ret talimatını içeren satır 2'ye geri "
"döneriz."

#: src/ch11-06-inlining-in-cairo.md:185
msgid ""
"It is interesting to note that in both Sierra code and Casm code, the "
"`not_inlined` function will be called and executed before the body of the "
"`inlined` function, even though the Cairo program executes `inlined() + "
"not_inlined()`."
msgstr ""
"Hem Sierra kodunda hem de Casm kodunda, Kahire programı inlined() + "
"not_inlined() çalıştırsa bile, not_inlined işlevinin inlined işlevinin "
"gövdesinden önce çağrılacağını ve çalıştırılacağını belirtmek ilginçtir."

#: src/ch11-06-inlining-in-cairo.md:187
msgid ""
"The Casm code of our program clearly shows that there is a function call for "
"the `not_inlined` function, while the `inlined` function is correctly "
"inlined."
msgstr ""
"Programımızın Casm kodu, not_inlined işlevi için bir işlev çağrısı olduğunu "
"açıkça gösterirken, inlined işlevi doğru sıralanmıştır."

#: src/ch11-06-inlining-in-cairo.md:189
msgid "Additional Optimizations"
msgstr "Ek Optimizasyonlar"

#: src/ch11-06-inlining-in-cairo.md:191
msgid ""
"Let's study another program that shows other benefits that inlining may "
"sometimes provide. Listing 11-4 shows a Cairo program that calls 2 functions "
"and doesn't return anything:"
msgstr ""
"İnlining'in bazen sağlayabileceği diğer faydaları gösteren başka bir "
"programı inceleyelim. 11-4'ü listelemek, 2 işlevi çağıran ve hiçbir şey "
"döndürmeyen bir Kahire programını gösterir:"

#: src/ch11-06-inlining-in-cairo.md:210
msgid ""
"<span class=\"caption\">Listing 11-4: A small Cairo program that calls "
"`inlined` and `not_inlined` and doesn't return any value.</span>"
msgstr ""
"span class=\"caption\">Liste 11-4: inlined ve not_inlined olarak "
"adlandırılan ve herhangi bir değer döndürmeyen küçük bir Kahire programı./"
"span>"

#: src/ch11-06-inlining-in-cairo.md:212
msgid "Here is the corresponding Sierra code:"
msgstr "İşte buna karşılık gelen Sierra kodu:"

#: src/ch11-06-inlining-in-cairo.md:245
msgid ""
"In this specific case, we can observe that the compiler has applied "
"additional optimizations to the `main` function of our code : the code of "
"the `inlined` function, which is annotated with the `#[inline(always)]` "
"attribute, is actually not copied in the `main` function. Instead, the "
"`main` function starts with the `function_call` libfunc to call the "
"`not_inlined` function, entirely omitting the code of the `inlined` function."
msgstr ""
"Bu özel durumda, derleyicinin kodumuzun main fonksiyonuna ek optimizasyonlar "
"uyguladığını gözlemleyebiliriz: #[inline(hep)] özniteliği ile belirtilen "
"inline işlevinin kodu, aslında main işlevinde kopyalanmaz. Bunun yerine, "
"main işlevi, main işlevini çağırmak için function_callfunc ile başlar."

#: src/ch11-06-inlining-in-cairo.md:247
msgid ""
"Because `inlined` return value is never used, the compiler optimizes the "
"`main` function by skipping the `inlined` function code. This will actually "
"reduce the code length while reducing the number of steps required to "
"execute `main`."
msgstr ""
"inlined dönüş değeri asla kullanılmadığı için, derleyici inlined fonksiyon "
"kodunu atlayarak main işlevini optimize eder. Bu, main çalıştırmak için "
"gereken adımların sayısını azaltırken aslında kod uzunluğunu azaltacaktır."

#: src/ch11-06-inlining-in-cairo.md:249
msgid ""
"In contrast, line 0 uses the `function_call` libfunc to execute the "
"`not_inlined` function normally. This means that all the code from lines 7 "
"to 8 will be executed:"
msgstr ""
"Buna karşılık, 0 satırı not_inlined işlevini normal olarak yürütmek için "
"func_call libfunc kullanır. Bu, 7 ila 8 satırları arasındaki tüm kodun "
"çalıştırılacağı anlamına gelir:"

#: src/ch11-06-inlining-in-cairo.md:256
msgid ""
"This value stored in the variable with id `0` is then dropped on line 1, as "
"it is not used in the `main` function:"
msgstr ""
"id 0 ile değişkende depolanan bu değer daha sonra main işlevinde "
"kullanılmadığı için 1 satırına bırakılır:"

#: src/ch11-06-inlining-in-cairo.md:262
msgid ""
"Finally, as the `main` function doesn't return any value, a variable of unit "
"type `()` is created and returned:"
msgstr ""
"Son olarak, main işlevi herhangi bir değer döndürmediği için, () birim "
"tipinin bir değişkeni oluşturulur ve döndürülür:"

#: src/ch11-06-inlining-in-cairo.md:271
msgid ""
"Inlining is a compiler optimization technique that can be very useful in "
"various situations. Inlining a function allows to get rid of the overhead of "
"calling a function with the `function_call` libfunc by injecting the Sierra "
"code directly in the caller function's context, while potentially optimizing "
"the Sierra code executed to reduce the number of steps. If used effectively, "
"inlining can even reduce code length as shown in the previous example."
msgstr ""
"İnlining, çeşitli durumlarda çok yararlı olabilecek bir derleyici "
"optimizasyon tekniğidir. Bir fonksiyonun inlining edilmesi, Sierra kodunu "
"doğrudan arayan fonksiyonun bağlamına enjekte ederek function_call libfunc "
"ile bir fonksiyonu çağırmanın yükünden kurtulmayı sağlarken, potansiyel "
"olarak adımların sayısını azaltmak için çalıştırılan Sierra kodunu optimize "
"eder. Etkili kullanılırsa, inlining önceki örnekte gösterildiği gibi kod "
"uzunluğunu bile azaltabilir."

#: src/ch11-06-inlining-in-cairo.md:273
msgid ""
"Nevertheless, applying the `inline` attribute to a function with a lot of "
"code and few parameters might result in an increased code size, especially "
"if the inlined function is used many times in the codebase. Use inlining "
"only where it makes sense, and be aware that the compiler handles inlining "
"by default. Therefore, manually applying inlining is not recommended in most "
"situations, but can help improve and fine-tune your code's behavior."
msgstr ""
"Yine de, inline özniteliğini çok fazla kod ve az parametre içeren bir "
"fonksiyona uygulamak, özellikle satır içi fonksiyon kod tabanında birçok kez "
"kullanılıyorsa, kod boyutunun artmasına neden olabilir. Sadece mantıklı "
"olduğu yerde satırlama kullanın ve derleyicinin varsayılan olarak satırlama "
"işlemini yerine getirdiğini unutmayın. Bu nedenle, satırlamanın uygulanması "
"çoğu durumda önerilmez, ancak kodunuzun davranışını iyileştirmeye ve ince "
"ayar yapmaya yardımcı olabilir."

#: src/ch11-08-printing.md:3
msgid ""
"When writing a program, it is quite common to print some data to the "
"console, either for the normal process of the program or for debugging "
"purpose. In this chapter, we describe the options you have to print simple "
"and complex data types."
msgstr ""
"Bir program yazarken, programın normal işlemi için veya hata ayıklama amacı "
"için konsola bazı verileri yazdırmak oldukça yaygındır. Bu bölümde, basit ve "
"karmaşık veri türlerini yazdırmanız gereken seçenekleri açıklıyoruz."

#: src/ch11-08-printing.md:5
msgid "Printing Standard Data Types"
msgstr "Standart Veri Tiplerini Yazdırma"

#: src/ch11-08-printing.md:7
msgid "Cairo provides two macros to print standard data types:"
msgstr "Kahire standart veri türlerini yazdırmak için iki makro sağlar:"

#: src/ch11-08-printing.md:9
msgid "`println!` which prints on a new line"
msgstr "println! yeni bir satırda yazdırır"

#: src/ch11-08-printing.md:10
msgid "`print!` with inline printing"
msgstr "print! satır içi baskı ile"

#: src/ch11-08-printing.md:12
msgid ""
"Both take a `ByteArray` string as first parameter (see [Data Types](./"
"ch02-02-data-types.md#byte-array-strings)), which can be a simple string to "
"print a message or a string with placeholders to format the way values are "
"printed."
msgstr ""
"Her ikisi de ilk parametre olarak bir ByteArray dizgesi alır (bakınız [Veri "
"Türleri](./ch02-02-data-types.md#byte-array-strings)), bu da bir iletiyi "
"yazdırmak için basit bir dizge veya değerlerin basılma şeklini "
"biçimlendirmek için yer tutuculu bir dizge olabilir."

#: src/ch11-08-printing.md:14
msgid "There are two ways to use these placeholders and both can be mixed:"
msgstr ""
"Bu yer tutucuları kullanmanın iki yolu vardır ve her ikisi de "
"karıştırılabilir:"

#: src/ch11-08-printing.md:16
msgid ""
"empty curly brackets `{}` are replaced by values given as parameters to the "
"`print!` macro, in the same order."
msgstr ""
"boş kıvırcık parantez, aynı sırayla print! makrosuna parametreler olarak "
"verilen değerlerle değiştirilir."

#: src/ch11-08-printing.md:17
msgid ""
"curly brackets with variable names are directly replaced by the variable "
"value."
msgstr ""
"Değişken isimleri olan kıvırcık parantezler, değişken değeri ile doğrudan "
"değiştirilir."

#: src/ch11-08-printing.md:19
msgid "Here are some examples:"
msgstr "İşte bazı örnekler:"

#: src/ch11-08-printing.md:27
msgid "\"Hello world!\""
msgstr "\"Merhaba dünya!\""

#: src/ch11-08-printing.md:28
msgid "\"{} {} {}\""
msgstr "\"  \""

#: src/ch11-08-printing.md:28
msgid "// 10 20 30\n"
msgstr "// 10 20 30\n"

#: src/ch11-08-printing.md:29
msgid "\"{c} {a} {}\""
msgstr "\"c a \""

#: src/ch11-08-printing.md:29
msgid "// 30 10 20\n"
msgstr "// 30 10 20\n"

#: src/ch11-08-printing.md:33
msgid ""
"`print!` and `println!` macros use the `Display` trait under the hood, and "
"are therefore used to print the value of types that implement it. This is "
"the case for basic data types, but not for more complex ones. If you try to "
"print complex data type values with these macros, e.g. for debugging "
"purposes, you will get an error. In that case, you can either [manually "
"implement](./ch11-08-printing.md#printing-custom-data-types) the `Display` "
"trait for your type or use the `Debug` trait (see [below](./ch11-08-printing."
"md#print-debug-traces))."
msgstr ""
"print! ve println! makroları başlık altındaki Display özelliğini kullanır ve "
"bu nedenle onu uygulayan türlerin değerini yazdırmak için kullanılır. Bu, "
"temel veri türleri için geçerlidir, ancak daha karmaşık olanlar için "
"değildir. Karmaşık veri türü değerlerini bu makrolarla yazdırmaya "
"çalışırsanız, örneğin hata ayıklama amacıyla bir hata alırsınız. Bu durumda, "
"[manly]"

#: src/ch11-08-printing.md:39
msgid "Formatting"
msgstr "Biçimlendirme"

#: src/ch11-08-printing.md:41
msgid ""
"Cairo also provides a useful macro to handle string formatting: `format!`. "
"This macro works like `println!`, but instead of printing the output to the "
"screen, it returns a `ByteArray` with the contents. In the following "
"example, we perform string concatenation using either the `+` operator or "
"the `format!` macro. The version of the code using `format!` is much easier "
"to read, and the code generated by the `format!` macro uses snapshots, so "
"that this call doesn’t take ownership of any of its parameters."
msgstr ""
"Kahire ayrıca dize biçimlendirmesini işlemek için kullanışlı bir makro "
"sağlar: format!. Bu makro println! gibi çalışır, ancak çıktıyı ekrana "
"yazdırmak yerine, içeriğiyle birlikte bir ByteArray döndürür. Aşağıdaki "
"örnekte, + operatörünü veya format! makrosunu kullanarak dize birleştirme "
"işlemini gerçekleştiriyoruz. format! kodunun herhangi bir sürümünün okunması "
"çok daha kolaydır, ve bu kodu kullanır."

#: src/ch11-08-printing.md:46 src/ch11-08-printing.md:52
msgid "\"tic\""
msgstr "\"tic\""

#: src/ch11-08-printing.md:47 src/ch11-08-printing.md:53
msgid "\"tac\""
msgstr "\"tac\""

#: src/ch11-08-printing.md:48 src/ch11-08-printing.md:54
msgid "\"toe\""
msgstr "\"toe\""

#: src/ch11-08-printing.md:49
msgid "\"-\""
msgstr "\"-\""

#: src/ch11-08-printing.md:50
msgid ""
"// using + operator consumes the strings, so they can't be used again!\n"
msgstr ""
"// + operatörü kullanarak dizeleri tüketir, böylece tekrar kullanılamazlar!\n"

#: src/ch11-08-printing.md:55
msgid "\"{s1}-{s2}-{s3}\""
msgstr "\"s1-s2-s3\""

#: src/ch11-08-printing.md:55
msgid ""
"// s1, s2, s3 are not consumed by format!\n"
"    // or\n"
msgstr "// s1, s2, s3 formata göre tüketilmez! // veya\n"

#: src/ch11-08-printing.md:57
msgid "\"{}-{}-{}\""
msgstr "\"--\""

#: src/ch11-08-printing.md:63
msgid "Printing Custom Data Types"
msgstr "Özel Veri Türlerinin Yazdırılması"

#: src/ch11-08-printing.md:65
msgid ""
"As previously explained, if you try to print the value of a custom data type "
"with `print!` or `println!` macros, you'll get an error telling you that the "
"`Display` trait is not implemented for your custom type:"
msgstr ""
"Daha önce açıklandığı gibi, özel bir veri türünün değerini print! veya "
"println! makroları ile yazdırmaya çalışırsanız, özel türünüz için Display "
"özelliğinin uygulanmadığını söyleyen bir hata alırsınız:"

#: src/ch11-08-printing.md:71
msgid ""
"The `println!` macro can do many kinds of formatting, and by default, the "
"curly brackets tell `println!` to use formatting known as `Display` - output "
"intended for direct end user consumption. The primitive types we’ve seen so "
"far implement `Display` by default because there’s only one way you’d want "
"to show a `1` or any other primitive type to a user. But with structs, the "
"way `println!` should format the output is less clear because there are more "
"display possibilities: Do we want commas or not? Do we want to print the "
"curly brackets? Should all the fields be shown? Due to this ambiguity, Cairo "
"doesn’t try to guess what we want, and structs don’t have a provided "
"implementation of `Display` to use with `println!` and the `{}` placeholder."
msgstr ""
"println! makrosu birçok çeşit biçimlendirme yapabilir ve varsayılan olarak, "
"kıvırcık parantez println! Display olarak bilinen biçimlendirmeyi kullanmak "
"için kullanılır! Doğrudan son kullanıcı tüketimi için tasarlanmış çıktı. "
"Şimdiye kadar gördüğümüz ilkel tipler varsayılan olarak Display uygulamasını "
"istemiyor, çünkü bir kullanıcıya 1 veya başka bir ilkel tip göstermek "
"istiyorsunuz."

#: src/ch11-08-printing.md:73
msgid "Here is the `Display` trait to implement:"
msgstr "İşte uygulamak için Display özelliği:"

#: src/ch11-08-printing.md:81
msgid ""
"The second parameter `f` is of type `Formatter`, which is just a struct "
"containing a `ByteArray`, representing the pending result of formatting:"
msgstr ""
"İkinci parametre f, biçimlendirmenin bekleyen sonucunu temsil eden bir "
"ByteArray içeren bir yapı olan Formatter tipidir:"

#: src/ch11-08-printing.md:86
msgid "/// The pending result of formatting.\n"
msgstr "/// Biçimlendirmenin bekleyen sonucu.\n"

#: src/ch11-08-printing.md:91
msgid ""
"Knowing this, here is an example of how to implement the `Display` trait for "
"a custom `Point` struct:"
msgstr ""
"Bunu bilerek, özel bir Point yapısı için Display özelliğinin nasıl "
"uygulanacağına bir örnek:"

#: src/ch11-08-printing.md:104
msgid "\"Point ({}, {})\""
msgstr "\"Point (, )\""

#: src/ch11-08-printing.md:112 src/ch11-08-printing.md:156
msgid "// Point: (1, 3)\n"
msgstr "// Nokta: (1, 3)\n"

#: src/ch11-08-printing.md:116
msgid ""
"Cairo also provides the `write!` and `writeln!` macros to write formatted "
"strings in a formatter. Here is a short example using `write!` macro to "
"concatenate multiple strings on the same line and then print the result:"
msgstr ""
"Kahire ayrıca biçimlendiricide biçimlendirilmiş dizeler yazmak için write! "
"ve writeln! makrolarını da sağlar. write! makrosunu kullanarak aynı satırda "
"birden fazla dizeyi birleştirmek ve daha sonra sonucu yazdırmak için kısa "
"bir örnek:"

#: src/ch11-08-printing.md:126
msgid "\"hello\""
msgstr "\"merhaba\""

#: src/ch11-08-printing.md:127
msgid "\"world\""
msgstr "\"Dünya\""

#: src/ch11-08-printing.md:128
msgid "\" {a} {b}\""
msgstr "\" a b\""

#: src/ch11-08-printing.md:130
msgid "// helloworld 10 20\n"
msgstr "// aloworld 10 20\n"

#: src/ch11-08-printing.md:134
msgid ""
"It is also possible to implement the `Display` trait for the `Point` struct "
"using these macros, as shown here:"
msgstr ""
"Burada gösterildiği gibi, bu makroları kullanarak Point yapısı için Display "
"özelliğini uygulamak da mümkündür:"

#: src/ch11-08-printing.md:150
msgid "\"Point ({x}, {y})\""
msgstr "\"Point (x, y)\""

#: src/ch11-08-printing.md:160
msgid ""
"Printing complex data types this way might not be ideal as it requires "
"additional steps to use the `print!` and `println!` macros. If you need to "
"print complex data types, especially when debugging, use the `Debug` trait "
"described below instead."
msgstr ""
"Karmaşık veri türlerini bu şekilde yazdırmak, print! ve println! makrolarını "
"kullanmak için ek adımlar gerektirdiğinden ideal olmayabilir. Karmaşık veri "
"türlerini yazdırmanız gerekiyorsa, özellikle hata ayıklama sırasında, "
"aşağıda açıklanan Debug özelliğini kullanın."

#: src/ch11-08-printing.md:162
msgid "Print Debug Traces"
msgstr "Hata Ayıklama İzlerini Yazdır"

#: src/ch11-08-printing.md:164
msgid ""
"Cairo provides the `Debug` trait, which can be derived to print the value of "
"variables when debugging. Simply add `:?` within the curly brackets `{}` "
"placeholders in a `print!` or `println!` macro string."
msgstr ""
"Kahire, hata ayıklama sırasında değişkenlerin değerini yazdırmak için "
"türetilebilen Debug özelliğini sağlar. Sadece kıvırcık parantez içinde  yer "
"tutucuları bir print! veya println! makro dizisi ekleyin."

#: src/ch11-08-printing.md:166
msgid ""
"This trait is very useful and is implemented by default for basic data "
"types. It can also be simply derived for complex data types using the "
"`#[derive(Debug)]` attribute, as long as all types they contain implement "
"it. This eliminates the need to manually implement extra code to print "
"complex data types."
msgstr ""
"Bu özellik çok kullanışlıdır ve temel veri türleri için varsayılan olarak "
"uygulanır. İçerdikleri tüm türler uyguladığı sürece #[türev(Debug)]] "
"özniteliğini kullanarak karmaşık veri türleri için de basitçe türetilebilir. "
"Bu, karmaşık veri türlerini yazdırmak için ekstra kodu manuel olarak "
"uygulama ihtiyacını ortadan kaldırır."

#: src/ch11-08-printing.md:168
msgid ""
"Note that `assert_xx!` macros used in tests require the provided values to "
"implement the `Debug` trait, as they also print the result in case of "
"assertion failure."
msgstr ""
"Testlerde kullanılan assert_xx! makrolarının Debug özelliğini uygulamak için "
"sağlanan değerleri gerektirdiğini unutmayın, çünkü sonuç iddia hatası "
"durumunda da yazdırılır."

#: src/ch11-08-printing.md:170
msgid ""
"For more details about the `Debug` trait and its usage for printing values "
"when debugging, please refer to the [Derivable Traits](./appendix-03-"
"derivable-traits.md#debug-trait-for-printing-and-debugging) appendix."
msgstr ""
"Debug özelliği ve hata ayıklama sırasında yazdırma değerleri için kullanımı "
"hakkında daha fazla bilgi için, lütfen [Türev Edilebilir Özellikler](./"
"appendix-03-türevlenebilir-traits.md#debug-trait-for-printing-and-debugging) "
"ekine bakın."

#: src/appendix-00.md
msgid ""
"The following sections contain reference material you may find useful in "
"your Cairo journey."
msgstr ""
"Aşağıdaki bölümler, Kahire seyahatinizde yararlı bulabileceğiniz referans "
"materyalleri içerir."

#: src/appendix-01-keywords.md:1
msgid "Appendix A - Keywords"
msgstr "Ek A - Anahtar Kelimeler"

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or future "
"use by the Cairo language."
msgstr ""
"Aşağıdaki liste, Kahire dili tarafından mevcut veya gelecekteki kullanım "
"için ayrılmış anahtar kelimeler içerir."

#: src/appendix-01-keywords.md:5
msgid "There are three keyword categories:"
msgstr "Üç anahtar kelime kategorisi vardır:"

#: src/appendix-01-keywords.md:7
msgid "strict"
msgstr "sıkı"

#: src/appendix-01-keywords.md:8
msgid "loose"
msgstr "gevşek"

#: src/appendix-01-keywords.md:9
msgid "reserved"
msgstr "rezerve"

#: src/appendix-01-keywords.md:11
msgid ""
"There is a fourth category, which are functions from the core library. While "
"their names are not reserved, they are not recommended to be used as names "
"of any items to follow good practices."
msgstr ""
"Çekirdek kütüphaneden fonksiyonlar olan dördüncü bir kategori vardır. "
"İsimleri ayrılmamış olsa da, iyi uygulamaları takip etmek için herhangi bir "
"öğenin adı olarak kullanılması önerilmez."

#: src/appendix-01-keywords.md:16
msgid "Strict keywords"
msgstr "Sıkı anahtar kelimeler"

#: src/appendix-01-keywords.md:18
msgid ""
"These keywords can only be used in their correct contexts. They cannot be "
"used as names of any items."
msgstr ""
"Bu anahtar kelimeler yalnızca doğru bağlamlarında kullanılabilir. Herhangi "
"bir öğenin adı olarak kullanılamazlar."

#: src/appendix-01-keywords.md:21
msgid "`as` - Rename import"
msgstr "as - İçe aktarmayı yeniden adlandır"

#: src/appendix-01-keywords.md:22
msgid "`break` - Exit a loop immediately"
msgstr "break - Bir döngüden hemen çıkın"

#: src/appendix-01-keywords.md:23
msgid "`const` - Define constant items"
msgstr "const - Sabit öğeleri tanımla"

#: src/appendix-01-keywords.md:24
msgid "`continue` - Continue to the next loop iteration"
msgstr "devam - Bir sonraki döngü yinelemeye devam et"

#: src/appendix-01-keywords.md:25
msgid "`else` - Fallback for `if` and `if let` control flow constructs"
msgstr "else - if ve if kontrol akış yapıları için geri dönüş"

#: src/appendix-01-keywords.md:26
msgid "`enum` - Define an enumeration"
msgstr "enum - Bir sayım tanımla"

#: src/appendix-01-keywords.md:27
msgid ""
"`extern` - Function defined at the compiler level that can be compiled to "
"CASM"
msgstr "extern - CASM'ye derlenebilen derleyici düzeyinde tanımlanan fonksiyon"

#: src/appendix-01-keywords.md:28
msgid "`false` - Boolean false literal"
msgstr "false - Boolean false literal"

#: src/appendix-01-keywords.md:29
msgid "`fn` - Define a function"
msgstr "fn - Bir işlevi tanımla"

#: src/appendix-01-keywords.md:30
msgid "`if` - Branch based on the result of a conditional expression"
msgstr "if - Koşullu ifadenin sonucuna dayanan dal"

#: src/appendix-01-keywords.md:31
msgid "`impl` - Implement inherent or trait functionality"
msgstr "impl - Doğal veya özellik işlevselliğini uygulamak"

#: src/appendix-01-keywords.md:32
msgid ""
"`implicits` - Special kind of function parameters that are required to "
"perform certain actions"
msgstr ""
"implicits - Belirli eylemleri gerçekleştirmek için gerekli olan özel tür "
"fonksiyon parametreleri"

#: src/appendix-01-keywords.md:33
msgid "`let` - Bind a variable"
msgstr "let - Bir değişkeni bağla"

#: src/appendix-01-keywords.md:34
msgid "`loop` - Loop unconditionally"
msgstr "loop - Koşulsuz döngü"

#: src/appendix-01-keywords.md:35
msgid "`match` - Match a value to patterns"
msgstr "match - Bir değeri kalıplarla eşleştir"

#: src/appendix-01-keywords.md:36
msgid "`mod` - Define a module"
msgstr "mod - Bir modül tanımla"

#: src/appendix-01-keywords.md:37
msgid "`mut` - Denote variable mutability"
msgstr "mut - Denote değişkeni değiştirilebilirliği"

#: src/appendix-01-keywords.md:38
msgid ""
"`nopanic` - Functions marked with this notation mean that the function will "
"never panic."
msgstr ""
"nopanic - Bu notasyonla işaretlenmiş fonksiyonlar, fonksiyonun asla "
"paniklemeyeceği anlamına gelir."

#: src/appendix-01-keywords.md:39
msgid "`of` - Implement a trait"
msgstr "of - Bir özellik uygula"

#: src/appendix-01-keywords.md:40
msgid ""
"`pub` - Denote public visibility in items, such as struct and struct fields, "
"enums, consts, traits and impl blocks, or modules"
msgstr ""
"pub - Yapı ve yapı alanları, enumlar, kontlar, özellikler ve impl blokları "
"veya modüller gibi öğelerde kamu görünürlüğünü ifade edin"

#: src/appendix-01-keywords.md:41
msgid "`ref` - Parameter passed implicitly returned at the end of a function"
msgstr "ref - Parametre, bir fonksiyonun sonunda dolaylı olarak döndürüldü"

#: src/appendix-01-keywords.md:42
msgid "`return` - Return from function"
msgstr "return - Fonksiyondan dönüş"

#: src/appendix-01-keywords.md:43
msgid "`struct` - Define a structure"
msgstr "struct - Bir yapı tanımla"

#: src/appendix-01-keywords.md:44
msgid "`trait` - Define a trait"
msgstr "trait - Bir özelliği tanımla"

#: src/appendix-01-keywords.md:45
msgid "`true` - Boolean true literal"
msgstr "true - Boolean gerçek anlamıyla"

#: src/appendix-01-keywords.md:46
msgid "`type` - Define a type alias"
msgstr "type - Bir tür takma adı tanımla"

#: src/appendix-01-keywords.md:47
msgid "`use` - Bring symbols into scope"
msgstr "use - Sembolleri kapsam içine getirin"

#: src/appendix-01-keywords.md:48
msgid "`while` - loop conditionally based on the result of an expression"
msgstr "while - bir ifadenin sonucuna bağlı olarak koşullu olarak döngü"

#: src/appendix-01-keywords.md:52
msgid "Loose Keywords"
msgstr "Gevşek Anahtar Kelimeler"

#: src/appendix-01-keywords.md:54
msgid ""
"These keywords are associated with a specific behaviour, but can also be "
"used to define items."
msgstr ""
"Bu anahtar kelimeler belirli bir davranışla ilişkilidir, ancak öğeleri "
"tanımlamak için de kullanılabilir."

#: src/appendix-01-keywords.md:56
msgid "`self` - Method subject"
msgstr "self - Yöntem konusu"

#: src/appendix-01-keywords.md:57
msgid "`super` - Parent module of the current module"
msgstr "super - Geçerli modülün ana modülü"

#: src/appendix-01-keywords.md:61
msgid "Reserved Keywords"
msgstr "Ayrılmış Anahtar Kelimeler"

#: src/appendix-01-keywords.md:63
msgid ""
"These keywords aren't used yet, but they are reserved for future use. For "
"now, it is possible to use them to define items, although it is highly "
"recommended not to do so. The reasoning behind this recommendation is to "
"make current programs forward compatible with future versions of Cairo by "
"forbidding them to use these keywords."
msgstr ""
"Bu anahtar kelimeler henüz kullanılmamıştır, ancak gelecekteki kullanımlar "
"için ayrılmıştır. Şimdilik, öğeleri tanımlamak için bunları kullanmak "
"mümkündür, ancak bunu yapmamanız şiddetle tavsiye edilir. Bu tavsiyenin "
"arkasındaki gerekçe, mevcut programları bu anahtar kelimeleri kullanmalarını "
"yasaklayarak Kahire'nin gelecekteki sürümleriyle uyumlu hale getirmektir."

#: src/appendix-01-keywords.md:68
msgid "`Self`"
msgstr "Self"

#: src/appendix-01-keywords.md:69
msgid "`do`"
msgstr "do"

#: src/appendix-01-keywords.md:70
msgid "`dyn`"
msgstr "dyn"

#: src/appendix-01-keywords.md:71
msgid "`for`"
msgstr "for"

#: src/appendix-01-keywords.md:72
msgid "`hint`"
msgstr "hint"

#: src/appendix-01-keywords.md:73
msgid "`in`"
msgstr "in"

#: src/appendix-01-keywords.md:74
msgid "`macro`"
msgstr "macro"

#: src/appendix-01-keywords.md:75
msgid "`move`"
msgstr "Hareket et"

#: src/appendix-01-keywords.md:76
msgid "`static_assert`"
msgstr "static_assert"

#: src/appendix-01-keywords.md:77
msgid "`static`"
msgstr "statik"

#: src/appendix-01-keywords.md:78
msgid "`try`"
msgstr "try"

#: src/appendix-01-keywords.md:79
msgid "`typeof`"
msgstr "tipof"

#: src/appendix-01-keywords.md:80
msgid "`unsafe`"
msgstr "güvensiz"

#: src/appendix-01-keywords.md:81
msgid "`where`"
msgstr "nerede"

#: src/appendix-01-keywords.md:82
msgid "`with`"
msgstr "ile"

#: src/appendix-01-keywords.md:83
msgid "`yield`"
msgstr "yield"

#: src/appendix-01-keywords.md:87
msgid "Built-in Functions"
msgstr "Dahili Fonksiyonlar"

#: src/appendix-01-keywords.md:89
msgid ""
"The Cairo programming language provides several specific functions that "
"serve a special purpose. We will not cover all of them in this book, but "
"using the names of these functions as names of other items is not "
"recommended."
msgstr ""
"Kahire programlama dili, özel bir amaca hizmet eden birkaç özel işlev sunar. "
"Bu kitapta hepsini kapsamayacağız, ancak bu işlevlerin adlarını diğer "
"öğelerin adları olarak kullanmak önerilmez."

#: src/appendix-01-keywords.md:91
msgid ""
"`assert` - This function checks a boolean expression, and if it evaluates to "
"false, it triggers the panic function."
msgstr ""
"assert - Bu fonksiyon bir boolean ifadesini kontrol eder ve yanlış olarak "
"değerlendirilirse panik fonksiyonunu tetikler."

#: src/appendix-01-keywords.md:92
msgid ""
"`panic` - This function acknowledges the occurrence of an error and "
"terminates the program."
msgstr ""
"panic - Bu fonksiyon bir hatanın meydana geldiğini kabul eder ve programı "
"sonlandırır."

#: src/appendix-02-operators-and-symbols.md:1
msgid "Appendix B - Operators and Symbols"
msgstr "Ek B - Operatörler ve Semboller"

#: src/appendix-02-operators-and-symbols.md:3
msgid ""
"This appendix contains a glossary of Cairo's syntax, including operators and "
"other symbols that appear by themselves or in the context of paths, "
"generics, macros, attributes, comments, tuples, and brackets."
msgstr ""
"Bu ek, Kahire'nin sözdiziminin bir sözlüğünü içerir; operatörler ve kendi "
"başlarına veya yollar, jenerikler, makrolar, nitelikler, yorumlar, tuple'lar "
"ve parantezler bağlamında görünen diğer semboller de dahil olmak üzere."

#: src/appendix-02-operators-and-symbols.md:5
msgid "Operators"
msgstr "Operatörler"

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr ""
"Tablo B-1, Kahire'deki operatörleri, operatörün bağlamda nasıl görüneceğine, "
"kısa bir açıklamaya ve bu operatörün aşırı yüklenebilir olup olmadığına dair "
"bir örnek içerir. Bir operatör aşırı yüklenebilirse, bu operatörün aşırı "
"yüklenmesi için kullanılacak ilgili özellik listelenir."

#: src/appendix-02-operators-and-symbols.md:9
msgid "Operator"
msgstr "Operatör"

#: src/appendix-02-operators-and-symbols.md:9
#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:66
#: src/appendix-02-operators-and-symbols.md:76
#: src/appendix-02-operators-and-symbols.md:89
#: src/appendix-02-operators-and-symbols.md:120
#: src/appendix-02-operators-and-symbols.md:146
#: src/appendix-02-operators-and-symbols.md:154
#: src/appendix-02-operators-and-symbols.md:168
msgid "Explanation"
msgstr "Açıklama"

#: src/appendix-02-operators-and-symbols.md:9
msgid "Overloadable?"
msgstr "Aşırı yüklenebilir mi?"

#: src/appendix-02-operators-and-symbols.md:11
msgid "`!`"
msgstr "!"

#: src/appendix-02-operators-and-symbols.md:11
msgid "`!expr`"
msgstr "!expr"

#: src/appendix-02-operators-and-symbols.md:11
msgid "Logical complement"
msgstr "Mantıksal tamamlayıcı"

#: src/appendix-02-operators-and-symbols.md:11
msgid "`Not`"
msgstr "Hayır"

#: src/appendix-02-operators-and-symbols.md:12
msgid "`~`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:12
msgid "`~expr`"
msgstr "expr"

#: src/appendix-02-operators-and-symbols.md:12
msgid "Bitwise NOT"
msgstr "Bitwise NOT"

#: src/appendix-02-operators-and-symbols.md:12
msgid "`BitNot`"
msgstr "BitNot"

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!=`"
msgstr "!="

#: src/appendix-02-operators-and-symbols.md:13
msgid "`expr != expr`"
msgstr "expr!= expr"

#: src/appendix-02-operators-and-symbols.md:13
msgid "Non-equality comparison"
msgstr "Eşitsizlik karşılaştırması"

#: src/appendix-02-operators-and-symbols.md:13
#: src/appendix-02-operators-and-symbols.md:38
msgid "`PartialEq`"
msgstr "PartialEq"

#: src/appendix-02-operators-and-symbols.md:14
msgid "`%`"
msgstr "%"

#: src/appendix-02-operators-and-symbols.md:14
msgid "`expr % expr`"
msgstr "expr % expr"

#: src/appendix-02-operators-and-symbols.md:14
msgid "Arithmetic remainder"
msgstr "Aritmetik kalıntı"

#: src/appendix-02-operators-and-symbols.md:14
msgid "`Rem`"
msgstr "Rem"

#: src/appendix-02-operators-and-symbols.md:15
msgid "`%=`"
msgstr "%="

#: src/appendix-02-operators-and-symbols.md:15
msgid "`var %= expr`"
msgstr "var %= expr"

#: src/appendix-02-operators-and-symbols.md:15
msgid "Arithmetic remainder and assignment"
msgstr "Aritmetik kalıntı ve atama"

#: src/appendix-02-operators-and-symbols.md:15
msgid "`RemEq`"
msgstr "RemEq"

#: src/appendix-02-operators-and-symbols.md:16
msgid "`&`"
msgstr "&"

#: src/appendix-02-operators-and-symbols.md:16
msgid "`expr & expr`"
msgstr "expr & expr"

#: src/appendix-02-operators-and-symbols.md:16
msgid "Bitwise AND"
msgstr "Bitwise VE"

#: src/appendix-02-operators-and-symbols.md:16
msgid "`BitAnd`"
msgstr "BitAnd"

#: src/appendix-02-operators-and-symbols.md:17
msgid "`&&`"
msgstr "&&"

#: src/appendix-02-operators-and-symbols.md:17
msgid "`expr && expr`"
msgstr "expr && expr"

#: src/appendix-02-operators-and-symbols.md:17
msgid "Short-circuiting logical AND"
msgstr "Kısa devre mantıklı ve"

#: src/appendix-02-operators-and-symbols.md:18
#: src/appendix-02-operators-and-symbols.md:21
msgid "`*`"
msgstr "*"

#: src/appendix-02-operators-and-symbols.md:18
msgid "`expr * expr`"
msgstr "expr * expr"

#: src/appendix-02-operators-and-symbols.md:18
msgid "Arithmetic multiplication"
msgstr "Aritmetik çarpma"

#: src/appendix-02-operators-and-symbols.md:18
msgid "`Mul`"
msgstr "Mul"

#: src/appendix-02-operators-and-symbols.md:19
msgid "`*=`"
msgstr "*="

#: src/appendix-02-operators-and-symbols.md:19
msgid "`var *= expr`"
msgstr "var *= expr"

#: src/appendix-02-operators-and-symbols.md:19
msgid "Arithmetic multiplication and assignment"
msgstr "Aritmetik çarpma ve atama"

#: src/appendix-02-operators-and-symbols.md:19
msgid "`MulEq`"
msgstr "MulEq"

#: src/appendix-02-operators-and-symbols.md:20
msgid "`@`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`@var`"
msgstr "var"

#: src/appendix-02-operators-and-symbols.md:20
msgid "Snapshot"
msgstr "Snapshot"

#: src/appendix-02-operators-and-symbols.md:21
msgid "`*var`"
msgstr "*var"

#: src/appendix-02-operators-and-symbols.md:21
msgid "Desnap"
msgstr "Desnap"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`+`"
msgstr "+"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`expr + expr`"
msgstr "expr + expr"

#: src/appendix-02-operators-and-symbols.md:22
msgid "Arithmetic addition"
msgstr "Aritmetik ekleme"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`Add`"
msgstr "Add"

#: src/appendix-02-operators-and-symbols.md:23
msgid "`+=`"
msgstr "+="

#: src/appendix-02-operators-and-symbols.md:23
msgid "`var += expr`"
msgstr "var += expr"

#: src/appendix-02-operators-and-symbols.md:23
msgid "Arithmetic addition and assignment"
msgstr "Aritmetik ekleme ve atama"

#: src/appendix-02-operators-and-symbols.md:23
msgid "`AddEq`"
msgstr "AddEq"

#: src/appendix-02-operators-and-symbols.md:24
msgid "`,`"
msgstr ","

#: src/appendix-02-operators-and-symbols.md:24
msgid "`expr, expr`"
msgstr "expr, expr"

#: src/appendix-02-operators-and-symbols.md:24
msgid "Argument and element separator"
msgstr "Argüman ve eleman ayırıcı"

#: src/appendix-02-operators-and-symbols.md:25
#: src/appendix-02-operators-and-symbols.md:26
msgid "`-`"
msgstr "-"

#: src/appendix-02-operators-and-symbols.md:25
msgid "`-expr`"
msgstr "-expr"

#: src/appendix-02-operators-and-symbols.md:25
msgid "Arithmetic negation"
msgstr "Aritmetik olumsuzlama"

#: src/appendix-02-operators-and-symbols.md:25
msgid "`Neg`"
msgstr "Neg"

#: src/appendix-02-operators-and-symbols.md:26
msgid "`expr - expr`"
msgstr "expr - expr"

#: src/appendix-02-operators-and-symbols.md:26
msgid "Arithmetic subtraction"
msgstr "Aritmetik çıkarma"

#: src/appendix-02-operators-and-symbols.md:26
msgid "`Sub`"
msgstr "Sub"

#: src/appendix-02-operators-and-symbols.md:27
msgid "`-=`"
msgstr "-="

#: src/appendix-02-operators-and-symbols.md:27
msgid "`var -= expr`"
msgstr "var -= expr"

#: src/appendix-02-operators-and-symbols.md:27
msgid "Arithmetic subtraction and assignment"
msgstr "Aritmetik çıkarma ve atama"

#: src/appendix-02-operators-and-symbols.md:27
msgid "`SubEq`"
msgstr "SubEq"

#: src/appendix-02-operators-and-symbols.md:28
msgid "`->`"
msgstr "->"

#: src/appendix-02-operators-and-symbols.md:28
msgid "`fn(...) -> type`, <code>\\|...\\| -> type</code>"
msgstr "fn(...)> type, code>...> type/code>"

#: src/appendix-02-operators-and-symbols.md:28
msgid "Function and closure return type"
msgstr "Fonksiyon ve kapatma dönüş tipi"

#: src/appendix-02-operators-and-symbols.md:29
msgid "`.`"
msgstr "."

#: src/appendix-02-operators-and-symbols.md:29
msgid "`expr.ident`"
msgstr "expr.ident"

#: src/appendix-02-operators-and-symbols.md:29
msgid "Member access"
msgstr "Üye erişimi"

#: src/appendix-02-operators-and-symbols.md:30
msgid "`/`"
msgstr "/"

#: src/appendix-02-operators-and-symbols.md:30
msgid "`expr / expr`"
msgstr "expr / expr"

#: src/appendix-02-operators-and-symbols.md:30
msgid "Arithmetic division"
msgstr "Aritmetik bölme"

#: src/appendix-02-operators-and-symbols.md:30
msgid "`Div`"
msgstr "Div"

#: src/appendix-02-operators-and-symbols.md:31
msgid "`/=`"
msgstr "/="

#: src/appendix-02-operators-and-symbols.md:31
msgid "`var /= expr`"
msgstr "var /= expr"

#: src/appendix-02-operators-and-symbols.md:31
msgid "Arithmetic division and assignment"
msgstr "Aritmetik bölünme ve atama"

#: src/appendix-02-operators-and-symbols.md:31
msgid "`DivEq`"
msgstr "DivEq"

#: src/appendix-02-operators-and-symbols.md:32
#: src/appendix-02-operators-and-symbols.md:33
msgid "`:`"
msgstr ":"

#: src/appendix-02-operators-and-symbols.md:32
msgid "`pat: type`, `ident: type`"
msgstr "pat: type, ident: type"

#: src/appendix-02-operators-and-symbols.md:32
msgid "Constraints"
msgstr "Kısıtlamalar"

#: src/appendix-02-operators-and-symbols.md:33
msgid "`ident: expr`"
msgstr "ident: expr"

#: src/appendix-02-operators-and-symbols.md:33
msgid "Struct field initializer"
msgstr "Struct alan başlatıcısı"

#: src/appendix-02-operators-and-symbols.md:34
msgid "`;`"
msgstr ";"

#: src/appendix-02-operators-and-symbols.md:34
msgid "`expr;`"
msgstr "expr;"

#: src/appendix-02-operators-and-symbols.md:34
msgid "Statement and item terminator"
msgstr "Açıklama ve madde sonlandırıcı"

#: src/appendix-02-operators-and-symbols.md:35
msgid "`<`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "`expr < expr`"
msgstr "expr  expr"

#: src/appendix-02-operators-and-symbols.md:35
msgid "Less than comparison"
msgstr "Karşılaştırmadan daha az"

#: src/appendix-02-operators-and-symbols.md:35
#: src/appendix-02-operators-and-symbols.md:36
#: src/appendix-02-operators-and-symbols.md:40
#: src/appendix-02-operators-and-symbols.md:41
msgid "`PartialOrd`"
msgstr "PartialOrd"

#: src/appendix-02-operators-and-symbols.md:36
msgid "`<=`"
msgstr "="

#: src/appendix-02-operators-and-symbols.md:36
msgid "`expr <= expr`"
msgstr "expr = expr"

#: src/appendix-02-operators-and-symbols.md:36
msgid "Less than or equal to comparison"
msgstr "Karşılaştırmadan daha az veya eşit"

#: src/appendix-02-operators-and-symbols.md:37
msgid "`=`"
msgstr "="

#: src/appendix-02-operators-and-symbols.md:37
msgid "`var = expr`"
msgstr "var = expr"

#: src/appendix-02-operators-and-symbols.md:37
msgid "Assignment"
msgstr "Atama"

#: src/appendix-02-operators-and-symbols.md:38
msgid "`==`"
msgstr "="

#: src/appendix-02-operators-and-symbols.md:38
msgid "`expr == expr`"
msgstr "expr == expr"

#: src/appendix-02-operators-and-symbols.md:38
msgid "Equality comparison"
msgstr "Eşitlik karşılaştırması"

#: src/appendix-02-operators-and-symbols.md:39
msgid "`=>`"
msgstr "=>"

#: src/appendix-02-operators-and-symbols.md:39
msgid "`pat => expr`"
msgstr "pat => expr"

#: src/appendix-02-operators-and-symbols.md:39
msgid "Part of match arm syntax"
msgstr "Eşleme kolu sözdiziminin bir parçası"

#: src/appendix-02-operators-and-symbols.md:40
msgid "`>`"
msgstr ">"

#: src/appendix-02-operators-and-symbols.md:40
msgid "`expr > expr`"
msgstr "expr> expr"

#: src/appendix-02-operators-and-symbols.md:40
msgid "Greater than comparison"
msgstr "Karşılaştırmadan daha büyük"

#: src/appendix-02-operators-and-symbols.md:41
msgid "`>=`"
msgstr ">="

#: src/appendix-02-operators-and-symbols.md:41
msgid "`expr >= expr`"
msgstr "expr>= expr"

#: src/appendix-02-operators-and-symbols.md:41
msgid "Greater than or equal to comparison"
msgstr "Karşılaştırmadan daha büyük veya eşit"

#: src/appendix-02-operators-and-symbols.md:42
msgid "`^`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`expr ^ expr`"
msgstr "expr  expr"

#: src/appendix-02-operators-and-symbols.md:42
msgid "Bitwise exclusive OR"
msgstr "Bitwise özel VEYA"

#: src/appendix-02-operators-and-symbols.md:42
msgid "`BitXor`"
msgstr "BitXor"

#: src/appendix-02-operators-and-symbols.md:43
msgid "<code>\\|</code>"
msgstr "code>/code>"

#: src/appendix-02-operators-and-symbols.md:43
msgid "<code>expr \\| expr</code>"
msgstr "code>expr  expr/code>"

#: src/appendix-02-operators-and-symbols.md:43
msgid "Bitwise OR"
msgstr "Bitwise VEYA"

#: src/appendix-02-operators-and-symbols.md:43
msgid "`BitOr`"
msgstr "BitOr"

#: src/appendix-02-operators-and-symbols.md:44
msgid "<code>\\|\\|</code>"
msgstr "code>/code>"

#: src/appendix-02-operators-and-symbols.md:44
msgid "<code>expr \\|\\| expr</code>"
msgstr "code>expr  expr/code>"

#: src/appendix-02-operators-and-symbols.md:44
msgid "Short-circuiting logical OR"
msgstr "Kısa devre mantıksal VEYA"

#: src/appendix-02-operators-and-symbols.md:45
msgid "`?`"
msgstr "?"

#: src/appendix-02-operators-and-symbols.md:45
msgid "expr?"
msgstr "expr?"

#: src/appendix-02-operators-and-symbols.md:45
msgid "Error propagation"
msgstr "Hata yayılımı"

#: src/appendix-02-operators-and-symbols.md:47
msgid "<span class=\"caption\">Table B-1: Operators</span>"
msgstr "span class=\"caption\">Tablo B-1: Operatörler/span>"

#: src/appendix-02-operators-and-symbols.md:49
msgid "Non Operator Symbols"
msgstr "Operatör Olmayan Semboller"

#: src/appendix-02-operators-and-symbols.md:51
msgid ""
"The following list contains all symbols that are not used as operators; that "
"is, they do not have the same behavior as a function or method call."
msgstr ""
"Aşağıdaki liste, operatör olarak kullanılmayan tüm sembolleri içerir; yani, "
"bir işlev veya yöntem çağrısı ile aynı davranışa sahip değildirler."

#: src/appendix-02-operators-and-symbols.md:53
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr ""
"Tablo B-2, kendi başlarına görünen ve çeşitli yerlerde geçerli olan "
"sembolleri gösterir."

#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:66
#: src/appendix-02-operators-and-symbols.md:76
#: src/appendix-02-operators-and-symbols.md:89
#: src/appendix-02-operators-and-symbols.md:120
#: src/appendix-02-operators-and-symbols.md:146
#: src/appendix-02-operators-and-symbols.md:154
msgid "Symbol"
msgstr "Sembol"

#: src/appendix-02-operators-and-symbols.md:57
msgid "`..._u8`, `..._usize`, `..._bool`, etc."
msgstr "..._u8,..._usize,..._bool, vb."

#: src/appendix-02-operators-and-symbols.md:57
msgid "Numeric literal of specific type"
msgstr "Belirli tipteki sayısal literal"

#: src/appendix-02-operators-and-symbols.md:58
msgid "`\"...\"`"
msgstr "\"...\""

#: src/appendix-02-operators-and-symbols.md:58
msgid "String literal"
msgstr "Dize harfi"

#: src/appendix-02-operators-and-symbols.md:59
msgid "`'...'`"
msgstr "'...'"

#: src/appendix-02-operators-and-symbols.md:59
msgid "Short string, 31 ASCII characters maximum"
msgstr "Kısa dize, 31 ASCII karakter maksimum"

#: src/appendix-02-operators-and-symbols.md:60
msgid "`_`"
msgstr "_"

#: src/appendix-02-operators-and-symbols.md:60
msgid "“Ignored” pattern binding"
msgstr "\"Uygunsuz\" desen bağlama"

#: src/appendix-02-operators-and-symbols.md:62
msgid "<span class=\"caption\">Table B-2: Stand-Alone Syntax</span>"
msgstr "span class=\"caption\">Tablo B-2: Stand-Alone Syntax/span>"

#: src/appendix-02-operators-and-symbols.md:64
msgid ""
"Table B-3 shows symbols that are used within the context of a module "
"hierarchy path to access an item."
msgstr ""
"Tablo B-3, bir öğeye erişmek için bir modül hiyerarşi yolu bağlamında "
"kullanılan sembolleri gösterir."

#: src/appendix-02-operators-and-symbols.md:68
msgid "`ident::ident`"
msgstr "ident::ident"

#: src/appendix-02-operators-and-symbols.md:68
msgid "Namespace path"
msgstr "Namespace yolu"

#: src/appendix-02-operators-and-symbols.md:69
msgid "`super::path`"
msgstr "süper::path"

#: src/appendix-02-operators-and-symbols.md:69
msgid "Path relative to the parent of the current module"
msgstr "Geçerli modülün ebeveynine göre yol"

#: src/appendix-02-operators-and-symbols.md:70
msgid "`trait::method(...)`"
msgstr "trait::method(...)"

#: src/appendix-02-operators-and-symbols.md:70
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr "Tanımlayan özelliği adlandırarak bir yöntem çağrısını ayrıştırmak"

#: src/appendix-02-operators-and-symbols.md:72
msgid "<span class=\"caption\">Table B-3: Path-Related Syntax</span>"
msgstr "span class=\"caption\">Table B-3: Path-Related Syntax/span>"

#: src/appendix-02-operators-and-symbols.md:74
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr ""
"Tablo B-4, genel tip parametrelerin kullanılması bağlamında görünen "
"sembolleri gösterir."

#: src/appendix-02-operators-and-symbols.md:78
msgid "`path<...>`"
msgstr "yol...>"

#: src/appendix-02-operators-and-symbols.md:78
msgid "Specifies parameters to generic type in a type (e.g., `Array<u8>`)"
msgstr "Bir tipteki genel tipe parametreleri belirtir (örneğin, Arrayu8>)"

#: src/appendix-02-operators-and-symbols.md:79
msgid "`path::<...>`, `method::<...>`"
msgstr "path::...>, method:...>"

#: src/appendix-02-operators-and-symbols.md:79
msgid ""
"Specifies parameters to a generic type, function, or method in an "
"expression; often referred to as turbofish"
msgstr ""
"Parametreleri genel bir türe, fonksiyona veya yönteme bir ifadede belirtir; "
"genellikle turbofish olarak adlandırılır."

#: src/appendix-02-operators-and-symbols.md:80
msgid "`fn ident<...> ...`"
msgstr "fn ident...>..."

#: src/appendix-02-operators-and-symbols.md:80
msgid "Define generic function"
msgstr "Jenerik fonksiyonu tanımla"

#: src/appendix-02-operators-and-symbols.md:81
msgid "`struct ident<...> ...`"
msgstr "Struct ident...>..."

#: src/appendix-02-operators-and-symbols.md:81
msgid "Define generic structure"
msgstr "Jenerik yapıyı tanımla"

#: src/appendix-02-operators-and-symbols.md:82
msgid "`enum ident<...> ...`"
msgstr "enum ident...>..."

#: src/appendix-02-operators-and-symbols.md:82
msgid "Define generic enumeration"
msgstr "Genel numaralandırmayı tanımla"

#: src/appendix-02-operators-and-symbols.md:83
msgid "`impl<...> ...`"
msgstr "impl...>..."

#: src/appendix-02-operators-and-symbols.md:83
msgid "Define generic implementation"
msgstr "Genel uygulamayı tanımla"

#: src/appendix-02-operators-and-symbols.md:85
msgid "<span class=\"caption\">Table B-4: Generics</span>"
msgstr "span class=\"caption\">Tablo B-4: Genel/span>"

#: src/appendix-02-operators-and-symbols.md:87
msgid ""
"Table B-5 shows symbols that appear in the context of specifying attributes "
"on an item."
msgstr ""
"Tablo B-5, bir öğedeki özniteliklerin belirtilmesi bağlamında görünen "
"sembolleri gösterir."

#: src/appendix-02-operators-and-symbols.md:91
msgid "`#[derive(...)]`"
msgstr "#[türev(...)]"

#: src/appendix-02-operators-and-symbols.md:91
msgid "Automatically implements a trait for a type"
msgstr "Bir tür için bir özelliği otomatik olarak uygular"

#: src/appendix-02-operators-and-symbols.md:92
msgid "`#[inline]`"
msgstr "#[inline]"

#: src/appendix-02-operators-and-symbols.md:92
msgid "Hint to the compiler to allow inlining of annotated function"
msgstr ""
"Derleyiciye not edilen fonksiyonun astarlanmasına izin vermek için ipucu"

#: src/appendix-02-operators-and-symbols.md:93
msgid "`#[inline(always)]`"
msgstr "#[inline(hep)]"

#: src/appendix-02-operators-and-symbols.md:93
msgid "Hint to the compiler to systematically inline annotated function"
msgstr "Derleyiciye sistematik olarak satır içi açıklama işlevine işaret et"

#: src/appendix-02-operators-and-symbols.md:94
msgid "`#[inline(never)]`"
msgstr "#[inline(never)]"

#: src/appendix-02-operators-and-symbols.md:94
msgid "Hint to the compiler to never inline annotated function"
msgstr ""
"Derleyiciye not edilmiş bir işlevi asla satır içine almaması için ipucu"

#: src/appendix-02-operators-and-symbols.md:95
msgid "`#[must_use]`"
msgstr "#[must_use]"

#: src/appendix-02-operators-and-symbols.md:95
msgid ""
"Hint to the compiler that the return value of a function or a specific "
"returned type must be used"
msgstr ""
"Derleyiciye, bir fonksiyonun veya belirli bir döndürülen türün dönüş "
"değerinin kullanılması gerektiğine dair ipucu"

#: src/appendix-02-operators-and-symbols.md:96
msgid "`#[generate_trait]`"
msgstr "#[genate_trait]"

#: src/appendix-02-operators-and-symbols.md:96
msgid "Automatically generates a trait for an impl"
msgstr "Bir impl için otomatik olarak bir özellik oluşturur"

#: src/appendix-02-operators-and-symbols.md:97
msgid "`#[available_gas(...)]`"
msgstr "#[kullanılabilir_gaz(...)]"

#: src/appendix-02-operators-and-symbols.md:97
msgid "Set the maximum amount of gas available to execute a function"
msgstr ""
"Bir fonksiyonu çalıştırmak için mevcut maksimum gaz miktarını ayarlayın"

#: src/appendix-02-operators-and-symbols.md:98
msgid "`#[panic_with('...', wrapper_name)]`"
msgstr "#[panic_with('...', wrapper_name]]"

#: src/appendix-02-operators-and-symbols.md:98
msgid ""
"Creates a wrapper for the annotated function which will panic if the "
"function returns `None` or `Err`, with the given data as the panic error"
msgstr ""
"None veya Err işlevinin geri gelmesi durumunda panik yapacak olan açıklamalı "
"fonksiyon için bir ambalaj oluşturur, verilen veriler panik hatası olarak"

#: src/appendix-02-operators-and-symbols.md:99
msgid "`#[test]`"
msgstr "#[test]"

#: src/appendix-02-operators-and-symbols.md:99
msgid "Describe a function as a test function"
msgstr "Bir fonksiyonu bir test fonksiyonu olarak tanımlamak"

#: src/appendix-02-operators-and-symbols.md:100
msgid "`#[cfg(...)]`"
msgstr "#[cfg(...)]"

#: src/appendix-02-operators-and-symbols.md:100
msgid ""
"Configuration attribute, especially used to configure a `tests` module with "
"`#[cfg(test)]`"
msgstr ""
"Yapılandırma özniteliği, özellikle bir tests modülünü #[cfg(test)] ile "
"yapılandırmak için kullanılır"

#: src/appendix-02-operators-and-symbols.md:101
msgid "`#[should_panic]`"
msgstr "#[olmalı_panik]"

#: src/appendix-02-operators-and-symbols.md:101
msgid "Specifies that a test function should necessarily panic"
msgstr "Bir test fonksiyonunun mutlaka panik yapması gerektiğini belirtir"

#: src/appendix-02-operators-and-symbols.md:102
msgid "`#[starknet::contract]`"
msgstr "#[starknet::contract]"

#: src/appendix-02-operators-and-symbols.md:102
msgid "Defines a Starknet smart contract"
msgstr "Starknet akıllı sözleşmesini tanımlar"

#: src/appendix-02-operators-and-symbols.md:103
msgid "`#[starknet::interface]`"
msgstr "#[starknet::interface]"

#: src/appendix-02-operators-and-symbols.md:103
msgid "Defines a Starknet interface"
msgstr "Bir Starknet arayüzü tanımlar"

#: src/appendix-02-operators-and-symbols.md:104
msgid "`#[starknet::component]`"
msgstr "#[starknet::component]"

#: src/appendix-02-operators-and-symbols.md:104
msgid "Defines a Starknet component"
msgstr "Starknet bileşenini tanımlar"

#: src/appendix-02-operators-and-symbols.md:105
msgid "`#[starknet::embeddable]`"
msgstr "#[starknet::embeddable]"

#: src/appendix-02-operators-and-symbols.md:105
msgid ""
"Defines an isolated embeddable implementation that can be injected in any "
"smart contract"
msgstr ""
"Herhangi bir akıllı sözleşmede enjekte edilebilen izole bir gömülü "
"uygulamayı tanımlar"

#: src/appendix-02-operators-and-symbols.md:106
msgid "`#[embeddable_as(...)]`"
msgstr "#[embeddable_as(...)]"

#: src/appendix-02-operators-and-symbols.md:106
msgid "Defines an embeddable implementation inside a component"
msgstr "Bir bileşenin içine gömülebilir bir uygulamayı tanımlar"

#: src/appendix-02-operators-and-symbols.md:107
msgid "`#[storage]`"
msgstr "#[Depolama]"

#: src/appendix-02-operators-and-symbols.md:107
msgid "Defines the storage of a smart contract"
msgstr "Akıllı sözleşmenin depolanmasını tanımlar"

#: src/appendix-02-operators-and-symbols.md:108
msgid "`#[event]`"
msgstr "#[olay]"

#: src/appendix-02-operators-and-symbols.md:108
msgid "Defines an event in a smart contract"
msgstr "Akıllı sözleşmede bir olayı tanımlar"

#: src/appendix-02-operators-and-symbols.md:109
msgid "`#[constructor]`"
msgstr "#[yapımcı]"

#: src/appendix-02-operators-and-symbols.md:109
msgid "Defines the constructor in a smart contract"
msgstr "Yapılandırıcıyı akıllı bir sözleşmede tanımlar"

#: src/appendix-02-operators-and-symbols.md:110
msgid "`#[abi(embed_v0)]`"
msgstr "#[abi(embed_v0)]"

#: src/appendix-02-operators-and-symbols.md:110
msgid ""
"Defines an implementation of a trait, exposing the functions of the impl as "
"entrypoints of a contract"
msgstr ""
"Bir özelliğin uygulanmasını tanımlar, impl'nin işlevlerini bir sözleşmenin "
"giriş noktaları olarak ortaya çıkarır"

#: src/appendix-02-operators-and-symbols.md:111
msgid "`#[abi(per_item)]`"
msgstr "#[abi(per_item)]"

#: src/appendix-02-operators-and-symbols.md:111
msgid ""
"Allows individual definition of the entrypoint type of functions inside an "
"impl"
msgstr "Bir impl içindeki girdi noktası tipinin bireysel tanımına izin verir"

#: src/appendix-02-operators-and-symbols.md:112
msgid "`#[external(v0)]`"
msgstr "#[dış(v0)]"

#: src/appendix-02-operators-and-symbols.md:112
msgid "Defines an external function when `#[abi(per_item)]` is used"
msgstr "#[abi(per_item)] kullanıldığında bir dış fonksiyonu tanımlar"

#: src/appendix-02-operators-and-symbols.md:113
msgid "`#[flat]`"
msgstr "#[flat]"

#: src/appendix-02-operators-and-symbols.md:113
msgid ""
"Defines a enum variant of the `Event` enum that is not nested, ignoring the "
"variant name in the serialization process, very useful for composability "
"when using Starknet components"
msgstr ""
"Event enum'un bir enum varyantını tanımlar, serileştirme işleminde varyant "
"adını göz ardı eder, Starknet bileşenlerini kullanırken uyumluluk için çok "
"kullanışlıdır."

#: src/appendix-02-operators-and-symbols.md:114
msgid "`#[key]`"
msgstr "#[anahtar]"

#: src/appendix-02-operators-and-symbols.md:114
msgid ""
"Defines an indexed `Event` enum field, allowing for more efficient queries "
"and filtering of events"
msgstr ""
"İndekslenmiş bir Event enum alanını tanımlar, daha verimli sorgulara ve "
"olayların filtrelenmesine izin verir"

#: src/appendix-02-operators-and-symbols.md:116
msgid "<span class=\"caption\">Table B-5: Attributes</span>"
msgstr "span class=\"caption\">Tablo B-5: Öznitelikler/span>"

#: src/appendix-02-operators-and-symbols.md:118
msgid ""
"Table B-6 shows symbols that appear in the context of calling or defining "
"macros."
msgstr ""
"Tablo B-6, makroları çağırma veya tanımlama bağlamında görünen sembolleri "
"gösterir."

#: src/appendix-02-operators-and-symbols.md:122
msgid "`print!`"
msgstr "print!"

#: src/appendix-02-operators-and-symbols.md:122
msgid "Inline printing"
msgstr "Satır içi baskı"

#: src/appendix-02-operators-and-symbols.md:123
msgid "`println!`"
msgstr "println!"

#: src/appendix-02-operators-and-symbols.md:123
msgid "Print on a new line"
msgstr "Yeni bir satırda yazdır"

#: src/appendix-02-operators-and-symbols.md:124
msgid "`consteval_int!`"
msgstr "consteval_int!"

#: src/appendix-02-operators-and-symbols.md:124
msgid "Declare a constant that is the result of a computation of integers"
msgstr "Tam sayıların hesaplanmasının sonucu olan bir sabiti ilan edin"

#: src/appendix-02-operators-and-symbols.md:125
msgid "`array!`"
msgstr "array!"

#: src/appendix-02-operators-and-symbols.md:125
msgid "Instantiate and fill arrays"
msgstr "Dizileri anlık olarak doldur ve doldur"

#: src/appendix-02-operators-and-symbols.md:126
msgid "`panic!`"
msgstr "panic!"

#: src/appendix-02-operators-and-symbols.md:126
msgid ""
"Calls `panic` function and allows to provide a message error longer than 31 "
"characters"
msgstr ""
"panic işlevini çağırır ve 31 karakterden daha uzun bir mesaj hatası sağlar"

#: src/appendix-02-operators-and-symbols.md:127
msgid "`assert!`"
msgstr "assert!"

#: src/appendix-02-operators-and-symbols.md:127
msgid "Evaluates a Boolean and panics if `false`"
msgstr "Bir Boolean değerlendirir ve false ise panikler"

#: src/appendix-02-operators-and-symbols.md:128
msgid "`assert_eq!`"
msgstr "assert_eq!"

#: src/appendix-02-operators-and-symbols.md:128
msgid "Evaluates an equality, and panics if not equal"
msgstr "Eşitliği değerlendirir ve eşit değilse panikler"

#: src/appendix-02-operators-and-symbols.md:129
msgid "`assert_ne!`"
msgstr "assert_ne!"

#: src/appendix-02-operators-and-symbols.md:129
msgid "Evaluates an equality, and panics if equal"
msgstr "Eşitliği değerlendirir ve eşitse panikler"

#: src/appendix-02-operators-and-symbols.md:130
msgid "`assert_lt!`"
msgstr "assert_lt!"

#: src/appendix-02-operators-and-symbols.md:130
msgid "Evaluates a comparison, and panics if greater or equal"
msgstr "Bir karşılaştırmayı değerlendirir ve daha büyük veya eşitse panikler"

#: src/appendix-02-operators-and-symbols.md:131
msgid "`assert_le!`"
msgstr "assert_le!"

#: src/appendix-02-operators-and-symbols.md:131
msgid "Evaluates a comparison, and panics if greater"
msgstr "Bir karşılaştırmayı değerlendirir ve daha büyükse panikler"

#: src/appendix-02-operators-and-symbols.md:132
msgid "`assert_gt!`"
msgstr "assert_gt!"

#: src/appendix-02-operators-and-symbols.md:132
msgid "Evaluates a comparison, and panics if lower or equal"
msgstr "Bir karşılaştırmayı değerlendirir ve daha düşük veya eşitse panikler"

#: src/appendix-02-operators-and-symbols.md:133
msgid "`assert_ge!`"
msgstr "assert_ge!"

#: src/appendix-02-operators-and-symbols.md:133
msgid "Evaluates a comparison, and panics if lower"
msgstr "Bir karşılaştırmayı değerlendirir ve daha düşükse panikler"

#: src/appendix-02-operators-and-symbols.md:134
msgid "`format!`"
msgstr "format!"

#: src/appendix-02-operators-and-symbols.md:134
msgid "Format a string and returns a `ByteArray` with the contents"
msgstr "Bir dizeyi biçimlendirin ve içeriği olan bir ByteArray döndürür"

#: src/appendix-02-operators-and-symbols.md:135
msgid "`write!`"
msgstr "Yaz!"

#: src/appendix-02-operators-and-symbols.md:135
msgid "Write formatted strings in a formatter"
msgstr "Biçimlendirilmiş dizeleri bir biçimlendiriciye yazın"

#: src/appendix-02-operators-and-symbols.md:136
msgid "`writeln!`"
msgstr "writeln!"

#: src/appendix-02-operators-and-symbols.md:136
msgid "Write formatted strings in a formatter on a new line"
msgstr "Biçimlendirilmiş dizeleri yeni bir satırda biçimlendiriciye yazın"

#: src/appendix-02-operators-and-symbols.md:137
msgid "`get_dep_component!`"
msgstr "get_dep_component!"

#: src/appendix-02-operators-and-symbols.md:137
msgid ""
"Returns the requested component state from a snapshot of the state inside a "
"component"
msgstr ""
"İstenen bileşen durumunu, bir bileşenin içindeki durumun bir anlık "
"görüntüsünden döndürür"

#: src/appendix-02-operators-and-symbols.md:138
msgid "`get_dep_component_mut!`"
msgstr "get_dep_component_mut!"

#: src/appendix-02-operators-and-symbols.md:138
msgid ""
"Returns the requested component state from a reference of the state inside a "
"component"
msgstr ""
"İstenen bileşen durumunu, bir bileşen içindeki durum referansından döndürür"

#: src/appendix-02-operators-and-symbols.md:139
msgid "`component!`"
msgstr "bileşen!"

#: src/appendix-02-operators-and-symbols.md:139
msgid "Macro used in Starknet contracts to embed a component inside a contract"
msgstr ""
"Makro Starknet sözleşmelerinde bir bileşeni bir sözleşmenin içine "
"yerleştirmek için kullanılır"

#: src/appendix-02-operators-and-symbols.md:142
msgid "<span class=\"caption\">Table B-6: Macros</span>"
msgstr "span class=\"caption\">Tablo B-6: Makrolar/span>"

#: src/appendix-02-operators-and-symbols.md:144
msgid "Table B-7 shows symbols that create comments."
msgstr "Tablo B-7 yorum oluşturan sembolleri gösterir."

#: src/appendix-02-operators-and-symbols.md:148
msgid "`//`"
msgstr "/"

#: src/appendix-02-operators-and-symbols.md:148
msgid "Line comment"
msgstr "Satır yorumu"

#: src/appendix-02-operators-and-symbols.md:150
msgid "<span class=\"caption\">Table B-7: Comments</span>"
msgstr "span class=\"caption\">Tablo B-7: Yorumlar/span>"

#: src/appendix-02-operators-and-symbols.md:152
msgid "Table B-8 shows symbols that appear in the context of using tuples."
msgstr "Tablo B-8, tuples kullanımı bağlamında görünen sembolleri gösterir."

#: src/appendix-02-operators-and-symbols.md:156
msgid "`()`"
msgstr "()"

#: src/appendix-02-operators-and-symbols.md:156
msgid "Empty tuple (aka unit), both literal and type"
msgstr "Boş tuple (aka birim), hem gerçek hem de tip"

#: src/appendix-02-operators-and-symbols.md:157
msgid "`(expr)`"
msgstr "(expr)"

#: src/appendix-02-operators-and-symbols.md:157
msgid "Parenthesized expression"
msgstr "Parenthesized ifadesi"

#: src/appendix-02-operators-and-symbols.md:158
msgid "`(expr,)`"
msgstr "(expr,)"

#: src/appendix-02-operators-and-symbols.md:158
msgid "Single-element tuple expression"
msgstr "Tek-elementli tümle ifadesi"

#: src/appendix-02-operators-and-symbols.md:159
msgid "`(type,)`"
msgstr "(tip,)"

#: src/appendix-02-operators-and-symbols.md:159
msgid "Single-element tuple type"
msgstr "Tek elemanlı tuple tipi"

#: src/appendix-02-operators-and-symbols.md:160
msgid "`(expr, ...)`"
msgstr "(expr,...)"

#: src/appendix-02-operators-and-symbols.md:160
msgid "Tuple expression"
msgstr "Tuple ifadesi"

#: src/appendix-02-operators-and-symbols.md:161
msgid "`(type, ...)`"
msgstr "(tip,...)"

#: src/appendix-02-operators-and-symbols.md:161
msgid "Tuple type"
msgstr "Tuple tipi"

#: src/appendix-02-operators-and-symbols.md:162
msgid "`expr(expr, ...)`"
msgstr "expr(expr,...)"

#: src/appendix-02-operators-and-symbols.md:162
msgid ""
"Function call expression; also used to initialize tuple `struct`s and tuple "
"`enum` variants"
msgstr ""
"Fonksiyon çağrı ifadesi; ayrıca tuple structs ve tuple enum varyantlarını "
"başlatmak için kullanılır"

#: src/appendix-02-operators-and-symbols.md:164
msgid "<span class=\"caption\">Table B-8: Tuples</span>"
msgstr "span class=\"caption\">Tablo B-8: Tuples/span>"

#: src/appendix-02-operators-and-symbols.md:166
msgid "Table B-9 shows the contexts in which curly braces are used."
msgstr "Tablo B-9, kıvırcık diş tellerinin kullanıldığı bağlamları gösterir."

#: src/appendix-02-operators-and-symbols.md:168
msgid "Context"
msgstr "Bağlam"

#: src/appendix-02-operators-and-symbols.md:170
msgid "`{...}`"
msgstr "..."

#: src/appendix-02-operators-and-symbols.md:170
msgid "Block expression"
msgstr "Blok ifadesi"

#: src/appendix-02-operators-and-symbols.md:171
msgid "`Type {...}`"
msgstr "Type..."

#: src/appendix-02-operators-and-symbols.md:171
msgid "`struct` literal"
msgstr "struct gerçek anlamda"

#: src/appendix-02-operators-and-symbols.md:173
msgid "<span class=\"caption\">Table B-9: Curly Braces</span>"
msgstr "span class=\"caption\">Tablo B-9: Kıvırcık Braces/span>"

#: src/appendix-03-derivable-traits.md:1
msgid "Appendix C - Derivable Traits"
msgstr "Ek C - Türevlenebilir Özellikleri"

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which "
"you can apply to a struct or enum definition. The `derive` attribute "
"generates code to implement a default trait on the type you’ve annotated "
"with the `derive` syntax."
msgstr ""
"Kitaptaki çeşitli yerlerde, bir yapısal veya enum tanımına "
"uygulayabileceğiniz derive özniteliğini tartıştık. derive özniteliği, derive "
"sözdizimi ile not ettiğiniz tür üzerinde varsayılan bir özellik uygulamak "
"için kod oluşturur."

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the "
"traits in the standard library compatible with the `derive` attribute."
msgstr ""
"Bu ekte, standart kütüphanedeki derive özniteliği ile uyumlu tüm özellikleri "
"detaylandıran kapsamlı bir referans sunuyoruz."

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that "
"can be implemented on your types using `derive`. Other traits defined in the "
"standard library don’t have sensible default behavior, so it’s up to you to "
"implement them in a way that makes sense for what you’re trying to "
"accomplish."
msgstr ""
"Burada listelenen bu özellikler, derive kullanarak çekirdek kitaplığı "
"tarafından tanımlanabilecek özelliklerdir. Standart kütüphanede tanımlanan "
"diğer özelliklerin mantıklı varsayılan davranışları yoktur, bu nedenle "
"bunları başarmaya çalıştığınız şey için mantıklı bir şekilde uygulamak size "
"kalmıştır."

#: src/appendix-03-derivable-traits.md:9
msgid "Drop and Destruct"
msgstr "Düşme ve Yıkım"

#: src/appendix-03-derivable-traits.md:11
msgid ""
"When moving out of scope, variables need to be moved first. This is where "
"the `Drop` trait intervenes. You can find more details about its usage [here]"
"(ch04-01-what-is-ownership.md#no-op-destruction-the-drop-trait)."
msgstr ""
"Kapsam dışına taşınırken, değişkenlerin önce taşınması gerekir. Drop "
"özelliğinin müdahale ettiği yer burasıdır. Kullanımı hakkında daha fazla "
"ayrıntı bulabilirsiniz [burada] (ch04-01-what-is-ownership.md#no-op-"
"destruction-the-drop-trait)."

#: src/appendix-03-derivable-traits.md:13
msgid ""
"Moreover, Dictionaries need to be squashed before going out of scope. "
"Calling the `squash` method on each of them manually can quickly become "
"redundant. `Destruct` trait allows Dictionaries to be automatically squashed "
"when they get out of scope. You can also find more information about "
"`Destruct` [here](ch04-01-what-is-ownership.md#destruction-with-a-side-"
"effect-the-destruct-trait)."
msgstr ""
"Ayrıca, Dictionary'lerin kapsam dışına çıkmadan önce ezilmesi gerekir. Her "
"biri üzerindeki squash yöntemini manuel olarak çağırmak hızla gereksiz hale "
"gelebilir. Destruct özelliği, Dictionary'lerin kapsam dışına çıktıklarında "
"otomatik olarak ezilmesine izin verir. Destruct [burada] (ch04-01-what-is-"
"storkship.md#destruction-with-the-side-de) hakkında daha fazla bilgi "
"bulabilirsiniz."

#: src/appendix-03-derivable-traits.md:15
msgid "`Clone` and `Copy` for Duplicating Values"
msgstr "Değerleri Çoğaltmak için Clone ve Copy"

#: src/appendix-03-derivable-traits.md:17
msgid ""
"The `Clone` trait provides the functionality to explicitly create a deep "
"copy of a value."
msgstr ""
"Clone özelliği, bir değerin derin bir kopyasını açıkça oluşturmak için "
"işlevsellik sağlar."

#: src/appendix-03-derivable-traits.md:19
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone "
"on each of the type's components. This means all the fields or values in the "
"type must also implement `Clone` to derive `Clone`."
msgstr ""
"Clone'un çıkarılması, clone yöntemini uygular; bu da, türün bileşenlerinin "
"her birine klon adını verir. Bu, türdeki tüm alanların veya değerlerin "
"Clone'yi türetmek için Clone'yi de uygulaması gerektiği anlamına gelir."

#: src/appendix-03-derivable-traits.md:21
msgid "Here is a simple example:"
msgstr "İşte basit bir örnek:"

#: src/appendix-03-derivable-traits.md:32
#: src/appendix-03-derivable-traits.md:50
msgid "\"Not equal\""
msgstr "\"Eşit değil\""

#: src/appendix-03-derivable-traits.md:36
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy` "
"on any type whose parts all implement `Copy`."
msgstr ""
"Copy özelliği, değerlerin çoğaltılmasını sağlar. Parçalarının tümü Copy'yi "
"uygulayan herhangi bir türde Copy'yi türetebilirsiniz."

#: src/appendix-03-derivable-traits.md:49
msgid "// Copy Trait prevents first_struct from moving into second_struct\n"
msgstr ""
"// Kopyalama Trait, first_struct'un second_struct'a geçmesini engeller\n"

#: src/appendix-03-derivable-traits.md:51
msgid "\"Not Equal\""
msgstr "\"Eşit Değil\""

#: src/appendix-03-derivable-traits.md:55
msgid "`Debug` for Printing and Debugging"
msgstr "Baskı ve Hata Ayıklama için Debug"

#: src/appendix-03-derivable-traits.md:57
msgid ""
"The `Debug` trait enables debug formatting in format strings, which you "
"indicate by adding `:?` within `{}` placeholders."
msgstr ""
"Hata ayıklama özelliği,  yer tutucular içinde :? ekleyerek belirttiğiniz "
"biçim dizelerinde hata ayıklama biçimlendirmesini sağlar."

#: src/appendix-03-derivable-traits.md:59
msgid ""
"It allows you to print instances of a type for debugging purposes, so you "
"and other programmers using this type can inspect an instance at a "
"particular point in a program’s execution."
msgstr ""
"Hata ayıklama amacıyla bir türün örneklerini yazdırmanıza izin verir, "
"böylece siz ve bu türü kullanan diğer programcılar bir programın "
"yürütülmesindeki belirli bir noktada bir örneği inceleyebilir."

#: src/appendix-03-derivable-traits.md:61
msgid ""
"For example, if you want to print the value of a variable of type `Point`, "
"you can do it as follows:"
msgstr ""
"Örneğin, Point tipinde bir değişkenin değerini yazdırmak istiyorsanız, "
"aşağıdaki gibi yapabilirsiniz:"

#: src/appendix-03-derivable-traits.md:72
msgid "\"{:?}\""
msgstr "\":?\""

#: src/appendix-03-derivable-traits.md:81
msgid ""
"The `Debug` trait is required, for example, when using the `assert_xx!` "
"macros in tests. Theses macros print the values of instances given as "
"arguments if the equality or comparison assertion fails so programmers can "
"see why the two instances weren’t equal."
msgstr ""
"Debug özelliği, örneğin, testlerde assert_xx! makrolarını kullanırken "
"gereklidir. Bu makrolar, eşitlik veya karşılaştırma iddiası başarısız "
"olursa, argüman olarak verilen örneklerin değerlerini yazdırır, böylece "
"programcılar iki örneğin neden eşit olmadığını görebilir."

#: src/appendix-03-derivable-traits.md:83
msgid "`Default` for Default Values"
msgstr "Varsayılan Değerler için Default"

#: src/appendix-03-derivable-traits.md:85
msgid ""
"The `Default` trait allows creation of a default value of a type. The most "
"common default value is zero. All primitive types in the standard library "
"implement `Default`."
msgstr ""
"Default özelliği, bir türün varsayılan değerinin oluşturulmasına izin verir. "
"En yaygın varsayılan değer sıfırdır. Standart kütüphanedeki tüm ilkel türler "
"Default uygular."

#: src/appendix-03-derivable-traits.md:87
msgid ""
"If you want to derive `Default` on a composite type, each of its elements "
"must already implement `Default`. If you have an [`enum`](ch06-01-enums.md) "
"type, you must declare its default value by using the `#[default]` attribute "
"on one of its variants."
msgstr ""
"Default'u kompozit bir tipte türetmek istiyorsanız, elemanlarının her biri "
"Default'yu zaten uygulamalıdır. [enum] (ch06-01-enums.md) tipiniz varsa, "
"varyantlarından birinde #[varsayılan] özniteliğini kullanarak varsayılan "
"değerini beyan etmelisiniz."

#: src/appendix-03-derivable-traits.md:89
msgid "An example:"
msgstr "Bir örnek:"

#: src/appendix-03-derivable-traits.md:108
msgid "\"item1 mismatch\""
msgstr "\"1. madde uyuşmazlığı\""

#: src/appendix-03-derivable-traits.md:109
msgid "\"item2 mismatch\""
msgstr "\"Item2 uyuşmazlığı\""

#: src/appendix-03-derivable-traits.md:112
msgid "\"case mismatch\""
msgstr "\"Dava uyuşmazlığı\""

#: src/appendix-03-derivable-traits.md:116
msgid "`PartialEq` for Equality Comparisons"
msgstr "Eşitlik Karşılaştırmaları için PartialEq"

#: src/appendix-03-derivable-traits.md:118
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for "
"equality, thereby enabling the `==` and `!=` operators."
msgstr ""
"PartialEq özelliği eşitlik için bir türün örnekleri arasında karşılaştırma "
"yapılmasına izin verir, böylece ==  ve!= operatörleri etkinleştirilir."

#: src/appendix-03-derivable-traits.md:120
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all "
"their fields are equal; they are not equal if any field is different. When "
"derived for enums, each variant is equal to itself and not equal to the "
"other variants."
msgstr ""
"PartialEq yapıtlar üzerinde türetildiğinde, iki örnek sadece tüm alanları "
"eşitse eşittir; herhangi bir alan farklıysa eşit değildir. Enumlar için "
"türetildiğinde, her varyant kendine eşittir ve diğer varyantlara eşit "
"değildir."

#: src/appendix-03-derivable-traits.md:122
msgid ""
"You can write your own implementation of the `PartialEq` trait for your "
"type, if you can't derive it or if you want to implement your custom rules. "
"In the following example, we write an implementation for `PartialEq` in "
"which we consider that two rectangles are equal if they have the same area:"
msgstr ""
"Türünüz için PartialEq özelliğinin kendi uygulamanızı yazabilirsiniz, eğer "
"türetemezseniz veya özel kurallarınızı uygulamak istiyorsanız. Aşağıdaki "
"örnekte, iki dikdörtgenin aynı alana sahip olması durumunda eşit olduğunu "
"düşündüğümüz PartialEq için bir uygulama yazıyoruz:"

#: src/appendix-03-derivable-traits.md:145
msgid "\"Are rect1 and rect2 equal? {}\""
msgstr "\"Rekt1 ve rekt2 eşit mi?\""

#: src/appendix-03-derivable-traits.md:149
msgid ""
"The `PartialEq` trait is required when using the `assert_eq!` macro in "
"tests, which needs to be able to compare two instances of a type for "
"equality."
msgstr ""
"PartialEq özelliği, assert_eq! makrosunu testlerde kullanırken gereklidir, "
"bu da eşitlik için bir türün iki örneğini karşılaştırabilmelidir."

#: src/appendix-03-derivable-traits.md:162
msgid "\"Structs are different\""
msgstr "\"Yapılar farklı\""

#: src/appendix-03-derivable-traits.md:166
msgid "Serializing with `Serde`"
msgstr "Serde ile serileştirme"

#: src/appendix-03-derivable-traits.md:168
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` "
"functions for data structures defined in your crate. It allows you to "
"transform your structure into an array (or the opposite)."
msgstr ""
"Serde, kasanızda tanımlanan veri yapıları için serialize ve deserialize "
"işlevleri için özellik uygulamaları sağlar. Yapınızı bir diziye (veya tam "
"tersi) dönüştürmenizi sağlar."

#: src/appendix-03-derivable-traits.md:170
msgid ""
"**[Serialization](https://en.wikipedia.org/wiki/Serialization)** is a "
"process of transforming data structures into a format that can be easily "
"stored or transmitted. Let's say you are running a program and would like to "
"persist its state to be able to resume it later. To do this, you could take "
"each of the objects your program is using and save their information, for "
"example in a file. This is a simplified version of serialization. Now if you "
"want to resume your program with this saved state, you would perform "
"**deserialization**, which means loading the state of the objects from the "
"saved source."
msgstr ""
"**[Serialization](https://en.wikipedia.org/wiki/Serialization)** veri "
"yapılarını kolayca saklanabilen veya iletilebilen bir formata dönüştürme "
"işlemidir. Diyelim ki bir program çalıştırıyorsunuz ve daha sonra devam "
"edebilmek için durumunu sürdürmek istiyorsunuz. Şimdi bunu yapmak için, "
"programınızın kullandığı her bir nesneyi alıp, örneğin bir dosyadaki "
"bilgileri kaydetmek isteyebilirsiniz."

#: src/appendix-03-derivable-traits.md:172
msgid "For example:"
msgstr "Örneğin:"

#: src/appendix-03-derivable-traits.md:190
msgid "If you run the `main` function, the output will be:"
msgstr "main işlevini çalıştırırsanız, çıkış şöyle olacaktır:"

#: src/appendix-03-derivable-traits.md:196
msgid ""
"We can see here that our struct `A` has been serialized into the output "
"array. Note that the `serialize` function takes as argument a snapshot of "
"the type you want to convert into an array. This is why deriving `Drop` for "
"`A` is required here, as the `main` function keeps ownership of the "
"`first_struct` struct."
msgstr ""
"Burada A yapımızın çıktı dizisine seri hale getirildiğini görebiliriz. "
"serialize fonksiyonunun, bir diziye dönüştürmek istediğiniz türün bir anlık "
"görüntüsünü argüman olarak aldığını unutmayın. A için Drop türevinin burada "
"gerekli olmasının nedeni budur, çünkü main işlevi first_struct yapısının "
"mülkiyetini korur."

#: src/appendix-03-derivable-traits.md:198
msgid ""
"Also, we can use the `deserialize` function to convert the serialized array "
"back into our `A` struct."
msgstr ""
"Ayrıca, serileştirilmiş diziyi A yapımıza geri dönüştürmek için deserialize "
"işlevini kullanabiliriz."

#: src/appendix-03-derivable-traits.md:218
msgid ""
"Here we are converting a serialized array span back to the struct `A`. "
"`deserialize` returns an `Option` so we need to unwrap it. When using "
"`deserialize` we also need to specify the type we want to deserialize into."
msgstr ""
"Burada serileştirilmiş bir dizi aralığını A yapısına geri dönüştürüyoruz. "
"deserialize bir Option döndürür, bu yüzden onu açmamız gerekir. deserialize "
"kullanırken, deserialize etmek istediğimiz türü de belirtmemiz gerekir."

#: src/appendix-03-derivable-traits.md:220
msgid "Hashing with `Hash`"
msgstr "Hash ile karıştırma"

#: src/appendix-03-derivable-traits.md:222
msgid ""
"It is possible to derive the `Hash` trait on structs and enums. This allows "
"them to be hashed easily using any available hash function. For a struct or "
"an enum to derive the `Hash` attribute, all fields or variants need to be "
"hashable themselves."
msgstr ""
"Hash özelliğini structlar ve enumlar üzerinde türetmek mümkündür. Bu, mevcut "
"herhangi bir hash fonksiyonu kullanılarak kolayca haşlanmalarını sağlar. Bir "
"struct veya enum için Hash özniteliğini türetmek için, tüm alanların veya "
"varyantların kendilerinin haşlanabilir olması gerekir."

#: src/appendix-03-derivable-traits.md:224
msgid ""
"You can refer to the [Hashes section](ch11-04-hash.md) to get more "
"information about how to hash complex data types."
msgstr ""
"Karmaşık veri türlerinin nasıl özetleneceği hakkında daha fazla bilgi "
"edinmek için [Hashes bölümüne] (ch11-04-hash.md) başvurabilirsiniz."

#: src/appendix-03-derivable-traits.md:226
msgid "Starknet Storage with `starknet::Store`"
msgstr "starknet ile Starknet Depolama::Store"

#: src/appendix-03-derivable-traits.md:228
msgid ""
"The `starknet::Store` trait is relevant only when building on [Starknet]"
"(ch13-00-introduction-to-starknet-smart-contracts.md). It allows for a type "
"to be used in smart contract storage by automatically implementing the "
"necessary read and write functions."
msgstr ""
"starknet::Store özelliği yalnızca [Starknet](ch13-00-introduction-to-"
"starknet-smart-contracts.md) üzerinde kurulurken geçerlidir. Gerekli okuma "
"ve yazma işlevlerini otomatik olarak uygulayarak akıllı sözleşme "
"depolamasında bir türün kullanılmasını sağlar."

#: src/appendix-03-derivable-traits.md:230
msgid ""
"You can find detailed information about the inner workings of Starknet "
"storage in the [Contract storage section](ch14-01-contract-storage.md)."
msgstr ""
"Starknet depolamasının iç işleyişi hakkında ayrıntılı bilgileri [Contract "
"depolama bölümünde] (ch14-01-contract-storage.md) bulabilirsiniz."

#: src/appendix-04-cairo-prelude.md:1
msgid "Appendix D - The Cairo Prelude"
msgstr "Ek D - Kahire Prelüd"

#: src/appendix-04-cairo-prelude.md:3
msgid "Prelude"
msgstr "Prelude"

#: src/appendix-04-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data "
"types, and traits that are automatically brought into scope of every module "
"in a Cairo crate without needing explicit import statements. Cairo's prelude "
"provides the basic building blocks developers need to start Cairo programs "
"and writing smart contracts."
msgstr ""
"Kahire prelüd, açık ithalat ifadelerine ihtiyaç duymadan Kahire kasasındaki "
"her modülün kapsamına otomatik olarak getirilen yaygın olarak kullanılan "
"modüller, işlevler, veri türleri ve özelliklerin bir koleksiyonudur. Kahire "
"prelüd, geliştiricilerin Kahire programlarını başlatması ve akıllı "
"sözleşmeler yazması için ihtiyaç duydukları temel yapı bloklarını sağlar."

#: src/appendix-04-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the _[lib.cairo](https://github.com/"
"starkware-libs/cairo/blob/main/corelib/src/lib.cairo)_ file of the corelib "
"crate and contains Cairo's primitive data types, traits, operators, and "
"utility functions. This includes:"
msgstr ""
"Çekirdek kütüphane prelüd _[lib.cairo](https://github.com/starkware-libs/"
"cairo/blob/main/corelib/src/lib.cairo)_ dosyasında tanımlanmıştır ve "
"Kahire'nin ilkel veri türlerini, özelliklerini, operatörlerini ve yardımcı "
"işlevlerini içerir. Buna şunlar dahildir:"

#: src/appendix-04-cairo-prelude.md:15
msgid "Data types: integers, bools, arrays, dicts, etc."
msgstr "Veri türleri: tam sayılar, bools, diziler, dicts, vb."

#: src/appendix-04-cairo-prelude.md:16
msgid ""
"Traits: behaviors for arithmetic, comparison, and serialization operations"
msgstr ""
"Özellikleri: Aritmetik, karşılaştırma ve serileştirme işlemleri için "
"davranışlar"

#: src/appendix-04-cairo-prelude.md:17
msgid "Operators: arithmetic, logical, bitwise"
msgstr "Operatörler: aritmetik, mantıksal, bitwise"

#: src/appendix-04-cairo-prelude.md:18
msgid "Utility functions - helpers for arrays, maps, boxing, etc."
msgstr "Yardımcı fonksiyonlar - diziler, haritalar, boks vb. için yardımcılar."

#: src/appendix-04-cairo-prelude.md:20
msgid ""
"The core library prelude delivers the fundamental programming constructs and "
"operations needed for basic Cairo programs, without requiring the explicit "
"import of elements. Since the core library prelude is automatically "
"imported, its contents are available for use in any Cairo crate without "
"explicit imports. This prevents repetition and provides a better devX. This "
"is what allows you to use `ArrayTrait::append()` or the `Default` trait "
"without bringing them explicitly into scope."
msgstr ""
"Çekirdek kütüphane önlüğü, temel Kahire programları için gerekli temel "
"programlama yapılarını ve işlemleri, öğelerin açık bir şekilde içe "
"aktarılmasını gerektirmeden sunar. Çekirdek kütüphane önlüğü otomatik olarak "
"içe aktarıldığından, içeriği açık bir şekilde içe aktarılmadan herhangi bir "
"Kahire kasasında kullanılabilir. Bu tekrarlamayı önler ve daha iyi bir devX "
"sağlar. ArrayTrait::append() veya Default özelliğini açıkça kapsamadan "
"kullanmanızı sağlayan şey budur."

#: src/appendix-04-cairo-prelude.md:28
msgid ""
"You can choose which prelude to use. For example, adding `edition = "
"\"2023_11\"` in the _Scarb.toml_ configuration file will load the prelude "
"from November 2023. Note that when you create a new project using `scarb "
"new` command, the _Scarb.toml_ file will automatically include `edition = "
"\"2023_11\"`."
msgstr ""
"Hangi önbelleği kullanacağınızı seçebilirsiniz. Örneğin, _Scarb.toml_ "
"yapılandırma dosyasına edition = \"2023_11\" eklenmesi, önbelleği Kasım "
"2023'ten itibaren yükleyecektir. scarb new komutunu kullanarak yeni bir "
"proje oluşturduğunuzda, _Scarb.toml_ dosyasının otomatik olarak edition = "
"\"2023_11\" içereceğini unutmayın."

#: src/appendix-04-cairo-prelude.md:30
msgid "The compiler currently exposes 2 different versions of the prelude:"
msgstr "Derleyici şu anda prelüdün 2 farklı sürümünü açığa çıkarır:"

#: src/appendix-04-cairo-prelude.md:32
msgid ""
"A general version, with a lot of traits that are made available, "
"corresponding to `edition = \"2023_01\"`."
msgstr ""
"edition = \"2023_01\"'e karşılık gelen, kullanılabilir hale getirilen birçok "
"özelliğe sahip genel bir sürüm."

#: src/appendix-04-cairo-prelude.md:33
msgid ""
"A restricted version, including the most essential traits needed for general "
"Cairo programming, corresponding to `edition = 2023_11`."
msgstr ""
"edition = 2023_11'ye karşılık gelen, genel Kahire programlaması için gerekli "
"olan en temel özellikler de dahil olmak üzere sınırlı bir sürüm."

#: src/appendix-05-common-error-messages.md:1
msgid "Appendix E - Common Error Messages"
msgstr "Ek E - Ortak Hata Mesajları"

#: src/appendix-05-common-error-messages.md:3
msgid ""
"You might encounter error messages when writing Cairo code. Some of them "
"occur very frequently, which is why we will be listing the most common error "
"messages in this appendix to help you resolve common issues."
msgstr ""
"Kahire kodunu yazarken hata mesajlarıyla karşılaşabilirsiniz. Bazıları çok "
"sık meydana gelir, bu nedenle ortak sorunları çözmenize yardımcı olmak için "
"bu ekteki en yaygın hata mesajlarını listeleyeceğiz."

#: src/appendix-05-common-error-messages.md:5
msgid ""
"`Variable not dropped.`: this error message means that you are trying to "
"make a variable with a type that do not implement the `Drop` trait go out of "
"scope, withtout destroying it. Make sure that variables that need to be "
"dropped at the end of the execution of a function implement the `Drop` trait "
"or the `Destruct` trait. See [Ownership](ch04-01-what-is-ownership."
"md#destroying-values---example-with-feltdict) section."
msgstr ""
"Variable not drop.: Bu hata mesajı, Drop özelliğini uygulamayan bir türe "
"sahip bir değişkeni kapsam dışına çıkarmaya çalıştığınız anlamına gelir, onu "
"yok eder. Bir fonksiyonun yürütülmesinin sonunda düşmesi gereken "
"değişkenlerin Drop özelliğini veya Destruct-what-what-whonest özelliğini "
"uyguladığından emin olun."

#: src/appendix-05-common-error-messages.md:7
msgid ""
"`Variable was previously moved.`: this error message means that you are "
"trying to use a variable whose ownership has already been transferred to "
"another function. When a variable doesn't implement the `Copy` trait, it is "
"passed by value to functions, and ownership of the variable is transferred "
"to the function. Such a variable cannot be used anymore in the current "
"context after its ownership has been transferred. It is often useful to use "
"the `clone` method in this situation."
msgstr ""
"Variable daha önce taşındı.: Bu hata mesajı, sahipliği zaten başka bir "
"fonksiyona aktarılan bir değişkeni kullanmaya çalıştığınız anlamına gelir. "
"Bir değişken Copy özelliğini uygulamadığında, fonksiyona değer tarafından "
"geçirilir ve değişkenin mülkiyeti fonksiyona aktarılır. Böyle bir değişken, "
"sahipliği aktarıldıktan sonra mevcut bağlamda kullanılamaz. Bu yöntemde "
"clone kullanımı genellikle yararlıdır."

#: src/appendix-05-common-error-messages.md:9
msgid ""
"`error: Trait has no implementation in context: core::fmt::Display::"
"<package_name::struct_name>`: this error message is encountered if you try "
"to print an instance of a custom data type with `{}` placeholders in a "
"`print!` or `println!` macro. To mitigate this issue, you need to either "
"manually implement the `Display` trait for your type, or use the `Debug` "
"trait by applying `derive(Debug)` to your type, allowing to print your "
"instance by adding `:?` in `{}` placeholders."
msgstr ""
"error: Trait'in bağlamda bir uygulaması yoktur: core::fmt::Display::"
"package_name:::struct_name>:  print! veya println! makro. Bu sorunu "
"hafifletmek için, Display özelliğinizi manuel olarak uygulamanız gerekir."

#: src/appendix-05-common-error-messages.md:11
msgid ""
"`Got an exception while executing a hint: Hint Error: Failed to deserialize "
"param #x.`: this error means that the execution failed because an entrypoint "
"was called without the expected arguments. Make sure that the arguments you "
"provide when calling an entrypoint are correct. There is a classic issue "
"with `u256` variables, which are actually structs of 2 `u128`. Therefore, "
"when calling a function that takes a `u256` as argument, you need to pass 2 "
"values."
msgstr ""
"Bir ipucu çalıştırırken bir istisna var: İpucu Hatası: Param # x'i "
"deserialize etmek için başarısız.: Bu hata, yürütmenin başarısız olduğu "
"anlamına gelir çünkü bir giriş noktası beklenen argümanlar olmadan "
"çağrılmıştır. Bir giriş noktasını çağırırken verdiğiniz argümanların doğru "
"olduğundan emin olun. u256 değişkenleriyle ilgili klasik bir sorun var, "
"aslında 2 u128'nin yapıtlarıdır. Bu nedenle, bir fonksiyona ihtiyaç "
"duyduğunuzda,"

#: src/appendix-05-common-error-messages.md:13
msgid ""
"`Item path::item is not visible in this context.`: this error message lets "
"us know that the path to bring an item into scope is correct, but there is a "
"vibility issue. In cairo, all items are private to parent modules by "
"default. To resolve this issue, make sure that all the modules on the path "
"to items and items themselves are declared with `pub(crate)` or `pub` to "
"have access to them."
msgstr ""
"Item yolu:: item bu bağlamda görünür değildir.: bu hata mesajı bize bir "
"öğeyi kapsama alanına getirme yolunun doğru olduğunu, ancak bir uygunluk "
"sorunu olduğunu bildirir. cairo'da, tüm öğeler varsayılan olarak ana "
"modüllere özeldir. Bu sorunu çözmek için, öğelere ve öğelere giden yoldaki "
"tüm modüllerin kendilerine erişmesi için pub(krate) veya pub ile ilan "
"edildiğinden emin olun."

#: src/appendix-05-common-error-messages.md:15
msgid ""
"`Identifier not found.`: this error message is a bit aspecific but might "
"indicate that:"
msgstr ""
"Tanımlayıcı bulunamadı.: bu hata mesajı biraz spesifiktir, ancak şunları "
"gösterebilir:"

#: src/appendix-05-common-error-messages.md:16
msgid ""
"A variable is being used before it has been declared. Make sure to declare "
"variables with the `let` keyword."
msgstr ""
"Bildirilmeden önce bir değişken kullanılıyor. let anahtar kelimesi ile "
"değişkenleri beyan etmeyi unutmayın."

#: src/appendix-05-common-error-messages.md:17
msgid ""
"The path to bring an item into scope is wrongly defined. Make sure to use "
"valid paths."
msgstr ""
"Bir öğeyi kapsama alanına getirme yolu yanlış tanımlanmıştır. Geçerli "
"yolları kullandığınızdan emin olun."

#: src/appendix-05-common-error-messages.md:19
msgid "Starknet Components Related Error Messages"
msgstr "Starknet Bileşenleri İlgili Hata Mesajları"

#: src/appendix-05-common-error-messages.md:21
msgid ""
"You might encounter some errors when trying to implement components. "
"Unfortunately, some of them lack meaningful error messages to help debug. "
"This section aims to provide you with some pointers to help you debug your "
"code."
msgstr ""
"Bileşenleri uygulamaya çalışırken bazı hatalarla karşılaşabilirsiniz. Ne "
"yazık ki, bazıları hata ayıklamaya yardımcı olmak için anlamlı hata "
"mesajlarından yoksundur. Bu bölüm, kodunuzu hata ayıklamanıza yardımcı "
"olacak bazı işaretçiler sağlamayı amaçlamaktadır."

#: src/appendix-05-common-error-messages.md:25
msgid ""
"`Trait not found. Not a trait.`: this error can occur when you're not "
"importing the component's impl block correctly in your contract. Make sure "
"to respect the following syntax:"
msgstr ""
"Trait bulunamadı. Bir özellik değil.: Bu hata, bileşenin impl bloğunu "
"sözleşmenizde doğru bir şekilde içe aktarmadığınızda ortaya çıkabilir. "
"Aşağıdaki sözdizimlerine saygı gösterdiğinizden emin olun:"

#: src/appendix-05-common-error-messages.md:33
msgid ""
"`Plugin diagnostic: name is not a substorage member in the contract's "
"Storage. Consider adding to Storage: (...)`: the compiler helps you a lot "
"debugging this by giving you recommendation on the action to take. "
"Basically, you forgot to add the component's storage to your contract's "
"storage. Make sure to add the path to the component's storage annotated with "
"the `#[substorage(v0)]` attribute to your contract's storage."
msgstr ""
"Plugin diagnostic: name is not a substorage member in the contract's "
"Storage. Storage'a eklemeyi düşünün: (...): derleyici size eylem hakkında "
"tavsiye vererek bunu hata ayıklamanıza yardımcı olur. Temel olarak, "
"bileşenin depolamasını sözleşmenizin deposuna eklemeyi unuttunuz. "
"#[substorages] özniteliğinizle belirtilen bileşenin depolamasına yol "
"eklediğinizden emin olun."

#: src/appendix-05-common-error-messages.md:35
msgid ""
"`Plugin diagnostic: name is not a nested event in the contract's Event enum. "
"Consider adding to the Event enum:` similar to the previous error, the "
"compiler tells you that you forgot to add the component's events to your "
"contract's events. Make sure to add the path to the component's events to "
"your contract's events."
msgstr ""
"Plugin diagnostik: ad, sözleşmenin Etkinlik enum'unda yerleşik bir olay "
"değildir. Olay enum'una eklemeyi düşünün: önceki hataya benzer şekilde, "
"derleyici, bileşenin olaylarını sözleşmenizin etkinliklerine eklemeyi "
"unuttuğunuzu söyler. Bileşenin olaylarını sözleşmenizin etkinliklerine "
"eklediğinizden emin olun."

#: src/appendix-06-useful-development-tools.md:1
msgid "Appendix F - Useful Development Tools"
msgstr "Ek F - Faydalı Geliştirme Araçları"

#: src/appendix-06-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo "
"project provides. We’ll look at automatic formatting, quick ways to apply "
"warning fixes, a linter, and integrating with IDEs."
msgstr ""
"Bu ekte, Kahire projesinin sağladığı bazı yararlı geliştirme araçlarından "
"bahsediyoruz. Otomatik biçimlendirmeye, uyarı düzeltmelerini uygulamanın "
"hızlı yollarına, bir linter'a ve IDE'lerle bütünleşmeye bakacağız."

#: src/appendix-06-useful-development-tools.md:7
msgid "Automatic Formatting with `scarb fmt`"
msgstr "scarb fmt ile otomatik biçimlendirme"

#: src/appendix-06-useful-development-tools.md:9
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command. If you're "
"using the Cairo binaries directly, you can run `cairo-format` instead. Many "
"collaborative projects use `scarb fmt` to prevent arguments about which "
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""
"Scarb projeleri scarb fmt komutu kullanılarak biçimlendirilebilir. Kahire "
"ikililerini doğrudan kullanıyorsanız, bunun yerine cairo-format "
"çalıştırabilirsiniz. Birçok işbirlikçi proje, Kahire'yi yazarken hangi stili "
"kullanacağına dair argümanları önlemek için scarb fmt kullanır: herkes aracı "
"kullanarak kodlarını biçimlendirir."

#: src/appendix-06-useful-development-tools.md:14
msgid ""
"To format any Cairo project, enter the following inside the project "
"directory:"
msgstr ""
"Herhangi bir Kahire projesini biçimlendirmek için, proje dizininin içine "
"aşağıdakileri girin:"

#: src/appendix-06-useful-development-tools.md:20
msgid "IDE Integration Using `cairo-language-server`"
msgstr "IDE Entegrasyon cairo-language-server kullanarak"

#: src/appendix-06-useful-development-tools.md:22
msgid ""
"To help IDE integration, the Cairo community recommends using the [`cairo-"
"language-server`](https://github.com/starkware-libs/cairo/tree/main/crates/"
"cairo-lang-language-server)<!-- ignore -->. This tool is a set of compiler-"
"centric utilities that speaks the [Language Server Protocol](http://"
"langserver.org/)<!--\n"
"ignore -->, which is a specification for IDEs and programming languages to "
"communicate with each other. Different clients can use `cairo-language-"
"server`, such as [the Cairo extension for Visual Studio Code](https://"
"marketplace.visualstudio.com/items?itemName=starkware.cairo1)."
msgstr ""
"IDE entegrasyonuna yardımcı olmak için, Kahire topluluğu [cairo-language-"
"server](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-"
"language-server]!-- görmezden gelin --> için [Language Server Protocol]"
"(http://lang.org/) görmezden gelinen bir derleyici-merkezli yardımcı program "
"kümesidir."

#: src/appendix-06-useful-development-tools.md:32
msgid ""
"Visit the `vscode-cairo` [page](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1)<!-- ignore --> to install it on VSCode. You will "
"get abilities such as autocompletion, jump to definition, and inline errors."
msgstr ""
"vscode-cairo [sayfa](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1)!-- görmezden gelin -> VSCode'a yüklemek için. "
"Otomatik tamamlama, tanıma atlama ve satır içi hatalar gibi yetenekler elde "
"edeceksiniz."

#: src/appendix-06-useful-development-tools.md:38
msgid ""
"Note: If you have Scarb installed, it should work out of the box with the "
"Cairo VSCode extension, without a manual installation of the language server."
msgstr ""
"Not: Scarb yüklüyse, dil sunucusunun manuel kurulumu olmadan Kahire VSCode "
"uzantısı ile kutunun dışında çalışmalıdır."

#: src/appendix-07-cairo-binaries.md:1
msgid "Appendix G - Installing the Cairo Binaries"
msgstr "Ek G - Kahire Binarylerinin Kurulması"

#: src/appendix-07-cairo-binaries.md:3
msgid ""
"If you want to have access to the Cairo binaries, for anything that you "
"could not achieve by purely using Scarb you can install them by following "
"the instructions below."
msgstr ""
"Kahire ikililerine erişmek istiyorsanız, sadece Scarb'ı kullanarak elde "
"edemeyeceğiniz herhangi bir şey için aşağıdaki talimatları izleyerek bunları "
"yükleyebilirsiniz."

#: src/appendix-07-cairo-binaries.md:5
msgid "Prerequisites"
msgstr "Önkoşullar"

#: src/appendix-07-cairo-binaries.md:7
msgid ""
"You will need to have [Rust](https://www.rust-lang.org) and [Git](https://"
"git-scm.com/) installed."
msgstr ""
"[Rust](https://www.rust-lang.org) ve [Git](https://git-scm.com/) yüklü "
"olması gerekir."

#: src/appendix-07-cairo-binaries.md:9
msgid ""
"To install Rust, you first need the [`rustup`](https://www.rust-lang.org/"
"tools/install) tool. It allows you to install Rust using the following "
"command:"
msgstr ""
"Rust'ı yüklemek için önce [rustup](https://www.rust-lang.org/tools/install) "
"aracına ihtiyacınız var. Rust'ı aşağıdaki komutu kullanarak yüklemenizi "
"sağlar:"

#: src/appendix-07-cairo-binaries.md:11
msgid "# Install stable Rust\n"
msgstr "# Kararlı Rust takın\n"

#: src/appendix-07-cairo-binaries.md:15
msgid ""
"Follow the link for information on how to install [Git](https://git-scm.com/"
"downloads)."
msgstr ""
"[Git] nasıl kurulacağı hakkında bilgi için bağlantıyı takip edin(https://git-"
"scm.com/downloads)."

#: src/appendix-07-cairo-binaries.md:17
msgid ""
"The next step is to install Cairo. We will download Cairo manually, using "
"Cairo repository or with an installation script. You’ll need an internet "
"connection for the download."
msgstr ""
"Bir sonraki adım Kahire'yi kurmaktır. Kahire'yi manuel olarak, Kahire "
"deposunu kullanarak veya bir kurulum senaryosuyla indireceğiz. İndirmek için "
"bir internet bağlantısına ihtiyacınız olacak."

#: src/appendix-07-cairo-binaries.md:19
msgid ""
"Installing Cairo with a Script ([Installer](https://github.com/franalgaba/"
"cairo-installer) by [Fran](https://github.com/franalgaba))"
msgstr ""
"[Fran](https://github.com/franalgaba/cairo-installer) tarafından Kahire'yi "
"bir Script ([Installer]) ile yüklemek"

#: src/appendix-07-cairo-binaries.md:21
msgid "Install"
msgstr "Yükle"

#: src/appendix-07-cairo-binaries.md:23
msgid ""
"If you wish to install a specific release of Cairo rather than the latest "
"head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export "
"CAIRO_GIT_TAG=v2.5.1`)."
msgstr ""
"Kahire'nin en son kafa yerine belirli bir sürümünü yüklemek istiyorsanız, "
"CAIRO_GIT_TAG ortam değişkenini (örneğin export CAIRO_GIT_TAG=v2.5.1) "
"ayarlayın."

#: src/appendix-07-cairo-binaries.md:29
msgid ""
"After installing, follow [these instructions](#set-up-your-shell-environment-"
"for-cairo) to set up your shell environment."
msgstr ""
"Kurulumdan sonra, kabuk ortamınızı kurmak için [#set-up-your-shell-"
"environment-for-cairo] 'yu izleyin."

#: src/appendix-07-cairo-binaries.md:31
msgid "Update"
msgstr "Güncelle"

#: src/appendix-07-cairo-binaries.md:33
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-"
"installer | bash\n"
"```"
msgstr ""
"rm -fr /.cairo curl -L https://github.com/franalgaba/cairo-installer/raw/"
"main/bin/cairo-installer  bash"

#: src/appendix-07-cairo-binaries.md:38
msgid "Uninstall"
msgstr "Kaldır"

#: src/appendix-07-cairo-binaries.md:40
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, "
"just remove it:"
msgstr ""
"Kahire, $CAIRO_ROOT (varsayılan: /.cairo) içinde kuruludur. Kaldırmak için, "
"sadece kaldırın:"

#: src/appendix-07-cairo-binaries.md:46
msgid "then remove these three lines from .bashrc:"
msgstr "Sonra bu üç satırı.bashrc'den kaldırın:"

#: src/appendix-07-cairo-binaries.md:49
msgid "\"$HOME/.cairo/target/release:$PATH\""
msgstr "\"$HOME/.cairo/target/release:$PATH\" (İngilizce)."

#: src/appendix-07-cairo-binaries.md:52
msgid "and finally, restart your shell:"
msgstr "ve son olarak, kabuğunuzu yeniden başlatın:"

#: src/appendix-07-cairo-binaries.md:58
msgid "Set Up your Shell Environment for Cairo"
msgstr "Kahire için Kabuk Ortamını Ayarla"

#: src/appendix-07-cairo-binaries.md:60
msgid ""
"Define environment variable `CAIRO_ROOT` to point to the path where Cairo "
"will store its data. `$HOME/.cairo` is the default. If you installed Cairo "
"via Git checkout, we recommend to set it to the same location as where you "
"cloned it."
msgstr ""
"Kahire'nin verilerini saklayacağı yolu işaret etmek için CAIRO_ROOT ortam "
"değişkenini tanımla. $HOME/.cairo varsayılandır. Git checkout üzerinden "
"Kahire'yi kurduysanız, onu klonladığınız yerle aynı konuma ayarlamanızı "
"tavsiye ederiz."

#: src/appendix-07-cairo-binaries.md:64
msgid "Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr ""
"cairo-* çalıştırılabilirlerini PATH dosyanıza ekleyin, eğer zaten orada "
"değilse"

#: src/appendix-07-cairo-binaries.md:66
msgid ""
"The below setup should work for the vast majority of users for common use "
"cases."
msgstr ""
"Aşağıdaki kurulum, kullanıcıların büyük çoğunluğu için ortak kullanım "
"durumları için çalışmalıdır."

#: src/appendix-07-cairo-binaries.md:68
msgid "For **bash**:"
msgstr "** bash ** için:"

#: src/appendix-07-cairo-binaries.md:70
msgid ""
"Stock Bash startup files vary widely between distributions in which of them "
"source which, under what circumstances, in what order and what additional "
"configuration they perform. As such, the most reliable way to get Cairo in "
"all environments is to append Cairo configuration commands to both `.bashrc` "
"(for interactive shells) and the profile file that Bash would use (for login "
"shells)."
msgstr ""
"Stock Bash başlangıç dosyaları, hangi koşullarda hangi sırayla ve hangi ek "
"yapılandırmayı gerçekleştirdikleri konusunda kaynak olan dağıtımlar arasında "
"büyük farklılıklar gösterir. Bu nedenle, Kahire'yi tüm ortamlarda almanın en "
"güvenilir yolu, Kahire yapılandırma komutlarını hem.bashrc'ye (interaktif "
"kabuklar için) hem de Bash'in kullanacağı profil dosyasına (giriş kabukları "
"için) eklemektir."

#: src/appendix-07-cairo-binaries.md:76
msgid ""
"First, add the commands to `~/.bashrc` by running the following in your "
"terminal:"
msgstr ""
"İlk olarak, terminalinizde aşağıdaki komutları çalıştırarak /.bashrc "
"komutlarını ekleyin:"

#: src/appendix-07-cairo-binaries.md:79 src/appendix-07-cairo-binaries.md:89
#: src/appendix-07-cairo-binaries.md:95 src/appendix-07-cairo-binaries.md:102
msgid "'export CAIRO_ROOT=\"$HOME/.cairo\"'"
msgstr "'ihracat CAIRO_ROOT=\"$HOME/.cairo\""

#: src/appendix-07-cairo-binaries.md:80 src/appendix-07-cairo-binaries.md:90
#: src/appendix-07-cairo-binaries.md:96 src/appendix-07-cairo-binaries.md:103
msgid ""
"'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"'"
msgstr ""
"'command -v cairo-combile>/dev/null  export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"\"\""

#: src/appendix-07-cairo-binaries.md:83
msgid ""
"Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add "
"the commands there as well. If you have none of these, add them to `~/."
"profile`."
msgstr ""
"Daha sonra, /.profile, /.bash_profile veya /.bash_login komutlarınız varsa, "
"komutları da ekleyin. Bunlardan hiçbiriniz yoksa, bunları /.profile'e "
"ekleyin."

#: src/appendix-07-cairo-binaries.md:86
msgid "to add to `~/.profile`:"
msgstr "/.profile'a eklemek için:"

#: src/appendix-07-cairo-binaries.md:93
msgid "to add to `~/.bash_profile`:"
msgstr "/.bash_profile'a eklemek için:"

#: src/appendix-07-cairo-binaries.md:99
msgid "For **Zsh**:"
msgstr "**Zsh ** için:"

#: src/appendix-07-cairo-binaries.md:106
msgid ""
"If you wish to get Cairo in non-interactive login shells as well, also add "
"the commands to `~/.zprofile` or `~/.zlogin`."
msgstr ""
"Kahire'yi etkileşimli olmayan giriş kabuklarında da almak istiyorsanız, "
"komutları /.zprofile veya /.zlogin'ye de ekleyin."

#: src/appendix-07-cairo-binaries.md:108
msgid "For **Fish shell**:"
msgstr "**Balık kabuğu **:"

#: src/appendix-07-cairo-binaries.md:110
msgid "If you have Fish 3.2.0 or newer, execute this interactively:"
msgstr ""
"Eğer Balık 3.2.0 veya daha yenisi varsa, bunu etkileşimli olarak "
"gerçekleştirin:"

#: src/appendix-07-cairo-binaries.md:117
msgid "Otherwise, execute the snippet below:"
msgstr "Aksi takdirde, aşağıdaki snippet'i çalıştırın:"

#: src/appendix-07-cairo-binaries.md:124
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which "
"provides alternative shell completions for many command line tools with an "
"IDE-like popup interface in the terminal window. (Note that their "
"completions are independent of Cairo's codebase so they might be slightly "
"out of sync for bleeding-edge interface changes.)"
msgstr ""
"MacOS'ta, terminal penceresinde IDE benzeri bir açılır arayüze sahip birçok "
"komut satırı aracı için alternatif kabuk tamamlamaları sağlayan [Fig]"
"(https://fig.io/) 'yı da yüklemek isteyebilirsiniz. (Tamamlamalarının "
"Kahire'nin kod tabanından bağımsız olduğunu unutmayın, böylece kanamalı "
"kenar arayüzü değişiklikleri için biraz senkronize olmayabilirler.)"

#: src/appendix-07-cairo-binaries.md:130
msgid "Restart your Shell"
msgstr "Kabuğunuzu Yeniden Başlatın"

#: src/appendix-07-cairo-binaries.md:132
msgid "for the `PATH` changes to take effect."
msgstr "PATH değişikliklerinin yürürlüğe girmesi için."

#: src/appendix-07-cairo-binaries.md:135
msgid "\"$SHELL\""
msgstr "\"$SHELL\""

#: src/appendix-07-cairo-binaries.md:138
msgid ""
"Installing Cairo Manually ([Guide](https://github.com/auditless/cairo-"
"template) by [Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""
"Kahire'yi [Guide] [https://github.com/auitless/cairo-template] [Abdel] "
"tarafından manuel olarak yüklemek (https://github.com/abdelhamidbakhta)"

#: src/appendix-07-cairo-binaries.md:140
msgid "Step 1: Install Cairo 1.0"
msgstr "Adım 1: Kahire 1.0'ı yükleyin"

#: src/appendix-07-cairo-binaries.md:142
msgid ""
"If you are using an x86 Linux system and can use the release binary, "
"download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""
"Bir x86 Linux sistemi kullanıyorsanız ve sürüm ikilisini "
"kullanabiliyorsanız, Kahire'yi buradan indirebilirsiniz: https://github.com/"
"starkware-libs/cairo/releases>."

#: src/appendix-07-cairo-binaries.md:144
msgid "For everyone else, we recommend compiling Cairo from source as follows:"
msgstr ""
"Diğer herkes için, Kahire'yi aşağıdaki gibi kaynaktan derlemenizi tavsiye "
"ederiz:"

#: src/appendix-07-cairo-binaries.md:147
msgid "# Start by defining environment variable CAIRO_ROOT\n"
msgstr "# Çevre değişkeni CAIRO_ROOT'u tanımlayarak başlayın\n"

#: src/appendix-07-cairo-binaries.md:148
msgid "\"${HOME}/.cairo\""
msgstr "\"$HOME/.cairo\" (İngilizce)."

#: src/appendix-07-cairo-binaries.md:149
msgid "# Create .cairo folder if it doesn't exist yet\n"
msgstr "# Henüz mevcut değilse.cairo klasörü oluştur\n"

#: src/appendix-07-cairo-binaries.md:152
msgid "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
msgstr "# Kahire derleyicisini $CAIRO_ROOT ile klonla (varsayılan kök)\n"

#: src/appendix-07-cairo-binaries.md:155
msgid ""
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the "
"compiler\n"
"# Fetch all tags (versions)\n"
msgstr ""
"# OPTIONAL/RECOMMENDED: Derleyicinin belirli bir sürümünü yüklemek "
"istiyorsanız # Tüm etiketleri alın (sürümler)\n"

#: src/appendix-07-cairo-binaries.md:158
msgid "# View tags (you can also do this in the Cairo compiler repository)\n"
msgstr ""
"# Etiketleri görüntüleyin (bunu Kahire derleyici deposunda da "
"yapabilirsiniz)\n"

#: src/appendix-07-cairo-binaries.md:160
msgid "# Checkout the version you want\n"
msgstr "# İstediğiniz versiyonu kontrol edin\n"

#: src/appendix-07-cairo-binaries.md:163
msgid "# Generate release binaries\n"
msgstr "# Serbest bırakma ikilileri oluştur\n"

#: src/appendix-07-cairo-binaries.md:168
msgid "."
msgstr "."

#: src/appendix-07-cairo-binaries.md:170
msgid "**NOTE: Keeping Cairo up to date**"
msgstr "**NOT: Kahire'yi güncel tutmak **"

#: src/appendix-07-cairo-binaries.md:172
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to "
"do is pull the latest changes and rebuild as follows:"
msgstr ""
"Artık Kahire derleyiciniz klonlanmış bir depoda olduğuna göre, yapmanız "
"gereken tek şey en son değişiklikleri çekmek ve aşağıdaki gibi yeniden inşa "
"etmektir:"

#: src/appendix-07-cairo-binaries.md:179
msgid "Step 2: Add Cairo 1.0 Executables to Your Path"
msgstr "Adım 2: Yolunuza Kahire 1.0 Executables ekleyin"

#: src/appendix-07-cairo-binaries.md:182
msgid "\"$CAIRO_ROOT/target/release:$PATH\""
msgstr "\"$CAIRO_ROOT/hedef/release:$PATH\" (İngilizce)."

#: src/appendix-07-cairo-binaries.md:185
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path "
"accordingly.**"
msgstr ""
"**NOT: Bir Linux ikilisinden yükleniyorsa, hedef yolu buna göre uyarlayın. **"

#: src/appendix-07-cairo-binaries.md:187
msgid "Step 3: Setup Language Server"
msgstr "Adım 3: Dil Sunucusu Kur"

#: src/appendix-07-cairo-binaries.md:189
msgid "VS Code Extension"
msgstr "VS Kod Uzantısı"

#: src/appendix-07-cairo-binaries.md:191
msgid ""
"If you have the previous Cairo 0 extension installed, you can disable/"
"uninstall it."
msgstr ""
"Önceki Kahire 0 uzantısı yüklüyse, devre dışı bırakabilir / "
"kaldırabilirsiniz."

#: src/appendix-07-cairo-binaries.md:192
msgid ""
"Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation. You can find the link to the extension [here](https://"
"marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false), or "
"just search for \"Cairo 1.0\" in the VS Code marketplace."
msgstr ""
"Uygun sözdizimi vurgulama ve kod navigasyonu için Kahire 1 uzantısını "
"yükleyin. [burada] uzantısının bağlantısını bulabilirsiniz (https://"
"marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false), "
"veya sadece VS Code pazarında \"Cairo 1.0\" için arama yapın."

#: src/appendix-07-cairo-binaries.md:193
msgid ""
"The extension will work out of the box once you will have [Scarb](./ch01-03-"
"hello-scarb.md) installed."
msgstr ""
"Uzantı, [Scarb](./ch01-03-hello-scarb.md) yüklendikten sonra kutudan çıkacak."

#: src/appendix-07-cairo-binaries.md:195
msgid "Cairo Language Server without Scarb"
msgstr "Scarb olmadan Kahire Dil Sunucusu"

#: src/appendix-07-cairo-binaries.md:197
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language "
"Server with the compiler binary. From [Step 1](#installing-cairo-with-a-"
"script-installer-by-fran), the `cairo-language-server` binary should be "
"built and executing this command will copy its path into your clipboard."
msgstr ""
"Scarb'a bağlı kalmak istemiyorsanız, yine de derleyici ikilisiyle Kahire Dil "
"Sunucusu'nu kullanabilirsiniz. [Adım 1](#installing-cairo-with-a-script-"
"installer-by-fran), cairo-language-server ikilisi oluşturulmalı ve bu "
"komutun çalıştırılması yolunu panonuza kopyalayacaktır."

#: src/appendix-07-cairo-binaries.md:204
msgid ""
"Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting "
"the path."
msgstr ""
"Yolu yapıştırarak Kahire 1.0 uzantısının cairo1.languageServerPath'sini "
"güncelleyin."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"All through the previous sections, you've mostly written programs with a "
"`main` entrypoint. In the coming sections, you will learn to write and "
"deploy Starknet contracts."
msgstr ""
"Önceki bölümler boyunca çoğunlukla main giriş noktası olan programlar "
"yazdınız. Önümüzdeki bölümlerde Starknet sözleşmelerini yazmayı ve dağıtmayı "
"öğreneceksiniz."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"One of the key applications of the Cairo language is writing smart contracts "
"for the Starknet network. Starknet is a permissionless decentralized network "
"that leverages zk-STARKs technology for scalability. As a Layer 2 (L2) "
"scalability solution for Ethereum, Starknet aims to provide fast, secure, "
"and low-cost transactions. It operates as a validity rollup, commonly known "
"as a zero-knowledge rollup, and is built on top of the Cairo VM."
msgstr ""
"Kahire dilinin önemli uygulamalarından biri Starknet ağı için akıllı "
"sözleşmeler yazmaktır. Starknet, zk-STARKs teknolojisini ölçeklenebilirlik "
"için kullanan izinsiz merkezi olmayan bir ağdır. Ethereum için Katman 2 (L2) "
"ölçeklenebilirlik çözümü olarak, Starknet hızlı, güvenli ve düşük maliyetli "
"işlemler sağlamayı amaçlamaktadır. Yaygın olarak sıfır bilgili bir rulo "
"olarak bilinen geçerli bir rulo olarak çalışır ve Kahire VM'nin üzerine inşa "
"edilmiştir."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Starknet contracts are programs specifically designed to run within the "
"Starknet OS. The Starknet OS is a Cairo program itself, which means that any "
"operation executed by the Starknet OS can be proven and succinctly verified. "
"Smart contracts can access Starknet's persistent state through the OS, "
"enabling them to read or modify variables in Starknet’s state, communicate "
"with other contracts, and interact seamlessly with the underlying Layer 1 "
"(L1) network."
msgstr ""
"Starknet sözleşmeleri, Starknet OS içinde çalışacak şekilde özel olarak "
"tasarlanmış programlardır. Starknet OS, bir Kahire programıdır, bu da "
"Starknet OS tarafından yürütülen herhangi bir işlemin kanıtlanabileceği ve "
"kısa sürede doğrulanabileceği anlamına gelir. Akıllı sözleşmeler, "
"Starknet'in işletim sistemi aracılığıyla Starknet'in kalıcı durumuna "
"erişebilir, Starknet'in durumundaki değişkenleri okumalarını veya "
"değiştirmelerini sağlayabilir, diğer sözleşmelerle iletişim kurabilir ve "
"altta yatan Katman 1 (L1) ağıyla sorunsuz bir şekilde etkileşime girebilir."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"If you want to learn more about the Starknet network itself, its "
"architecture and the tooling available, you should read the [Starknet Book]"
"(https://book.starknet.io/). In this book, we will only focus on writing "
"smart contracts in Cairo."
msgstr ""
"Starknet ağının kendisi, mimarisi ve mevcut araç gereçler hakkında daha "
"fazla bilgi edinmek istiyorsanız [Starknet Kitabı]'nı (https://book.starknet."
"io/) okumalısınız. Bu kitapta sadece Kahire'de akıllı sözleşmeler yazmaya "
"odaklanacağız."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Scarb"
msgstr "Scarb"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Scarb facilitates smart contract development for Starknet. To enable this "
"feature, you'll need to make some configurations in your _Scarb.toml_ file "
"(see [Installation](./ch01-01-installation.md) for how to install Scarb)."
msgstr ""
"Scarb, Starknet için akıllı sözleşme geliştirmeyi kolaylaştırır. Bu özelliği "
"etkinleştirmek için, Scarb'ın nasıl kurulacağı için _Scarb.toml_ dosyanızda "
"bazı yapılandırmalar yapmanız gerekir (bkz. [Installation](./ch01-01-"
"installation.md))."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"First, add the `starknet` dependency to your _Scarb.toml_ file. Next, enable "
"the Starknet contract compilation of the package by adding a `[[target."
"starknet-contract]]` section. By default, specifying this target will build "
"a Sierra Contract Class file, which can be deployed on Starknet. If you omit "
"to specify the target, your package will compile but will not produce an "
"output that you can use with Starknet."
msgstr ""
"İlk olarak, starknet bağımlılığını _Scarb.toml_ dosyanıza ekleyin. Daha "
"sonra, bir [target.starknet-contract] bölümü ekleyerek paketin Starknet "
"sözleşme derlemesini etkinleştirin. Varsayılan olarak, bu hedefi belirtmek, "
"Starknet'te konuşlandırılabilecek bir Sierra Contract Class dosyası "
"oluşturacaktır. Hedefi belirtmeyi ihmal ederseniz, paketiniz derlenecek "
"ancak Stark ile kullanabileceğiniz bir çıktı üretmeyecektir."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Below is the minimal _Scarb.toml_ file required to compile a crate "
"containing Starknet contracts:"
msgstr ""
"Aşağıda Starknet sözleşmelerini içeren bir sandık derlemek için gereken "
"minimum _Scarb.toml_ dosyası bulunmaktadır:"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.6.3\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"toml [package] name = \"package_name\" version = \"0.1.0\" [bağımlılar] "
"starknet = \">=2.6.3\" [hedef.starknet-sözleşme]"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"To compile contracts defined in your package's dependencies, please refer to "
"the [Scarb documentation](https://docs.swmansion.com/scarb/docs/extensions/"
"starknet/contract-target.html#compiling-external-contracts)."
msgstr ""
"Paketinizin bağımlılıklarında tanımlanan sözleşmeleri derlemek için lütfen "
"[Scarb documentation](https://docs.swmansion.com/scarb/docs/extensions/"
"starknet/contract-target.html#compilling-external-contracts] adresine "
"bakınız."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid "Starknet Foundry"
msgstr "Starknet Dökümhanesi"

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"Starknet Foundry is a tool chain for Starknet smart contract development. It "
"supports many features, including writing and running tests with advanced "
"features, deploying contracts, interacting with the Starknet network, and "
"more."
msgstr ""
"Starknet Foundry, Starknet akıllı sözleşme geliştirme için bir araç "
"zinciridir. Gelişmiş özelliklere sahip testlerin yazılması ve "
"çalıştırılması, sözleşmelerin dağıtılması, Starknet ağıyla etkileşim ve daha "
"fazlası dahil olmak üzere birçok özelliği destekler."

#: src/ch13-00-introduction-to-starknet-smart-contracts.md
msgid ""
"We'll describe Starknet Foundry in more detail in [Chapter 17](./ch17-02-"
"testing-smart-contracts.md#testing-smart-contracts-with-starknet-foundry) "
"when discussing Starknet smart contract testing and security."
msgstr ""
"Starknet Foundry'yi Starknet akıllı sözleşme testi ve güvenliğini "
"tartışırken [Bölüm 17](./ch17-02-testing-smart-contracts.md#testing-smart-"
"contracts-with-starknet-foundry) 'de daha ayrıntılı olarak açıklayacağız."

#: src/ch13-01-general-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart contracts "
"are, what they are used for, and why blockchain developers would use Cairo "
"and Starknet. If you are already familiar with blockchain programming, feel "
"free to skip this chapter. The last part might still be interesting though."
msgstr ""
"Bu bölüm size akıllı sözleşmelerin ne olduğuna, ne için kullanıldıklarına ve "
"blok zinciri geliştiricilerinin neden Kahire ve Starknet kullanacağına dair "
"yüksek düzeyde bir giriş sağlayacaktır. Zaten blok zinciri programlamasını "
"biliyorsanız, bu bölümü atlamaktan çekinmeyin. Son bölüm yine de ilginç "
"olabilir."

#: src/ch13-01-general-introduction-to-smart-contracts.md:6
msgid "Smart Contracts"
msgstr "Akıllı Sözleşmeler"

#: src/ch13-01-general-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth "
"of Ethereum. Smart contracts are essentially programs deployed on a "
"blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that "
"are executed based on specific inputs. They primarily consist of two "
"components: storage and functions. Once deployed, users can interact with "
"smart contracts by initiating blockchain transactions containing execution "
"data (which function to call and with what input). Smart contracts can "
"modify and read the storage of the underlying blockchain. A smart contract "
"has its own address and is considered a blockchain account, meaning it can "
"hold tokens."
msgstr ""
"Akıllı sözleşmeler popülerlik kazandı ve Ethereum'un doğuşuyla daha yaygın "
"hale geldi. Akıllı sözleşmeler aslında bir blok zincirinde konuşlandırılmış "
"programlardır. \"Akıllı sözleşme\" terimi, \"akıllı\" veya \"sözleşmeler\" "
"değil, belirli girdilere dayalı olarak yürütülen kod ve talimatlar olduğu "
"için biraz yanıltıcıdır. Öncelikle iki bileşenden oluşurlar: depolama ve "
"işlevler. Kullanıldıktan sonra, kullanıcılar, yürütme verileri içeren (bir "
"blok zincirini çağırma işlevi ve akıllı girişi olan) blok zinciri "
"işlemlerini başlatarak akıllı sözleşmelerle etkileşime girebilirler."

#: src/ch13-01-general-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on "
"the blockchain. For example, on Ethereum and the [EVM-compatible ecosystem]"
"(https://ethereum.org/en/developers/docs/evm/), the most commonly used "
"language is Solidity, while on Starknet, it is Cairo. The way the code is "
"compiled also differs based on the blockchain. On Ethereum, Solidity is "
"compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then "
"into Cairo Assembly (CASM)."
msgstr ""
"Akıllı sözleşmeler yazmak için kullanılan programlama dili, blok zincirine "
"bağlı olarak değişir. Örneğin, Ethereum ve [EVM uyumlu ekosistem] (https://"
"ethereum.org/en/developers/docs/evm/), en yaygın kullanılan dil Solidity, "
"Starknet'te ise Kahire'dir. Kodun derlenme şekli de blok zincirine göre "
"değişir. Ethereum'da Solidity bytecode'a derlenir ve Kahire'ye derlenir."

#: src/ch13-01-general-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are "
"**permissionless**, meaning anyone can deploy a smart contract on the "
"network (within the context of a decentralized blockchain, of course). Smart "
"contracts are also **transparent**; the data stored by the smart contract is "
"accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write "
"smart contracts that use other smart contracts. Smart contracts can only "
"access and interact with data from the blockchain they are deployed on. They "
"require third-party software (called _oracles_) to access external data (the "
"price of a token for instance)."
msgstr ""
"Akıllı sözleşmeler birkaç benzersiz özelliğe sahiptir. ** izinsiz **, yani "
"herkes ağ üzerinde akıllı bir sözleşme yapabilir (merkezsiz bir blok zinciri "
"bağlamında, tabii ki). Akıllı sözleşmeler de ** şeffaf **; Akıllı sözleşme "
"tarafından depolanan veriler herkes tarafından erişilebilir. Sözleşmeyi "
"oluşturan kod ayrıca şeffaf olabilir, üçüncü bir yazılıma olanak tanır. Bu, "
"geliştiricilerin diğer akıllı sözleşmeleri kullanan akıllı sözleşmeler "
"yazmalarına izin verir. Akıllı sözleşmeler yalnızca blok zincirine "
"erişebilir ve etkileşime girebilir."

#: src/ch13-01-general-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, "
"it is required to know what the other contracts look like. Hence, Ethereum "
"developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to "
"build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs (Non-"
"Fungible Tokens) like `CryptoPunks` or `Everai`."
msgstr ""
"Geliştiricilerin birbirleriyle etkileşime girebilecek akıllı sözleşmeler "
"oluşturmaları için, diğer sözleşmelerin neye benzediğini bilmeleri gerekir. "
"Bu nedenle, Ethereum geliştiricileri akıllı sözleşme geliştirme için "
"standartlar oluşturmaya başladı, ERCxx. En çok kullanılan ve ünlü iki "
"standart, USDC, DAI veya STARK gibi belirteçleri oluşturmak için kullanılan "
"ERC20'dir."

#: src/ch13-01-general-introduction-to-smart-contracts.md:18
msgid "Use Cases"
msgstr "Vakaları Kullan"

#: src/ch13-01-general-introduction-to-smart-contracts.md:20
msgid ""
"There are many possible use cases for smart contracts. The only limits are "
"the technical constraints of the blockchain and the creativity of developers."
msgstr ""
"Akıllı sözleşmeler için birçok olası kullanım durumu vardır. Tek sınırlar, "
"blok zincirinin teknik kısıtlamaları ve geliştiricilerin yaratıcılığıdır."

#: src/ch13-01-general-introduction-to-smart-contracts.md:22
msgid "DeFi"
msgstr "DeFi"

#: src/ch13-01-general-introduction-to-smart-contracts.md:24
msgid ""
"For now, the principal use case for smart contracts is similar to that of "
"Ethereum or Bitcoin, which is essentially handling money. In the context of "
"the alternative payment system promised by Bitcoin, smart contracts on "
"Ethereum enable the creation of decentralized financial applications that no "
"longer rely on traditional financial intermediaries. This is what we call "
"DeFi (decentralized finance). DeFi consists of various projects such as "
"lending/borrowing applications, decentralized exchanges (DEX), on-chain "
"derivatives, stablecoins, decentralized hedge funds, insurance, and many "
"more."
msgstr ""
"Şimdilik, akıllı sözleşmeler için ana kullanım durumu, esasen parayı ele "
"alan Ethereum veya Bitcoin'inkine benzer. Bitcoin tarafından vaat edilen "
"alternatif ödeme sistemi bağlamında, Ethereum'daki akıllı sözleşmeler, artık "
"geleneksel finansal aracılara dayanmayan merkezi olmayan finansal "
"uygulamaların oluşturulmasını sağlar. DeFi (merkezsizleştirilmiş finans) "
"dediğimiz şey budur. DeFi, borç verme / borç verme uygulamaları, merkezi "
"olmayan borsalar (DEX), zincirli türevler, sabit paralar gibi çeşitli "
"projelerden oluşur."

#: src/ch13-01-general-introduction-to-smart-contracts.md:26
msgid "Tokenization"
msgstr "Tokenizasyon"

#: src/ch13-01-general-introduction-to-smart-contracts.md:28
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such "
"as real estate, art, or precious metals. Tokenization divides an asset into "
"digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and "
"simplify the buying and selling process."
msgstr ""
"Akıllı sözleşmeler, gayrimenkul, sanat veya değerli metaller gibi gerçek "
"dünya varlıklarının tokenizasyonunu kolaylaştırabilir. Tokenizasyon, bir "
"varlığı blok zinciri platformlarında kolayca takas edilebilen ve "
"yönetilebilen dijital tokenlere böler. Bu, likiditeyi artırabilir, kesirli "
"mülkiyeti etkinleştirebilir ve satın alma ve satma sürecini "
"basitleştirebilir."

#: src/ch13-01-general-introduction-to-smart-contracts.md:30
msgid "Voting"
msgstr "Oylama"

#: src/ch13-01-general-introduction-to-smart-contracts.md:32
msgid ""
"Smart contracts can be used to create secure and transparent voting systems. "
"Votes can be recorded on the blockchain, ensuring immutability and "
"transparency. The smart contract can then automatically tally the votes and "
"declare the results, minimizing the potential for fraud or manipulation."
msgstr ""
"Akıllı sözleşmeler güvenli ve şeffaf oylama sistemleri oluşturmak için "
"kullanılabilir. Oylar blok zincirine kaydedilebilir, değişmezlik ve "
"şeffaflık sağlanabilir. Akıllı sözleşme daha sonra oyları otomatik olarak "
"sıralayabilir ve sonuçları ilan edebilir, dolandırıcılık veya manipülasyon "
"potansiyelini en aza indirebilir."

#: src/ch13-01-general-introduction-to-smart-contracts.md:34
msgid "Royalties"
msgstr "Royalties"

#: src/ch13-01-general-introduction-to-smart-contracts.md:36
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and "
"other content creators. When a piece of content is consumed or sold, the "
"smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for "
"intermediaries."
msgstr ""
"Akıllı sözleşmeler sanatçılar, müzisyenler ve diğer içerik oluşturucular "
"için telif ödemelerini otomatikleştirebilir. Bir içerik parçası "
"tüketildiğinde veya satıldığında, akıllı sözleşme telif haklarını otomatik "
"olarak doğru sahiplerine hesaplayabilir ve dağıtabilir, adil bir tazminat "
"sağlar ve aracılara olan ihtiyacı azaltır."

#: src/ch13-01-general-introduction-to-smart-contracts.md:38
msgid "Decentralized Identities DIDs"
msgstr "Merkezi Olmayan Kimlikler DID'ler"

#: src/ch13-01-general-introduction-to-smart-contracts.md:40
msgid ""
"Smart contracts can be used to create and manage digital identities, "
"allowing individuals to control their personal information and share it with "
"third parties securely. The smart contract could verify the authenticity of "
"a user's identity and automatically grant or revoke access to specific "
"services based on the user's credentials."
msgstr ""
"Akıllı sözleşmeler, dijital kimlikleri oluşturmak ve yönetmek için "
"kullanılabilir ve bireylerin kişisel bilgilerini kontrol etmelerine ve "
"üçüncü taraflarla güvenli bir şekilde paylaşmalarına olanak tanır. Akıllı "
"sözleşme, bir kullanıcının kimliğinin doğruluğunu doğrulayabilir ve "
"kullanıcının kimlik bilgilerine dayanarak belirli hizmetlere otomatik olarak "
"erişim sağlayabilir veya iptal edebilir."

#: src/ch13-01-general-introduction-to-smart-contracts.md:46
msgid "The Rise of Starknet and Cairo"
msgstr "Starknet ve Kahire'nin Yükselişi"

#: src/ch13-01-general-introduction-to-smart-contracts.md:48
msgid ""
"Ethereum, being the most widely used and resilient smart contract platform, "
"became a victim of its own success. With the rapid adoption of some "
"previously mentioned use cases, mainly DeFi, the cost of performing "
"transactions became extremely high, rendering the network almost unusable. "
"Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue."
msgstr ""
"En yaygın kullanılan ve dayanıklı akıllı sözleşme platformu olan Ethereum, "
"kendi başarısının kurbanı oldu. Daha önce sözü edilen bazı kullanım "
"durumlarının, özellikle DeFi'nin hızlı bir şekilde benimsenmesiyle, "
"işlemlerin yapılmasının maliyeti son derece yüksek hale geldi ve ağı "
"neredeyse kullanılamaz hale getirdi. Ekosistemdeki mühendisler ve "
"araştırmacılar, bu ölçeklenebilirlik sorununu çözmek için çözümler üzerinde "
"çalışmaya başladılar."

#: src/ch13-01-general-introduction-to-smart-contracts.md:50
msgid ""
"A famous trilemma called The Blockchain Trilemma in the blockchain space "
"states that it is hard to achieve a high level of scalability, "
"decentralization, and security simultaneously; trade-offs must be made. "
"Ethereum is at the intersection of decentralization and security. "
"Eventually, it was decided that Ethereum's purpose would be to serve as a "
"secure settlement layer, while complex computations would be offloaded to "
"other networks built on top of Ethereum. These are called Layer 2s (L2s)."
msgstr ""
"Blok zinciri alanındaki The Blockchain Trilemma adlı ünlü bir trilemma, "
"yüksek düzeyde ölçeklenebilirlik, ademi merkeziyetçilik ve aynı anda "
"güvenlik elde etmenin zor olduğunu belirtir; takaslar yapılmalıdır. "
"Ethereum, ademi merkeziyetçilik ve güvenliğin kesiştiği noktadadır. Sonunda, "
"Ethereum'un amacının güvenli bir yerleşim katmanı olarak hizmet etmek "
"olacağına karar verildi, karmaşık hesaplamalar ise Ethereum'un üzerine inşa "
"edilen diğer ağlara yüklenecekti."

#: src/ch13-01-general-introduction-to-smart-contracts.md:52
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. "
"Both approaches involve compressing and batching numerous transactions "
"together, computing the new state, and settling the result on Ethereum (L1). "
"The difference lies in the way the result is settled on L1. For optimistic "
"rollups, the new state is considered valid by default, but there is a 7-day "
"window for nodes to identify malicious transactions."
msgstr ""
"İki ana L2 türü iyimser rollup ve geçerlilik rollup'larıdır. Her iki "
"yaklaşım da çok sayıda işlemi birbirine sıkıştırmayı ve toplulaştırmayı, "
"yeni durumu hesaplamayı ve sonucu Ethereum'a (L1) yerleştirmeyi içerir. "
"Fark, sonucun L1'e yerleşme biçiminde yatmaktadır. İyimser rollup'lar için, "
"yeni durum varsayılan olarak geçerli kabul edilir, ancak düğümlerin kötü "
"niyetli işlemleri tanımlaması için 7 günlük bir pencere vardır."

#: src/ch13-01-general-introduction-to-smart-contracts.md:54
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove "
"that the new state has been correctly computed. This is the purpose of "
"STARKs, this cryptographic technology could permit validity rollups to scale "
"significantly more than optimistic rollups. You can learn more about STARKs "
"from Starkware's Medium [article](https://medium.com/starkware/starks-"
"starkex-and-starknet-9a426680745a), which serves as a good primer."
msgstr ""
"Buna karşılık, Starknet gibi geçerlilik rollupları, yeni durumun doğru bir "
"şekilde hesaplandığını kanıtlamak için kriptografiyi kullanır. Bu "
"STARK'ların amacı budur, bu kriptografi teknolojisi, iyimser rollup'lardan "
"önemli ölçüde daha fazla ölçeklendirmeye izin verebilir. STARK'lar hakkında "
"daha fazla bilgi Starkware's Medium [article](https://medium.com/starkware/"
"starks-stark-kex-ve-stark hizmet veren bir a7454-980"

#: src/ch13-01-general-introduction-to-smart-contracts.md:56
msgid ""
"Starknet's architecture is thoroughly described in the [Starknet Book]"
"(https://book.starknet.io/ch03-00-architecture.html), which is a great "
"resource to learn more about the Starknet network."
msgstr ""
"Starknet'in mimarisi, Starknet ağı hakkında daha fazla bilgi edinmek için "
"harika bir kaynak olan [Starknet Book](https://book.starknet.io/ch03-00-"
"architecture.html) 'de ayrıntılı olarak tanımlanmıştır."

#: src/ch13-01-general-introduction-to-smart-contracts.md:58
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work "
"with STARKs and make them general-purpose. With Cairo, we can write "
"**provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another."
msgstr ""
"Kahire'yi hatırlıyor musunuz? Aslında, STARK'larla çalışmak ve onları genel "
"amaçlı hale getirmek için özel olarak geliştirilmiş bir dildir. Kahire ile "
"** uygulanabilir kod ** yazabiliriz. Starknet bağlamında, bu, hesaplamaların "
"bir eyaletten diğerine doğruluğunu kanıtlamaya olanak tanır."

#: src/ch13-01-general-introduction-to-smart-contracts.md:60
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM "
"(either as-is or adapted) as a base layer, Starknet employs its own VM. This "
"frees developers from the constraints of the EVM, opening up a broader range "
"of possibilities. Coupled with decreased transaction costs, the combination "
"of Starknet and Cairo creates an exciting playground for developers. Native "
"account abstraction enables more complex logic for accounts, that we call "
"\"Smart Accounts\", and transaction flows. Emerging use cases include "
"**transparent AI** and machine learning applications. Finally, **blockchain "
"games** can be developed entirely **on-chain**. Starknet has been "
"specifically designed to maximize the capabilities of STARK proofs for "
"optimal scalability."
msgstr ""
"Starknet'in EVM'yi (ya as-is ya da uyarlanmış) bir temel katman olarak "
"kullanmayı seçen rakiplerinin çoğundan farklı olarak, Starknet kendi VM'sini "
"kullanır. Bu, geliştiricileri EVM'nin kısıtlamalarından kurtarır, daha geniş "
"bir olasılık yelpazesi açar **. Azaltılmış işlem maliyetleri ile "
"birleştiğinde, Starknet ve Kahire kombinasyonu geliştiriciler için heyecan "
"verici bir oyun alanı oluşturur. Yerli hesap soyutlaması, \"Akıllı\" olarak "
"adlandırdığımız hesaplar için daha karmaşık bir mantık sağlar."

#: src/ch13-01-general-introduction-to-smart-contracts.md:62
msgid ""
"Learn more about Account Abstraction in the [Starknet Book](https://book."
"starknet.io/ch04-00-account-abstraction.html)."
msgstr ""
"[Starknet Book]'daki Hesap Özeti hakkında daha fazla bilgi edinin(https://"
"book.starknet.io/ch04-00-account-abstraction.html)."

#: src/ch13-01-general-introduction-to-smart-contracts.md:68
msgid "Cairo Programs and Starknet Contracts: What Is the Difference?"
msgstr "Kahire Programları ve Starknet Sözleşmeleri: Fark Nedir?"

#: src/ch13-01-general-introduction-to-smart-contracts.md:70
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts "
"previously learned in this book are still applicable to write Starknet "
"contracts. As you may have already noticed, a Cairo program must always have "
"a `main` function that serves as the entry point for this program:"
msgstr ""
"Starknet sözleşmeleri Kahire programlarının özel bir üst kümesidir, bu "
"nedenle bu kitapta daha önce öğrenilen kavramlar Starknet sözleşmeleri "
"yazmak için hala geçerlidir. Daha önce de fark etmiş olabileceğiniz gibi, "
"bir Kahire programının her zaman bu programın giriş noktası olarak hizmet "
"veren bir ana işlevi olmalıdır:"

#: src/ch13-01-general-introduction-to-smart-contracts.md:77
msgid ""
"Contracts deployed on the Starknet network are essentially programs that are "
"run by the sequencer, and as such, have access to Starknet's state. "
"Contracts do not have a `main` function but one or multiple functions that "
"can serve as entry points."
msgstr ""
"Starknet ağında konuşlandırılan sözleşmeler esasen sıralayıcı tarafından "
"çalıştırılan programlardır ve bu nedenle Starknet'in durumuna erişebilirler. "
"Sözleşmeler bir ana işlevine sahip değildir, ancak giriş noktaları olarak "
"hizmet verebilecek bir veya birden fazla işleve sahiptir."

#: src/ch13-01-general-introduction-to-smart-contracts.md:79
msgid ""
"Starknet contracts are defined within [modules](./ch07-02-defining-modules-"
"to-control-scope.md). For a module to be handled as a contract by the "
"compiler, it must be annotated with the `#[starknet::contract]` attribute."
msgstr ""
"Starknet sözleşmeleri [modüller] içinde tanımlanır(./ch07-02-defining-"
"modules-to-control-scope.md). Derleyici tarafından bir sözleşme olarak ele "
"alınacak bir modül için #[starknet::contract] özniteliği ile not edilmelidir."

#: src/ch13-02-anatomy-of-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts using a "
"very simple smart contract as example. You will learn how to write a "
"contract that allows anyone to store a single number on the Starknet "
"blockchain."
msgstr ""
"Bu bölüm, örnek olarak çok basit bir akıllı sözleşme kullanarak Starknet "
"sözleşmelerinin temellerini tanıtacaktır. Starknet blok zincirinde herkesin "
"tek bir numarayı saklamasına izin veren bir sözleşmenin nasıl yazılacağını "
"öğreneceksiniz."

#: src/ch13-02-anatomy-of-a-simple-contract.md:5
msgid ""
"Let's consider the following contract for the whole chapter. It might not be "
"easy to understand it all at once, but we will go through it step by step:"
msgstr ""
"Tüm bölüm için aşağıdaki sözleşmeyi düşünelim. Hepsini bir kerede anlamak "
"kolay olmayabilir, ancak bunu adım adım gözden geçireceğiz:"

#: src/ch13-02-anatomy-of-a-simple-contract.md:34
msgid "<span class=\"caption\">Listing 13-1: A simple storage contract</span>"
msgstr "span class=\"caption\">Liste 13-1: Basit bir depolama sözleşmesi/span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:36
msgid "What Is this Contract?"
msgstr "Bu Sözleşme Nedir?"

#: src/ch13-02-anatomy-of-a-simple-contract.md:38
msgid ""
"Contracts are defined by encapsulating state and logic within a module "
"annotated with the `#[starknet::contract]` attribute."
msgstr ""
"Sözleşmeler, #[starknet::contract] özniteliği ile belirtilen bir modül "
"içindeki durum ve mantığın kapsüllenmesiyle tanımlanır."

#: src/ch13-02-anatomy-of-a-simple-contract.md:40
msgid ""
"The state is defined within the `Storage` struct, and is always initialized "
"empty. Here, our struct contains a single a field called `stored_data` of "
"type `u128` (unsigned integer of 128 bits), indicating that our contract can "
"store any number between 0 and \\\\( {2^{128}} - 1 \\\\)."
msgstr ""
"Durum, Storage yapısı içinde tanımlanır ve her zaman boş olarak başlatılır. "
"Burada, u128 tipinde stored_data adlı tek bir alan bulunur (128 bitlik "
"imzasız tam sayı), bu da sözleşmemizin 0 ile (2128 - 1) arasındaki herhangi "
"bir sayıyı depolayabileceğini gösterir."

#: src/ch13-02-anatomy-of-a-simple-contract.md:42
msgid ""
"The logic is defined by functions that interact with the state. Here, our "
"contract defines and publicly exposes the functions `set` and `get` that can "
"be used to modify or retrieve the value of the stored variable. You can "
"think of it as a single slot in a database that you can query and modify by "
"calling functions of the code that manages the database."
msgstr ""
"Mantık, devletle etkileşime giren işlevlerle tanımlanır. Burada, "
"sözleşmemiz, depolanan değişkenin değerini değiştirmek veya almak için "
"kullanılabilecek set ve get işlevlerini tanımlar ve halka açıklar. "
"Veritabanını yöneten kodun işlevlerini arayarak sorgulayabileceğiniz ve "
"değiştirebileceğiniz bir veritabanındaki tek bir yuva olarak "
"düşünebilirsiniz."

#: src/ch13-02-anatomy-of-a-simple-contract.md:45
msgid "The Interface: the Contract's Blueprint"
msgstr "Arayüz: Sözleşmenin Mavi Baskısı"

#: src/ch13-02-anatomy-of-a-simple-contract.md:55
msgid "<span class=\"caption\">Listing 13-2: A basic contract interface</span>"
msgstr "span class=\"caption\">Liste 13-2: Temel bir sözleşme arayüzü/span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:58
msgid ""
"Interfaces represent the blueprint of the contract. They define the "
"functions that the contract exposes to the outside world. In Cairo, they're "
"defined by annotating a trait with the `#[starknet::interface]` attribute. "
"All functions of the trait are considered public functions of any contract "
"that implements this trait, and are callable from the outside world."
msgstr ""
"Arayüzler, sözleşmenin planını temsil eder. Sözleşmenin dış dünyaya ifşa "
"ettiği işlevleri tanımlarlar. Kahire'de, #[starknet::interface] özniteliği "
"ile bir özellik belirterek tanımlanırlar. Özelliğin tüm işlevleri, bu "
"özelliği uygulayan ve dış dünyadan çağrılabilen herhangi bir sözleşmenin "
"kamu işlevleri olarak kabul edilir."

#: src/ch13-02-anatomy-of-a-simple-contract.md:60
msgid ""
"All contract interfaces use a generic type for the `self` parameter, "
"representing the contract state. We chose to name this generic parameter "
"`TContractState` in our interface, but this is not enforced and any name can "
"be chosen."
msgstr ""
"Tüm sözleşme arayüzleri, sözleşme durumunu temsil eden self parametresi için "
"genel bir tür kullanır. Arayüzümüzde bu genel parametreyi TContractState "
"olarak adlandırmayı seçtik, ancak bu zorunlu değildir ve herhangi bir isim "
"seçilebilir."

#: src/ch13-02-anatomy-of-a-simple-contract.md:62
msgid ""
"In our interface, note the generic type `TContractState` of the `self` "
"argument which is passed by reference to the `set` function. Seeing the "
"`self` argument passed in a contract function tells us that this function "
"can access the state of the contract. The `ref` modifier implies that `self` "
"may be modified, meaning that the storage variables of the contract may be "
"modified inside the `set` function."
msgstr ""
"Arayüzümüzde, set fonksiyonuna atıfla geçen self argümanının tContractState "
"jenerik tipine dikkat edin. self argümanının bir sözleşme işlevinde "
"geçtiğini görmek, bu fonksiyonun sözleşmenin durumuna erişebileceğini "
"söyler. ref değiştiricisi, self'in değiştirilebileceği anlamına gelir, yani "
"sözleşmenin depolama değişkenleri setset fonksiyonu içinde değiştirilebilir."

#: src/ch13-02-anatomy-of-a-simple-contract.md:64
msgid ""
"On the other hand, the `get` function takes a snapshot of `TContractState`, "
"which immediately tells us that it does not modify the state (and indeed, "
"the compiler will complain if we try to modify storage inside the `get` "
"function)."
msgstr ""
"Öte yandan, get işlevi TContractState'in bir anlık görüntüsünü alır, bu da "
"bize hemen durumu değiştirmediğini söyler (ve gerçekten de, derleyici get "
"işlevinin içindeki depolamayı değiştirmeye çalışırsak şikayet edecektir)."

#: src/ch13-02-anatomy-of-a-simple-contract.md:66
msgid ""
"By leveraging the [traits & impls](./ch08-02-traits-in-cairo.md) mechanism "
"from Cairo, we can make sure that the actual implementation of the contract "
"matches its interface. In fact, you will get a compilation error if your "
"contract doesn’t conform with the declared interface. For example, Listing "
"13-3 shows a wrong implementation of the `ISimpleStorage` interface, "
"containing a slightly different `set` function that doesn't have the same "
"signature."
msgstr ""
"Kahire'den [traits & impls](./ch08-02-traits-in-cairo.md) mekanizmasından "
"yararlanarak, sözleşmenin gerçek uygulamasının arayüzüyle eşleştiğinden emin "
"olabiliriz. Aslında, sözleşmeniz ilan edilen arayüze uymuyorsa bir derleme "
"hatası alırsınız. Örneğin, Listeleme 13-3, aynı imzaya sahip olmayan "
"ISampleStorage arayüzünün yanlış bir uygulamasını gösterir."

#: src/ch13-02-anatomy-of-a-simple-contract.md:78
msgid ""
"<span class=\"caption\">Listing 13-3: A wrong implementation of the "
"interface of the contract. This does not compile, as the signature of `set` "
"doesn't match the trait's.</span>"
msgstr ""
"span class=\"caption\">Liste 13-3: Sözleşmenin arayüzünün yanlış bir şekilde "
"uygulanması. set imzası özelliğinkiyle eşleşmediği için bu derleme yapmaz./"
"span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:80
msgid ""
"Trying to compile a contract using this implementation will result in the "
"following error:"
msgstr ""
"Bu uygulamayı kullanarak bir sözleşme derlemeye çalışmak aşağıdaki hataya "
"neden olacaktır:"

#: src/ch13-02-anatomy-of-a-simple-contract.md:100
msgid "Public Functions Defined in an Implementation Block"
msgstr "Bir Uygulama Blokunda Tanımlanan Kamu İşlevleri"

#: src/ch13-02-anatomy-of-a-simple-contract.md:102
msgid "Before we explore things further down, let's define some terminology."
msgstr ""
"Olayları daha aşağıda incelemeden önce, biraz terminoloji tanımlayalım."

#: src/ch13-02-anatomy-of-a-simple-contract.md:104
msgid ""
"In the context of Starknet, a _public function_ is a function that is "
"exposed to the outside world. A public function can be called by anyone, "
"either from outside the contract or from within the contract itself. In the "
"example above, `set` and `get` are public functions."
msgstr ""
"Starknet bağlamında, bir _public function_ dış dünyaya maruz kalan bir "
"fonksiyondur. Bir kamu işlevi, sözleşmenin dışından veya sözleşmenin "
"kendisinden herkes tarafından çağrılabilir. Yukarıdaki örnekte, set ve get "
"kamu fonksiyonlarıdır."

#: src/ch13-02-anatomy-of-a-simple-contract.md:106
msgid ""
"What we call an _external_ function is a public function that can be "
"directly invoked through a Starknet transaction and that can mutate the "
"state of the contract. `set` is an external function."
msgstr ""
"Bir _external_ fonksiyonu dediğimiz şey, bir Starknet işlemiyle doğrudan "
"çağrılabilen ve sözleşmenin durumunu değiştirebilen bir kamu işlevidir. set "
"harici bir işlevdir."

#: src/ch13-02-anatomy-of-a-simple-contract.md:108
msgid ""
"A _view_ function is a public function that is typically read-only and "
"cannot mutate the state of the contract. However, this limitation is only "
"enforced by the compiler, and not by Starknet itself. We will discuss the "
"implications of this in a later section. `get` is a view function."
msgstr ""
"Bir _view_ işlevi, genellikle salt okunur olan ve sözleşmenin durumunu "
"değiştiremeyen bir kamu işlevidir. Bununla birlikte, bu sınırlama yalnızca "
"derleyici tarafından uygulanır, Starknet'in kendisi tarafından değil. Bunun "
"sonuçlarını daha sonraki bir bölümde tartışacağız. get bir görünüm işlevidir."

#: src/ch13-02-anatomy-of-a-simple-contract.md:123
msgid ""
"<span class=\"caption\">Listing 13-4: `SimpleStorage` implementation</span>"
msgstr "span class=\"caption\">Liste 13-4: BasitDepolama uygulaması/span>"

#: src/ch13-02-anatomy-of-a-simple-contract.md:125
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in "
"order to match the interface, the public functions of the contract must be "
"defined in an implementation of this trait — which allows us to make sure "
"that the implementation of the contract matches its interface."
msgstr ""
"Sözleşme arayüzü IsimpleStorage özelliği olarak tanımlandığından, arayüzle "
"eşleşmek için, sözleşmenin kamu işlevleri bu özelliğin uygulanmasında "
"tanımlanmalıdır - bu da sözleşmenin uygulanmasının arayüzüyle eşleştiğinden "
"emin olmamızı sağlar."

#: src/ch13-02-anatomy-of-a-simple-contract.md:127
msgid ""
"However, simply defining the functions in the implementation block is not "
"enough. The implementation block must be annotated with the "
"`#[abi(embed_v0)]` attribute. This attribute exposes the functions defined "
"in this implementation to the outside world — forget to add it and your "
"functions will not be callable from the outside. All functions defined in a "
"block marked as `#[abi(embed_v0)]` are consequently _public functions_."
msgstr ""
"Bununla birlikte, uygulama bloğundaki işlevleri basitçe tanımlamak yeterli "
"değildir. Uygulama bloğu #[abi(embed_v0)]] özniteliği ile açıklanmalıdır. Bu "
"öznitelik, bu uygulamada tanımlanan işlevleri dış dünyaya ifşa eder - "
"eklemeyi unutmayın ve işlevleriniz dışarıdan çağrılabilir olmayacaktır. "
"#[abi(embed_v0)] olarak işaretlenmiş bir blokta tanımlanan tüm işlevler "
"sonuç olarak _public fonksiyonlardır."

#: src/ch13-02-anatomy-of-a-simple-contract.md:129
msgid ""
"Because the `SimpleStorage` contract is defined as a module, we need to "
"access the interface defined in the parent module. We can either bring it to "
"the current scope with the `use` keyword, or refer to it directly using "
"`super`."
msgstr ""
"SimpleStorage sözleşmesi bir modül olarak tanımlandığından, ana modülde "
"tanımlanan arayüze erişmemiz gerekir. use anahtar kelimesi ile mevcut "
"kapsamına getirebilir veya super kullanarak doğrudan ona başvurabiliriz."

#: src/ch13-02-anatomy-of-a-simple-contract.md:131
msgid ""
"When writing the implementation of an interface, the `self` parameter in the "
"trait methods **must** be of type `ContractState`. The `ContractState` type "
"is generated by the compiler, and gives access to the storage variables "
"defined in the `Storage` struct. Additionally, `ContractState` gives us the "
"ability to emit events. The name `ContractState` is not surprising, as it’s "
"a representation of the contract’s state, which is what we think of `self` "
"in the contract interface trait. When `self` is a snapshot of "
"`ContractState`, only read access is allowed, and emitting events is not "
"possible."
msgstr ""
"Bir arayüzün uygulanmasını yazarken, özellik yöntemlerindeki self "
"parametresi **ContractState türünde olmalıdır. ContractState tipi derleyici "
"tarafından oluşturulur ve Storage yapısında tanımlanan depolama "
"değişkenlerine erişim sağlar. Ayrıca, ContractState'ın kendisi bize olayları "
"yayma yeteneği vermez. ContractState adı şaşırtıcı değildir."

#: src/ch13-02-anatomy-of-a-simple-contract.md:135
msgid "Accessing and Modifying the Contract's State"
msgstr "Sözleşmenin Devletine Erişim ve Değiştirilmesi"

#: src/ch13-02-anatomy-of-a-simple-contract.md:137
msgid ""
"Two methods are commonly used to access or modify the state of a contract:"
msgstr ""
"Bir sözleşmenin durumuna erişmek veya değiştirmek için yaygın olarak iki "
"yöntem kullanılır:"

#: src/ch13-02-anatomy-of-a-simple-contract.md:138
msgid ""
"`read`, which returns the value of a storage variable. This method is called "
"on the variable itself and does not take any argument."
msgstr ""
"read, bir depolama değişkeninin değerini döndürür. Bu yöntem değişkenin "
"kendisinde adlandırılır ve herhangi bir argüman almaz."

#: src/ch13-02-anatomy-of-a-simple-contract.md:144
msgid ""
"`write`, which allows to write a new value in a storage slot. This method is "
"also called on the variable itself and takes one argument, which is the "
"value to be written. Note that `write` may take more than one argument, "
"depending on the type of the storage variable. For example, writing on a "
"mapping requires 2 arguments: the key and the value to be written."
msgstr ""
"write, bir depolama yuvasında yeni bir değer yazmasına izin verir. Bu yöntem "
"aynı zamanda değişkenin kendisinde de adlandırılır ve yazılacak değer olan "
"bir argüman alır. write'ın depolama değişkeninin türüne bağlı olarak birden "
"fazla argüman alabileceğini unutmayın. Örneğin, bir haritalama üzerinde "
"yazma 2 argüman gerektirir: anahtar ve yazılacak değer."

#: src/ch13-02-anatomy-of-a-simple-contract.md:150
msgid ""
"Reminder: if the contract state is passed as a snapshot with `@` instead of "
"passed by reference with `ref`, attempting to modify the contract state will "
"result in a compilation error."
msgstr ""
"Hatırlatma: Sözleşme durumu ref ile referansla geçmek yerine  ile anlık "
"görüntü olarak geçerse, sözleşme durumunu değiştirmeye çalışmak derleme "
"hatası ile sonuçlanacaktır."

#: src/ch13-02-anatomy-of-a-simple-contract.md:152
msgid ""
"This contract does not do much apart from allowing anyone to store a single "
"number that is accessible by anyone in the world. Anyone could call `set` "
"again with a different value and overwrite the current number. Nevertheless, "
"each value stored in the storage of the contract will still be stored in the "
"history of the blockchain. Later in this book, you will see how you can "
"impose access restrictions so that only you can alter the number."
msgstr ""
"Bu sözleşme, herhangi birinin dünyadaki herhangi biri tarafından "
"erişilebilen tek bir numarayı depolamasına izin vermekten başka bir şey "
"yapmaz. Herkes set'yi farklı bir değerle tekrar arayabilir ve mevcut sayının "
"üzerine yazabilir. Bununla birlikte, sözleşmenin depolanmasında depolanan "
"her değer hala blok zincirinin geçmişinde saklanacaktır. Bu kitapta daha "
"sonra, yalnızca sayıyı değiştirebilmeniz için erişim kısıtlamalarını nasıl "
"empoze edebileceğinizi göreceksiniz."

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"In the previous section, we gave an introductory example of a smart contract "
"written in Cairo, describing the basic blocks to build smart contracts on "
"Starknet. In this section, we'll be taking a deeper look at all the "
"components of a smart contract, step by step."
msgstr ""
"Bir önceki bölümde, Starknet üzerinde akıllı sözleşmeler yapmak için temel "
"blokları tanımlayan Kahire'de yazılmış akıllı bir sözleşmenin giriş örneğini "
"verdik. Bu bölümde, akıllı bir sözleşmenin tüm bileşenlerine adım adım daha "
"derinlemesine bakacağız."

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"When we discussed [_interfaces_](./ch13-02-anatomy-of-a-simple-contract."
"md#the-interface-the-contracts-blueprint), we specified the difference "
"between the two types of _public functions_, i.e., _external functions_ and "
"_view functions_, and we mentioned how to interact with the _storage_ of a "
"contract."
msgstr ""
"[_interfaces_](./ch13-02-anatomy-of-a-simple-contract.md#the-interface-the-"
"contracts-blueprint) konusunu ele aldığımızda, iki tür _public functions_, "
"yani _external functions_ ve _view functions_ arasındaki farkı belirttik ve "
"bir sözleşmenin _storage_ ile nasıl etkileşime gireceğimizi belirttik."

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "At this point, you should have multiple questions that come to mind:"
msgstr "Bu noktada, akla gelen birden fazla sorunuz olmalıdır:"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How can I store more complex data types?"
msgstr "Daha karmaşık veri türlerini nasıl saklayabilirim?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How do I define internal/private functions?"
msgstr "İç/özel fonksiyonları nasıl tanımlarım?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "How can I emit events? How can I index them?"
msgstr "Olayları nasıl yayabilirim? Onları nasıl indeksleyebilirim?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid "Is there a way to reduce the boilerplate?"
msgstr "Kazan plakasını azaltmanın bir yolu var mı?"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"Luckily, we'll be answering all these questions in this chapter. Let's "
"consider the `NameRegistry` contract in Listing 14-1 that we'll be using "
"throughout this chapter:"
msgstr ""
"Neyse ki, bu bölümde tüm bu soruları cevaplayacağız. Listeleme 14-1'deki "
"NameRegistry sözleşmesini bu bölüm boyunca kullanacağımızı düşünelim:"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:62 src/ch14-01-contract-storage.md:184
#: src/ch14-01-contract-storage.md:297 src/ch14-01-contract-storage.md:403
#: src/ch14-01-contract-storage.md:509 src/ch14-01-contract-storage.md:615
#: src/ch14-01-contract-storage.md:727 src/ch14-01-contract-storage.md:833
#: src/ch14-02-contract-functions.md:38
msgid "// Public functions inside an impl block\n"
msgstr "// Bir impl bloğu içindeki genel işlevler\n"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:79 src/ch14-01-contract-storage.md:201
#: src/ch14-01-contract-storage.md:314 src/ch14-01-contract-storage.md:420
#: src/ch14-01-contract-storage.md:526 src/ch14-01-contract-storage.md:632
#: src/ch14-01-contract-storage.md:744 src/ch14-01-contract-storage.md:850
#: src/ch14-02-contract-functions.md:97
msgid "// Standalone public function\n"
msgstr "// Bağımsız kamu işlevi\n"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:85 src/ch14-01-contract-storage.md:207
#: src/ch14-01-contract-storage.md:320 src/ch14-01-contract-storage.md:426
#: src/ch14-01-contract-storage.md:532 src/ch14-01-contract-storage.md:638
#: src/ch14-01-contract-storage.md:750 src/ch14-01-contract-storage.md:856
#: src/ch14-02-contract-functions.md:112
msgid "// Could be a group of functions about a same topic\n"
msgstr "// Aynı konuyla ilgili bir grup fonksiyon olabilir\n"

#: src/ch14-00-building-starknet-smart-contracts.md
#: src/ch14-01-contract-storage.md:102 src/ch14-01-contract-storage.md:224
#: src/ch14-01-contract-storage.md:337 src/ch14-01-contract-storage.md:443
#: src/ch14-01-contract-storage.md:549 src/ch14-01-contract-storage.md:655
#: src/ch14-01-contract-storage.md:767 src/ch14-01-contract-storage.md:873
#: src/ch14-02-contract-functions.md:129
msgid "// Free function\n"
msgstr "// Serbest fonksiyon\n"

#: src/ch14-00-building-starknet-smart-contracts.md
msgid ""
"<span class=\"caption\">Listing 14-1: Our reference contract for this "
"chapter</span>"
msgstr ""
"span class=\"caption\">Liste 14-1: Bu bölüm için referans sözleşmemiz/span>"

#: src/ch14-01-contract-storage.md:3
msgid ""
"The most common way for interacting with a contract’s storage is through "
"storage variables. As stated previously, storage variables allow you to "
"store data that will be stored in the contract's storage that is itself "
"stored on the blockchain. These data are persistent and can be accessed and "
"potentially modified anytime once the contract is deployed."
msgstr ""
"Bir sözleşmenin depolamasıyla etkileşime girmenin en yaygın yolu depolama "
"değişkenleridir. Daha önce de belirtildiği gibi, depolama değişkenleri, "
"sözleşmenin depolama alanında saklanacak verileri blok zincirinde "
"saklamanıza izin verir. Bu veriler kalıcıdır ve sözleşme konuşlandırıldıktan "
"sonra her zaman erişilebilir ve potansiyel olarak değiştirilebilir."

#: src/ch14-01-contract-storage.md:5
msgid ""
"Storage variables in Starknet contracts are stored in a special struct "
"called `Storage`:"
msgstr ""
"Starknet sözleşmelerindeki depolama değişkenleri Storage adı verilen özel "
"bir yapıda saklanır:"

#: src/ch14-01-contract-storage.md:111
msgid ""
"The `Storage` struct is a [struct](./ch05-00-using-structs-to-structure-"
"related-data.md) like any other, except that it **must** be annotated with "
"the `#[storage]` attribute. This annotation tells the compiler to generate "
"the required code to interact with the blockchain state, and allows you to "
"read and write data from and to storage. Moreover, this allows you to define "
"storage mappings using the dedicated `LegacyMap` type."
msgstr ""
"Storage struct, herhangi bir diğerleri gibi bir [struct] (./ch05-00-using-"
"structs-to-structure-related-data.md) 'dir, bunun dışında ** #[storage] "
"özniteliği ile anons edilmelidir. Bu açıklama derleyiciye blok zinciri "
"durumuyla etkileşime girmesi için gerekli kodu oluşturmasını ve bu veriyi "
"okumasını ve yazmasını sağlar."

#: src/ch14-01-contract-storage.md:113
msgid ""
"Variables declared in the `Storage` struct are not stored contiguously but "
"in different locations in the contract's storage. The storage address of a "
"particular variable is determined by the variable's name, and the eventual "
"keys of the variable if it is a mapping."
msgstr ""
"Storage yapısında beyan edilen değişkenler bitişik olarak değil, sözleşmenin "
"deposundaki farklı konumlarda depolanır. Belirli bir değişkenin depolama "
"adresi, değişkenin adı ve bir haritalama ise değişkenin nihai anahtarları "
"ile belirlenir."

#: src/ch14-01-contract-storage.md:117
msgid "Addresses of Storage Variables"
msgstr "Depolama Değişkenlerinin Adresleri"

#: src/ch14-01-contract-storage.md:119
msgid "The address of a storage variable is computed as follows:"
msgstr "Bir depolama değişkeninin adresi aşağıdaki gibi hesaplanır:"

#: src/ch14-01-contract-storage.md:121
msgid ""
"If the variable is a single value, the address is the `sn_keccak` hash of "
"the ASCII encoding of the variable's name. `sn_keccak` is Starknet's version "
"of the Keccak256 hash function, whose output is truncated to 250 bits."
msgstr ""
"Değişken tek bir değer ise, adres değişkenin adının ASCII kodlamasının "
"sn_keccak hash'idir. sn_keccak, Starknet'in çıkışı 250 bite kadar kesilen "
"Keccak256 hash fonksiyonunun sürümüdür."

#: src/ch14-01-contract-storage.md:123
msgid ""
"If the variable is composed of multiple values (i.e., a tuple, a struct or "
"an enum), we also use the `sn_keccak` hash of the ASCII encoding of the "
"variable's name to determine the base address in storage. Then, depending on "
"the type, the storage layout will differ. See the [\"Storing Custom Types\"]"
"(./ch14-01-contract-storage.md#storing-custom-types) section."
msgstr ""
"Değişken birden fazla değerden (yani, bir tuple, bir struct veya bir enum) "
"oluşursa, depolamadaki temel adresi belirlemek için değişkenin adının ASCII "
"kodlamasının sn_keccak hash'ini de kullanırız. Daha sonra, türüne bağlı "
"olarak, depolama düzeni farklı olacaktır. [\"Storing Custom Types\"](./"
"ch14-01-contract-storm) bölümüne bakın."

#: src/ch14-01-contract-storage.md:125
msgid ""
"If the variable is a [mapping](./ch14-01-contract-storage.html#storage-"
"mappings) with a key `k`, the address of the value at key `k` is "
"`h(sn_keccak(variable_name),k)`, where ℎ is the Pedersen hash and the final "
"value is taken modulo \\\\( {2^{251}} - 256\\\\). If the key is composed of "
"more than one `felt252`, the address of the value will be `h(..."
"h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)`, with `k_1,...,k_n` being "
"all `felt252` that constitute the key. In the case of mappings to complex "
"values (e.g., tuples or structs), then this complex value lies in a "
"continuous segment starting from the address calculated with the previous "
"formula. Note that 256 field elements is the current limitation on the "
"maximal size of a complex storage value."
msgstr ""
"Eğer değişken bir [mapping](./ch14-01-contract-storage.html#storage-"
"mappings) k tuşu ile k değeri, k anahtarındaki değerin "
"h(sn_keccak(variable_name),k değeri, padersen hash olan ve son değerin "
"modulo ( 225) olarak alındığı bir değerdir."

#: src/ch14-01-contract-storage.md:127
msgid ""
"You can access the address of a storage variable by calling the `address` "
"function on the variable, which returns a `StorageBaseAddress` value."
msgstr ""
"StorageBaseAddress değerini döndüren değişken üzerindeki address "
"fonksiyonunu arayarak bir depolama değişkeninin adresine erişebilirsiniz."

#: src/ch14-01-contract-storage.md:236
msgid "Interacting with Storage Variables"
msgstr "Depolama Değişkenleri ile Etkileşim"

#: src/ch14-01-contract-storage.md:238
msgid ""
"Variables stored in the `Storage` struct can be accessed and modified using "
"the `read` and `write` functions, respectively. As previously mentioned, you "
"can get their address in storage using the `address` function. All these "
"functions are automatically generated by the compiler for each storage "
"variable."
msgstr ""
"Storage yapısında depolanan değişkenlere sırasıyla read ve write işlevleri "
"kullanılarak erişilebilir ve değiştirilebilir. Daha önce de belirtildiği "
"gibi, address işlevini kullanarak adreslerini depoda alabilirsiniz. Tüm bu "
"işlevler, her depolama değişkeni için derleyici tarafından otomatik olarak "
"oluşturulur."

#: src/ch14-01-contract-storage.md:240
msgid ""
"To read the value of the `owner` storage variable, which is a single value, "
"we call the `read` function on the `owner` variable, passing in no "
"parameters."
msgstr ""
"Tek bir değer olan owner depolama değişkeninin değerini okumak için, owner "
"değişkenindeki read fonksiyonuna hiçbir parametrede geçmeksizin diyoruz."

#: src/ch14-01-contract-storage.md:346
msgid ""
"To read the value of the storage variable `names`, which is a mapping from "
"`ContractAddress` to `felt252`, we call the `read` function on the `names` "
"variable, passing in the key `address` as a parameter. If the mapping had "
"more than one key, we would pass in the other keys as parameters as well."
msgstr ""
"ContractAddress ile felt252 arasında bir haritalama olan names depolama "
"değişkeninin değerini okumak için, names değişkenindeki read fonksiyonunu "
"parametre olarak address anahtarına geçiyoruz. Haritalamanın birden fazla "
"anahtarı olsaydı, diğer anahtarlarda da parametre olarak geçerdik."

#: src/ch14-01-contract-storage.md:452
msgid ""
"To write a new value to the storage slot of a storage variable, we call the "
"`write` function passing in the eventual keys and the value as arguments. As "
"with the `read` function, the number of arguments depends on the storage "
"variable type. Here, we only pass in the value to write to the `owner` "
"variable as it is a simple variable."
msgstr ""
"Bir depolama değişkeninin depolama yuvasına yeni bir değer yazmak için, "
"nihai anahtarlarda geçen write fonksiyonu ve argüman olarak değer diyoruz. "
"read fonksiyonunda olduğu gibi, argüman sayısı depolama değişken türüne "
"bağlıdır. Burada, basit bir değişken olduğu için owner değişkenine yazmak "
"için sadece değer geçeriz."

#: src/ch14-01-contract-storage.md:558
msgid ""
"In this second example, we need to pass `user` and `name` as arguments, "
"because `names` is a mapping, with `user` as key and `name` as value."
msgstr ""
"Bu ikinci örnekte, user ve name'yi argüman olarak geçmemiz gerekir, çünkü "
"names bir haritalamadır, user anahtar ve name değer olarak."

#: src/ch14-01-contract-storage.md:664
msgid "Storing Custom Types"
msgstr "Özel Türlerin Saklanması"

#: src/ch14-01-contract-storage.md:666
msgid ""
"The `Store` trait, defined in the `starknet::storage_access` module, is used "
"to specify how a type should be stored in storage. In order for a type to be "
"stored in storage, it **must** implement the `Store` trait. Most types from "
"the core library, such as unsigned integers (`u8`, `u128`, `u256`...), "
"`felt252`, `bool`, `ByteArray`, `ContractAddress`, etc. implement the "
"`Store` trait and can thus be stored without further action."
msgstr ""
"starknet::storage_access modülünde tanımlanan Store özelliği, bir türün "
"depolamada nasıl saklanması gerektiğini belirtmek için kullanılır. Bir türün "
"depolamada saklanması için, **Store özelliğinin uygulanması gerekir. İmzasız "
"tamsayılar (u8, u128, u256...), felt gibi çekirdek kütüphaneden gelen çoğu "
"tür"

#: src/ch14-01-contract-storage.md:668
msgid ""
"But what if you wanted to store a type that you defined yourself, such as an "
"enum or a struct? In that case, you have to explicitly tell the compiler how "
"to store this type."
msgstr ""
"Ancak, kendinizi tanımladığınız bir türü, örneğin bir enum veya bir struct "
"depolamak isteseydiniz? Bu durumda, derleyiciye bu türün nasıl saklanacağını "
"açıkça söylemeniz gerekir."

#: src/ch14-01-contract-storage.md:670
msgid ""
"In our example, we want to store a `Person` struct in storage, which is only "
"possible by implementing the `Store` trait for the `Person` type. This can "
"be simply achieved by adding a `#[derive(starknet::Store)]` attribute on top "
"of our struct definition. Note that all the members of the struct need to "
"implement the `Store` trait."
msgstr ""
"Örneğimizde, sadece Person tipi için Store özelliğini uygulayarak mümkün "
"olan bir Person yapısı depolamada saklamak istiyoruz. Bu, yapı tanımımızın "
"üzerine bir #[türev(starknet::Store)]] özniteliği eklenerek basitçe elde "
"edilebilir. Yapıtın tüm üyelerinin Store özelliğini uygulamak zorunda "
"olduklarını unutmayın."

#: src/ch14-01-contract-storage.md:776
msgid ""
"Similarly, Enums can only be written to storage if they implement the "
"`Store` trait, which can be trivially derived as long as all associated "
"types implement the `Store` trait."
msgstr ""
"Benzer şekilde, Enum'lar yalnızca Store özelliğini uygularlarsa depolamaya "
"yazılabilir, bu da tüm ilişkili türler Store özelliğini uyguladığı sürece "
"önemsiz olarak türetilebilir."

#: src/ch14-01-contract-storage.md:882
msgid ""
"You might have noticed that we also derived `Drop` and `Serde` on our custom "
"types. Both of them are required for properly serializing arguments passed "
"to entrypoints and deserializing their outputs."
msgstr ""
"Özel türlerimizde de Drop ve Serde türettiğimizi fark etmiş olabilirsiniz. "
"Her ikisi de giriş noktalarına aktarılan argümanları düzgün bir şekilde "
"serileştirmek ve çıktılarını deserialize etmek için gereklidir."

#: src/ch14-01-contract-storage.md:884
msgid "Structs Storage Layout"
msgstr "Structs Depolama Düzeni"

#: src/ch14-01-contract-storage.md:886
msgid ""
"On Starknet, structs are stored in storage as a sequence of primitive types. "
"The elements of the struct are stored in the same order as they are defined "
"in the struct definition. The first element of the struct is stored at the "
"base address of the struct, which is computed as specified in [\"Addresses "
"of Storage Variables\"](./ch14-01-contract-storage.html#addresses-of-storage-"
"variables) section and can be obtained by calling `var.address()`, and "
"subsequent elements are stored at addresses contiguous to the first element. "
"For example, the storage layout for the `owner` variable of type `Person` "
"will result in the following layout:"
msgstr ""
"Starknet'te, struct'lar bir dizi ilkel tip olarak depolanır. struct'ın "
"elemanları, struct tanımında tanımlandığı gibi aynı sırada saklanır. "
"struct'ın ilk elemanı, struct'ın [\"Storage Değişkenlerinin Adresleri ve "
"Adresleri\" olarak belirtilen temel adresinde saklanır."

#: src/ch14-01-contract-storage.md:890
msgid "Fields"
msgstr "Alanlar"

#: src/ch14-01-contract-storage.md:890 src/ch14-01-contract-storage.md:905
#: src/ch14-01-contract-storage.md:912
msgid "Address"
msgstr "Adres"

#: src/ch14-01-contract-storage.md:892
msgid "name"
msgstr "isim"

#: src/ch14-01-contract-storage.md:892
msgid "owner.address()"
msgstr "sahibi.address()"

#: src/ch14-01-contract-storage.md:893
msgid "address"
msgstr "adres"

#: src/ch14-01-contract-storage.md:893
msgid "owner.address() +1"
msgstr "owner.address() +1"

#: src/ch14-01-contract-storage.md:895
msgid ""
"Note that tuples are similarly stored in contract's storage, with the first "
"element of the tuple being stored at the base address, and subsequent "
"elements stored contiguously."
msgstr ""
"Tuple'ların benzer şekilde sözleşmenin deposunda depolandığını, tuple'ın ilk "
"elemanının temel adreste depolandığını ve sonraki elemanların bitişik olarak "
"depolandığını unutmayın."

#: src/ch14-01-contract-storage.md:899
msgid "Enums Storage Layout"
msgstr "Enums Depolama Düzeni"

#: src/ch14-01-contract-storage.md:901
msgid ""
"When you store an enum variant, what you're essentially storing is the "
"variant's index and eventual associated values. This index starts at 0 for "
"the first variant of your enum and increments by 1 for each subsequent "
"variant. If your variant has an associated value, this value is stored "
"starting from the address immediately following the address of the index of "
"the variant. For example, suppose we have the `RegistrationType` enum with "
"the `finite` variant that carries an associated limit date, and the "
"`infinite` variant without associated data. The storage layout for the "
"`finite` variant would look like this:"
msgstr ""
"Bir enum varyantı depoladığınızda, esas olarak depoladığınız şey varyantın "
"indeksi ve nihai ilişkili değerlerdir. Bu indeks, enum'unuzun ilk varyantı "
"için 0'dan başlar ve sonraki her varyantı için 1 oranında artar. "
"Varyantınızın ilişkili bir değeri varsa, bu değer, varyantın indeksini takip "
"eden adresten başlayarak saklanır. Örneğin, bu varyantın  ile ilişkili bir "
"varyantı olmadığını varsayalım."

#: src/ch14-01-contract-storage.md:905 src/ch14-01-contract-storage.md:912
msgid "Element"
msgstr "Eleman"

#: src/ch14-01-contract-storage.md:907
msgid "Variant index (0 for finite)"
msgstr "Varyant indeksi (0 sonlu için)"

#: src/ch14-01-contract-storage.md:907 src/ch14-01-contract-storage.md:914
msgid "registration_type.address()"
msgstr "kayıt_type.address()"

#: src/ch14-01-contract-storage.md:908
msgid "Associated limit date"
msgstr "İlişkili limit tarihi"

#: src/ch14-01-contract-storage.md:908
msgid "registration_type.address() + 1"
msgstr "registership_type.address() + 1"

#: src/ch14-01-contract-storage.md:910
msgid "while the storage layout for the `infinite` would be as follows:"
msgstr "infinite için depolama düzeni aşağıdaki gibidir:"

#: src/ch14-01-contract-storage.md:914
msgid "Variant index (1 for infinite)"
msgstr "Varyant indeksi (1 sonsuz için)"

#: src/ch14-01-contract-storage.md:916
msgid "Storage Mappings"
msgstr "Depolama Haritaları"

#: src/ch14-01-contract-storage.md:918
msgid ""
"Storage mappings are similar to hash tables in that they allow mapping keys "
"to values. However, unlike a typical hash table, the key data itself is not "
"stored - only its hash is used to look up the associated value in the "
"contract's storage. Mappings do not have a concept of length or whether a "
"key/value pair is set. All values are by default set to 0. The only way to "
"remove an entry from a mapping is to set its value to the default zero value."
msgstr ""
"Depolama haritalamaları, anahtarların değerlere eşlenmesine izin verdikleri "
"hash tablolarına benzer. Bununla birlikte, tipik bir hash tablosundan farklı "
"olarak, anahtar verinin kendisi depolanmaz - yalnızca hash'i, sözleşmenin "
"deposundaki ilişkili değeri aramak için kullanılır. Haritalamalarda uzunluk "
"kavramı veya bir anahtar / değer çiftinin ayarlanıp ayarlanmadığı yoktur. "
"Tüm değerler varsayılan olarak 0 olarak ayarlanır. Bir haritalamadan bir "
"girişi kaldırmanın tek yolu, değerini varsayılan değere ayarlamaktır."

#: src/ch14-01-contract-storage.md:921
msgid ""
"Mappings are only used to compute the location of data in the storage of a "
"contract given certain keys. They are thus **only allowed as storage "
"variables**. They cannot be used as parameters or return parameters of "
"contract functions, and cannot be used as types inside structs."
msgstr ""
"Haritalamalar, yalnızca belirli anahtarlar verilen bir sözleşmenin "
"depolanmasındaki verilerin konumunu hesaplamak için kullanılır. Bu nedenle "
"** yalnızca depolama değişkenleri ** olarak izin verilir. Sözleşme "
"işlevlerinin parametreleri veya dönüş parametreleri olarak kullanılamazlar "
"ve strüktlerin içindeki tipler olarak kullanılamazlar."

#: src/ch14-01-contract-storage.md:933
msgid ""
"To declare a mapping, use the `LegacyMap` type enclosed in angle brackets "
"`<>`, specifying the key and value types."
msgstr ""
"Bir haritalamayı beyan etmek için, anahtar ve değer türlerini belirten > "
"açılı parantez içinde bulunan LegacyMap tipini kullanın."

#: src/ch14-01-contract-storage.md:936
msgid ""
"You can also create more complex mappings with multiple keys. You can find "
"in Listing 14-2 the popular `allowances` storage variable of the ERC20 "
"Standard which maps an `owner` and an allowed `spender` to their `allowance` "
"amount using multiple keys passed inside a tuple:"
msgstr ""
"Birden fazla tuşla daha karmaşık haritalar da oluşturabilirsiniz. Listeleme "
"14-2'de, bir  sahibi ve izin verilen bir spender'yi bir tümenin içinde geçen "
"birden fazla tuş kullanarak haritalayan ERC20 Standardının popüler "
"allowances depolama değişkenini bulabilirsiniz:"

#: src/ch14-01-contract-storage.md:945
msgid ""
"<span class=\"caption\">Listing 14-2: Storing a mapping with multiple keys "
"inside a tuple</span>"
msgstr ""
"span class=\"caption\">Listing 14-2: Bir tuple içinde birden fazla anahtar "
"içeren bir haritanın saklanması/span>"

#: src/ch14-01-contract-storage.md:947
msgid ""
"The address in storage of a variable stored in a mapping is computed "
"according to the description in the [\"Addresses of Storage Variables\"](./"
"ch14-01-contract-storage.html#addresses-of-storage-variables) section."
msgstr ""
"Bir haritalamada depolanan bir değişkenin depolanmasındaki adres, [\"Depo "
"Değişkenlerinin Adresleri\"] [./ch14-01-sözleşme-depolama.html#adresleri-of-"
"depolama-değişkenleri] bölümündeki açıklamaya göre hesaplanır."

#: src/ch14-01-contract-storage.md:949
msgid ""
"If the key of a mapping is a struct, each element of the struct constitutes "
"a key. Moreover, the struct should implement the `Hash` trait, which can be "
"derived with the `#[derive(Hash)]` attribute. For example, if you have a "
"struct with two fields, the address will be `h(h(sn_keccak(variable_name),"
"k_1),k_2)` modulo \\\\( {2^{251}} - 256\\\\), where `k_1` and `k_2` are the "
"values of the two fields of the struct."
msgstr ""
"Bir haritalamanın anahtarı bir yapı ise, yapının her elemanı bir anahtar "
"oluşturur. Ayrıca, yapı #[türev(Hash)]] özniteliği ile türetilebilen Hash "
"özelliğini uygulamalıdır. Örneğin, iki alanlı bir yapınız varsa, adres "
"h(snkeccak(variable_name),_k olacaktır."

#: src/ch14-01-contract-storage.md:951
msgid ""
"Similarly, in the case of a nested mapping using a tuple as key, such as "
"`LegacyMap::<(ContractAddress, ContractAddress), u8>`, the address will be "
"computed in the same way, with each element of the tuple being a key: "
"`h(h(sn_keccak(variable_name),k_1),k_2)`."
msgstr ""
"Benzer şekilde, LegacyMap::(ContractAddress, ContractAddress), u8> gibi "
"anahtar olarak bir tuple kullanarak bir yuvalanmış haritalama durumunda, "
"adres aynı şekilde hesaplanacaktır, tuple'ın her elemanı bir anahtardır: "
"h(h(sn_keccak(variable_name),k_1,k_2)."

#: src/ch14-02-contract-functions.md:3
msgid ""
"In this section, we are going to be looking at the different types of "
"functions you could encounter in Starknet smart contracts."
msgstr ""
"Bu bölümde, Starknet akıllı sözleşmelerinde karşılaşabileceğiniz farklı "
"işlev türlerine bakacağız."

#: src/ch14-02-contract-functions.md:5
msgid ""
"Functions can access the contract's state easily via `self: ContractState`, "
"which abstracts away the complexity of underlying system calls "
"(`storage_read_syscall` and `storage_write_syscall`). The compiler provides "
"two modifiers: `ref` and `@` to decorate `self`, which intends to "
"distinguish view and external functions."
msgstr ""
"Fonksiyonlar, sözleşmenin durumuna self: ContractState aracılığıyla kolayca "
"erişebilir, bu da altta yatan sistem çağrılarının karmaşıklığını soyutlar "
"(storage_read_syscall ve storage_write_syscall). Derleyici iki değiştirici "
"sağlar: ref ve, görüş ve dış işlevleri ayırt etmeyi amaçlayan self'i "
"süslemek için."

#: src/ch14-02-contract-functions.md:7
msgid "1. Constructors"
msgstr "1. Yapıcılar"

#: src/ch14-02-contract-functions.md:9
msgid ""
"Constructors are a special type of function that only runs once when "
"deploying a contract, and can be used to initialize the state of a contract."
msgstr ""
"Yapıcılar, bir sözleşmeyi dağıtırken yalnızca bir kez çalışan ve bir "
"sözleşmenin durumunu başlatmak için kullanılabilen özel bir işlev türüdür."

#: src/ch14-02-contract-functions.md:20
msgid "Some important rules to note:"
msgstr "Dikkat edilmesi gereken bazı önemli kurallar:"

#: src/ch14-02-contract-functions.md:22
msgid "A contract can't have more than one constructor."
msgstr "Bir sözleşme birden fazla yapıcıya sahip olamaz."

#: src/ch14-02-contract-functions.md:23
msgid ""
"The constructor function must be named `constructor`, and must be annotated "
"with the `#[constructor]` attribute."
msgstr ""
"Yapılandırıcı fonksiyonun adı constructor olmalı ve #[constructor] "
"özniteliği ile anons edilmelidir."

#: src/ch14-02-contract-functions.md:25
msgid ""
"The `constructor` function might take arguments, which are passed when "
"deploying the contract. In our example, we pass some value corresponding to "
"a `Person` type as argument in order to store the `owner` information "
"(address and name) in the contract."
msgstr ""
"constructor işlevi, sözleşmeyi dağıtırken geçen argümanları alabilir. "
"Örneğimizde,  owner bilgilerini (adres ve ad) sözleşmede saklamak için bir "
"Person türüne karşılık gelen bir miktar değeri argüman olarak geçeriz."

#: src/ch14-02-contract-functions.md:27
msgid ""
"Note that the `constructor` function **must** take `self` as a first "
"argument, corresponding to the state of the contract, generally passed by "
"reference with the `ref` keyword to be able to modify the contract's state. "
"We will explain `self` and its type shortly."
msgstr ""
"constructor fonksiyonunun ** self'yi sözleşmenin durumuna karşılık gelen ilk "
"argüman olarak alması gerektiğini, genellikle sözleşmenin durumunu "
"değiştirebilmek için ref anahtar kelimesi ile referansla geçtiğini "
"unutmayın. self ve türünü kısa süre içinde açıklayacağız."

#: src/ch14-02-contract-functions.md:29
msgid "2. Public Functions"
msgstr "2. Kamu Fonksiyonları"

#: src/ch14-02-contract-functions.md:31
msgid ""
"As stated previously, public functions are accessible from outside of the "
"contract. They are usually defined inside an implementation block annotated "
"with the `#[abi(embed_v0)]` attribute, but might also be defined "
"independently under the `#[external(v0)]` attribute."
msgstr ""
"Daha önce belirtildiği gibi, kamu işlevleri sözleşmenin dışından "
"erişilebilir. Genellikle #[abi(embed_v0)] özniteliği ile belirtilen bir "
"uygulama bloğu içinde tanımlanırlar, ancak #[external(v0)]] özniteliği "
"altında bağımsız olarak da tanımlanabilirler."

#: src/ch14-02-contract-functions.md:33
msgid ""
"The `#[abi(embed_v0)]` attribute means that all functions embedded inside it "
"are implementations of the Starknet interface of the contract, and therefore "
"potential entry points."
msgstr ""
"#[abi(embed_v0)] özniteliği, içine gömülü tüm fonksiyonların sözleşmenin "
"Starknet arayüzünün uygulamaları ve dolayısıyla potansiyel giriş noktaları "
"olduğu anlamına gelir."

#: src/ch14-02-contract-functions.md:35
msgid ""
"Annotating an impl block with the `#[abi(embed_v0)]` attribute only affects "
"the visibility (i.e., public vs private/internal) of the functions it "
"contains, but it doesn't inform us on the ability of these functions to "
"modify the state of the contract."
msgstr ""
"#[abi(embed_v0)] özniteliği ile bir impl bloğunun belirtilmesi, yalnızca "
"içerdiği işlevlerin görünürlüğünü (yani kamuya özel/içsel) etkiler, ancak bu "
"işlevlerin sözleşmenin durumunu değiştirme yeteneği hakkında bizi "
"bilgilendirmez."

#: src/ch14-02-contract-functions.md:56
msgid ""
"Similarly to the `constructor` function, all public functions, either "
"standalone functions annotated with the `#[external(v0)]` or functions "
"within an impl block annotated with the `#[abi(embed_v0)]` attribute, "
"**must** take `self` as a first argument. This is not the case for private "
"functions."
msgstr ""
"constructor işlevine benzer şekilde, tüm kamu fonksiyonları, ya "
"#[external(v0)] ile belirtilen bağımsız fonksiyonlar ya da #[abi(embed_v0)] "
"özniteliği ile belirtilen bir impl bloğu içindeki fonksiyonlar, ** ilk "
"argüman olarak self almalıdır. Bu özel işlevler için geçerli değildir."

#: src/ch14-02-contract-functions.md:58
msgid "External Functions"
msgstr "Dış Fonksiyonlar"

#: src/ch14-02-contract-functions.md:60
msgid ""
"External functions are _public_ functions where the `self: ContractState` "
"argument is passed by reference with the `ref` keyword, which exposes both "
"the `read` and `write` access to storage variables. This allows modifying "
"the state of the contract via `self` directly."
msgstr ""
"Harici fonksiyonlar, self: ContractState argümanının, depolama "
"değişkenlerine hem read hem de write erişimini açığa çıkaran ref anahtar "
"kelimesi ile referans yoluyla geçtiği _public_ fonksiyonlarıdır. Bu, "
"sözleşmenin durumunu doğrudan self aracılığıyla değiştirmenizi sağlar."

#: src/ch14-02-contract-functions.md:69
msgid "View Functions"
msgstr "Fonksiyonları Göster"

#: src/ch14-02-contract-functions.md:71
msgid ""
"View functions are _public_ functions where the `self: ContractState` "
"argument is passed as snapshot, which only allows the `read` access to "
"storage variables, and restricts writes to storage made via `self` by "
"causing compilation errors. The compiler will mark their `state_mutability` "
"to `view`, preventing any state modification through `self` directly."
msgstr ""
"self: ContractState argümanının anlık görüntü olarak geçtiği, yalnızca "
"depolama değişkenlerine read erişimine izin veren ve derleme hatalarına "
"neden olarak self aracılığıyla yapılan depolamaya yazılanları kısıtlayan "
"_public_ fonksiyonlarıdır. Derleyici, state_mutability'lerini view olarak "
"işaretleyecek ve self aracılığıyla herhangi bir durum değişikliğini doğrudan "
"önleyecektir."

#: src/ch14-02-contract-functions.md:80
msgid "State Mutability of Public Functions"
msgstr "Kamu Fonksiyonlarının Devlet Mutabilitesi"

#: src/ch14-02-contract-functions.md:82
msgid ""
"However, as you may have noticed, passing `self` as a snapshot only "
"restricts the storage write access via `self` at compile time. It does not "
"prevent state modification via direct system calls, nor calling another "
"contract that would modify the state."
msgstr ""
"Ancak, fark etmiş olabileceğiniz gibi, self'yi bir anlık görüntü olarak "
"geçmek, derleme zamanında yalnızca self aracılığıyla depolama yazma "
"erişimini kısıtlar. Doğrudan sistem çağrıları yoluyla durum değişikliğini "
"engellemez veya durumu değiştirecek başka bir sözleşme çağırmaz."

#: src/ch14-02-contract-functions.md:84
msgid ""
"The read-only property of view functions is not enforced on Starknet, and "
"sending a transaction targeting a view function _could_  change the state."
msgstr ""
"Yalnızca okunur görünüm işlevleri özelliği Starknet'te uygulanmaz ve bir "
"görünüm fonksiyonunu hedefleyen bir işlem gönderir _could_ durumu değiştirir."

#: src/ch14-02-contract-functions.md:86
msgid ""
"In conclusion, even though external and view functions are distinguished by "
"the Cairo compiler, **all public functions** can be called through an invoke "
"transaction and have the potential to modify states on Starknet. Also, all "
"public functions can be queried via `starknet_call` on Starknet, which will "
"not create a transaction and hence will not change the state."
msgstr ""
"Sonuç olarak, dış ve görünüm işlevleri Kahire derleyicisi tarafından ayırt "
"edilmesine rağmen, ** tüm kamu işlevleri ** bir çağrı işlemi yoluyla "
"çağrılabilir ve Starknet'teki durumları değiştirme potansiyeline sahip "
"olabilir. Ayrıca, tüm kamu işlevleri, bir işlem oluşturmayacak ve bu nedenle "
"devleti değiştirmeyecek olan Starknet'te starknet_call aracılığıyla "
"sorgulanabilir."

#: src/ch14-02-contract-functions.md:88
msgid ""
"**Warning:** This is different from the EVM where a `staticcall` opcode is "
"provided, which prevents storage modifications in the current context and "
"subcontexts. Hence developers **should not** have the assumption that "
"calling a view function on another contract cannot modify the state."
msgstr ""
"**Uyarı:** Bu, mevcut bağlam ve alt metinlerdeki depolama değişikliklerini "
"engelleyen bir staticcall opcode'un sağlandığı EVM'den farklıdır. Bu nedenle "
"geliştiriciler ** başka bir sözleşmede bir görünüm fonksiyonunu çağırmanın "
"durumu değiştiremeyeceği varsayımına sahip olmamalıdır."

#: src/ch14-02-contract-functions.md:90
msgid "Standalone Public Functions"
msgstr "Bağımsız Kamu Fonksiyonları"

#: src/ch14-02-contract-functions.md:92
msgid ""
"It is also possible to define public functions outside of an implementation "
"of a trait, using the `#[external(v0)]` attribute. Doing this will "
"automatically generate the corresponding ABI, allowing these standalone "
"public functions to be callable by anyone from the outside. These functions "
"can also be called from within the contract just like any function in "
"Starknet contracts. The first parameter must be `self`."
msgstr ""
"#[external(v0)] özniteliğini kullanarak bir özelliğin uygulanması dışında "
"kamu işlevlerini tanımlamak da mümkündür. Bunu yapmak otomatik olarak "
"karşılık gelen ABI'yi oluşturacak ve bu bağımsız kamu işlevlerinin dışarıdan "
"herkes tarafından aranabilir olmasını sağlayacaktır. Bu işlevler, Starknet "
"sözleşmelerindeki herhangi bir işlev gibi sözleşmenin içinden de "
"çağrılabilir. İlk parametre self olmalıdır."

#: src/ch14-02-contract-functions.md:94
msgid ""
"Here, we define a standalone `get_contract_name` function outside of an impl "
"block:"
msgstr ""
"Burada, bir impl bloğunun dışında bağımsız bir get_contract_name işlevi "
"tanımlıyoruz:"

#: src/ch14-02-contract-functions.md:104
msgid "3. Private Functions"
msgstr "3. Özel Fonksiyonlar"

#: src/ch14-02-contract-functions.md:106
msgid ""
"Functions that are not defined with the `#[external(v0)]` attribute or "
"inside a block annotated with the `#[abi(embed_v0)]` attribute are private "
"functions (also called internal functions). They can only be called from "
"within the contract."
msgstr ""
"#[external(v0)] özniteliği ile tanımlanmayan veya #[abi(embed_v0)]] "
"özniteliği ile belirtilen bir bloğun içindeki fonksiyonlar özel "
"fonksiyonlardır (iç fonksiyonlar olarak da adlandırılır). Sadece sözleşmenin "
"içinden çağrılabilirler."

#: src/ch14-02-contract-functions.md:108
msgid ""
"They can be grouped in a dedicated impl block (e.g., in components, to "
"easily import internal functions all at once in the embedding contracts) or "
"just be added as free functions inside the contract module. Note that these "
"2 methods are equivalent. Just choose the one that makes your code more "
"readable and easy to use."
msgstr ""
"Özel bir impl bloğunda gruplandırılabilirler (örneğin, bileşenlerde, gömme "
"sözleşmelerinde dahili işlevleri kolayca içe aktarmak için) veya sadece "
"sözleşme modülü içinde ücretsiz işlevler olarak eklenebilirler. Bu 2 "
"yöntemin eşdeğer olduğunu unutmayın. Kodunuzu daha okunabilir ve kullanımı "
"kolay hale getiren birini seçin."

#: src/ch14-02-contract-functions.md:135
msgid ""
"Wait, what is this `#[generate_trait]` attribute? Where is the trait "
"definition for this implementation? Well, the `#[generate_trait]` attribute "
"is a special attribute that tells the compiler to generate a trait "
"definition for the implementation block. This allows you to get rid of the "
"boilerplate code of defining a trait with generic parameters and "
"implementing it for the implementation block. With this attribute, we can "
"simply define the implementation block directly, without any generic "
"parameter, and use `self: ContractState` in our functions."
msgstr ""
"Bekle, bu #[genate_trait] özniteliği nedir? Bu uygulama için özellik tanımı "
"nerede? Peki, #[genate_trait] özniteliği, derleyiciye uygulama bloğu için "
"bir özellik tanımı oluşturmasını söyleyen özel bir özniteliktir. Bu, genel "
"parametrelerle bir özellik tanımlamanın ve uygulama bloğu için uygulamanın "
"kazan plakası kodundan kurtulmanızı sağlar. Bu öznitelikle, herhangi bir "
"parametreyi doğrudan kullanmadan tanımlayabiliriz."

#: src/ch14-02-contract-functions.md:137
msgid ""
"The `#[generate_trait]` attribute is mostly used to define private impl "
"blocks. It might also be used in addition to `#[abi(per_item)]` to define "
"the various entrypoints of a contract (see [next section](./ch14-02-contract-"
"functions.md#4-abiper_item-attribute))."
msgstr ""
"#[genate_trait] özniteliği çoğunlukla özel impl bloklarını tanımlamak için "
"kullanılır. Bir sözleşmenin çeşitli giriş noktalarını tanımlamak için "
"#[abi(per_item)] ek olarak da kullanılabilir (bkz. [sonraki bölüm](./ch14-02-"
"contract-functions.md#4-abiper_item-attribute)))."

#: src/ch14-02-contract-functions.md:139
msgid ""
"Note: using `#[generate_trait]` in addition to the `#[abi(embed_v0)]` "
"attribute for a public impl block is not recommended, as it will result in a "
"failure to generate the corresponding ABI. Public functions should only be "
"defined in an impl block annotated with `#[generate_trait]` if this block is "
"also annotated with the `#[abi(per_item)]` attribute."
msgstr ""
"Not: #[genate_trait] ek olarak #[abi(embed_v0)] özniteliği bir halka açık "
"impl bloğu için tavsiye edilmez, çünkü ilgili ABI'yi oluşturmada bir "
"başarısızlıkla sonuçlanacaktır. Kamusal işlevler yalnızca #[genate_trait] "
"özniteliği ile belirtilen bir impl bloğunda tanımlanmalıdır."

#: src/ch14-02-contract-functions.md:144
msgid "`[abi(per_item)]` Attribute"
msgstr "[abi(per_item)] Öznitelik"

#: src/ch14-02-contract-functions.md:146
msgid ""
"You can also define the entrypoint type of functions individually inside an "
"impl block using the`#[abi(per_item)]` attribute on top of your impl. It is "
"often used with the `#[generate_trait]` attribute, as it allows you to "
"define entrypoints without an explicit interface. In this case, the "
"functions will not be grouped under an impl in the ABI. Note that when using "
"`#[abi(per_item)]` attribute, public functions need to be annotated with the "
"`#[external(v0)]` attribute - otherwise, they will not be exposed and will "
"be considered as private functions."
msgstr ""
"Ayrıca, impl'nizin üstündeki #[abi(per_item)] özniteliğini kullanarak bir "
"impl bloğunun içindeki fonksiyonların giriş noktasını tek tek "
"tanımlayabilirsiniz. Aksi takdirde açık bir arayüz olmadan giriş noktalarını "
"tanımlamanıza izin verdiği için #[genate_trait] özniteliği ile birlikte "
"kullanılır. Bu durumda, fonksiyonlar ABI'de bir impl altında "
"gruplandırılmayacaktır."

#: src/ch14-02-contract-functions.md:148
msgid "Here is a short example:"
msgstr "İşte kısa bir örnek:"

#: src/ch14-02-contract-functions.md:160
msgid "// this is a constructor function\n"
msgstr "// bu bir constructor fonksiyonudur\n"

#: src/ch14-02-contract-functions.md:164
msgid "// this is a public function\n"
msgstr "// bu bir kamu fonksiyonudur\n"

#: src/ch14-02-contract-functions.md:168
msgid "// this is a l1_handler function\n"
msgstr "// bu bir l1_handler fonksiyonudur\n"

#: src/ch14-02-contract-functions.md:171
msgid "// this is an internal function\n"
msgstr "// bu bir iç fonksiyondur\n"

#: src/ch14-02-contract-functions.md:177
msgid ""
"In the case of `#[abi(per_item)]` attribute usage without "
"`#[generate_trait]`, it will only be possible to include `constructor`, `l1-"
"handler` and `internal` functions in the trait implementation. Indeed, "
"`#[abi(per_item)]` only works with a trait that is not defined as a Starknet "
"interface. Hence, it will be mandatory to create another trait defined as "
"interface to implement public functions."
msgstr ""
"#[abi(per_item)]] #[generate_trait] olmadan öznitelik kullanımı durumunda, "
"yalnızca constructor, l1-handler ve internal işlevlerini özellik "
"uygulamasına dahil etmek mümkün olacaktır. Gerçekten de, #[abi(per_item)] "
"yalnızca bir Starknet arayüzü olarak tanımlanmayan bir özellikle çalışır."

#: src/ch14-03-contract-events.md:3
msgid ""
"Events are custom data structures that are emitted by smart contracts during "
"execution. They provide a way for smart contracts to communicate with the "
"external world by logging information about specific occurrences in a "
"contract."
msgstr ""
"Olaylar, yürütme sırasında akıllı sözleşmeler tarafından yayılan özel veri "
"yapılarıdır. Akıllı sözleşmelerin, bir sözleşmedeki belirli olaylarla ilgili "
"bilgileri günlüğe kaydederek dış dünyayla iletişim kurması için bir yol "
"sağlarlar."

#: src/ch14-03-contract-events.md:5
msgid ""
"Events play a crucial role in the integration of smart contracts in real-"
"world applications. Take, for instance, the Non-Fungible Tokens (NFTs) "
"minted on Starknet. An event is emitted each time a token is minted. This "
"event is indexed and stored in some database, allowing applications to "
"display almost instantaneously useful information to users. If the contract "
"doesn't emit an event when minting a new token, it would be less practical, "
"with the need of querying the state of the blockchain to get the data needed."
msgstr ""
"Olaylar, akıllı sözleşmelerin gerçek dünyadaki uygulamalardaki "
"entegrasyonunda çok önemli bir rol oynar. Örneğin, Starknet'te basılan "
"Fungible Token'ları (NFT'ler) ele alalım. Bir token basıldığında bir olay "
"yayılır. Bu olay, bazı veritabanında indekslenir ve saklanır, uygulamaların "
"kullanıcılara neredeyse anında yararlı bilgiler görüntülemesine izin verir. "
"Sözleşme, yeni bir jetonu bastırırken bir olay yaymazsa, blok zincirinin "
"daha az pratik olması gerekir."

#: src/ch14-03-contract-events.md:7
msgid "Defining Events"
msgstr "Olayları Tanımlamak"

#: src/ch14-03-contract-events.md:9
msgid ""
"All the different events in a contract are defined under the `Event` enum, "
"which must implement the `starknet::Event` trait. This trait is defined in "
"the core library as follows:"
msgstr ""
"Bir sözleşmedeki tüm farklı olaylar, starknet::Event özelliğini uygulamak "
"zorunda olan Event enum altında tanımlanır. Bu özellik çekirdek kütüphanede "
"aşağıdaki gibi tanımlanır:"

#: src/ch14-03-contract-events.md:18
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate "
"an implementation for the above trait, instantiated with the `Event` type, "
"which in our example is the following enum:"
msgstr ""
"#[türev(starknet::Event)] özniteliği, derleyicinin yukarıdaki özellik için "
"bir uygulama oluşturmasına neden olur ve örneğimizde aşağıdaki enum olan "
"Event tipi ile anında oluşturulur:"

#: src/ch14-03-contract-events.md:29
msgid ""
"Each variant of the `Event` enum has to be a struct or an enum, and each "
"variant needs to implement the `starknet::Event` trait itself. Moreover, the "
"members of these variants must implement the `Serde` trait (_c.f._ [Appendix "
"C: Serializing with Serde](./appendix-03-derivable-traits.html#serializing-"
"with-serde)), as keys/data are added to the event using a serialization "
"process."
msgstr ""
"Event enum'un her varyantı bir yapı veya enum olmak zorundadır ve her "
"varyantın starknet::Event özelliğinin kendisini uygulaması gerekir. Ayrıca, "
"bu varyantların üyeleri Serde özelliğini (_c.f._ [Ek C: Serileştirme Serde "
"ile) uygulamalıdır."

#: src/ch14-03-contract-events.md:31
msgid ""
"The auto-implementation of the `starknet::Event` trait will implement the "
"`append_keys_and_data` function for each variant of our `Event` enum. The "
"generated implementation will append a single key based on the variant name "
"(`StoredName`), and then recursively call `append_keys_and_data` in the impl "
"of the `Event` trait for the variant’s type."
msgstr ""
"starknet'in otomatik uygulaması::Event özelliği, Event enum'umuzun her bir "
"varyantı için append_keys_and_data işlevini uygulayacaktır. Oluşturulan "
"uygulama, varyant adına (StoredName) dayanan tek bir anahtar ekleyecek ve "
"ardından append_keys_and_data değişkenini Event özelliği için impl'de "
"yeniden çağıracaktır."

#: src/ch14-03-contract-events.md:33
msgid ""
"In our example, the `Event` enum contains only one variant, which is a "
"struct named `StoredName`. We chose to name our variant with the same name "
"as the struct name, but this is not enforced."
msgstr ""
"Örneğimizde, Event enum, StoredName adlı bir struct olan sadece bir varyant "
"içerir. Varyantımızı struct adı ile aynı isimle adlandırmayı seçtik, ancak "
"bu uygulanmadı."

#: src/ch14-03-contract-events.md:44
msgid ""
"Whenever an enum that derives the `starknet::Event` trait has an enum "
"variant, this enum is nested by default. Therefore, the list of keys "
"corresponding to the variant’s name will include the `sn_keccak` hash of the "
"variant's name itself. This can be superfluous, typically when using "
"embedded components in contracts. Indeed, in such cases, we might want the "
"events defined in the components to be emitted without any additional data, "
"and it could be useful to annotate the enum variant with the `#[flat]` "
"attribute. By doing so, we allow to opt out of the nested behavior and "
"ignore the variant name in the serialization process. On the other hand, "
"nested events have the benefit of distinguishing between the main contract "
"event and different components events, which might be helpful."
msgstr ""
"starknet::Event özelliğini türeten bir enum varyantı olduğunda, bu enum "
"varsayılan olarak yuvalanır. Bu nedenle, varyantın adına karşılık gelen "
"anahtarların listesi, varyantın adı arasındaki sn_keccak hash'ini "
"içerecektir. Bu, tipik olarak sözleşmelerde gömülü bileşenleri kullanırken "
"gereksiz olabilir. Gerçekten de, bu gibi durumlarda, ortaya çıkan herhangi "
"bir ek bileşen içermeyen olayların tanımlanmasını isteyebiliriz."

#: src/ch14-03-contract-events.md:46
msgid ""
"In our contract, we defined an event named `StoredName` that emits the "
"contract address of the caller and the name stored within the contract, "
"where the `user` field is serialized as a key and the `name` field is "
"serialized as data."
msgstr ""
"Sözleşmemizde, user alanının anahtar olarak seri hale getirildiği ve name "
"alanının veri olarak seri hale getirildiği, arayanın sözleşme adresini ve "
"sözleşme içinde depolanan adı yayan StoredName adlı bir olayı tanımladık."

#: src/ch14-03-contract-events.md:48
msgid ""
"Indexing events fields allows for more efficient queries and filtering of "
"events. To index a field as a key of an event, simply annotate it with the "
"`#[key]` attribute as demonstrated in the example for the `user` key. By "
"doing so, any indexed field will allow queries of events that contain a "
"given value for that field with \\\\( O(log(n)) \\\\) time complexity, while "
"non indexed fields require any query to iterate over all events, providing \\"
"\\( O(n) \\\\) time complexity."
msgstr ""
"İndeksleme olayları alanları daha verimli sorgulara ve olayların "
"filtrelenmesine izin verir. Bir alanı bir olayın anahtarı olarak indekslemek "
"için, user anahtarı örneğinde gösterildiği gibi #[anahtar] özniteliği ile "
"not edin. Bunu yaparak, indekslenmiş herhangi bir alan, (O(log(n)  zaman "
"karmaşıklığına sahip bu alan için belirli bir değer içeren olayların "
"sorgularına izin verir, indekslenmemiş alanların ise herhangi bir sorgusunu "
"gerektirir."

#: src/ch14-03-contract-events.md:50
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: "
"name })`, a key corresponding to the name ` StoredName`, specifically "
"`sn_keccak(StoredName)`, is appended to the keys list. `user`is serialized "
"as key, thanks to the `#[key]` attribute, while address is serialized as "
"data. After everything is processed, we end up with the following keys and "
"data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [name]`."
msgstr ""
"self.emit(StoredName  user: user, name: name ) ile olayı yayınlarken,  "
"StoredName ismine karşılık gelen bir anahtar, özellikle "
"sn_keccak(StoredName) anahtar listesine eklenir. username(StoredName) "
"anahtar olarak serileştirilir ve #[key] özniteliği sayesinde, adres veri "
"olarak işlenir."

#: src/ch14-03-contract-events.md:54
msgid "Emitting Events"
msgstr "Olayları Yayan"

#: src/ch14-03-contract-events.md:56
msgid ""
"After defining events, we can emit them using `self.emit`, with the "
"following syntax:"
msgstr ""
"Olayları tanımladıktan sonra, aşağıdaki sözdizimi ile self.emit kullanarak "
"bunları yayabiliriz:"

#: src/ch14-03-contract-events.md:62
msgid ""
"The `emit` function is called on `self` and takes a reference to `self`, i."
"e., state modification capabilities are required. Therefore, it is not "
"possible to emit events in view functions."
msgstr ""
"emit fonksiyonu self olarak adlandırılır ve self, yani durum değiştirme "
"yeteneklerine bir referans alır. Bu nedenle, görünüm işlevlerinde olayları "
"yaymak mümkün değildir."

#: src/ch15-00-starknet-cross-contract-interactions.md
msgid ""
"Interactions between smart contracts are an important feature when creating "
"complex decentralized applications, as it allows for composability and "
"separation of concerns. This chapter sheds light on how to make contracts "
"interact with each other."
msgstr ""
"Akıllı sözleşmeler arasındaki etkileşimler, karmaşık merkezi olmayan "
"uygulamalar yaratırken önemli bir özelliktir, çünkü bu, karmaşıklık ve "
"endişelerin ayrılmasına izin verir. Bu bölüm, sözleşmelerin birbirleriyle "
"nasıl etkileşime girebileceğine ışık tutar."

#: src/ch15-00-starknet-cross-contract-interactions.md
msgid ""
"Specifically, you'll learn about ABIs, contract interfaces, the contract and "
"library dispatchers and their low-level system call equivalents!"
msgstr ""
"Özellikle, ABI'ler, sözleşme arayüzleri, sözleşme ve kütüphane göndericileri "
"ve düşük seviyeli sistem çağrı eşdeğerleri hakkında bilgi edineceksiniz!"

#: src/ch15-01-abis-and-contract-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a "
"common practice which enables us to build flexible contracts that can speak "
"with each other."
msgstr ""
"Bir blok zincirindeki akıllı sözleşmeler arasındaki çapraz sözleşme "
"etkileşimleri, birbirleriyle konuşabilecek esnek sözleşmeler inşa etmemizi "
"sağlayan yaygın bir uygulamadır."

#: src/ch15-01-abis-and-contract-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr "Starknet'te bunu başarmak için ara yüz dediğimiz bir şey gerekiyor."

#: src/ch15-01-abis-and-contract-interfaces.md:7
msgid "ABI - Application Binary Interface"
msgstr "ABI - Uygulama İkili Arayüzü"

#: src/ch15-01-abis-and-contract-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the "
"contract's functions and structures, giving anyone (or any other contract) "
"the ability to form encoded calls to it. It is a blueprint that instructs "
"how functions should be called, what input parameters they expect, and in "
"what format."
msgstr ""
"Starknet'te, bir sözleşmenin ABI'si, sözleşmenin işlevlerinin ve yapılarının "
"JSON temsilidir, herhangi birine (veya başka bir sözleşmeye) kodlanmış "
"çağrılar oluşturma yeteneği verir. Fonksiyonların nasıl adlandırılması "
"gerektiğini, hangi girdi parametrelerini beklediklerini ve hangi formatta "
"olduğunu öğreten bir taslaktır."

#: src/ch15-01-abis-and-contract-interfaces.md:11
msgid ""
"While we write our smart contract logics in high-level Cairo, they are "
"stored on the VM as executable bytecodes which are in binary formats. Since "
"this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods "
"which can be called to a smart contract for execution. Without an ABI, it "
"becomes practically impossible for external actors to understand how to "
"interact with a contract."
msgstr ""
"Akıllı sözleşme mantıklarımızı üst düzey Kahire'de yazarken, VM'de ikili "
"formatlarda çalıştırılabilir bytecodes olarak depolanırlar. Bu bytecode "
"insan okunabilir olmadığından, yorumlanmasını gerektirir. Bu, ABI'lerin "
"devreye girdiği, yürütme için akıllı bir sözleşmeye çağrılabilecek belirli "
"yöntemleri tanımladığı yerdir. Bir ABI olmadan, dış aktörlerin bir "
"sözleşmeyle nasıl etkileşime gireceğini anlamaları pratik olarak imkansız "
"hale gelir."

#: src/ch15-01-abis-and-contract-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data "
"correctly, making it understandable by the smart contract and vice versa. "
"When you interact with a smart contract through a block explorer like "
"[Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), "
"they use the contract's ABI to format the data you send to the contract and "
"the data it returns."
msgstr ""
"ABI'ler tipik olarak dApps ön uçlarında kullanılır, verileri doğru "
"biçimlendirmesine izin verir, akıllı sözleşme ile anlaşılabilir hale getirir "
"ve tam tersi olur. [Voyager] (https://voyager.online/) veya [Starkscan] "
"(https://starkscan.co/) gibi bir blok gezgini aracılığıyla akıllı bir "
"sözleşme ile etkileşime girdiğinizde, sözleşmeye gönderdiğiniz verileri "
"biçimlendirmek için sözleşmenin ABI'sini kullanırlar ve verileri döndürür."

#: src/ch15-01-abis-and-contract-interfaces.md:15
#: src/ch16-05-02-randomness.md:25
msgid "Interface"
msgstr "Arayüz"

#: src/ch15-01-abis-and-contract-interfaces.md:17
msgid ""
"The interface of a contract is a list of the functions it exposes publicly. "
"It specifies the function signatures (name, parameters, visibility and "
"return value) contained in a smart contract without including the function "
"body."
msgstr ""
"Bir sözleşmenin arayüzü, herkese açık olarak ortaya çıkardığı işlevlerin bir "
"listesidir. İşlev gövdesini içermeyen akıllı bir sözleşmede yer alan işlev "
"imzalarını (isim, parametreler, görünürlük ve dönüş değeri) belirtir."

#: src/ch15-01-abis-and-contract-interfaces.md:20
msgid ""
"Contract interfaces in Cairo are traits annotated with the `#[starknet::"
"interface]` attribute. If you are new to traits, check out the dedicated "
"chapter on [traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"Kahire'deki sözleşme arayüzleri, #[starknet::interface] özniteliği ile "
"belirtilen özelliklerdir. Eğer özelliklerde yeniyseniz, [traits](./ch08-02-"
"traits-in-cairo.md) üzerindeki özel bölüme göz atın."

#: src/ch15-01-abis-and-contract-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the "
"`TContractState` type. This is required for functions to access the "
"contract's storage, so that they can read and write to it."
msgstr ""
"Önemli bir özellik, bu özelliğin TContractState tipi üzerinde jenerik olması "
"gerektiğidir. Bu, işlevlerin sözleşmenin deposuna erişmesi için gereklidir, "
"böylece okuma ve yazma yapabilirler."

#: src/ch15-01-abis-and-contract-interfaces.md:24
msgid ""
"Note: The contract constructor is not part of the interface. Nor are "
"internal functions part of the interface."
msgstr ""
"Not: Sözleşme oluşturucu arayüzün bir parçası değildir. İç fonksiyonlar da "
"arayüzün bir parçası değildir."

#: src/ch15-01-abis-and-contract-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's "
"a generic trait over the `TContractState` type. `view` functions have a self "
"parameter of type `@TContractState`, while `external` functions have a self "
"parameter of type passed by reference `ref self: TContractState`."
msgstr ""
"İşte bir ERC20 token sözleşmesi için örnek bir arayüz. Gördüğünüz gibi, "
"TContractState tipi üzerinde genel bir özelliktir. view fonksiyonları "
"TContractState tipinin öz parametresine sahipken, external fonksiyonları "
"referans ref self:TContractState tarafından aktarılan öz parametresine "
"sahiptir."

#: src/ch15-01-abis-and-contract-interfaces.md:55
msgid "<span class=\"caption\">Listing 15-1: A simple ERC20 Interface.</span>"
msgstr "span class=\"caption\">Listeleme 15-1: Basit bir ERC20 Arayüzü./span>"

#: src/ch15-01-abis-and-contract-interfaces.md:57
msgid ""
"In the next chapter, we will see how we can call contracts from other smart "
"contracts using _dispatchers_ and _syscalls_ ."
msgstr ""
"Bir sonraki bölümde, _dispatchers_ ve _syscalls_ kullanarak diğer akıllı "
"sözleşmelerden sözleşmeleri nasıl çağırabileceğimizi göreceğiz."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:3
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically "
"created and exported by the compiler. Let's consider an interface that we "
"named IERC20, these would be:"
msgstr ""
"Bir sözleşme arayüzü tanımlandığında, iki gönderici otomatik olarak "
"oluşturulur ve derleyici tarafından dışa aktarılır. IERC20 adını verdiğimiz "
"bir arayüz düşünelim, bunlar:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:5
msgid "The Contract Dispatcher `IERC20Dispatcher`"
msgstr "Sözleşme Dispatcher IERC20Dispatcher"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:6
msgid "The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr "Kütüphane Dispatcher IERC20LibraryDispatcher"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:8
msgid ""
"The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to "
"call the functions defined in the interface on the dispatcher struct."
msgstr ""
"Derleyici ayrıca bir özellik IERC20DispatcherTrait üretir, bu da gönderici "
"yapısındaki arayüzde tanımlanan işlevleri çağırmamızı sağlar."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:10
msgid ""
"In this chapter, we are going to discuss what these are, how they work and "
"how to use them."
msgstr ""
"Bu bölümde bunların ne olduğunu, nasıl çalıştıklarını ve nasıl "
"kullanılacağını tartışacağız."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:12
msgid ""
"To effectively break down the concepts in this chapter, we are going to be "
"using the IERC20 interface from the previous chapter (refer to Listing 15-1)."
msgstr ""
"Bu bölümdeki kavramları etkili bir şekilde parçalamak için, önceki bölümden "
"IERC20 arayüzünü kullanacağız (Listeleme 151'e bakınız)."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:14
msgid "Contract Dispatcher"
msgstr "Sözleşme Dispatcher"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` "
"attribute automatically generate a dispatcher and a trait on compilation. "
"Our `IERC20` interface is expanded into something like this:"
msgstr ""
"Daha önce de belirtildiği gibi, #[starknet::interface] özniteliği ile "
"belirtilen özellikler otomatik olarak bir gönderici ve derleme üzerinde bir "
"özellik oluşturur. IERC20 arayüzümüz şu şekilde genişletilir:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:19
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to "
"keep this chapter concise and straight to the point, we focused on one view "
"function `name`, and one external function `transfer`."
msgstr ""
"** Not: ** IERC20 arayüzümüz için genişletilmiş kod çok daha uzundur, ancak "
"bu bölümü özlü ve düz bir noktaya getirmek için, bir görünüm fonksiyonu name "
"ve bir dış fonksiyon transfer üzerine odaklandık."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:37
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:41
msgid "// starknet::call_contract_syscall is called in here\n"
msgstr "// starknet::call_contract_syscall buraya çağrılır\n"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:46
msgid ""
"<span class=\"caption\">Listing 15-2: An expanded form of the "
"IERC20Dispatcher trait.</span>"
msgstr ""
"span class=\"caption\">Liste 15-2: IERC20Dispatcher özelliğinin "
"genişletilmiş bir formu./span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a "
"contract address and implements the `DispatcherTrait` generated by the "
"compiler, allowing us to call functions from another contract. This means "
"that we can instantiate a struct with the address of the contract we want to "
"call, and then simply call the functions defined in the interface on the "
"dispatcher struct as if they were methods of that type."
msgstr ""
"Gördüğünüz gibi, \"klasik\" gönderici sadece bir sözleşme adresini saran ve "
"derleyici tarafından oluşturulan DispatcherTrait'i uygulayan, başka bir "
"sözleşmeden fonksiyonları çağırmamızı sağlayan bir yapıdır. Bu, aramak "
"istediğimiz sözleşmenin adresiyle bir yapıyı hazırlayabileceğimiz anlamına "
"gelir ve daha sonra basitçe, gönderici yapıdaki arayüzde tanımlanan "
"işlevleri, yöntemlerden biriymiş gibi adlandırabiliriz."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:50
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes "
"thanks to the power of Cairo plugins."
msgstr ""
"Ayrıca tüm bunların Kahire eklentilerinin gücü sayesinde sahne arkasında "
"soyutlandığını da belirtmek gerekir."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:52
msgid "Calling Contracts using the Contract Dispatcher"
msgstr "Sözleşme dağıtıcısını kullanarak Sözleşmeleri çağırmak"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:54
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to "
"call functions defined on an ERC-20 token. Calling `transfer_token` will "
"modify the state of the contract deployed at `contract_address`."
msgstr ""
"Bu, TokenWrapper adlı bir sözleşmenin bir ERC-20 belirteci üzerinde "
"tanımlanan işlevleri çağırmak için bir gönderici kullanarak bir örneğidir. "
"transfer_token çağrısı, contract_address adresinde konuşlandırılan "
"sözleşmenin durumunu değiştirecektir."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:94
msgid "//**** Specify interface here ****//\n"
msgstr "//**** Burada arayüz belirtin ***//\n"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:125
msgid ""
"<span class=\"caption\">Listing 15-3: A sample contract which uses the "
"Contract Dispatcher.</span>"
msgstr ""
"span class=\"caption=\"Listing 15-3: Contract Dispatcher kullanan bir örnek "
"sözleşme./span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:127
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` generated by the compiler, which allows us to make calls "
"to the methods implemented for the `IERC20Dispatcher` struct (`name`, "
"`transfer`, etc), passing in the `contract_address` of the contract we want "
"to call in the `IERC20Dispatcher` struct."
msgstr ""
"Gördüğünüz gibi, ilk önce IERC20DispatcherTrait ve IERC20Dispatcher'yi "
"derleyici tarafından oluşturulan ve IERC20Dispatcher struct (name, transfer, "
"vb.) için uygulanan yöntemlere çağrılar yapmamızı sağlayan "
"earch20DispatcherTrait ve IERC'de aramak istediğimiz sözleşmenin "
"contractle_adres'ini içe aktarmamız gerekiyordu."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:129
msgid "Library Dispatcher"
msgstr "Kütüphane Dispatcher"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library "
"dispatcher lies in the execution context of the logic defined in the class. "
"While regular dispatchers are used to call functions from **contracts** "
"(with an associated state), library dispatchers are used to call **classes** "
"(stateless)."
msgstr ""
"Sözleşmeli gönderici ile kütüphane göndericisi arasındaki temel fark, "
"sınıfta tanımlanan mantığın yürütme bağlamında yatmaktadır. Düzenli "
"göndericiler ** sözleşmeli ** 'den fonksiyonları çağırmak için kullanılırken "
"(bir ilişkili devlet ile), kütüphane göndericileri ** sınıfları ** "
"(devletsiz) çağırmak için kullanılır."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr "İki sözleşmeli A ve B'yi ele alalım."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the "
"execution context of the logic defined in B is that of B. This means that "
"the value returned by `get_caller_address()` in B will return the address of "
"A, and updating a storage variable in B will update the storage of B."
msgstr ""
"A, ** sözleşme** B'den fonksiyonları çağırmak için IBDispatcher "
"kullandığında, B'de tanımlanan mantığın yürütme bağlamı B'ninkidir. Bu, B'de "
"get_caller_address() tarafından döndürülen değerin A'nın adresini "
"döndüreceği ve B'de bir depolama değişkenini güncellemenin B'nin "
"depolamasını güncelleyeceği anlamına gelir."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B, "
"the execution context of the logic defined in B's class is that of A. This "
"means that the value returned by `get_caller_address()` variable in B will "
"return the address of the caller of A, and updating a storage variable in "
"B's class will update the storage of A (remember that the **class** of B is "
"stateless; there is no state that can be updated!)"
msgstr ""
"A, B'nin ** sınıfından ** işlevlerini çağırmak için IBLibraryDispatcher "
"kullandığında, B'nin sınıfında tanımlanan mantığın yürütme bağlamı A'dır. "
"Bu, B'deki get_caller_address() değişkeni tarafından döndürülen değerin "
"A'nın arayanının adresini döndüreceği ve B'nin sınıfındaki bir depolama "
"değişkeninin güncellenemeyeceği anlamına gelir."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:139
msgid ""
"The expanded form of the struct and trait generated by the compiler look "
"like:"
msgstr ""
"Derleyici tarafından oluşturulan yapının ve özelliğin genişletilmiş biçimi "
"şöyle görünüyor:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:157
#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:161
msgid "// starknet::syscalls::library_call_syscall  is called in here\n"
msgstr "// starknet::syscalls::library_call_syscall burada çağrılır\n"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:166
msgid ""
"<span class=\"caption\">Listing 15-4: An expanded form of the IERC20 trait.</"
"span>"
msgstr ""
"span class=\"caption\">Listeleme 15-4: IERC20 özelliğinin genişletilmiş bir "
"formu./span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:168
msgid ""
"Notice that the main difference between the regular contract dispatcher and "
"the library dispatcher is that the former uses `call_contract_syscall` while "
"the latter uses `library_call_syscall`."
msgstr ""
"Düzenli sözleşme göndericisi ile kütüphane göndericisi arasındaki temel "
"farkın, eskisinin call_contract_syscall kullanırken, ikincisinin "
"library_call_syscall kullandığına dikkat edin."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:170
msgid "Calling Contracts using the Library Dispatcher"
msgstr "Kütüphane Göndericisini Kullanarak Sözleşmeleri Aramak"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:172
msgid ""
"Below's a sample code for calling contracts using the Library Dispatcher."
msgstr ""
"Aşağıda Kütüphane Dispatcher'ı kullanarak sözleşmeleri aramak için örnek bir "
"kod verilmiştir."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:208
msgid ""
"<span class=\"caption\">Listing 15-5: A sample contract using the Library "
"Dispatcher.</span>"
msgstr ""
"span class=\"caption=\"Listing 15-5: Library Dispatcher'ı kullanan bir örnek "
"sözleşme./span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:210
msgid ""
"As you can see, we had to first import in our contract the "
"`IContractADispatcherTrait` and `IContractALibraryDispatcher` which were "
"generated from our interface by the compiler. Then, we can create an "
"instance of `IContractALibraryDispatcher` passing in the `class_hash` of the "
"class we want to make library calls to. From there, we can call the "
"functions defined in that class, executing its logic in the context of our "
"contract. When we call `set_value` on ContractA, it will make a library call "
"to the `set_value` function in IContractA, updating the value of the storage "
"variable `value` in ContractA."
msgstr ""
"Gördüğünüz gibi, ilk önce IContractAdispatcherTrait ve "
"IContractALibraryDispatcher adlı sözleşmemizde, derleyici tarafından "
"arayüzümüzden oluşturulan IContractALibraryDispatcher değerini, class_hash "
"olarak tanımlanan sınıftan geçen bir IContractALibraryDispatcher örneği "
"oluşturabiliriz."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:212
msgid "Using low-level syscalls"
msgstr "Düşük seviyeli syscalls kullanımı"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:214
msgid ""
"Another way to call other contracts and classes is to use the `starknet::"
"call_contract_syscall`and `starknet::library_call_syscall` system calls. The "
"dispatchers we described in the previous sections are high-level syntaxes "
"for these low-level system calls."
msgstr ""
"Diğer sözleşmeleri ve sınıfları çağırmanın bir başka yolu, starknet::"
"call_contract_syscall ve starknet::library_call_syscall sistem çağrılarını "
"kullanmaktır. Önceki bölümlerde tanımladığımız göndericiler, bu düşük "
"seviyeli sistem çağrıları için üst düzey sözdizimleridir."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:216
msgid ""
"Using these syscalls can be handy for customized error handling or to get "
"more control over the serialization/deserialization of the call data and the "
"returned data. Here's an example demonstrating how to use a "
"`call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr ""
"Bu syscall'ları kullanmak, özelleştirilmiş hata işleme için veya çağrı "
"verilerinin ve iade edilen verilerin serileştirilmesi / serileştirilmesi "
"üzerinde daha fazla kontrol elde etmek için kullanışlı olabilir. İşte bir "
"ERC20 sözleşmesinin transfer işlevini aramak için bir call_contract_sycall "
"nasıl kullanılacağını gösteren bir örnek:"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:254
msgid "\"transferFrom\""
msgstr "\"transferFrom\""

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:265
msgid ""
"<span class=\"caption\">Listing 15-6: A sample contract using syscalls.</"
"span>"
msgstr ""
"span class=\"caption=\"Listing 15-6: Syscalls kullanarak bir örnek sözleşme./"
"span>"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:267
msgid ""
"To use this syscall, we passed in the contract address, the selector of the "
"function we want to call (see next section), and the call arguments."
msgstr ""
"Bu syscall'ı kullanmak için, sözleşme adresini, aramak istediğimiz "
"fonksiyonun seçicisini (bir sonraki bölüme bakın) ve çağrı argümanlarını "
"geçtik."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:269
msgid ""
"The call arguments must be provided as an array of `felt252`. To build this "
"array, we serialize the expected function parameters into an "
"`Array<felt252>` using the `Serde` trait, and then pass this array as "
"calldata. At the end, we are returned a serialized value which we'll need to "
"deserialize ourselves!"
msgstr ""
"Çağrı argümanları bir dizi felt252 olarak sağlanmalıdır. Bu diziyi "
"oluşturmak için, beklenen fonksiyon parametrelerini bir Arrayfelt252> Serde "
"özelliğini kullanarak seri hale getiriyoruz ve daha sonra bu diziyi calldata "
"olarak geçiyoruz. Sonunda, kendimizi deserialize etmemiz gereken "
"serileştirilmiş bir değere geri dönüyoruz!"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:271
msgid "Entry Point Selector"
msgstr "Giriş Noktası Seçici"

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:273
msgid ""
"In the context of a smart contract, a selector is a unique identifier for a "
"specific entrypoint of a contract. When a transaction is sent to a contract, "
"it includes the selector in the calldata to specify which function should be "
"executed."
msgstr ""
"Akıllı bir sözleşme bağlamında, bir seçici, bir sözleşmenin belirli bir "
"giriş noktası için benzersiz bir tanımlayıcıdır. Bir işlem bir sözleşmeye "
"gönderildiğinde, hangi işlevin yürütülmesi gerektiğini belirtmek için çağrı "
"verisindeki seçiciyi içerir."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:275
msgid ""
"On Starknet, the selector is computed by applying the `sn_keccak` hash "
"function to the string representation of the function name. If the function "
"name is `transfer`, the selector can be computed with `selector!"
"(\"transfer\")`"
msgstr ""
"Starknet'te seçici, fonksiyon adının dize gösterimine sn_keccak hash "
"fonksiyonunu uygulayarak hesaplanır. Eğer fonksiyon adı transfer ise, seçici "
"selector!(\"transfer\") ile hesaplanabilir."

#: src/ch15-02-contract-dispatchers-library-dispatchers-and-system-calls.md:277
msgid ""
"Note that in `starknet::call_contract_syscall`, we didn't specify the "
"function name as a string, but rather used the `selector!` macro, which "
"computes the `sn_keccak` hash of the provided function signature."
msgstr ""
"starknet::call_contract_syscall'de fonksiyon adını dize olarak "
"belirtmediğimizi, bunun yerine verilen fonksiyon imzasının sn_keccak "
"hash'ini hesaplayan selector! makrosunu kullandığını unutmayın."

#: src/ch16-01-optimizing-storage-costs.md:3
msgid ""
"Bit-packing is a simple concept: use as few bits as possible to store a "
"piece of data. When done well, it can significantly reduce the size of the "
"data you need to store. This is especially important in smart contracts, "
"where storage is expensive."
msgstr ""
"Bit paketleme basit bir kavramdır: bir veri parçasını saklamak için mümkün "
"olduğunca az bit kullanın. İyi yapıldığında, saklamanız gereken verilerin "
"boyutunu önemli ölçüde azaltabilir. Bu, depolamanın pahalı olduğu akıllı "
"sözleşmelerde özellikle önemlidir."

#: src/ch16-01-optimizing-storage-costs.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage "
"usage to reduce gas costs. Indeed, most of the cost associated with a "
"transaction is related to storage updates; and each storage slot costs gas "
"to write to. This means that by packing multiple values into fewer slots, "
"you can decrease the gas cost incurred by the users of your smart contract."
msgstr ""
"Kahire akıllı sözleşmeleri yazarken, gaz maliyetlerini azaltmak için "
"depolama kullanımını optimize etmek önemlidir. Gerçekten de, bir işlemle "
"ilişkili maliyetin çoğu depolama güncellemeleri ile ilgilidir; ve her bir "
"depolama yuvasına yazılacak gaz maliyeti. Bu, birden fazla değeri daha az "
"yuvaya paketleyerek, akıllı sözleşmenizin kullanıcılarının maruz kaldığı gaz "
"maliyetini azaltabileceğiniz anlamına gelir."

#: src/ch16-01-optimizing-storage-costs.md:8
msgid "Integer Structure and Bitwise Operators"
msgstr "Integer Yapısı ve Bitwise Operatörleri"

#: src/ch16-01-optimizing-storage-costs.md:10
msgid ""
"An integer is coded on a certain number of bits, depending on its size (For "
"example, a `u8` integer is coded on 8 bits)."
msgstr ""
"Bir tam sayı, boyutuna bağlı olarak belirli sayıda bit üzerinde kodlanır "
"(örneğin, bir u8 tamsayısı 8 bit üzerinde kodlanır)."

#: src/ch16-01-optimizing-storage-costs.md:19
msgid ""
"Intuitively, several integers can be combined into a single integer if the "
"size of this single integer is greater than or equal to the sum of the sizes "
"of the integers (For example, two `u8` and one `u16` in one `u32`)."
msgstr ""
"Sezgisel olarak, bu tek tamsayının boyutu tamsayıların boyutlarının "
"toplamından büyük veya eşitse, birkaç tamsayı tek bir tamsayıda "
"birleştirilebilir (örneğin, iki u8 ve bir u16 bir u32)."

#: src/ch16-01-optimizing-storage-costs.md:21
msgid "But, to do that, we need some bitwise operators:"
msgstr "Ancak, bunun için, bazı bitwise operatörlerine ihtiyacımız var:"

#: src/ch16-01-optimizing-storage-costs.md:23
msgid ""
"multiplying or dividing an integer by a power of 2 shifts the integer value "
"to the left or to the right respectively"
msgstr ""
"Bir tamsayıyı 2'lik bir güçle çarpmak veya bölmek, tamsayı değerini "
"sırasıyla sola veya sağa kaydırır."

#: src/ch16-01-optimizing-storage-costs.md:32
msgid ""
"applying a mask (`AND` operator) on an integer value isolates some bits of "
"this integer"
msgstr ""
"Bir tam sayı değeri üzerine bir maske (AND operatörü) uygulamak, bu tam "
"sayının bazı bitlerini izole eder."

#: src/ch16-01-optimizing-storage-costs.md:41
msgid ""
"adding (`OR` operator) two integers will combine both values into a single "
"one."
msgstr ""
"(OR operatörü) ekleyerek iki tam sayı, her iki değeri de tek bir değerde "
"birleştirecektir."

#: src/ch16-01-optimizing-storage-costs.md:50
msgid ""
"With these bitwise operators, let's see how to combine two `u8` integers "
"into a single `u16` integer (called `packing`) and reversely (called "
"`unpacking`) in the following example:"
msgstr ""
"Bu bitwise operatörleri ile, iki u8 tamsayısını tek bir u16 tamsayısı "
"(packing olarak adlandırılır) ve ters olarak (unpacking olarak adlandırılır) "
"aşağıdaki örnekte nasıl birleştireceğimizi görelim:"

#: src/ch16-01-optimizing-storage-costs.md:59
msgid "Bit-packing in Cairo"
msgstr "Kahire'de Bit-paketleme"

#: src/ch16-01-optimizing-storage-costs.md:61
msgid ""
"The storage of a Starknet smart contract is a map with 2<sup>251</sup> "
"slots, where each slot is a `felt252` which is initialized to 0."
msgstr ""
"Bir Starknet akıllı sözleşmenin depolanması, her bir yuvanın 0 olarak "
"başlatıldığı felt252 olan 2sup>251/sup> yuvalarına sahip bir haritadır."

#: src/ch16-01-optimizing-storage-costs.md:63
msgid ""
"As we saw earlier, to reduce gas costs due to storage updates, we have to "
"use as few bits as possible, so we have to organize stored variables by "
"packing them."
msgstr ""
"Daha önce gördüğümüz gibi, depolama güncellemeleri nedeniyle gaz "
"maliyetlerini azaltmak için mümkün olduğunca az bit kullanmak zorundayız, bu "
"yüzden bunları paketleyerek depolanan değişkenleri organize etmeliyiz."

#: src/ch16-01-optimizing-storage-costs.md:65
msgid ""
"For example, consider the following `Sizes` struct with 3 fields of "
"different types: one `u8`, one `u32` and one `u64`. The total size is 8 + 32 "
"+ 64 = 104 bits. This is less than a slot size (i.e 251 bits) so we can pack "
"them together to be stored into a single slot."
msgstr ""
"Örneğin, aşağıdaki Sizes yapısını 3 farklı türdeki alanla düşünün: bir u8, "
"bir u32 ve bir u64. Toplam boyut 8 + 32 + 64 = 104 bit'tir. Bu, bir yuva "
"boyutundan (yani 251 bit) daha azdır, böylece onları tek bir yuvaya saklamak "
"için bir araya getirebiliriz."

#: src/ch16-01-optimizing-storage-costs.md:67
msgid ""
"Note that, as it also fits in a `u128`, it's a good practice to use the "
"smallest type to pack all your variables, so here a `u128` should be used."
msgstr ""
"u128'ye de uyduğu için, tüm değişkenlerinizi paketlemek için en küçük türü "
"kullanmak iyi bir uygulamadır, bu nedenle burada bir u128 kullanılmalıdır."

#: src/ch16-01-optimizing-storage-costs.md:77
msgid ""
"To pack these 3 variables into a `u128` we have to successively shift them "
"to the left, and finally sum them."
msgstr ""
"Bu 3 değişkeni bir u128 olarak paketlemek için bunları art arda sola "
"kaydırmamız ve son olarak bunları özetlememiz gerekir."

#: src/ch16-01-optimizing-storage-costs.md:86
msgid ""
"To unpack these 3 variables from a `u128` we have to successively shift them "
"to the right and use a mask to isolate them."
msgstr ""
"Bu 3 değişkeni bir u128'den açmak için bunları art arda sağa kaydırmalı ve "
"onları izole etmek için bir maske kullanmalıyız."

#: src/ch16-01-optimizing-storage-costs.md:95
msgid "The `StorePacking` Trait"
msgstr "StorePacking Trait"

#: src/ch16-01-optimizing-storage-costs.md:97
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into "
"fewer storage slots. `StorePacking<T, PackedT>` is a generic trait taking "
"the type you want to pack (`T`) and the destination type (`PackedT`) as "
"parameters. It provides two functions to implement: `pack` and `unpack`."
msgstr ""
"Kahire, yapı alanlarını daha az depolama yuvasına paketlemeyi etkinleştirmek "
"için StorePacking özelliğini sağlar. StorePackingT, PackedT>, paketlemek "
"istediğiniz türü (T) ve varış türünü (PackedT) parametre olarak alan genel "
"bir özelliktir. Uygulamak için iki işlev sağlar: pack ve unpack."

#: src/ch16-01-optimizing-storage-costs.md:99
msgid "Here is the implementation of the example of the previous chapter:"
msgstr "İşte bir önceki bölümün örneğinin uygulanması:"

#: src/ch16-01-optimizing-storage-costs.md:138
msgid "//don't forget to import it!\n"
msgstr "//ithal etmeyi unutmayın!\n"

#: src/ch16-01-optimizing-storage-costs.md:147
msgid ""
"// This will automatically pack the\n"
"        // struct into a single u128\n"
msgstr "// Bu, // yapısını otomatik olarak tek bir u128'e paketleyecektir.\n"

#: src/ch16-01-optimizing-storage-costs.md:155
msgid ""
"// this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
msgstr ""
"// bu otomatik olarak // paketlenmiş-temsilini Boyutlar yapısında açar\n"

#: src/ch16-01-optimizing-storage-costs.md:166
msgid "In this code snippet, you see that:"
msgstr "Bu kod snippet'inde şunu görüyorsunuz:"

#: src/ch16-01-optimizing-storage-costs.md:168
msgid ""
"`TWO_POW_8` and `TWO_POW_40` are used to shift left in the `pack` function "
"and shift right in the `unpack`function,"
msgstr ""
"TWO_POW_8 ve TWO_POW_40, pack fonksiyonunda sola kaymak ve unpack işlevinde "
"sağa kaymak için kullanılır,"

#: src/ch16-01-optimizing-storage-costs.md:169
msgid ""
"`MASK_8` and `MASK_32` are used to isolate a variable in the `unpack` "
"function,"
msgstr ""
"MASK_8 ve MASK_32, unpack işlevindeki bir değişkeni izole etmek için "
"kullanılır,"

#: src/ch16-01-optimizing-storage-costs.md:170
msgid ""
"all the variables from the storage are converted to `u128` to be able to use "
"bitwise operators."
msgstr ""
"Depolamadaki tüm değişkenler bitwise operatörlerini kullanabilmek için "
"u128'ye dönüştürülür."

#: src/ch16-01-optimizing-storage-costs.md:172
msgid ""
"This technique can be used for any group of fields that fit within the bit "
"size of the packed storage type. For example, if you have a struct with "
"multiple fields whose bit sizes add up to 256 bits, you can pack them into a "
"single `u256` variable. If the bit sizes add up to 512 bits, you can pack "
"them into a single `u512` variable, and so on. You can define your own "
"structs and logic to pack and unpack them."
msgstr ""
"Bu teknik, paketlenmiş depolama türünün bit boyutuna uyan herhangi bir alan "
"grubu için kullanılabilir. Örneğin, bit boyutları 256 bit'e kadar olan "
"birden fazla alana sahip bir yapınız varsa, bunları tek bir u256 değişkenine "
"paketleyebilirsiniz. Bit boyutları 512 bit'e kadar eklenirse, bunları tek "
"bir u512 değişkenine paketleyebilirsiniz, vb. Kendi yapılarınızı "
"tanımlayabilir ve bunları paketleyebilirsiniz."

#: src/ch16-01-optimizing-storage-costs.md:174
msgid ""
"The rest of the work is done magically by the compiler - if a type "
"implements the `StorePacking` trait, then the compiler will know it can use "
"the `StoreUsingPacking` implementation of the `Store` trait in order to pack "
"before writing and unpack after reading from storage. One important detail, "
"however, is that the type that `StorePacking::pack` spits out also has to "
"implement `Store` for `StoreUsingPacking` to work. Most of the time, we will "
"want to pack into a felt252 or u256 - but if you want to pack into a type of "
"your own, make sure that this one implements the `Store` trait."
msgstr ""
"İşin geri kalanı, derleyici tarafından sihirli bir şekilde yapılır - bir tür "
"bu StorePacking özelliğini uygularsa, derleyici, depolamadan okuduktan sonra "
"StoreUsingPacking özelliğini paketlemek ve paketlemek için Store özelliğini "
"kullanabileceğini bilecektir. Bununla birlikte, en önemli ayrıntı, "
"StorePacking:pack tükürüğünün Store'u uygulamak için de sahip olmasını "
"isteyeceğiniz türdendir."

#: src/ch16-02-00-composability-and-components.md:1
msgid "Components: Lego-Like Building Blocks for Smart Contracts"
msgstr "Bileşenleri: Akıllı Sözleşmeler için Lego-Like Yapı Blokları"

#: src/ch16-02-00-composability-and-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and "
"bug-prone, as this logic can hardly be reused and needs to be reimplemented "
"in each contract. But what if there was a way to snap in just the extra "
"functionality you need inside your contract, separating the core logic of "
"your contract from the rest?"
msgstr ""
"Ortak bir mantığı ve depolamayı paylaşan sözleşmeler geliştirmek acı verici "
"ve hataya eğilimli olabilir, çünkü bu mantık neredeyse tekrar kullanılamaz "
"ve her sözleşmede yeniden uygulanması gerekir. Ancak, sözleşmenizin temel "
"mantığını diğerlerinden ayırarak, sözleşmenizin içinde ihtiyacınız olan "
"ekstra işlevselliği yakalamanın bir yolu olsaydı ne olurdu?"

#: src/ch16-02-00-composability-and-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating "
"reusable logic, storage, and events that can be incorporated into multiple "
"contracts. They can be used to extend a contract's functionality, without "
"having to reimplement the same logic over and over again."
msgstr ""
"Bileşenler tam olarak bunu sağlar. Birden fazla sözleşmeye dahil "
"edilebilecek yeniden kullanılabilir mantığı, depolamayı ve olayları "
"kapsülleyen modüler eklentilerdir. Aynı mantığı tekrar tekrar uygulamak "
"zorunda kalmadan bir sözleşmenin işlevselliğini genişletmek için "
"kullanılabilirler."

#: src/ch16-02-00-composability-and-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts "
"by plugging in a module that you or someone else wrote. This module can be a "
"simple one, like an ownership component, or more complex like a full-fledged "
"ERC20 token."
msgstr ""
"Bileşenleri Lego blokları olarak düşünün. Sizin veya bir başkasının yazdığı "
"bir modülü takarak sözleşmelerinizi zenginleştirmenizi sağlarlar. Bu modül, "
"bir sahiplik bileşeni gibi basit veya tam teşekküllü bir ERC20 jetonu gibi "
"daha karmaşık olabilir."

#: src/ch16-02-00-composability-and-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and "
"functions. Unlike a contract, a component cannot be declared or deployed. "
"Its logic will eventually be part of the contract’s bytecode it has been "
"embedded in."
msgstr ""
"Bir bileşen, depolama, olay ve işlevleri içerebilen ayrı bir modüldür. Bir "
"sözleşmenin aksine, bir bileşen ilan edilemez veya dağıtılamaz. Mantığı, "
"sonunda, gömülü olduğu sözleşmenin bytecode'unun bir parçası olacaktır."

#: src/ch16-02-00-composability-and-components.md:24
msgid "What's in a Component?"
msgstr "Bileşende ne var?"

#: src/ch16-02-00-composability-and-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr "Bir bileşen bir sözleşmeye çok benzer. Aşağıdakileri içerebilir:"

#: src/ch16-02-00-composability-and-components.md:28
msgid "Storage variables"
msgstr "Depolama değişkenleri"

#: src/ch16-02-00-composability-and-components.md:29
msgid "Events"
msgstr "Etkinlikler"

#: src/ch16-02-00-composability-and-components.md:30
msgid "External and internal functions"
msgstr "Dış ve iç fonksiyonlar"

#: src/ch16-02-00-composability-and-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The "
"component's code becomes part of the contract it's embedded to."
msgstr ""
"Bir sözleşmeden farklı olarak, bir bileşen kendi başına konuşlandırılamaz. "
"Bileşenin kodu, gömülü olduğu sözleşmenin bir parçası haline gelir."

#: src/ch16-02-00-composability-and-components.md:35
msgid "Creating Components"
msgstr "Bileşenlerin Oluşturulması"

#: src/ch16-02-00-composability-and-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a "
"`#[starknet::component]` attribute. Within this module, you can declare a ` "
"Storage` struct and `Event` enum, as usually done in [contracts](./ch13-02-"
"anatomy-of-a-simple-contract.md)."
msgstr ""
"Bir bileşen oluşturmak için, önce bir #[starknet::component] özniteliği ile "
"dekore edilmiş kendi modülünde tanımlayın. Bu modül içinde, genellikle "
"[contracts](./ch13-02-anatomy-of-a-simple-contract.md) 'de yapıldığı gibi "
"bir  Storage struct ve Event enum ilan edebilirsiniz."

#: src/ch16-02-00-composability-and-components.md:41
msgid ""
"The next step is to define the component interface, containing the "
"signatures of the functions that will allow external access to the "
"component's logic. You can define the interface of the component by "
"declaring a trait with the `#[starknet::interface]` attribute, just as you "
"would with contracts. This interface will be used to enable external access "
"to the component's functions using the [dispatcher](./ch15-02-contract-"
"dispatchers-library-dispatchers-and-system-calls.md) pattern."
msgstr ""
"Bir sonraki adım, bileşenin mantığına harici erişim sağlayacak işlevlerin "
"imzalarını içeren bileşen arayüzünü tanımlamaktır. #[starknet:interface] "
"özniteliği ile bir özellik bildirerek bileşenin arayüzünü "
"tanımlayabilirsiniz, tıpkı sözleşmelerde olduğu gibi. Bu arayüz, bileşenin "
"işlevlerine [dispatcher](./ch15-02-contract-dispat-chers."

#: src/ch16-02-00-composability-and-components.md:48
msgid ""
"The actual implementation of the component's external logic is done in an "
"`impl` block marked as `#[embeddable_as(name)]`. Usually, this `impl` block "
"will be an implementation of the trait defining the interface of the "
"component."
msgstr ""
"Bileşenin dış mantığının gerçek uygulaması, #[embeddable_as(name)]] olarak "
"işaretlenmiş bir impl bloğunda yapılır. Genellikle, bu impl bloğu, bileşenin "
"arayüzünü tanımlayan özelliğin bir uygulaması olacaktır."

#: src/ch16-02-00-composability-and-components.md:52
msgid ""
"Note: `name` is the name that we’ll be using in the contract to refer to the "
"component. It is different than the name of your impl."
msgstr ""
"Not: name, sözleşmede bileşene atıfta bulunmak için kullanacağımız isimdir. "
"Bu, impl'nizin adından farklıdır."

#: src/ch16-02-00-composability-and-components.md:55
msgid ""
"You can also define internal functions that will not be accessible "
"externally, by simply omitting the `#[embeddable_as(name)]` attribute above "
"the internal `impl` block. You will be able to use these internal functions "
"inside the contract you embed the component in, but not interact with it "
"from outside, as they're not a part of the abi of the contract."
msgstr ""
"Ayrıca #[embeddable_as(name)] özniteliğini dahili impl bloğunun üstünden "
"atlayarak harici olarak erişilemeyecek iç fonksiyonları da "
"tanımlayabilirsiniz. Bu iç işlevleri, bileşeni yerleştirdiğiniz sözleşmenin "
"içinde kullanabilirsiniz, ancak sözleşmenin abisinin bir parçası olmadıkları "
"için dışarıdan etkileşimde bulunamazsınız."

#: src/ch16-02-00-composability-and-components.md:61
msgid ""
"Functions within these `impl` block expect arguments like `ref self: "
"ComponentState<TContractState>` (for state-modifying functions) or `self: "
"@ComponentState<TContractState>` (for view functions). This makes the impl "
"generic over `TContractState`, allowing us to use this component in any "
"contract."
msgstr ""
"Bu impl bloğu içindeki işlevler, ref benliği: ComponentStateTContractState> "
"(devlet değiştirme işlevleri için) veya self: @ComponentStateTContractState> "
"(görme işlevleri için) gibi argümanları bekler. Bu, impl jenerikini "
"TContractState üzerinde yapar ve bu bileşeni herhangi bir sözleşmede "
"kullanmamıza izin verir."

#: src/ch16-02-00-composability-and-components.md:70
msgid "Example: an Ownable Component"
msgstr "Örnek: Sahiplenilebilir Bileşen"

#: src/ch16-02-00-composability-and-components.md:72
msgid ""
"⚠️ The example shown below has not been audited and is not intended for "
"production use. The authors are not responsible for any damages caused by "
"the use of this code."
msgstr ""
"Aşağıda gösterilen örnek denetlenmemiştir ve üretim kullanımına yönelik "
"değildir. Yazarlar bu kodun kullanımından kaynaklanan herhangi bir zarardan "
"sorumlu değildir."

#: src/ch16-02-00-composability-and-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available "
"externally to manage ownership of a contract, would look like this:"
msgstr ""
"Bir sözleşmenin mülkiyetini yönetmek için harici olarak mevcut yöntemleri "
"tanımlayan Sahipli bileşenin arayüzü şu şekilde görünecektir:"

#: src/ch16-02-00-composability-and-components.md:88
msgid "The component itself is defined as:"
msgstr "Bileşenin kendisi şöyle tanımlanır:"

#: src/ch16-02-00-composability-and-components.md:166
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The "
"only differences relate to the `#[embeddable_as]` attribute above the impl "
"and the genericity of the impl block that we will dissect in details."
msgstr ""
"Bu sözdizimi aslında sözleşmeler için kullanılan sözdizimi ile oldukça "
"benzerdir. Tek farklar, impl'nin üzerindeki #[embeddable_as] özniteliği ve "
"ayrıntılı olarak inceleyeceğimiz impl bloğunun genelliği ile ilgilidir."

#: src/ch16-02-00-composability-and-components.md:170
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to "
"the implementation of the interface trait, and one containing methods that "
"should not be exposed externally and are only meant for internal use. "
"Exposing the `assert_only_owner` as part of the interface wouldn't make "
"sense, as it's only meant to be used internally by a contract embedding the "
"component."
msgstr ""
"Gördüğünüz gibi, bileşenimizin iki impl bloğu vardır: biri arayüz "
"özelliğinin uygulanmasına karşılık gelir ve biri harici olarak maruz "
"bırakılmaması gereken ve yalnızca dahili kullanım için olan yöntemleri "
"içerir. Arayüzün bir parçası olarak assert_only_owner'ı açığa çıkarmak "
"mantıklı olmaz, çünkü yalnızca bileşeni gömen bir sözleşme ile dahili olarak "
"kullanılması amaçlanmıştır."

#: src/ch16-02-00-composability-and-components.md:176
msgid "A Closer Look at the `impl` Block"
msgstr "impl Bloğuna Daha Yakından Bir Bakış"

#: src/ch16-02-00-composability-and-components.md:185
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable "
"inside a contract. It allows us to specify the name of the impl that will be "
"used in the contract to refer to this component. In this case, the component "
"will be referred to as `Ownable` in contracts embedding it."
msgstr ""
"#[embeddable_as] özniteliği, impl'i bir sözleşmenin içine gömülebilir olarak "
"işaretlemek için kullanılır. Bu bileşene atıfta bulunmak için sözleşmede "
"kullanılacak impl'in adını belirtmemize izin verir. Bu durumda, bileşen "
"gömülü sözleşmelerde Ownable olarak anılacaktır."

#: src/ch16-02-00-composability-and-components.md:190
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, "
"with the added restriction that `TContractState` must implement the "
"`HasComponent<T>` trait. This allows us to use the component in any "
"contract, as long as the contract implements the `HasComponent` trait. "
"Understanding this mechanism in details is not required to use components, "
"but if you're curious about the inner workings, you can read more in the "
"[\"Components Under the Hood\"](./ch16-02-01-under-the-hood.md) section."
msgstr ""
"Uygulamanın kendisi ComponentStateTContractState> üzerinde geneldir, "
"TContractState'in HasComponentT> özelliğini uygulaması gereken ek kısıtlama "
"ile. Bu, sözleşme HasComponent özelliğini uyguladığı sürece, herhangi bir "
"sözleşmedeki bileşeni kullanmamızı sağlar. Bu mekanizmayı ayrıntılarda "
"anlamak, bileşenleri kullanmak için gerekli değildir, ancak meraklıysanız"

#: src/ch16-02-00-composability-and-components.md:197
msgid ""
"One of the major differences from a regular smart contract is that access to "
"storage and events is done via the generic `ComponentState<TContractState>` "
"type and not `ContractState`. Note that while the type is different, "
"accessing storage or emitting events is done similarly via `self."
"storage_var_name.read()` or `self.emit(...).`"
msgstr ""
"Düzenli bir akıllı sözleşmeden en büyük farklardan biri, depolama ve "
"etkinliklere erişimin ComponentStateTContractState> türü değil, genel "
"ContractState üzerinden yapılmasıdır. Tür farklı olsa da, depolama veya "
"yayan etkinliklere erişmenin self.storage_var_name.read() veya self."
"emit(...) aracılığıyla benzer şekilde yapıldığını unutmayın."

#: src/ch16-02-00-composability-and-components.md:203
msgid ""
"Note: To avoid the confusion between the embeddable name and the impl name, "
"we recommend keeping the suffix `Impl` in the impl name."
msgstr ""
"Not: Gömülü isim ile impl adı arasındaki karışıklığı önlemek için, Impl son "
"ekini impl adında tutmanızı öneririz."

#: src/ch16-02-00-composability-and-components.md:208
msgid "Migrating a Contract to a Component"
msgstr "Bir Sözleşmenin Bir Bileşene Taşınması"

#: src/ch16-02-00-composability-and-components.md:210
msgid ""
"Since both contracts and components share a lot of similarities, it's "
"actually very easy to migrate from a contract to a component. The only "
"changes required are:"
msgstr ""
"Hem sözleşmeler hem de bileşenler birçok benzerliği paylaştığından, bir "
"sözleşmeden bir bileşene göç etmek aslında çok kolaydır. Gerekli olan tek "
"değişiklikler:"

#: src/ch16-02-00-composability-and-components.md:214
msgid "Adding the `#[starknet::component]` attribute to the module."
msgstr "#[starknet::component] özniteliğini modüle eklemek."

#: src/ch16-02-00-composability-and-components.md:215
msgid ""
"Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will "
"be embedded in another contract."
msgstr ""
"#[embeddable_as(name)] özniteliğini başka bir sözleşmeye gömülecek olan impl "
"bloğuna eklemek."

#: src/ch16-02-00-composability-and-components.md:217
msgid "Adding generic parameters to the `impl` block:"
msgstr "impl bloğuna jenerik parametreler ekleme:"

#: src/ch16-02-00-composability-and-components.md:218
msgid "Adding `TContractState` as a generic parameter."
msgstr "TContractState genel parametre olarak eklenir."

#: src/ch16-02-00-composability-and-components.md:219
msgid "Adding `+HasComponent<TContractState>` as an impl restriction."
msgstr "+HasComponentTContractState> impl kısıtlaması olarak eklenir."

#: src/ch16-02-00-composability-and-components.md:220
msgid ""
"Changing the type of the `self` argument in the functions inside the `impl` "
"block to `ComponentState<TContractState>` instead of `ContractState`."
msgstr ""
"Impl bloğu içindeki işlevlerdeki self argümanının türünü ContractState "
"yerine ComponentStateTContractState> olarak değiştirmek."

#: src/ch16-02-00-composability-and-components.md:223
msgid ""
"For traits that do not have an explicit definition and are generated using "
"`#[generate_trait]`, the logic is the same - but the trait is generic over "
"`TContractState` instead of `ComponentState<TContractState>`, as "
"demonstrated in the example with the `InternalTrait`."
msgstr ""
"Açık bir tanımı olmayan ve #[genate_trait] kullanılarak oluşturulan "
"özellikler için, mantık aynıdır - ancak özellik, InternalTrait örneğinde "
"gösterildiği gibi, ComponentState yerine TContractState üzerinde geneldir."

#: src/ch16-02-00-composability-and-components.md:228
msgid "Using Components Inside a Contract"
msgstr "Bir Sözleşmenin İçindeki Bileşenleri Kullanmak"

#: src/ch16-02-00-composability-and-components.md:230
msgid ""
"The major strength of components is how it allows reusing already built "
"primitives inside your contracts with a restricted amount of boilerplate. To "
"integrate a component into your contract, you need to:"
msgstr ""
"Bileşenlerin ana gücü, sözleşmelerinizin içinde zaten inşa edilmiş ilkelleri "
"sınırlı miktarda kazan plakasıyla yeniden kullanmaya nasıl izin verdiğidir. "
"Bir bileşeni sözleşmenize entegre etmek için şunları yapmanız gerekir:"

#: src/ch16-02-00-composability-and-components.md:234
msgid "Declare it with the `component!()` macro, specifying"
msgstr "component!() makrosu ile açıklayın, belirtin"

#: src/ch16-02-00-composability-and-components.md:236
msgid "The path to the component `path::to::component`."
msgstr "path::to:component bileşenine giden yol."

#: src/ch16-02-00-composability-and-components.md:237
msgid ""
"The name of the variable in your contract's storage referring to this "
"component's storage (e.g. `ownable`)."
msgstr ""
"Sözleşmenizin deposundaki değişkenin adı, bu bileşenin deposuna atıfta "
"bulunur (örn. ownable)."

#: src/ch16-02-00-composability-and-components.md:239
msgid ""
"The name of the variant in your contract's event enum referring to this "
"component's events (e.g. `OwnableEvent`)."
msgstr ""
"Sözleşmenizin olay enum'undaki varyantın adı bu bileşenin olaylarına atıfta "
"bulunur (örneğin OwnableEvent)."

#: src/ch16-02-00-composability-and-components.md:242
msgid ""
"Add the path to the component's storage and events to the contract's "
"`Storage` and `Event`. They must match the names provided in step 1 (e.g. "
"`ownable: ownable_component::Storage` and `OwnableEvent: ownable_component::"
"Event`)."
msgstr ""
"Bileşenin deposuna ve etkinliklerine yolu sözleşmenin Storage ve Event'sine "
"ekleyin. 1. adımda verilen isimlerle eşleşmelidirler (örneğin ownable: "
"ownable_component::Storage ve OwnableEvent: ownable_component:Event)."

#: src/ch16-02-00-composability-and-components.md:247
msgid ""
"The storage variable **MUST** be annotated with the `#[substorage(v0)]` "
"attribute."
msgstr ""
"**MUST** depolama değişkeni #[substoage(v0)] özniteliği ile not edilir."

#: src/ch16-02-00-composability-and-components.md:250
msgid ""
"Embed the component's logic defined inside your contract, by instantiating "
"the component's generic impl with a concrete `ContractState` using an impl "
"alias. This alias must be annotated with `#[abi(embed_v0)]` to externally "
"expose the component's functions."
msgstr ""
"Bileşenin genel impl'sini bir impl takma adı kullanarak somut bir "
"ContractState ile hazırlayarak, sözleşmenizin içinde tanımlanan bileşenin "
"mantığını yerleştirin. Bu takma ad, bileşenin işlevlerini dıştan açığa "
"çıkarmak için #[abi(embed_v0)]] ile eklenmelidir."

#: src/ch16-02-00-composability-and-components.md:255
msgid ""
"As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`. "
"Indeed, we don't want to expose externally the functions defined in this "
"impl. However, we might still want to access them internally."
msgstr ""
"Gördüğünüz gibi, InternalImpl #[abi(embed_v0)] ile işaretli değildir. "
"Gerçekten de, bu impl'de tanımlanan işlevleri dışsal olarak ifşa etmek "
"istemiyoruz. Ancak, yine de bunlara dahili olarak erişmek isteyebiliriz."

#: src/ch16-02-00-composability-and-components.md:259
msgid ""
"For example, to embed the `Ownable` component defined above, we would do the "
"following:"
msgstr ""
"Örneğin, yukarıda tanımlanan Ownable bileşenini gömmek için şunları yapardık:"

#: src/ch16-02-00-composability-and-components.md:297
msgid ""
"The component's logic is now seamlessly part of the contract! We can "
"interact with the components functions externally by calling them using the "
"`IOwnableDispatcher` instantiated with the contract's address."
msgstr ""
"Bileşenin mantığı artık sözleşmenin sorunsuz bir parçası! Sözleşmenin adresi "
"ile hazır hale getirilmiş IOwnableDispatcher kullanarak bileşenler "
"işlevlerini harici olarak çağırarak etkileşimde bulunabiliriz."

#: src/ch16-02-00-composability-and-components.md:310
msgid "Stacking Components for Maximum Composability"
msgstr "Maksimum Kompozisyon için İstifleme Bileşenleri"

#: src/ch16-02-00-composability-and-components.md:312
msgid ""
"The composability of components really shines when combining multiple of "
"them together. Each adds its features onto the contract. You can rely on "
"[Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) "
"implementation of components to quickly plug-in all the common "
"functionalities you need a contract to have."
msgstr ""
"Bileşenlerin bileşimi, birden çok bileşeni bir araya getirirken gerçekten "
"parlar. Her biri, özelliklerini sözleşmeye ekler. [Openzeppelin's](https://"
"github.com/OpenZeppelin/cairo-contracts) bileşenlerin uygulanmasına "
"güvenerek, bir sözleşmeye ihtiyacınız olan tüm ortak işlevleri hızlı bir "
"şekilde takabilirsiniz."

#: src/ch16-02-00-composability-and-components.md:318
msgid ""
"Developers can focus on their core contract logic while relying on battle-"
"tested and audited components for everything else."
msgstr ""
"Geliştiriciler, diğer her şey için savaş test edilmiş ve denetlenmiş "
"bileşenlere güvenirken temel sözleşme mantığına odaklanabilirler."

#: src/ch16-02-00-composability-and-components.md:321
msgid ""
"Components can even [depend](./ch16-02-02-component-dependencies.md) on "
"other components by restricting the `TContractstate` they're generic on to "
"implement the trait of another component. Before we dive into this "
"mechanism, let's first look at [how components work under the hood](./"
"ch16-02-01-under-the-hood.md)."
msgstr ""
"Bileşenler, TContractstate'i kısıtlayarak diğer bileşenlere bile [./"
"ch16-02-02-02-02-bileşen-bağımlılar.md] bağlanabilir - bunlar başka bir "
"bileşenin özelliğini uygulamak için jeneriktir. Bu mekanizmaya dalmadan "
"önce, önce [bileşenlerin kaputun altında nasıl çalıştığına] bakalım (./"
"ch16-02-01-alt-the-hood.md)."

#: src/ch16-02-01-under-the-hood.md:1
msgid "Components: Under the Hood"
msgstr "Bileşenleri: Başlık altında"

#: src/ch16-02-01-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to Starknet contracts. But how does "
"this magic actually happen behind the scenes?"
msgstr ""
"Bileşenleri Starknet sözleşmeleri için güçlü modülerlik sağlar. Ama bu büyü "
"aslında sahne arkasında nasıl gerçekleşir?"

#: src/ch16-02-01-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the "
"mechanisms that enable component composability."
msgstr ""
"Bu bölüm, bileşen uyumluluğunu sağlayan mekanizmaları açıklamak için "
"derleyici içlerinin derinliklerine dalacaktır."

#: src/ch16-02-01-under-the-hood.md:9
msgid "A Primer on Embeddable Impls"
msgstr "Gömülü İmpler Üzerine Bir Astar"

#: src/ch16-02-01-under-the-hood.md:11
msgid ""
"Before digging into components, we need to understand _embeddable impls_."
msgstr ""
"Bileşenleri kazmadan önce, _embeddeble impls_ değerini anlamamız gerekir."

#: src/ch16-02-01-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`) "
"can be made embeddable. Embeddable impls can be injected into any contract, "
"adding new entry points and modifying the ABI of the contract."
msgstr ""
"Bir Starknet arayüz özelliğinin bir impl'si (#[starknet::interface] ile "
"işaretlenmiştir) gömülebilir hale getirilebilir. Gömülü impls herhangi bir "
"sözleşmeye enjekte edilebilir, yeni giriş noktaları ekleyebilir ve "
"sözleşmenin ABI'sini değiştirebilir."

#: src/ch16-02-01-under-the-hood.md:17
msgid "Let's look at an example to see this in action:"
msgstr "Bunu eylemde görmek için bir örneğe bakalım:"

#: src/ch16-02-01-under-the-hood.md:42
msgid ""
"By embedding `SimpleImpl`, we externally expose `ret4` in the contract's ABI."
msgstr ""
"SimpleImpl'yi yerleştirerek, sözleşmenin ABI'sine ret4'yi harici olarak ifşa "
"ediyoruz."

#: src/ch16-02-01-under-the-hood.md:44
msgid ""
"Now that we’re more familiar with the embedding mechanism, we can now see "
"how components build on this."
msgstr ""
"Gömme mekanizmasına daha aşina olduğumuza göre, artık bileşenlerin bunun "
"üzerine nasıl inşa edildiğini görebiliriz."

#: src/ch16-02-01-under-the-hood.md:47
msgid "Inside Components: Generic Impls"
msgstr "İç Bileşenleri: Genel Impls"

#: src/ch16-02-01-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr "Bileşenlerde kullanılan impl blok sözdizimi hatırla:"

#: src/ch16-02-01-under-the-hood.md:58
msgid "The key points:"
msgstr "Anahtar noktalar:"

#: src/ch16-02-01-under-the-hood.md:60
msgid ""
"`OwnableImpl` requires the implementation of the "
"`HasComponent<TContractState>` trait by the underlying contract, which is "
"automatically generated with the `component!()` macro when using a component "
"inside a contract."
msgstr ""
"OwnableImpl, bir sözleşmenin içindeki bir bileşeni kullanırken otomatik "
"olarak component!() makrosu ile oluşturulan HasComponentTContractState> "
"özelliğinin altta yatan sözleşme tarafından uygulanmasını gerektirir."

#: src/ch16-02-01-under-the-hood.md:65
msgid ""
"The compiler will generate an impl that wraps any function in `OwnableImpl`, "
"replacing the `self: ComponentState<TContractState>` argument with `self: "
"TContractState`, where access to the component state is made via the "
"`get_component` function in the `HasComponent<TContractState>` trait."
msgstr ""
"Derleyici, OwnableImpl'deki herhangi bir işlevi saran bir impl oluşturacak, "
"self: ComponentStateTContractState> argümanını self: TContractState ile "
"değiştirecektir, burada bileşen durumuna erişim HasComponentTContractState> "
"özelliğindeki get_component fonksiyonu aracılığıyla yapılır."

#: src/ch16-02-01-under-the-hood.md:70
msgid ""
"For each component, the compiler generates a `HasComponent` trait. This "
"trait defines the interface to bridge between the actual `TContractState` of "
"a generic contract, and `ComponentState<TContractState>`."
msgstr ""
"Her bileşen için derleyici bir HasComponent özelliği oluşturur. Bu özellik, "
"genel bir sözleşmenin gerçek TContractState ile ComponentState arasında "
"köprü kurmak için arayüzü tanımlar."

#: src/ch16-02-01-under-the-hood.md:75
msgid "// generated per component\n"
msgstr "// bileşen başına oluşturulur\n"

#: src/ch16-02-01-under-the-hood.md:85
msgid ""
"In our context `ComponentState<TContractState>` is a type specific to the "
"ownable component, i.e. it has members based on the storage variables "
"defined in `ownable_component::Storage`. Moving from the generic "
"`TContractState` to `ComponentState<TContractState>` will allow us to embed "
"`Ownable` in any contract that wants to use it. The opposite direction "
"(`ComponentState<TContractState>` to `ContractState`) is useful for "
"dependencies (see the `Upgradeable` component depending on an `IOwnable` "
"implementation example in the [Components dependencies ](./ch16-02-02-"
"component-dependencies.md) section)."
msgstr ""
"İçeriğimizde ComponentStateTContractState>, ownable_component::Storage'da "
"tanımlanan depolama değişkenlerine dayanan bir türdür. Genel "
"TContractState'den ComponentStateTContractState>'a (ComponentState) herhangi "
"bir sözleşmede Ownable'ı yerleştirmemize izin verecektir."

#: src/ch16-02-01-under-the-hood.md:94
msgid ""
"To put it briefly, one should think of an implementation of the above "
"`HasComponent<T>` as saying: **“Contract whose state T has the upgradeable "
"component”.**"
msgstr ""
"Kısaca söylemek gerekirse, yukarıdaki HasComponentT> uygulamasının şöyle bir "
"şekilde uygulanması düşünülmelidir: ** \"T durumu yükseltilebilir bileşene "
"sahip olan Contract\".**"

#: src/ch16-02-01-under-the-hood.md:98
msgid "`Ownable` is annotated with the `embeddable_as(<name>)` attribute:"
msgstr "Ownable, embeddable_as(name>) özniteliği ile belirtilir:"

#: src/ch16-02-01-under-the-hood.md:100
msgid ""
"`embeddable_as` is similar to `embeddable`; it only applies to impls of "
"`starknet::interface` traits and allows embedding this impl in a contract "
"module. That said, `embeddable_as(<name>)` has another role in the context "
"of components. Eventually, when embedding `OwnableImpl` in some contract, we "
"expect to get an impl with the following functions:"
msgstr ""
"embeddable_as, embeddable'a benzer; sadece starknet:interface özellikleri "
"için geçerlidir ve bu impl'yi bir sözleşme modülüne yerleştirmeye izin "
"verir. Bununla birlikte, embeddable_as(name>) bileşenlerin bağlamında başka "
"bir role sahiptir. Sonunda, bazı sözleşmelerde OwnableImpl gömülürken, "
"aşağıdaki işlevleri almayı bekliyoruz:"

#: src/ch16-02-01-under-the-hood.md:112
msgid ""
"Note that while starting with a function receiving the generic type "
"`ComponentState<TContractState>`, we want to end up with a function "
"receiving `ContractState`. This is where `embeddable_as(<name>)` comes in. "
"To see the full picture, we need to see what is the impl generated by the "
"compiler due to the `embeddable_as(Ownable)` annotation:"
msgstr ""
"ComponentStateTContractState> jenerik türünü alan bir fonksiyonla başlarken, "
"ContractState alan bir fonksiyonla bitirmek istediğimizi unutmayın. "
"embeddable_as(name>) burada devreye girer. Tam resmi görmek için, "
"derleyicinin embeddable_as(Own):"

#: src/ch16-02-01-under-the-hood.md:140
msgid ""
"Note that thanks to having an impl of `HasComponent<TContractState>`, the "
"compiler was able to wrap our functions in a new impl that doesn’t directly "
"know about the `ComponentState` type. `Ownable`, whose name we chose when "
"writing `embeddable_as(Ownable)`, is the impl that we will embed in a "
"contract that wants ownership."
msgstr ""
"HasComponentTContractState> impl'sine sahip olması sayesinde, derleyici, "
"fonksiyonlarımızı ComponentState tipini doğrudan bilmeyen yeni bir impl'ye "
"sarabildi. embeddable_as(Ownable) yazarken adını seçtiğimiz Ownable, "
"sahiplik isteyen bir sözleşmeye yerleştireceğimiz impl'dir."

#: src/ch16-02-01-under-the-hood.md:146
msgid "Contract Integration"
msgstr "Sözleşme Entegrasyonu"

#: src/ch16-02-01-under-the-hood.md:148
msgid ""
"We've seen how generic impls enable component reusability. Next let's see "
"how a contract integrates a component."
msgstr ""
"Jenerik impls'in bileşen yeniden kullanılabilirliğini nasıl sağladığını "
"gördük. Daha sonra bir sözleşmenin bir bileşeni nasıl entegre ettiğini "
"görelim."

#: src/ch16-02-01-under-the-hood.md:151
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic "
"impl with the concrete `ContractState` of the contract."
msgstr ""
"Sözleşme, bileşenin genel impl'sini sözleşmenin beton ContractState ile "
"anlık hale getirmek için **impl takma adını ** kullanır."

#: src/ch16-02-01-under-the-hood.md:161
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl "
"alias syntax. We’re instantiating the generic `OwnableImpl<TContractState>` "
"with the concrete type `ContractState`. Recall that "
"`OwnableImpl<TContractState>` has the `HasComponent<TContractState>` generic "
"impl parameter. An implementation of this trait is generated by the "
"`component!` macro."
msgstr ""
"Yukarıdaki satırlar, impl takma sözdiziminin yanında Kahire impl yerleştirme "
"mekanizmasını kullanır. OwnableImplTContractState> jenerik ContractState "
"beton tipi ile anlık hale getiriyoruz. OwnableImplTContractState>'nin "
"HasComponentTContractState> jenerik impl parametresine sahip olduğunu "
"hatırlayın."

#: src/ch16-02-01-under-the-hood.md:167
msgid ""
"Note that only the using contract could have implemented this trait since "
"only it knows about both the contract state and the component state."
msgstr ""
"Sadece kullanım sözleşmesinin bu özelliği uygulayabileceğini unutmayın, "
"çünkü sadece sözleşme durumu ve bileşen durumu hakkında bilgi sahibidir."

#: src/ch16-02-01-under-the-hood.md:171
msgid ""
"This glues everything together to inject the component logic into the "
"contract."
msgstr ""
"Bu, bileşen mantığını sözleşmeye enjekte etmek için her şeyi birbirine "
"yapıştırır."

#: src/ch16-02-01-under-the-hood.md:173
msgid "Key Takeaways"
msgstr "Anahtar Takeaways"

#: src/ch16-02-01-under-the-hood.md:175
msgid ""
"Embeddable impls allow injecting components logic into contracts by adding "
"entry points and modifying the contract ABI."
msgstr ""
"Gömülü impls, giriş noktaları ekleyerek ve sözleşmeyi değiştirerek "
"bileşenlerin mantığını sözleşmelere enjekte etmeye izin verir."

#: src/ch16-02-01-under-the-hood.md:177
msgid ""
"The compiler automatically generates a `HasComponent` trait implementation "
"when a component is used in a contract. This creates a bridge between the "
"contract's state and the component's state, enabling interaction between the "
"two."
msgstr ""
"Derleyici, bir sözleşmede bir bileşen kullanıldığında otomatik olarak bir "
"HasComponent özellik uygulaması oluşturur. Bu, sözleşmenin durumu ile "
"bileşenin durumu arasında bir köprü oluşturarak ikisi arasındaki etkileşimi "
"sağlar."

#: src/ch16-02-01-under-the-hood.md:181
msgid ""
"Components encapsulate reusable logic in a generic, contract-agnostic way. "
"Contracts integrate components through impl aliases and access them via the "
"generated `HasComponent` trait."
msgstr ""
"Bileşenler, yeniden kullanılabilir mantığı genel, sözleşme-agnostik bir "
"şekilde kapsüller. Sözleşmeler, bileşenleri impl takma adlarıyla "
"bütünleştirir ve oluşturulan HasComponent özelliği ile bunlara erişir."

#: src/ch16-02-01-under-the-hood.md:184
msgid ""
"Components build on embeddable impls by defining generic component logic "
"that can be integrated into any contract wanting to use that component. Impl "
"aliases instantiate these generic impls with the contract's concrete storage "
"types."
msgstr ""
"Bileşenler, bu bileşeni kullanmak isteyen herhangi bir sözleşmeye entegre "
"edilebilen jenerik bileşen mantığını tanımlayarak yerleştirilebilir impls "
"üzerine inşa edilir. Impl takma adları, bu jenerik impls'leri sözleşmenin "
"beton depolama türleriyle anlıklaştırır."

#: src/ch16-02-02-component-dependencies.md:3
msgid ""
"Working with components becomes more complex when we try to use one "
"component inside another. As mentioned earlier, a component can only be "
"embedded within a contract, meaning that it's not possible to embed a "
"component within another component. However, this doesn't mean that we can't "
"use one component inside another. In this section, we will see how to use a "
"component as a dependency of another component."
msgstr ""
"Bileşenlerle çalışmak, bir bileşeni diğerinin içinde kullanmaya "
"çalıştığımızda daha karmaşık hale gelir. Daha önce de belirtildiği gibi, bir "
"bileşen yalnızca bir sözleşmenin içine yerleştirilebilir, yani bir bileşeni "
"başka bir bileşenin içine yerleştirmenin mümkün olmadığı anlamına gelir. "
"Bununla birlikte, bu, bir bileşeni diğerinin içinde kullanamayacağımız "
"anlamına gelmez. Bu bölümde, bir bileşeni başka bir bileşenin bağımlılığı "
"olarak nasıl kullanacağımızı göreceğiz."

#: src/ch16-02-02-component-dependencies.md:5
msgid ""
"Consider a component called `OwnableCounter` whose purpose is to create a "
"counter that can only be incremented by its owner. This component can be "
"embedded in any contract, so that any contract that uses it will have a "
"counter that can only be incremented by its owner."
msgstr ""
"Amacı sadece sahibi tarafından artırılabilen bir sayaç oluşturmak olan "
"OwnableCounter adlı bir bileşen düşünün. Bu bileşen herhangi bir sözleşmeye "
"gömülebilir, böylece onu kullanan herhangi bir sözleşme yalnızca sahibi "
"tarafından artırılabilen bir sayaç olacaktır."

#: src/ch16-02-02-component-dependencies.md:7
msgid ""
"The first way to implement this is to create a single component that "
"contains both counter and ownership features from within a single component. "
"However, this approach is not recommended: our goal is to minimize the "
"amount of code duplication and take advantage of component reusability. "
"Instead, we can create a new component that _depends_ on the `Ownable` "
"component for the ownership features, and internally defines the logic for "
"the counter."
msgstr ""
"Bunu gerçekleştirmenin ilk yolu, hem sayaç hem de sahiplik özelliklerini tek "
"bir bileşenden içeren tek bir bileşen oluşturmaktır. Ancak, bu yaklaşım "
"önerilmez: amacımız kod çoğaltma miktarını en aza indirmek ve bileşen "
"yeniden kullanılabilirliğinden yararlanmaktır. Bunun yerine, sahiplik "
"özellikleri için  Sahiplenilebilir bileşenine bağlı olan yeni bir bileşen "
"oluşturabilir ve dahili olarak sayaç için mantığı tanımlar."

#: src/ch16-02-02-component-dependencies.md:9
msgid ""
"Listing 16-1 shows the complete implementation, which we'll break down right "
"after:"
msgstr ""
"Listeleme 16-1, aşağıdakilerden hemen sonra parçalayacağımız tam uygulamayı "
"gösterir:"

#: src/ch16-02-02-component-dependencies.md:58
msgid ""
"<span class=\"caption\">Listing 16-1: An OwnableCounter Component</span>"
msgstr "span class=\"caption\">Listing 16-1: A OwnableCounter Component/span>"

#: src/ch16-02-02-component-dependencies.md:60
msgid "Specificities"
msgstr "Özgüllükler"

#: src/ch16-02-02-component-dependencies.md:62
msgid "Specifying Dependencies on Another Component"
msgstr "Başka Bir Bileşene Bağımlılıklar Belirtilmesi"

#: src/ch16-02-02-component-dependencies.md:73
msgid ""
"In [chapter 8](./ch08-02-traits-in-cairo.md), we introduced trait bounds, "
"which are used to specify that a generic type must implement a certain "
"trait. In the same way, we can specify that a component depends on another "
"component by restricting the `impl` block to be available only for contracts "
"that contain the required component. In our case, this is done by adding a "
"restriction `impl Owner: ownable_component::HasComponent<TContractState>`, "
"which indicates that this `impl` block is only available for contracts that "
"contain an implementation of the `ownable_component::HasComponent` trait. "
"This essentially means that the \\`TContractState' type has access to the "
"ownable component. See [Components under the hood](ch16-02-01-under-the-hood."
"md#inside-components-generic-impls) for more information."
msgstr ""
"[chapter 8](./ch08-02-traits-in-cairo.md) 'de, genel bir türün belirli bir "
"özelliği uygulamak zorunda olduğunu belirtmek için kullanılan özellik "
"sınırlarını tanıttık. Aynı şekilde, bir bileşenin yalnızca gerekli bileşeni "
"içeren sözleşmeler için mevcut olmasını kısıtlayarak başka bir bileşene "
"bağlı olduğunu belirtebiliriz. Bizim durumumuzda, bu, bir kısıtlama "
"ekleyerek yapılır _impl Sahibi:"

#: src/ch16-02-02-component-dependencies.md:76
msgid ""
"Although most of the trait bounds were defined using \\[anonymous "
"parameters\\]\\[anonymous generic impl operator\\], the dependency on the "
"`Ownable` component is defined using a named parameter (here, `Owner`). We "
"will need to use this explicit name when accessing the `Ownable`component "
"within the`impl` block."
msgstr ""
"Her ne kadar özellik sınırlarının çoğu [anonim parametreler][anonim jenerik "
"impl operatörü] kullanılarak tanımlanmış olsa da, Ownable bileşenine "
"bağımlılık, adlandırılmış bir parametre kullanılarak tanımlanır (burada, "
"Owner). impl bloğu içindeki Ownable bileşenine erişirken bu açık adı "
"kullanmamız gerekecektir."

#: src/ch16-02-02-component-dependencies.md:78
msgid ""
"While this mechanism is verbose and may not be easy to approach at first, it "
"is a powerful leverage of the trait system in Cairo. The inner workings of "
"this mechanism are abstracted away from the user, and all you need to know "
"is that when you embed a component in a contract, all other components in "
"the same contract can access it."
msgstr ""
"Bu mekanizma fiilen ve ilk başta yaklaşmak kolay olmasa da, Kahire'deki "
"özellik sisteminin güçlü bir kaldıraçtır. Bu mekanizmanın iç işleyişi "
"kullanıcıdan soyutlanır ve bilmeniz gereken tek şey, bir bileşeni bir "
"sözleşmeye gömdüğünüzde, aynı sözleşmedeki diğer tüm bileşenlerin ona "
"erişebileceğidir."

#: src/ch16-02-02-component-dependencies.md:82
msgid ""
"\\[anonymous generic impl operator\\]: ./ch08-01-generic-data-types "
"md#anonymous-generic-implementation-parameter--operator"
msgstr ""
"[anonim jenerik impl operatörü]:./ch08-01-generik-veri-tipleri md#anonim-"
"generik-uygulama-parametre--operatör"

#: src/ch16-02-02-component-dependencies.md:84
msgid "Using the Dependency"
msgstr "Bağımlılığı Kullanmak"

#: src/ch16-02-02-component-dependencies.md:86
msgid ""
"Now that we have made our `impl` depend on the `Ownable` component, we can "
"access its functions, storage, and events within the implementation block. "
"To bring the `Ownable` component into scope, we have two choices, depending "
"on whether we intend to mutate the state of the `Ownable` component or not. "
"If we want to access the state of the `Ownable` component without mutating "
"it, we use the `get_dep_component!` macro. If we want to mutate the state of "
"the `Ownable` component (for example, change the current owner), we use the "
"`get_dep_component_mut!` macro. Both macros take two arguments: the first is "
"`self`, either as a snapshot or by reference depending on mutability, "
"representing the state of the component using the dependency, and the second "
"is the component to access."
msgstr ""
"Şimdi impl bileşenimizi Ownable bileşenine bağlı hale getirdiğimize göre, "
"uygulama bloğu içindeki işlevlerine, depolamasına ve olaylarına "
"erişebiliriz. Ownable bileşenini kapsam içine getirmek için, Ownable_ "
"bileşeninin durumunu değiştirmek isteyip istemediğimize bağlı olarak iki "
"seçeneğimiz var. Ownable bileşeninin durumunu değiştirmeden erişmek "
"istiyorsak,"

#: src/ch16-02-02-component-dependencies.md:98
msgid ""
"In this function, we want to make sure that only the owner can call the "
"`increment` function. We need to use the `assert_only_owner` function from "
"the `Ownable` component. We'll use the `get_dep_component!` macro which will "
"return a snapshot of the requested component state, and call "
"`assert_only_owner` on it, as a method of that component."
msgstr ""
"Bu fonksiyonda, sadece sahibinin arınma fonksiyonunu çağırabileceğinden emin "
"olmak istiyoruz. Ownable bileşeninden assert_only_owner fonksiyonunu "
"kullanmamız gerekiyor. get_dep_component! makrosunu kullanacağız, bu da "
"istenen bileşen durumunun bir anlık görüntüsünü döndürecek ve bu bileşenin "
"bir yöntemi olarak assert_only_owner adını verecektir."

#: src/ch16-02-02-component-dependencies.md:101
msgid ""
"For the `transfer_ownership` function, we want to mutate that state to "
"change the current owner. We need to use the `get_dep_component_mut!` macro, "
"which will return the requested component state as a mutable reference, and "
"call `transfer_ownership` on it."
msgstr ""
"transfer_ownership işlevi için, mevcut sahibini değiştirmek için bu durumu "
"değiştirmek istiyoruz. İstenen bileşen durumunu değiştirilebilir bir "
"referans olarak döndürecek olan get_dep_component_mut! makrosunu kullanmamız "
"ve üzerinde transfer_ownership çağırmamız gerekiyor."

#: src/ch16-02-02-component-dependencies.md:112
msgid ""
"It works exactly the same as `get_dep_component!` except that we need to "
"pass the state as a `ref` so we can mutate it to transfer the ownership."
msgstr ""
"get_dep_component! ile tamamen aynı şekilde çalışır, ancak devleti bir ref "
"olarak geçmemiz gerekir, böylece mülkiyeti aktarmak için onu "
"değiştirebiliriz."

#: src/ch16-02-03-testing-components.md:3
msgid ""
"Testing components is a bit different than testing contracts. Contracts need "
"to be tested against a specific state, which can be achieved by either "
"deploying the contract in a test, or by simply getting the `ContractState` "
"object and modifying it in the context of your tests."
msgstr ""
"Test bileşenleri, sözleşmeleri test etmekten biraz farklıdır. Sözleşmelerin "
"belirli bir duruma karşı test edilmesi gerekir, bu da sözleşmeyi bir testte "
"dağıtarak veya sadece ContractState nesnesini alarak ve testleriniz "
"bağlamında değiştirerek elde edilebilir."

#: src/ch16-02-03-testing-components.md:6
msgid ""
"Components are a generic construct, meant to be integrated in contracts, "
"that can't be deployed on their own and don't have a `ContractState` object "
"that we could use. So how do we test them?"
msgstr ""
"Bileşenler, kendi başlarına konuşlandırılamayan ve kullanabileceğimiz bir "
"ContractState nesnesine sahip olmayan sözleşmelerde entegre edilmesi "
"amaçlanan genel bir yapıdır. Peki bunları nasıl test edeceğiz?"

#: src/ch16-02-03-testing-components.md:8
msgid ""
"Let's consider that we want to test a very simple component called "
"\"Counter\", that will allow each contract to have a counter that can be "
"incremented. The component is defined in Listing 16-2:"
msgstr ""
"Her sözleşmenin artırılabilen bir sayaça sahip olmasını sağlayacak "
"\"Counter\" adlı çok basit bir bileşeni test etmek istediğimizi düşünelim. "
"Bileşen Listeleme 16-2'de tanımlanmıştır:"

#: src/ch16-02-03-testing-components.md:33
msgid "<span class=\"caption\">Listing 16-2: A simple Counter component</span>"
msgstr "span class=\"caption\">Liste 16-2: Basit bir Sayaç bileşeni/span>"

#: src/ch16-02-03-testing-components.md:35
msgid "Testing the Component by Deploying a Mock Contract"
msgstr "Bir Sahte Sözleşme Dağıtarak Bileşenin Test Edilmesi"

#: src/ch16-02-03-testing-components.md:37
msgid ""
"The easiest way to test a component is to integrate it within a mock "
"contract. This mock contract is only used for testing purposes, and only "
"integrates the component you want to test. This allows you to test the "
"component in the context of a contract, and to use a Dispatcher to call the "
"component's entry points."
msgstr ""
"Bir bileşeni test etmenin en kolay yolu, onu sahte bir sözleşme içinde "
"entegre etmektir. Bu sahte sözleşme sadece test amaçlı kullanılır ve "
"yalnızca test etmek istediğiniz bileşeni entegre eder. Bu, bileşeni bir "
"sözleşme bağlamında test etmenizi ve bileşenin giriş noktalarını aramak için "
"bir Dispatcher kullanmanızı sağlar."

#: src/ch16-02-03-testing-components.md:39
msgid "We can define such a mock contract as follows:"
msgstr "Böyle bir sahte sözleşmeyi şöyle tanımlayabiliriz:"

#: src/ch16-02-03-testing-components.md:65
msgid ""
"This contract is entirely dedicated to testing the `Counter` component. It "
"embeds the component with the `component!` macro, exposes the component's "
"entry points by annotating the impl aliases with `#[abi(embed_v0)]`."
msgstr ""
"Bu sözleşme tamamen Counter bileşenini test etmeye adanmıştır. Bileşeni "
"component! makrosuyla gömer, impl takma adlarını #[abi(embed_v0)] ile "
"belirterek bileşenin giriş noktalarını açığa çıkarır."

#: src/ch16-02-03-testing-components.md:67
msgid ""
"We also need to define an interface that will be required to interact "
"externally with this mock contract."
msgstr ""
"Ayrıca, bu sahte sözleşme ile dış etkileşimde bulunması gereken bir arayüz "
"tanımlamamız gerekiyor."

#: src/ch16-02-03-testing-components.md:77
msgid ""
"We can now write tests for the component by deploying this mock contract and "
"calling its entry points, as we would with a typical contract."
msgstr ""
"Artık tipik bir sözleşmede olduğu gibi, bu sahte sözleşmeyi dağıtarak ve "
"giriş noktalarını arayarak bileşen için testler yazabiliriz."

#: src/ch16-02-03-testing-components.md:107
msgid "Testing Components Without Deploying a Contract"
msgstr "Bir Sözleşmeyi Dağıtmadan Bileşenleri Test Etmek"

#: src/ch16-02-03-testing-components.md:109
msgid ""
"In [Components under the hood](./ch16-02-01-under-the-hood.md), we saw that "
"components leveraged genericity to define storage and logic that could be "
"embedded in multiple contracts. If a contract embeds a component, a "
"`HasComponent` trait is created in this contract, and the component methods "
"are made available."
msgstr ""
"[Kutu altındaki bileşenler](./ch16-02-01-under-the-hood.md) 'de, "
"bileşenlerin birden fazla sözleşmeye gömülebilecek depolama ve mantığı "
"tanımlamak için genellikten yararlandığını gördük. Bir sözleşme bir bileşeni "
"gömerse, bu sözleşmede bir HasComponent özelliği oluşturulur ve bileşen "
"yöntemleri kullanılabilir hale getirilir."

#: src/ch16-02-03-testing-components.md:111
msgid ""
"This informs us that if we can provide a concrete `TContractState` that "
"implements the `HasComponent` trait to the `ComponentState` struct, should "
"be able to directly invoke the methods of the component using this concrete "
"`ComponentState` object, without having to deploy a mock."
msgstr ""
"Bu, ComponentState yapısına ComponentState özelliğini uygulayan bir somut "
"TContractState sağlayabilirsek, bu somut ComponentState nesnesini "
"kullanarak, bir alay uygulamak zorunda kalmadan, bileşenin yöntemlerini "
"doğrudan çağırabilmemiz gerektiğini bildirir."

#: src/ch16-02-03-testing-components.md:113
msgid ""
"Let's see how we can do that by using type aliases. We still need to define "
"a mock contract - let's use the same as above - but this time, we won't need "
"to deploy it."
msgstr ""
"Bunu tür takma adları kullanarak nasıl yapabileceğimizi görelim. Yine de "
"sahte bir sözleşme tanımlamamız gerekiyor - yukarıdakiyle aynı şekilde "
"kullanalım - ama bu sefer, dağıtmamıza gerek kalmayacak."

#: src/ch16-02-03-testing-components.md:115
msgid ""
"First, we need to define a concrete implementation of the generic "
"`ComponentState` type using a type alias. We will use the `MockContract::"
"ContractState` type to do so."
msgstr ""
"İlk olarak, jenerik ComponentState tipinin bir tür takma adını kullanarak "
"somut bir uygulamasını tanımlamamız gerekir. Bunu yapmak için MockContract::"
"ContractState tipini kullanacağız."

#: src/ch16-02-03-testing-components.md:123
#: src/ch16-02-03-testing-components.md:167
msgid "// You can derive even `Default` on this type alias\n"
msgstr "// Bu tür takma adda Default'u bile türetebilirsiniz\n"

#: src/ch16-02-03-testing-components.md:144
msgid ""
"We defined the `TestingState` type as an alias of the `CounterComponent::"
"ComponentState<MockContract::ContractState>` type. By passing the "
"`MockContract::ContractState` type as a concrete type for `ComponentState`, "
"we aliased a concrete implementation of the `ComponentState` struct to "
"`TestingState`."
msgstr ""
"ComponentState tipini CounterComponent::ComponentStateMockContract:::"
"ContractState> tipinin bir takma adı olarak tanımladık. ComponentState "
"tipini ComponentState için somut bir tür olarak geçerek, ComponentState "
"struct to TestingState'in somut bir uygulaması olarak isimlendirdik."

#: src/ch16-02-03-testing-components.md:146
msgid ""
"Because `MockContract` embeds `CounterComponent`, the methods of "
"`CounterComponent` defined in the `CounterImpl` block can now be used on a "
"`TestingState` object."
msgstr ""
"MockContract, CounterComponent'i gömdüğü için, CounterImpl bloğunda "
"tanımlanan CounterComponent yöntemleri artık TestingState nesnesinde "
"kullanılabilir."

#: src/ch16-02-03-testing-components.md:148
msgid ""
"Now that we have made these methods available, we need to instantiate an "
"object of type `TestingState`, that we will use to test the component. We "
"can do so by calling the `component_state_for_testing` function, which "
"automatically infers that it should return an object of type `TestingState`."
msgstr ""
"Şimdi bu yöntemleri kullanılabilir hale getirdiğimize göre, bileşeni test "
"etmek için kullanacağımız TestState tipi bir nesneyi anlık hale "
"getirmeliyiz. Bunu,  component_state_for_testing fonksiyonunu arayarak "
"yapabiliriz, bu da otomatik olarak TestState tipi bir nesneyi döndürmesi "
"gerektiğini gösterir."

#: src/ch16-02-03-testing-components.md:150
msgid ""
"We can even implement this as part of the `Default` trait, which allows us "
"to return an empty `TestingState` with the `Default::default()` syntax."
msgstr ""
"Bunu Default özelliğinin bir parçası olarak bile uygulayabiliriz, bu da "
"Default::default() sözdizimi ile boş bir TestState döndürmemizi sağlar."

#: src/ch16-02-03-testing-components.md:152
msgid "Let's summarize what we've done so far:"
msgstr "Şimdiye kadar yaptıklarımızı özetleyelim:"

#: src/ch16-02-03-testing-components.md:154
msgid "We defined a mock contract that embeds the component we want to test."
msgstr ""
"Test etmek istediğimiz bileşeni yerleştiren sahte bir sözleşme tanımladık."

#: src/ch16-02-03-testing-components.md:155
msgid ""
"We defined a concrete implementation of `ComponentState<TContractState>` "
"using a type alias with `MockContract::ContractState`, that we named "
"`TestingState`."
msgstr ""
"ComponentStateTContractState>'ın MockContract::ContractState adlı bir tür "
"takma ad kullanarak somut bir uygulamasını tanımladık."

#: src/ch16-02-03-testing-components.md:156
msgid ""
"We defined a function that uses `component_state_for_testing` to return a "
"`TestingState` object."
msgstr ""
"Bir TestState nesnesini döndürmek için component_state_for_testing kullanan "
"bir fonksiyon tanımladık."

#: src/ch16-02-03-testing-components.md:158
msgid ""
"We can now write tests for the component by calling its functions directly, "
"without having to deploy a mock contract. This approach is more lightweight "
"than the previous one, and it allows testing internal functions of the "
"component that are not exposed to the outside world trivially."
msgstr ""
"Artık sahte bir sözleşme yapmak zorunda kalmadan doğrudan işlevlerini "
"arayarak bileşen için testler yazabiliriz. Bu yaklaşım bir öncekinden daha "
"hafiftir ve bileşenin dış dünyaya önemsiz bir şekilde maruz kalmayan iç "
"işlevlerini test etmeye izin verir."

#: src/ch16-03-upgradeability.md:1
msgid "Upgradeable Contracts"
msgstr "Yükseltilebilir Sözleşmeler"

#: src/ch16-03-upgradeability.md:3
msgid ""
"Starknet separates contracts into classes and instances, making it simple to "
"upgrade a contract's logic without affecting its state."
msgstr ""
"Starknet, sözleşmeleri sınıflara ve örneklere ayırır ve bir sözleşmenin "
"mantığını durumunu etkilemeden yükseltmeyi kolaylaştırır."

#: src/ch16-03-upgradeability.md:5
msgid ""
"A contract class is the definition of the semantics of a contract. It "
"includes the entire logic of a contract: the name of the entry points, the "
"addresses of the storage variables, the events that can be emitted, etc. "
"Each class is uniquely identified by its class hash. A class does not have "
"its own storage: it's only a definition of logic."
msgstr ""
"Bir sözleşme sınıfı, bir sözleşmenin semantiğinin tanımıdır. Bir sözleşmenin "
"tüm mantığını içerir: giriş noktalarının adı, depolama değişkenlerinin "
"adresleri, yayılabilen olaylar vb. Her sınıf, sınıf hash'i ile benzersiz bir "
"şekilde tanımlanır. Bir sınıfın kendi depolama alanı yoktur: sadece mantığın "
"bir tanımıdır."

#: src/ch16-03-upgradeability.md:7
msgid ""
"Classes are typically identified by a [class hash](https://docs.starknet.io/"
"documentation/architecture_and_concepts/Smart_Contracts/class-hash). When "
"declaring a class, the network registers it and assigns a unique hash used "
"to identify the class and deploy contract instances from it."
msgstr ""
"Sınıflar tipik olarak bir [class hash] (https://docs.starknet.io/"
"documentation/architecture_and_concepts/Smart_Contracts/class-hash) ile "
"tanımlanır. Bir sınıfı ilan ederken, ağ bunu kaydeder ve sınıfı tanımlamak "
"ve sözleşme örneklerini dağıtmak için kullanılan benzersiz bir hash atar."

#: src/ch16-03-upgradeability.md:9
msgid ""
"A contract instance is a deployed contract corresponding to a class, with "
"its own storage."
msgstr ""
"Sözleşme örneği, bir sınıfa karşılık gelen, kendi depolama alanına sahip, "
"konuşlandırılmış bir sözleşmedir."

#: src/ch16-03-upgradeability.md:11
msgid ""
"Starknet natively supports upgradeable contracts through the "
"`replace_class_syscall` [system call](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/system-calls-cairo1/), enabling "
"simple contract upgrades without affecting the contract's state."
msgstr ""
"Starknet, replace_class_syscall [sistem çağrısı] aracılığıyla "
"yükseltilebilir sözleşmeleri destekler(https://docs.starknet.io/"
"documentation/architecture_and_concepts/Smart_Contracts/system-calls-"
"cairo1/), sözleşmenin durumunu etkilemeden basit sözleşme yükseltmelerini "
"sağlar."

#: src/ch16-03-upgradeability.md:16
msgid "Upgrading Contracts"
msgstr "Sözleşmelerin Yükseltilmesi"

#: src/ch16-03-upgradeability.md:18
msgid ""
"To upgrade a contract, expose an entry point that executes "
"`replace_class_syscall` with the new class hash as an argument:"
msgstr ""
"Bir sözleşmeyi yükseltmek için, argüman olarak yeni sınıf hash ile "
"replace_class_syscall çalıştıran bir giriş noktasını ortaya çıkarın:"

#: src/ch16-03-upgradeability.md:31
msgid ""
"<span class=\"caption\">Listing 16-3: Exposing `replace_class_syscall` to "
"update the contract's class</span>"
msgstr ""
"span class=\"caption\">Listeleme 16-3: Sözleşmenin sınıfını güncellemek için "
"replace_class_syscall'i ifşa etmek/span>"

#: src/ch16-03-upgradeability.md:33
msgid ""
"Note: Thoroughly review changes and potential impacts before upgrading, as "
"it's a delicate procedure with security implications. Don't allow arbitrary "
"addresses to upgrade your contract."
msgstr ""
"Not: Güvenlik etkileri olan hassas bir prosedür olduğu için yükseltmeden "
"önce değişiklikleri ve potansiyel etkileri iyice gözden geçirin. "
"Sözleşmenizi yükseltmek için keyfi adreslere izin vermeyin."

#: src/ch16-03-upgradeability.md:35
msgid "Upgradeable Component"
msgstr "Yükseltilebilir Bileşen"

#: src/ch16-03-upgradeability.md:37
msgid ""
"OpenZeppelin Contracts for Cairo provides the `Upgradeable` component that "
"can be embedded into your contract to make it upgradeable. This component is "
"a simple way to add upgradeability to your contract while relying on an "
"audited library. It can be combined with the `Ownable` component to restrict "
"the upgradeability to a single address, so that the contract owner has the "
"exclusive right to upgrade the contract."
msgstr ""
"OpenZeppelin Contracts for Cairo, yükseltilebilir hale getirmek için "
"sözleşmenize eklenebilecek Upgradeable bileşenini sağlar. Bu bileşen, "
"denetlenmiş bir kütüphaneye güvenirken sözleşmenize yükseltilebilirlik "
"eklemenin basit bir yoludur. Tek bir adrese yükseltilebilirliği kısıtlamak "
"için Ownable bileşeni ile birleştirilebilir, böylece sözleşme sahibi "
"sözleşmeyi yükseltme hakkına sahiptir."

#: src/ch16-03-upgradeability.md:51
msgid "/// Ownable\n"
msgstr "/// Sahiplenilebilir\n"

#: src/ch16-03-upgradeability.md:56
msgid "/// Upgradeable\n"
msgstr "/// Yükseltilebilir\n"

#: src/ch16-03-upgradeability.md:84
msgid "// This function can only be called by the owner\n"
msgstr "// Bu fonksiyon sadece sahibi tarafından çağrılabilir\n"

#: src/ch16-03-upgradeability.md:87
msgid "// Replace the class hash upgrading the contract\n"
msgstr "// Sözleşmeyi yükselten sınıf hash'ini değiştirin\n"

#: src/ch16-03-upgradeability.md:94
msgid ""
"<span class=\"caption\">Listing 16-4 Integrating OpenZeppelin's Upgradeable "
"component in a contract</span>"
msgstr ""
"span class=\"caption\">Bir sözleşmede 16-4 OpenZeppelin'in Yükseltilebilir "
"bileşenini listeleme/span>"

#: src/ch16-03-upgradeability.md:96
msgid ""
"For more information, please refer to the [OpenZeppelin docs API reference]"
"(https://docs.openzeppelin.com/contracts-cairo/0.9.0/api/upgrades)."
msgstr ""
"Daha fazla bilgi için lütfen [OpenZeppelin docs API referansı](https://docs."
"openzeppelin.com/contracts-cairo/0.0.0/api/upgrades) adresine bakın."

#: src/ch16-04-L1-L2-messaging.md:1
msgid "L1-L2 Messaging"
msgstr "L1-L2 Mesajlaşma"

#: src/ch16-04-L1-L2-messaging.md:3
msgid "A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr ""
"Layer 2'nin önemli bir özelliği, Layer 1 ile etkileşime girme yeteneğidir."

#: src/ch16-04-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` messaging system, which is different from its "
"consensus mechanism and the submission of state updates on L1. Messaging is "
"a way for smart-contracts on L1 to interact with smart-contracts on L2 (or "
"the other way around), allowing us to do \"cross-chain\" transactions. For "
"example, we can do some computations on a chain and use the result of this "
"computation on the other chain."
msgstr ""
"Starknet, fikir birliği mekanizmasından ve devlet güncellemelerinin L1'e "
"sunulmasından farklı olan kendi L1-L2 mesajlaşma sistemine sahiptir. "
"Mesajlaşma, L1'deki akıllı sözleşmelerin L2 üzerindeki akıllı sözleşmelerle "
"(veya başka bir şekilde) etkileşime girmesinin bir yoludur ve \"çapraz "
"zincir\" işlemleri yapmamızı sağlar. Örneğin, bir zincir üzerinde bazı "
"hesaplamalar yapabilir ve bu hesaplamanın sonucunu diğer zincirde "
"kullanabiliriz."

#: src/ch16-04-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to "
"bridge tokens from Ethereum to Starknet. You will simply have to deposit "
"your tokens in the L1 bridge contract, which will automatically trigger the "
"minting of the same token on L2. Another good use case for `L1-L2` messaging "
"would be [DeFi pooling](https://starkware.co/resource/defi-pooling/)."
msgstr ""
"Starknet üzerindeki köprülerin hepsi L1-L2 mesajlaşmasını kullanır. Diyelim "
"ki, tokenlerinizi Ethereum'dan Starknet'e köprülemek istiyorsunuz. "
"Jetonlarınızı L1 köprü sözleşmesine yatırmanız gerekecek, bu da aynı tokenin "
"L2'ye basılmasını otomatik olarak tetikleyecektir. L1-L2 mesajlaşması için "
"bir başka iyi kullanım durumu [DeFi havuzu] olacaktır [https://starkware.co/"
"resource/fi-de]."

#: src/ch16-04-L1-L2-messaging.md:9
msgid ""
"On Starknet, it's important to note that the messaging system is "
"**asynchronous** and **asymmetric**."
msgstr ""
"Starknet'te, mesajlaşma sisteminin ** asenkron ** ve ** asimetrik ** "
"olduğunu not etmek önemlidir."

#: src/ch16-04-L1-L2-messaging.md:11
msgid ""
"**Asynchronous**: this means that in your contract code (being Solidity or "
"Cairo), you can't wait the result of the message being sent on the other "
"chain within your contract code execution."
msgstr ""
"** Asenkron**: Bu, sözleşme kodunuzda (Solidity veya Kahire olmak üzere) "
"sözleşme kodu yürütmenizdeki diğer zincire gönderilen mesajın sonucunu "
"bekleyemeyeceğiniz anlamına gelir."

#: src/ch16-04-L1-L2-messaging.md:12
msgid ""
"**Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is "
"fully automated by the Starknet sequencer, which means that the message is "
"being automatically delivered to the target contract on L2. However, when "
"sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the "
"message is sent on L1 by the Starknet sequencer. You must then consume the "
"message manually via a transaction on L1."
msgstr ""
"** Asimetrik**: Ethereum'dan Starknet'e (L1->L2) bir mesaj göndermek "
"Starknet sekanslayıcı tarafından tamamen otomatikleştirilir, bu da mesajın "
"L2'deki hedef sözleşmeye otomatik olarak iletildiği anlamına gelir. Ancak, "
"Starknet'ten Ethereum'a (L2->L1) bir mesaj gönderirken, mesajın sadece "
"hash'i Starknet sekanslayıcı tarafından L1'e gönderilir. Daha sonra mesajı "
"L1 işlemi üzerinden manuel olarak tüketmelisiniz."

#: src/ch16-04-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr "Ayrıntılara dalalım."

#: src/ch16-04-L1-L2-messaging.md:18
msgid "The StarknetMessaging Contract"
msgstr "StarknetMesaj Sözleşmesi"

#: src/ch16-04-L1-L2-messaging.md:20
msgid ""
"The crucial component of the `L1-L2` Messaging system is the [`StarknetCore`]"
"(https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4) "
"contract. It is a set of Solidity contracts deployed on Ethereum that allows "
"Starknet to function properly. One of the contracts of `StarknetCore` is "
"called `StarknetMessaging` and it is the contract responsible for passing "
"messages between Starknet and Ethereum. `StarknetMessaging` follows an "
"[interface](https://github.com/starkware-libs/cairo-lang/"
"blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/"
"IStarknetMessaging.sol#L6) with functions allowing to send message to L2, "
"receiving messages on L1 from L2 and canceling messages."
msgstr ""
"L1-L2 Mesajlaşma sisteminin önemli bileşeni [Starknet-Core] (https://"
"etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4) iletileri "
"ile Starnet'in düzgün çalışmasını sağlayan bir dizi Solidity sözleşmesidir."

#: src/ch16-04-L1-L2-messaging.md:51
msgid "<span class=\"caption\"> Starknet messaging contract interface</span>"
msgstr "span class=\"caption\"> Starknet mesajlaşma sözleşme arayüzü/span>"

#: src/ch16-04-L1-L2-messaging.md:53
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly "
"listening to the logs emitted by the `StarknetMessaging` contract on "
"Ethereum. Once a message is detected in a log, the sequencer prepares and "
"executes a `L1HandlerTransaction` to call the function on the target L2 "
"contract. This takes up to 1-2 minutes to be done (few seconds for ethereum "
"block to be mined, and then the sequencer must build and execute the "
"transaction)."
msgstr ""
"L1->L2 mesajları durumunda, Starknet sıralayıcısı sürekli olarak "
"StarknetMesaging sözleşmesinin Ethereum üzerinde yaydığı günlükleri "
"dinliyor. Bir günlükte bir mesaj algılandığında, sıralayıcı hedef L2 "
"sözleşmesindeki işlevi çağırmak için bir L1HandlerTransaction hazırlar ve "
"çalıştırır. Bu işlemin yapılması 1-2 dakika kadar sürer (Etherethere için "
"birkaç saniye, daha sonra da maden bloğunun çalıştırılması gerekir)."

#: src/ch16-04-L1-L2-messaging.md:56
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of "
"the block produced. When the sequencer produces a block, it sends the hash "
"of each message prepared by contracts execution to the `StarknetCore` "
"contract on L1, where they can then be consumed once the block they belong "
"to is proven and verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""
"L2->L1 mesajları, L2 üzerindeki sözleşmeler yürütmesi ile hazırlanır ve "
"üretilen bloğun bir parçasıdır. Sıralayıcı bir blok ürettiğinde, L1 "
"üzerindeki StarknetCore sözleşmesine sözleşmeler yürütmesi ile hazırlanan "
"her mesajın hashini gönderir; böylece ait oldukları blok Ethereum'da "
"kanıtlandıktan ve doğrulandıktan sonra tüketilebilirler (şu an için yaklaşık "
"3-4 saattir)."

#: src/ch16-04-L1-L2-messaging.md:62
msgid "Sending Messages from Ethereum to Starknet"
msgstr "Ethereum'dan Starknet'e Mesaj Gönderme"

#: src/ch16-04-L1-L2-messaging.md:64
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity "
"contracts must call the `sendMessageToL2` function of the "
"`StarknetMessaging` contract. To receive these messages on Starknet, you "
"will need to annotate functions that can be called from L1 with the "
"`#[l1_handler]` attribute."
msgstr ""
"Ethereum'dan Starknet'e mesaj göndermek istiyorsanız, Solidity "
"sözleşmelerinizin StarknetMessage sözleşmesinin sendMessageToL2 işlevini "
"çağırması gerekir. Starknet'te bu mesajları almak için, L1'den #[l1_handler] "
"özniteliği ile çağrılabilecek işlevleri belirtmeniz gerekir."

#: src/ch16-04-L1-L2-messaging.md:66
msgid ""
"Let's take a simple contract taken from [this tutorial](https://github.com/"
"glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol) where "
"we want to send a message to Starknet. The `_snMessaging` is a state "
"variable already initialized with the address of the `StarknetMessaging` "
"contract. You can check all Starknet contract and sequencer addresses [here]"
"(https://docs.starknet.io/documentation/tools/important_addresses/)."
msgstr ""
"Starknet'e mesaj göndermek istediğimiz [https://github.com/glihm/starknet-"
"mesajlama-dev/blob/main/solidity/src/ContractMsg.sol] adresinden alınan "
"basit bir sözleşmeyi ele alalım. _sndocument_shttpsaging, Starknet adresiyle "
"zaten başlatılan bir durum değişkenidir."

#: src/ch16-04-L1-L2-messaging.md:70
msgid "// Sends a message on Starknet with a single felt.\n"
msgstr "// Starknet'e tek bir keçe ile mesaj gönderir.\n"

#: src/ch16-04-L1-L2-messaging.md:79
msgid ""
"// We \"serialize\" here the felt into a payload, which is an array of "
"uint256.\n"
msgstr ""
"// Burada keçeyi bir yük yüküne \"serileştiririz\", ki bu bir uint256 "
"dizisidir.\n"

#: src/ch16-04-L1-L2-messaging.md:83
msgid "// msg.value must always be >= 20_000 wei.\n"
msgstr "// msg.value her zaman>= 20_000 wei olmalıdır.\n"

#: src/ch16-04-L1-L2-messaging.md:92
msgid ""
"The function sends a message with a single felt value to the "
"`StarknetMessaging` contract. Please note that if you want to send more "
"complex data you can. Just be aware that your Cairo contract will only "
"understand `felt252` data type. So you must ensure that the serialization of "
"your data into the `uint256` array follow the Cairo serialization scheme."
msgstr ""
"İşlev, StarknetMesaj sözleşmesine tek bir keçe değeri ile bir mesaj "
"gönderir. Daha karmaşık veriler göndermek istiyorsanız, yapabileceğinizi "
"unutmayın. Kahire sözleşmenizin yalnızca felt252 veri türünü anlayacağını "
"unutmayın. Bu nedenle, verilerinizi uint256 dizisine serileştirmenin Kahire "
"serileştirme şemasını takip ettiğinden emin olmalısınız."

#: src/ch16-04-L1-L2-messaging.md:95
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the "
"minimum value we've to send here is `20k wei`, due to the fact that the "
"`StarknetMessaging` contract will register the hash of our message in the "
"storage of Ethereum."
msgstr ""
"value: msg.value'ye sahip olduğumuzu belirtmek önemlidir. Aslında, burada "
"göndermemiz gereken minimum değer 20k Wei'dir, çünkü StarknetMesaging "
"sözleşmesi mesajımızın hash'ini Ethereum'un deposuna kaydeder."

#: src/ch16-04-L1-L2-messaging.md:98
msgid ""
"In addition to those `20k wei`, since the `L1HandlerTransaction` executed by "
"the sequencer is not tied to any account (the message originates from L1), "
"you must also ensure that you pay enough fees on L1 for your message to be "
"deserialized and processed on L2."
msgstr ""
"Bu 20k wei'lere ek olarak, sıralayıcı tarafından yürütülen "
"L1HandlerTransaction herhangi bir hesaba bağlı olmadığından (mesaj L1), "
"mesajınızın deserialize edilmesi ve L2'de işlenmesi için L1'de yeterli ücret "
"ödediğinizden emin olmalısınız."

#: src/ch16-04-L1-L2-messaging.md:101
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as "
"it would be done for an `Invoke` transaction. For this, you can profile the "
"gas consumption using `starkli` or `snforge` to estimate the cost of your "
"message execution."
msgstr ""
"L1HandlerTransaction ücretleri, bir Invoke işlemi için yapılacağı gibi "
"düzenli bir şekilde hesaplanır. Bunun için, mesaj yürütmenizin maliyetini "
"tahmin etmek için starkli veya snforge kullanarak gaz tüketimini "
"profilleyebilirsiniz."

#: src/ch16-04-L1-L2-messaging.md:104
msgid "The signature of the `sendMessageToL2` is:"
msgstr "sendMessageToL2 imzası şu şekildedir:"

#: src/ch16-04-L1-L2-messaging.md:114
msgid "The parameters are as follows:"
msgstr "Parametreler aşağıdaki gibidir:"

#: src/ch16-04-L1-L2-messaging.md:116
msgid "`toAddress`: The contract address on L2 that will be called."
msgstr "toAddress: L2'de çağrılacak olan sözleşme adresi."

#: src/ch16-04-L1-L2-messaging.md:117
msgid ""
"`selector`: The selector of the function of this contract at `toAddress`. "
"This selector (function) must have the `#[l1_handler]` attribute to be "
"callable."
msgstr ""
"selector: Bu sözleşmenin toAddress işlevinin seçicisi. Bu seçici (fonksiyon) "
"#[l1_handler] özniteliğine sahip olmalıdır."

#: src/ch16-04-L1-L2-messaging.md:118
msgid ""
"`payload`: The payload is always an array of `felt252` (which are "
"represented by `uint256` in Solidity). For this reason we've inserted the "
"input `myFelt` into the array. This is why we need to insert the input data "
"into an array."
msgstr ""
"payload: Yük her zaman bir felt252 dizisidir (Solidity'de uint256 ile temsil "
"edilir). Bu nedenle myFelt girdisini diziye ekledik. Bu yüzden girdi "
"verilerini bir diziye sokmamız gerekiyor."

#: src/ch16-04-L1-L2-messaging.md:121
msgid "On the Starknet side, to receive this message, we have:"
msgstr "Starknet tarafında, bu mesajı almak için, elimizde:"

#: src/ch16-04-L1-L2-messaging.md:128
msgid ""
"// You can now use the data, automatically deserialized from the message "
"payload.\n"
msgstr ""
"// Artık ileti yükünden otomatik olarak deserialize edilmiş verileri "
"kullanabilirsiniz.\n"

#: src/ch16-04-L1-L2-messaging.md:133
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers "
"are special functions that can only be executed by a `L1HandlerTransaction`. "
"There is nothing particular to do to receive transactions from L1, as the "
"message is relayed by the sequencer automatically. In your `#[l1_handler]` "
"functions, it is important to verify the sender of the L1 message to ensure "
"that our contract can only receive messages from a trusted L1 contract."
msgstr ""
"Fonksiyonumuza #[l1_handler] özniteliğini eklememiz gerekiyor. L1 "
"işleyicileri, yalnızca bir L1HandlerTransaction tarafından çalıştırılabilen "
"özel işlevlerdir. Mesaj, dizileyici tarafından otomatik olarak iletildiği "
"için L1'den işlem almak için özel bir şey yoktur. #[l1_handler] "
"işlevlerinde, yalnızca L1 iletimizin göndericisini güvenilir bir iletinin "
"almasını sağlamak için doğrulamanız önemlidir."

#: src/ch16-04-L1-L2-messaging.md:138
msgid "Sending Messages from Starknet to Ethereum"
msgstr "Starknet'ten Ethereum'a Mesaj Gönderme"

#: src/ch16-04-L1-L2-messaging.md:140
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the "
"`send_message_to_l1` syscall in your Cairo contracts. This syscall allows "
"you to send messages to the `StarknetMessaging` contract on L1. Unlike `L1-"
">L2` messages, `L2->L1` messages must be consumed manually, which means that "
"you will need your Solidity contract to call the `consumeMessageFromL2` "
"function of the `StarknetMessaging` contract explicitly in order to consume "
"the message."
msgstr ""
"Starknet'ten Ethereum'a mesaj gönderirken, Kahire sözleşmelerinizde "
"send_message_to_l1 syscall'ı kullanmanız gerekecektir. Bu syscall, L1'deki "
"StarknetMessage sözleşmesine mesaj göndermenizi sağlar. L1->L2 mesajlarının "
"aksine, L2->L1 mesajlarının elle tüketilmesi gerekir, bu da Solidconsume "
"sözleşmenize ihtiyacınız olacağı anlamına gelir."

#: src/ch16-04-L1-L2-messaging.md:142
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr "L2'den L1'e bir mesaj göndermek için Starknet'te yapacağımız şey:"

#: src/ch16-04-L1-L2-messaging.md:146
msgid ""
"// Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
msgstr ""
"// Burada not edin, my_felt'i \"serialize ediyoruz\", çünkü yük // a "
"Spanfelt252> olmalıdır.\n"

#: src/ch16-04-L1-L2-messaging.md:153
msgid ""
"We simply build the payload and pass it, along with the L1 contract address, "
"to the syscall function."
msgstr ""
"Biz sadece yükü inşa ediyoruz ve L1 sözleşme adresi ile birlikte syscall "
"fonksiyonuna geçiyoruz."

#: src/ch16-04-L1-L2-messaging.md:155
msgid ""
"On L1, the important part is to build the same payload sent by the L2. Then "
"you call `consumeMessageFromL2` in you Solidity contract by passing the L2 "
"contract address and the payload. Please be aware that the L2 contract "
"address expected by the `consumeMessageFromL2` is the address of the "
"contract that sends the message on the L2 by calling "
"`send_message_to_l1_syscall`."
msgstr ""
"L1'de önemli olan, L2 tarafından gönderilen aynı yükü oluşturmaktır. "
"Ardından, L2 sözleşme adresini ve yükü geçerek Solidity sözleşmenizde "
"consumeMessageFromL2'yi ararsınız. consumeMessageFromL2 tarafından beklenen "
"L2 sözleşme adresinin, send_message_to_calls_calls1'i arayarak L2'ye mesajı "
"gönderen sözleşmenin adresi olduğunu unutmayın."

#: src/ch16-04-L1-L2-messaging.md:166
msgid "// You can use the message hash if you want here.\n"
msgstr "// Burada isterseniz hash iletisini kullanabilirsiniz.\n"

#: src/ch16-04-L1-L2-messaging.md:168
msgid ""
"// We expect the payload to contain only a felt252 value (which is a uint256 "
"in Solidity).\n"
msgstr ""
"// Yükün sadece bir keçe252 değeri içermesini bekliyoruz (bu, Solidity'de "
"bir uint256'dır).\n"

#: src/ch16-04-L1-L2-messaging.md:169
msgid "\"Invalid payload\""
msgstr "\"Geçersiz yük\""

#: src/ch16-04-L1-L2-messaging.md:173
msgid ""
"// From here, you can safely use `my_felt` as the message has been verified "
"by StarknetMessaging.\n"
msgstr ""
"// Buradan, mesaj StarknetMesaging tarafından doğrulandığı için my_felt'yi "
"güvenle kullanabilirsiniz.\n"

#: src/ch16-04-L1-L2-messaging.md:174
msgid "\"Invalid value\""
msgstr "\"Geçersiz değer\""

#: src/ch16-04-L1-L2-messaging.md:178
msgid ""
"As you can see, in this context we don't have to verify which contract from "
"L2 is sending the message (as we do on the L2 to verify which contract from "
"L1 is sending the message). But we are actually using the "
"`consumeMessageFromL2` of the `StarknetCore` contract to validate the inputs "
"(the contract address on L2 and the payload) to ensure we are only consuming "
"valid messages."
msgstr ""
"Gördüğünüz gibi, bu bağlamda, L2'den hangi sözleşmenin mesajı gönderdiğini "
"doğrulamak zorunda değiliz (L1'den hangi sözleşmenin mesajı gönderdiğini "
"doğrulamak için L2'de yaptığımız gibi). Ama aslında StarknetCore "
"sözleşmesinin consumeMessageFromL2'sini, girdileri doğrulamak için "
"kullanıyoruz (L2 üzerindeki sözleşme adresi ve yük)."

#: src/ch16-04-L1-L2-messaging.md:180
msgid ""
"**Note:** The `consumeMessageFromL2` function of the `StarknetCore` contract "
"is expected to be called from a Solidity contract, and not directly on the "
"`StarknetCore` contract. The reason of that is because the `StarknetCore` "
"contract is using `msg.sender` to actually compute the hash of the message. "
"And this `msg.sender` must correspond to the `to_address` field that is "
"given to the function `send_message_to_l1_syscall` that is called on "
"Starknet."
msgstr ""
"**Not:** StarknetCore sözleşmesinin consumeMessageFromL2 işlevinin bir "
"Solidity sözleşmesinden çağrılması bekleniyor ve Starknet_Core sözleşmesinde "
"doğrudan değil. Bunun nedeni, StarknetCore sözleşmesinin, mesajın hashini "
"hesaplamak için msg.sender işlevinin kullanılmasıdır."

#: src/ch16-04-L1-L2-messaging.md:182
msgid ""
"It is important to remember that on L1 we are sending a payload of "
"`uint256`, but the basic data type on Starknet is `felt252`; however, "
"`felt252` are approximately 4 bits smaller than `uint256`. So we have to pay "
"attention to the values contained in the payload of the messages we are "
"sending. If, on L1, we build a message with values above the maximum "
"`felt252`, the message will be stuck and never consumed on L2."
msgstr ""
"L1'de bir yük uint256 gönderdiğimizi hatırlamak önemlidir, ancak "
"Starknet'teki temel veri türü felt252'dir; Bununla birlikte, felt252'den "
"yaklaşık 4 bit daha küçüktür. Bu nedenle, gönderdiğimiz mesajların yükünde "
"bulunan değerlere dikkat etmeliyiz. L1'de, yukarıdaki değerleri içeren bir "
"mesaj oluşturursak, maksimum"

#: src/ch16-04-L1-L2-messaging.md:184
msgid "Cairo Serde"
msgstr "Kahire Serde"

#: src/ch16-04-L1-L2-messaging.md:186
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet "
"contracts, written in Cairo, can only understand serialized data. And "
"serialized data is always an array of `felt252`. In Solidity we have "
"`uint256` type, and `felt252` are approximately 4 bits smaller than "
"`uint256`. So we have to pay attention to the values contained in the "
"payload of the messages we are sending. If, on L1, we build a message with "
"values above the maximum `felt252`, the message will be stuck and never "
"consumed on L2."
msgstr ""
"L1 ve L2 arasında mesaj göndermeden önce, Kahire'de yazılan Starknet "
"sözleşmelerinin yalnızca serileştirilmiş verileri anlayabileceğini "
"unutmayın. Serileştirilmiş veriler her zaman bir dizi felt252'dir. Katılıkta "
"uint256 tipine sahibiz ve felt252, uint256'dan yaklaşık 4 bit daha küçük "
"değildir. Bu nedenle, bir Lload'da bulunan değerlere dikkat etmeliyiz."

#: src/ch16-04-L1-L2-messaging.md:190
msgid ""
"So for instance, an actual `uint256` value in Cairo is represented by a "
"struct like:"
msgstr ""
"Örneğin, Kahire'deki gerçek bir uint256 değeri aşağıdaki gibi bir yapı ile "
"temsil edilir:"

#: src/ch16-04-L1-L2-messaging.md:199
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for "
"the `high`. This means that to send only one `u256` to Cairo, you'll need to "
"send a payload from L1 with **TWO** values."
msgstr ""
"bir tanesi low için, diğeri de high için olmak üzere **TWO** keçeleri olarak "
"serileştirilecektir. Bu, Kahire'ye sadece bir u256 göndermek için, L1'den "
"**TWO** değerleri ile bir yük yüklemesi göndermeniz gerektiği anlamına gelir."

#: src/ch16-04-L1-L2-messaging.md:202
msgid "// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
msgstr ""
"// 1 değerini cairo cinsinden u256 olarak gönderelim: düşük = 1, yüksek = "
"0.\n"

#: src/ch16-04-L1-L2-messaging.md:208
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the "
"[Starknet documentation](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Network_Architecture/messaging-mechanism/)."
msgstr ""
"Mesajlaşma mekanizması hakkında daha fazla bilgi edinmek isterseniz "
"[Starknet documentation](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Network_Architecture/message-mechanism/) adresini "
"ziyaret edebilirsiniz."

#: src/ch16-04-L1-L2-messaging.md:210
msgid ""
"You can also find a [detailed guide here](https://github.com/glihm/starknet-"
"messaging-dev) to test the messaging system locally."
msgstr ""
"Ayrıca, mesajlaşma sistemini yerel olarak test etmek için bir [ayrıntılı "
"kılavuz burada] (https://github.com/glihm/starknet-message-dev) "
"bulabilirsiniz."

#: src/ch16-05-oracle-interactions.md:3
msgid ""
"This section focuses on the concept of bringing off-chain data to the "
"Starknet blockchain using oracles. Oracles are third-party services that "
"serve as intermediaries, securely transmitting external data, such as asset "
"prices, weather information, or other real-world data, to blockchains and "
"smart contracts. It also provides practical examples and code snippets "
"demonstrating how developers can interact with a specific oracle named "
"Pragma on Starknet network, covering topics like querying and handling price "
"data, and verifiable random function (VRF) to generate random numbers."
msgstr ""
"Bu bölüm, kahinleri kullanarak Starknet blok zincirine zincir dışı veri "
"getirme konseptine odaklanmaktadır. Oracle'lar, varlık fiyatları, hava "
"durumu bilgileri veya diğer gerçek dünya verileri gibi harici verileri blok "
"zincirlere ve akıllı sözleşmelere güvenli bir şekilde aktaran aracılar "
"olarak hizmet veren üçüncü taraf hizmetleridir. Ayrıca, geliştiricilerin "
"Starknet ağındaki Pragma adlı belirli bir kahinle nasıl etkileşime "
"girebileceğini gösteren pratik örnekler ve kod parçacıkları sağlar."

#: src/ch16-05-01-price-feeds.md:3
msgid ""
"Price feeds enabled by an oracle serve as a bridge between real-world data "
"feed and the blockchain. They provide real time pricing data that is "
"aggregated from multiple trusted external sources ( e.g. crypto exchanges, "
"financial data providers, etc. ) to the blockchain network."
msgstr ""
"Bir kahin tarafından etkinleştirilen fiyat beslemeleri, gerçek dünya veri "
"beslemesi ile blok zinciri arasında bir köprü görevi görür. Birden fazla "
"güvenilir dış kaynaktan (örneğin kripto borsaları, finansal veri "
"sağlayıcıları vb.) blok zinciri ağına toplanan gerçek zamanlı fiyatlandırma "
"verileri sağlarlar."

#: src/ch16-05-01-price-feeds.md:5
msgid ""
"For the example in this book section, we will use Pragma Oracle to read the "
"price feed for `ETH/USD` asset pair and also showcase a mini application "
"that utilizes this feed."
msgstr ""
"Bu kitap bölümündeki örnek için, ETH / USD varlık çifti için fiyat "
"beslemesini okumak için Pragma Oracle'ı kullanacağız ve ayrıca bu beslemeyi "
"kullanan bir mini uygulama sergileyeceğiz."

#: src/ch16-05-01-price-feeds.md:7
msgid ""
"[Pragma Oracle](https://www.pragma.build/) is a leading zero knowledge "
"oracle that provides access to off-chain data on Starknet blockchain in a "
"verifiable way."
msgstr ""
"[Pragma Oracle](https://www.pragma.build/) Starknet blok zincirindeki zincir "
"dışı verilere doğrulanabilir bir şekilde erişim sağlayan önde gelen bir "
"sıfır bilgi kahinidir."

#: src/ch16-05-01-price-feeds.md:9
msgid "Add Pragma as a Project Dependency"
msgstr "Proje Bağımlılığı Olarak Pragma Ekle"

#: src/ch16-05-01-price-feeds.md:11
msgid ""
"To get started with integrating Pragma on your Cairo smart contract for "
"price feed data, edit your project's `Scarb.toml` file to include the path "
"to use Pragma."
msgstr ""
"Fiyat besleme verileri için Kahire akıllı sözleşmenizde Pragma'yı entegre "
"etmeye başlamak için, Pragma'yı kullanma yolunu içerecek şekilde projenizin "
"Scarb.toml dosyasını düzenleyin."

#: src/ch16-05-01-price-feeds.md:13 src/ch16-05-02-randomness.md:20
msgid ""
"```toml\n"
"[dependencies]\n"
"pragma_lib = { git = \"https://github.com/astraly-labs/pragma-lib\" }\n"
"```"
msgstr ""
"toml [bağımlılar] pragma_lib =  git = \"https://github.com/astraly-labs/"
"pragma-lib\""

#: src/ch16-05-01-price-feeds.md:18
msgid "Creating a Price Feed Contract"
msgstr "Fiyat Besleme Sözleşmesi Oluşturmak"

#: src/ch16-05-01-price-feeds.md:20
msgid ""
"After adding the required dependencies for your project, you'll need to "
"define a contract interface that includes the required pragma price feed "
"entry point."
msgstr ""
"Projeniz için gerekli bağımlılıkları ekledikten sonra, gerekli pragma fiyat "
"besleme giriş noktasını içeren bir sözleşme arayüzü tanımlamanız gerekir."

#: src/ch16-05-01-price-feeds.md:22
msgid "Contract Interface"
msgstr "Sözleşme Arayüzü"

#: src/ch16-05-01-price-feeds.md:32
msgid ""
"Of the two public functions exposed in the `IPriceFeedExample`, the one "
"necessary to interact with the pragma price feed oracle is the "
"`get_asset_price` function, a view function that takes in the `asset_id` "
"argument and returns a `u128` value."
msgstr ""
"IPriceFeedExample'da açığa çıkan iki kamu işlevinden, pragma fiyat besleme "
"kahini ile etkileşime girmek için gerekli olan get_asset_price işlevi, "
"asset_id argümanını alan ve u128 değerini döndüren bir görünüm fonksiyonudur."

#: src/ch16-05-01-price-feeds.md:34
msgid "Pragma Dependency Import to Contract"
msgstr "Pragma Bağımlılığı Sözleşmeye İthalat"

#: src/ch16-05-01-price-feeds.md:41
msgid ""
"The snippet above shows the necessary imports you need to add to your "
"contract module in order to interact with the Pragma oracle."
msgstr ""
"Yukarıdaki snippet, Pragma kahini ile etkileşim kurmak için sözleşme "
"modülünüze eklemeniz gereken gerekli ithalatı gösterir."

#: src/ch16-05-01-price-feeds.md:43
msgid "Required Price Feed Function Impl in Contract"
msgstr "Sözleşmede Gerekli Fiyat Besleme Fonksiyonu Impl"

#: src/ch16-05-01-price-feeds.md:47 src/ch16-05-01-price-feeds.md:117
msgid "// Retrieve the oracle dispatcher\n"
msgstr "// Kahin göndericiyi geri al\n"

#: src/ch16-05-01-price-feeds.md:52 src/ch16-05-01-price-feeds.md:122
msgid "// Call the Oracle contract, for a spot entry\n"
msgstr "// Nokta girişi için Oracle sözleşmesini arayın\n"

#: src/ch16-05-01-price-feeds.md:60
msgid ""
"The `get_asset_price` function is responsible for retrieving the price of "
"the asset specified by the `asset_id` argument from Pragma Oracle. The "
"`get_data_median` method is called from the `IPragmaDispatcher` instance by "
"passing the `DataType::SpotEntry(asset_id)` as an argument and its output is "
"assigned to a variable named `output` of type `PragmaPricesResponse`. "
"Finally, the function returns the price of the requested asset as a `u128`."
msgstr ""
"get_asset_price işlevi, asset_id argümanı tarafından belirtilen varlığın "
"fiyatının Pragma Oracle'dan alınmasından sorumludur. get_data_median "
"yöntemi, IPragmaDispatcher örneğinden bir argüman olarak DataType::"
"SpotEntry(asset_id) değerini geçerek çağrılır ve çıktısı bir değişkene "
"atanır."

#: src/ch16-05-01-price-feeds.md:62
msgid "Example Application Using Pragma Price Feed"
msgstr "Pragma Fiyat Beslemesini Kullanarak Örnek Uygulama"

#: src/ch16-05-01-price-feeds.md:96
msgid "// Calculate the amount of ETH needed\n"
msgstr "// Gerekli ETH miktarını hesaplayın\n"

#: src/ch16-05-01-price-feeds.md:102 src/ch16-05-02-randomness.md:228
msgid "// ETH Contract Address\n"
msgstr "// ETH Sözleşme Adresi\n"

#: src/ch16-05-01-price-feeds.md:105
msgid "// Transfer the ETH to the caller\n"
msgstr "// ETH'yi arayana aktar\n"

#: src/ch16-05-01-price-feeds.md:132
msgid ""
"Note: Pragma returns the value of different token pairs using the decimal "
"factor of 6 or 8. You can convert the value to the required decimal factor "
"by dividing the value by \\\\( {10^{n}} \\\\), where `n` is the decimal "
"factor."
msgstr ""
"Not: Pragma, 6 veya 8'in ondalık faktörünü kullanarak farklı jeton "
"çiftlerinin değerini döndürür. n'nin ondalık faktör olduğu değeri ( 10n ) "
"ile bölerek değeri gerekli ondalık faktöre dönüştürebilirsiniz."

#: src/ch16-05-01-price-feeds.md:134
msgid ""
"The code above is an example implementation of an applications consuming a "
"price feed from the Pragma oracle. The contract imports necessary modules "
"and interfaces, including the `IPragmaABIDispatcher` for interacting with "
"the Pragma oracle contract and the `ERC20ABIDispatcher` for interacting with "
"the ETH ERC20 token contract."
msgstr ""
"Yukarıdaki kod, Pragma kahini'nden bir fiyat beslemesi tüketen bir "
"uygulamanın örnek bir uygulamasıdır. Sözleşme, Pragma kahini sözleşmesi ve "
"ETH ERC20 token sözleşmesi ile etkileşime girmek için IPragmaABIDispatcher "
"dahil olmak üzere gerekli modülleri ve arayüzleri ithal eder."

#: src/ch16-05-01-price-feeds.md:136
msgid ""
"The contract has a `const` that stores the token pair ID of `ETH/USD`, and a "
"`Storage` struct that holds two fields `pragma_contract` and "
"`product_price_in_usd`. The constructor function initializes the "
"`pragma_contract` address and sets the `product_price_in_usd` to 100."
msgstr ""
"Sözleşme, ETH/USD token çifti kimliğini depolayan bir const ve "
"pragma_contract ve product_price_in_usd olmak üzere iki alanı tutan bir "
"Storage yapısına sahiptir. Yapılandırıcı işlevi pragma_contract adresini "
"başlatır ve product_price_in_usd değerini 100 olarak ayarlar."

#: src/ch16-05-01-price-feeds.md:138
msgid ""
"The `buy_item` function is the main entry point for a user to purchase an "
"item. It retrieves the caller's address. It calls the `get_asset_price` "
"function to get the current price of ETH in USD using the `ETH_USD` asset "
"ID. It calculates the amount of ETH needed to buy the product based on the "
"product price in USD at the corresponding ETH price. It then checks if the "
"caller has enough ETH by calling the `balance_of` method on the ERC20 ETH "
"contract. If the caller has enough ETH, it calls the `transfer_from` method "
"of the `eth_dispatcher` instance to transfer the required amount of ETH from "
"the caller to another contract address."
msgstr ""
"buy_item işlevi, bir kullanıcının bir öğe satın alması için ana giriş "
"noktasıdır. Arayanın adresini alır. ETH_USD varlık kimliğini kullanarak "
"ETH'nin mevcut fiyatını USD cinsinden almak için get_asset_price işlevini "
"çağırır. Yeterli ETH fiyatından USD'deki ürün fiyatına dayalı olarak ETH'yi "
"satın almak için gereken ETH miktarını hesaplar. Daha sonra arayan kişinin "
"yeterli olup olmadığını kontrol eder."

#: src/ch16-05-01-price-feeds.md:140
msgid ""
"The `get_asset_price` function is the entry point to interact with the "
"Pragma oracle and has been explained in the section above."
msgstr ""
"get_asset_price işlevi, Pragma kahini ile etkileşime girmek için giriş "
"noktasıdır ve yukarıdaki bölümde açıklanmıştır."

#: src/ch16-05-01-price-feeds.md:142
msgid ""
"You can get a detailed guide on consuming data using Pragma price feeds "
"[here](https://docs.pragma.build/Resources/Cairo%201/data-feeds/consuming-"
"data)."
msgstr ""
"Pragma fiyat beslemelerini kullanarak veri tüketme konusunda ayrıntılı bir "
"rehber alabilirsiniz [burada](https://docs.pragma.build/Resources/Cairo%201/"
"data-feeds/eating-data)."

#: src/ch16-05-02-randomness.md:3
msgid ""
"Since all blockchains are fundamentally deterministic and most are public "
"ledgers, generating truly unpredictatable randomness on-chain presents a "
"challenge. This randomness is crucial for fair outcomes in gaming, "
"lotteries, and unique generation of NFTs. To address this, verifiable random "
"functions (VRFs) provided by oracles offer a solution. VRFs guarantee that "
"the randomness can't be predicted or tampered with, ensuring trust and "
"transparency in these applications."
msgstr ""
"Tüm blok zincirleri temelde deterministik olduğundan ve çoğu kamu defterleri "
"olduğundan, zincir üzerinde gerçekten öngörülemeyen rastgelelik üretmek bir "
"meydan okuma sunar. Bu rastgelelik, oyun, piyango ve benzersiz nesil "
"NFT'lerde adil sonuçlar için çok önemlidir. Bunu ele almak için, kahinler "
"tarafından sağlanan doğrulanabilir rastgele fonksiyonlar (VRF'ler) bir çözüm "
"sunar. VRF'ler, rastgeleliğin tahmin edilemeyeceğini veya bu uygulamalarla "
"oynanamayacağını, güven ve şeffaflığın sağlan garantisini verir."

#: src/ch16-05-02-randomness.md:5
msgid "Overview on VRFs"
msgstr "VRF'lere genel bakış"

#: src/ch16-05-02-randomness.md:7
msgid ""
"Pseudo-random but secure: VRFs use a secret key and a nonce (a unique input) "
"to generate an output that appears random. While technically 'pseudo-"
"random', it's practically impossible for another party to predict the "
"outcome without knowing the secret key."
msgstr ""
"Pseudo-rastgele ama güvenli: VRF'ler rastgele görünen bir çıktı oluşturmak "
"için gizli bir anahtar ve bir nonce (benzersiz bir girdi) kullanır. Teknik "
"olarak 'pseudo-rastgele' olsa da, başka bir tarafın gizli anahtarı bilmeden "
"sonucu tahmin etmesi neredeyse imkansızdır."

#: src/ch16-05-02-randomness.md:9
msgid ""
"Verifiable output: VRFs produce not only the random number but also a proof "
"that anyone can use to independently verify that the result was generated "
"correctly according to the function's parameters."
msgstr ""
"Doğrulanabilir çıktı: VRF'ler sadece rastgele sayıyı değil, aynı zamanda "
"sonucun fonksiyonun parametrelerine göre doğru bir şekilde oluşturulduğunu "
"bağımsız olarak doğrulamak için herkesin kullanabileceği bir kanıt üretir."

#: src/ch16-05-02-randomness.md:11
msgid "Generating Randomness with Pragma"
msgstr "Pragma ile Rastgelelik Oluşturmak"

#: src/ch16-05-02-randomness.md:13
msgid ""
"[Pragma](https://www.pragma.build/), an oracle on Starknet provides a "
"solution for generating random numbers using VRFs. Let's dive into how to "
"use Pragma VRF to generate a random number in a simple dice game contract."
msgstr ""
"[Pragma](https://www.pragma.build/), Starknet'teki bir kahin, VRF'leri "
"kullanarak rastgele sayılar oluşturmak için bir çözüm sunar. Basit bir zar "
"oyunu sözleşmesinde rastgele bir sayı oluşturmak için Pragma VRF'yi nasıl "
"kullanacağımıza bakalım."

#: src/ch16-05-02-randomness.md:16
msgid "Add Pragma as a Dependency"
msgstr "Bağımlılık Olarak Pragma Ekle"

#: src/ch16-05-02-randomness.md:18
msgid ""
"Edit your cairo project's `Scarb.toml` file to include the path to use "
"Pragma."
msgstr ""
"Cairo projenizin Scarb.toml dosyasını Pragma'yı kullanma yolunu içerecek "
"şekilde düzenleyin."

#: src/ch16-05-02-randomness.md:61
msgid ""
"<span class=\"caption\">Listing 16-5 shows a contract interfaces for Pragma "
"VRF and a simple dice game.</span>"
msgstr ""
"span class=\"caption\">Liste 16-5, Pragma VRF için bir sözleşme arabirimi ve "
"basit bir zar oyunu gösterir./span>"

#: src/ch16-05-02-randomness.md:63
msgid "Description of Key IPragmaVRF Entrypoints and Their Inputs"
msgstr "Anahtar IPragmaVRF Giriş Noktaları ve Girişlerinin Tanımı"

#: src/ch16-05-02-randomness.md:65
msgid ""
"The function `request_randomness_from_pragma` initiates a request for "
"verifiable randomness from the Pragma oracle. It does this by emitting an "
"event that triggers the following actions off-chain:"
msgstr ""
"request_randomness_from_pragma işlevi, Pragma kahini tarafından "
"doğrulanabilir rastgelelik için bir istek başlatır. Bunu, aşağıdaki "
"eylemleri zincir dışı tetikleyen bir olay yayarak yapar:"

#: src/ch16-05-02-randomness.md:67
msgid ""
"Randomness generation: The oracle generates random values and a "
"corresponding proof."
msgstr ""
"Rasgelelik jenerasyonu: Kahin rastgele değerler ve karşılık gelen bir kanıt "
"üretir."

#: src/ch16-05-02-randomness.md:68
msgid ""
"On-chain submission: The oracle submits the generated randomness and proof "
"back to the blockchain via the `receive_random_words` callback function."
msgstr ""
"On-chain submission: Oracle, oluşturulan rastgeleliği ve kanıtı "
"receive_random_words geri çağırma işlevi aracılığıyla blok zincirine geri "
"gönderir."

#: src/ch16-05-02-randomness.md:70
msgid "`request_randomness_from_pragma` Inputs"
msgstr "request_randomness_from_pragma Girişler"

#: src/ch16-05-02-randomness.md:72
msgid ""
"`seed`: A value used to initialize the randomness generation process. This "
"should be unique to ensure unpredictable results."
msgstr ""
"seed: Rastgelelik oluşturma işlemini başlatmak için kullanılan bir değer. "
"Bu, öngörülemeyen sonuçları sağlamak için benzersiz olmalıdır."

#: src/ch16-05-02-randomness.md:73
msgid ""
"`callback_address`: The contract address where the `receive_random_words` "
"function will be called to deliver the generated randomness. It is typically "
"the address of your deployed contract implementing Pragma VRF."
msgstr ""
"callback_address: receive_random_words işlevinin oluşturulan rastgeleliği "
"iletmek için çağrılacağı sözleşme adresidir. Genellikle Pragma VRF'yi "
"uygulayan konuşlandırılmış sözleşmenizin adresidir."

#: src/ch16-05-02-randomness.md:74
msgid ""
"`callback_fee_limit`: The maximum amount of gas you're willing to spend on "
"executing the `receive_random_words` callback function."
msgstr ""
"callback_fee_limit: receive_random_words geri çağırma işlevini yürütmek için "
"harcamak istediğiniz maksimum gaz miktarı."

#: src/ch16-05-02-randomness.md:75
msgid ""
"`publish_delay`: The minimum delay (in blocks) between requesting randomness "
"and the oracle fulfilling the request."
msgstr ""
"publish_delay: Rastgelelik isteme ile isteği yerine getiren kahin arasındaki "
"minimum gecikme (bloklarda)."

#: src/ch16-05-02-randomness.md:76
msgid ""
"`num_words`: The number of random values (each represented as a `felt252`) "
"you want to receive in a single callback."
msgstr ""
"num_words: Rastgele değerlerin sayısı (her biri felt252 olarak temsil "
"edilir) tek bir geri çağrıda almak istediğiniz."

#: src/ch16-05-02-randomness.md:77
msgid ""
"`calldata`: Additional data you want to pass to the `receive_random_words` "
"callback function."
msgstr ""
"calldata: receive_random_words geri çağırma işlevine geçmek istediğiniz ek "
"veriler."

#: src/ch16-05-02-randomness.md:79
msgid "`receive_randomn_words` Inputs"
msgstr "receive_randomn_words Girişler"

#: src/ch16-05-02-randomness.md:81
msgid ""
"`requester_address`: The contract address that initiated the randomness "
"request."
msgstr "requester_address: Rastgelelik isteğini başlatan sözleşme adresi."

#: src/ch16-05-02-randomness.md:82
msgid "`request_id`: A unique identifier assigned to the randomness request."
msgstr "request_id: Rastgelelik isteğine atanan benzersiz bir tanımlayıcı."

#: src/ch16-05-02-randomness.md:83
msgid ""
"`random_words`:  An array (span) of the generated random values (represented "
"as `felt252`)."
msgstr ""
"random_words: Oluşturulan rastgele değerlerin bir dizisi (span) (felt252 "
"olarak temsil edilir)."

#: src/ch16-05-02-randomness.md:84
msgid ""
"`calldata`:  Additional data passed along with the initial randomness "
"request."
msgstr "calldata: İlk rastgelelik isteği ile birlikte aktarılan ek veriler."

#: src/ch16-05-02-randomness.md:86
msgid "Dice Game Contract"
msgstr "Zar Oyun Sözleşmesi"

#: src/ch16-05-02-randomness.md:88
msgid ""
"This dice game contract allows players to guess a number between 1 & 6 "
"during an active game window. The contract owner then has the ability to "
"toggle the game window to disable new guesses from players. To determine the "
"winning number, the contract owner calls the "
"`request_randomness_from_pragma` function to request a random number from "
"the Pragma VRF oracle. Once the random number is received through the "
"`receive_random_words` callback function, it is stored in the "
"`last_random_number` storage variable. Each player has to call "
"`process_game_winners` function to determine if they have won or lost. The "
"`last_random_number` generated is then reduced to a number between 1 & 6, "
"and compared to the guesses of the players stored in the `user_guesses` "
"mapping, which leads to the emission of an event `GameWinner` or `GameLost`."
msgstr ""
"Bu zar oyun sözleşmesi, oyuncuların etkin bir oyun penceresi sırasında 1 ve "
"6 arasında bir sayı tahmin etmelerini sağlar. Sözleşme sahibi daha sonra "
"oyunculardan yeni tahminleri devre dışı bırakmak için oyun penceresini "
"değiştirme yeteneğine sahiptir. Kazanan sayıyı belirlemek için, sözleşme "
"sahibi, Pragma VRF kahininden rastgele bir sayı istemek için "
"request_randomness_from_pragma fonksiyonunu çağırır. Rastgele sayı "
"receive_random aracılığıyla alındığında"

#: src/ch16-05-02-randomness.md:223
msgid ""
"// Approve the randomness contract to transfer the callback fee\n"
"            // You would need to send some ETH to this contract first to "
"cover the fees\n"
msgstr ""
"// Geri çağırma ücretini aktarmak için rasgele sözleşmeyi onaylayın // "
"Ücretleri karşılamak için önce bu sözleşmeye biraz ETH göndermeniz gerekir\n"

#: src/ch16-05-02-randomness.md:236
msgid "// Request the randomness\n"
msgstr "// Rastgelelik isteği\n"

#: src/ch16-05-02-randomness.md:253
msgid ""
"// Have to make sure that the caller is the Pragma Randomness Oracle "
"contract\n"
msgstr ""
"// Arayanın Pragma Randomness Oracle sözleşmesi olduğundan emin olun.\n"

#: src/ch16-05-02-randomness.md:259
msgid ""
"// and that the current block is within publish_delay of the request block\n"
msgstr "// ve mevcut bloğun istek bloğunun yayın_ gecikmesi içinde olduğunu\n"

#: src/ch16-05-02-randomness.md:273
msgid "// ETH Contract Address            \n"
msgstr "// ETH Sözleşme Adresi\n"

#: src/ch16-05-02-randomness.md:282
msgid ""
"<span class=\"caption\">Listing 16-6: Simple Dice Game Contract using Pragma "
"VRF.</span>"
msgstr ""
"span class=\"caption\">Listing 16-6: Pragma VRF kullanarak Basit Zar Oyun "
"Sözleşmesi./span>"

#: src/ch16-05-02-randomness.md:284
msgid "NB: Fund Your Contract After Deployment to Utilize Pragma VRF"
msgstr "NB: Pragma VRF'yi Kullanmak İçin Dağıtım Sonrası Sözleşmenizi Fonlayın"

#: src/ch16-05-02-randomness.md:286
msgid ""
"After deploying your contract that includes Pragma VRF functionalities, "
"ensure it holds sufficient ETH to cover the expenses related to requesting "
"random values. Pragma VRF requires payment for both generating the random "
"numbers and executing the callback function defined in your contract."
msgstr ""
"Pragma VRF işlevlerini içeren sözleşmenizi dağıttıktan sonra, rastgele "
"değerler istemekle ilgili masrafları karşılamak için yeterli ETH tuttuğundan "
"emin olun. Pragma VRF, hem rastgele sayıları oluşturmak hem de sözleşmenizde "
"tanımlanan geri arama işlevini yürütmek için ödeme gerektirir."

#: src/ch16-05-02-randomness.md:288
msgid ""
"For more information, please refer to the [Pragma](https://docs.pragma.build/"
"Resources/Cairo%201/randomness/randomness) docs."
msgstr ""
"Daha fazla bilgi için lütfen [Pragma](https://docs.pragma.build/Resources/"
"Cairo%201/randomness/randomness] belgelerine bakınız."

#: src/ch16-06-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, "
"utilizing various features of the Cairo programming language. Your "
"contributions are welcome and encouraged, as we aim to gather as many "
"diverse examples as possible."
msgstr ""
"Bu bölüm, Kahire programlama dilinin çeşitli özelliklerini kullanarak "
"Starknet akıllı sözleşmelerinin ek örneklerini içerir. Katkılarınız "
"memnuniyetle karşılanır ve teşvik edilir, çünkü mümkün olduğunca çok sayıda "
"farklı örnek toplamayı amaçlıyoruz."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:1
msgid "Deploying and Interacting with a Voting contract"
msgstr "Oylama sözleşmesi ile dağıtım ve etkileşim"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the "
"contract's constructor. Three voters are initialized at this stage, and "
"their addresses are passed to an internal function **`_register_voters`**. "
"This function adds the voters to the contract's state, marking them as "
"registered and eligible to vote."
msgstr ""
"Starknet'teki **Vote** sözleşmesi, sözleşmenin yapıcısı aracılığıyla "
"seçmenlerin kaydedilmesiyle başlar. Bu aşamada üç seçmen başlatılır ve "
"adresleri bir iç işleve geçer **_register_voters**. Bu işlev, seçmenleri "
"sözleşmenin durumuna ekler ve bunları kayıtlı ve oy kullanmaya uygun olarak "
"işaretler."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to "
"represent the voting options (1 and 0, respectively). These constants "
"facilitate the voting process by standardizing the input values."
msgstr ""
"Sözleşme içinde, sabitler **YES** ve **NO** sırasıyla oylama seçeneklerini "
"(1 ve 0) temsil edecek şekilde tanımlanır. Bu sabitler, giriş değerlerini "
"standartlaştırarak oylama sürecini kolaylaştırır."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** "
"function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting, "
"the state of the contract is updated, recording the vote and marking the "
"voter as having voted. This ensures that the voter is not able to cast a "
"vote again within the same proposal. The casting of a vote triggers the "
"**`VoteCast`** event, logging the action."
msgstr ""
"Kayıt olduktan sonra, bir seçmen **vote** işlevini kullanarak oy "
"kullanabilir, 1 (YES) veya 0 (NO) oylarını seçebilir. Oy kullanırken, "
"sözleşmenin durumu güncellenir, oy kaydedilir ve seçmen oy kullanmış olarak "
"işaretlenir. Bu, seçmenin aynı öneri dahilinde tekrar oy kullanamamasını "
"sağlar. Bir oylamanın yapılması, **voteCast eylemini tetikler."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized "
"action is detected, such as a non-registered user attempting to vote or a "
"user trying to vote again, the **`UnauthorizedAttempt`** event is emitted."
msgstr ""
"Sözleşme ayrıca yetkisiz oy verme girişimlerini de izler. Kayıt dışı bir "
"kullanıcının oy kullanmaya çalışması veya tekrar oy vermeye çalışan bir "
"kullanıcı gibi yetkisiz bir eylem tespit edilirse, **  İzinsizAttempt** "
"olayı yayılır."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured "
"voting system, managing the lifecycle of a vote from registration to "
"casting, event logging, and result retrieval within the Starknet "
"environment. Constants like **`YES`** and **`NO`** help streamline the "
"voting process, while events play a vital role in ensuring transparency and "
"traceability."
msgstr ""
"Birlikte, bu işlevler, durumlar, sabitler ve olaylar, Starknet ortamında "
"kayıttan döküme, etkinlik kaydına ve sonuç alımına kadar bir oylamanın yaşam "
"döngüsünü yöneten yapılandırılmış bir oylama sistemi oluşturur. **YES** ve "
"**NO** gibi sabitler oylama sürecini düzene sokmaya yardımcı olurken, "
"etkinlikler şeffaflık ve izlenebilirliğin sağlanmasında hayati bir rol oynar."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:13
msgid "Listing 16-7 shows the `Vote` contract in detail:"
msgstr "16-7'nin listelenmesi, Vote sözleşmesini ayrıntılı olarak gösterir:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:16
msgid ""
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
msgstr ""
"/// @dev Çekirdek Kitaplığı Starknet Sözleşmesinin Dışındaki Traits İçin "
"İthalat\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:18
msgid ""
"/// @dev Trait defining the functions that can be implemented or called by "
"the Starknet Contract\n"
msgstr ""
"/// @dev Trait Starknet Sözleşmesi tarafından uygulanabilecek veya "
"çağrılabilecek fonksiyonları tanımlar\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:22
msgid "/// @dev Function that returns the current vote status\n"
msgstr "/// @dev Geçerli oy durumunu döndüren fonksiyon\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:24
msgid ""
"/// @dev Function that checks if the user at the specified address is "
"allowed to vote\n"
msgstr ""
"/// @dev Belirtilen adresteki kullanıcının oy kullanmasına izin verilip "
"verilmediğini kontrol eden fonksiyon\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:26
msgid ""
"/// @dev Function that checks if the specified address is registered as a "
"voter\n"
msgstr ""
"/// @dev Belirtilen adresin seçmen olarak kayıtlı olup olmadığını kontrol "
"eden fonksiyon\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:28
msgid "/// @dev Function that allows a user to vote\n"
msgstr "/// @dev Bir kullanıcının oy kullanmasına izin veren fonksiyon\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:31
msgid ""
"/// @dev Starknet Contract allowing three registered voters to vote on a "
"proposal\n"
msgstr ""
"/// @dev Starknet Sözleşmesi, üç kayıtlı seçmenin bir öneride oy "
"kullanmasına izin veriyor\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:41
msgid "/// @dev Structure that stores vote counts and voter states\n"
msgstr "/// @dev Oy sayımlarını ve seçmen durumlarını depolayan yapı\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:50
msgid ""
"/// @dev Contract constructor initializing the contract with a list of "
"registered voters and 0 vote count\n"
msgstr ""
"/// @dev Sözleşme yapıcısı, sözleşmeyi kayıtlı seçmenler listesi ve 0 oy "
"sayımı ile başlatıyor\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:58
msgid "// Register all voters by calling the _register_voters function\n"
msgstr "// Tüm seçmenleri _register_voters işlevini arayarak kaydedin\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:61
msgid "// Initialize the vote count to 0\n"
msgstr "// Oy sayımını 0'a başlat\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:66
msgid "/// @dev Event that gets emitted when a vote is cast\n"
msgstr "/// @dev Bir oylama yapıldığında yayılan olay\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:74
msgid "/// @dev Represents a vote that was cast\n"
msgstr "/// @dev Atılan bir oylamayı temsil eder\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:81
msgid "/// @dev Represents an unauthorized attempt to vote\n"
msgstr "/// @dev Yetkisiz oy verme girişimini temsil eder\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:87
msgid "/// @dev Implementation of VoteTrait for ContractState\n"
msgstr "/// @dev ContractState için VoteTrait Uygulaması\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:90
msgid "/// @dev Returns the voting results\n"
msgstr "/// @dev Oylama sonuçlarını döndürür\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:97
msgid "/// @dev Check whether a voter is allowed to vote\n"
msgstr ""
"/// @dev Bir seçmenin oy kullanmasına izin verilip verilmediğini kontrol "
"edin\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:102
msgid "/// @dev Check whether an address is registered as a voter\n"
msgstr ""
"/// @dev Bir adresin seçmen olarak kayıtlı olup olmadığını kontrol edin\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:107
msgid "/// @dev Submit a vote\n"
msgstr "/// @dev Bir oy gönder\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:109
msgid "\"VOTE_0_OR_1\""
msgstr "\"VOTE_0_OR_1\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:125
msgid "/// @dev Internal Functions implementation for the Vote contract\n"
msgstr "/// @dev Oy sözleşmesi için İç Fonksiyonlar uygulaması\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:128
msgid ""
"/// @dev Registers the voters and initializes their voting status to true "
"(can vote)\n"
msgstr ""
"/// @dev Seçmenleri kaydeder ve oy durumlarını doğru olarak başlatır (oy "
"kullanabilir)\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:146
msgid "/// @dev Asserts implementation for the Vote contract\n"
msgstr "/// Oy sözleşmesi için @dev Asserts uygulaması\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:149
msgid ""
"// @dev Internal function that checks if an address is allowed to vote\n"
msgstr ""
"// @dev Bir adresin oy kullanmasına izin verilip verilmediğini kontrol eden "
"dahili işlev\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:158
msgid "\"USER_NOT_REGISTERED\""
msgstr "\"USER_NOT_REGISTERED\" (İngilizce)."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:159
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:440
msgid "\"USER_ALREADY_VOTED\""
msgstr "\"USER_ALREADY_VOTED\" (İngilizce)."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:163
msgid "/// @dev Implement the VotingResultTrait for the Vote contract\n"
msgstr "/// @dev Oylama Sözleşmesi için Oy VermeResultTrait Uygulaması\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:166
msgid ""
"// @dev Internal function to get the voting results (yes and no vote "
"counts)\n"
msgstr ""
"// @dev Oylama sonuçlarını almak için iç fonksiyon (evet ve hayır oy "
"sayımı)\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:174
msgid ""
"// @dev Internal function to calculate the voting results in percentage\n"
msgstr "// @dev Oylama sonuçlarını yüzde olarak hesaplamak için iç fonksiyon\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:192
msgid "<span class=\"caption\">Listing 16-7: A voting smart contract</span>"
msgstr "span class=\"caption\">Liste 16-7: Oy veren akıllı sözleşme/span>"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:194
msgid "Deploying, Calling and Invoking the Voting Contract"
msgstr "Oy Sözleşmesinin Dağıtılması, Çağrılması ve Davet Edilmesi"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:196
msgid ""
"Part of the Starknet experience is deploying and interacting with smart "
"contracts."
msgstr ""
"Starknet deneyiminin bir kısmı akıllı sözleşmeleri dağıtmak ve etkileşim "
"kurmaktır."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:198
msgid ""
"Once the contract is deployed, we can interact with it by calling and "
"invoking its functions:"
msgstr ""
"Sözleşme dağıtıldıktan sonra, işlevlerini çağırarak ve çağırarak onunla "
"etkileşime geçebiliriz:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:200
msgid ""
"Calling contracts: Interacting with external functions that only read from "
"the state. These functions do not alter the state of the network, so they "
"don't require fees or signing."
msgstr ""
"Sözleşmeleri çağırmak: Sadece eyaletten okuyan harici işlevlerle etkileşim "
"kurmak. Bu işlevler ağın durumunu değiştirmez, bu nedenle ücret veya imza "
"gerektirmezler."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:201
msgid ""
"Invoking contracts: Interacting with external functions that can write to "
"the state. These functions do alter the state of the network and require "
"fees and signing."
msgstr ""
"Sözleşmeleri çağırmak: Devlete yazabilecek harici işlevlerle etkileşime "
"girmek. Bu işlevler ağın durumunu değiştirir ve ücret ve imza gerektirir."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:203
msgid ""
"We will setup a local development node using `katana` to deploy the voting "
"contract. Then, we'll interact with the contract by calling and invoking its "
"functions. You can also use the Goerli Testnet instead of `katana`. However, "
"we recommend using `katana` for local development and testing. You can find "
"the complete tutorial for `katana` in the [\"Katana: A Local Node\"](https://"
"book.starknet.io/ch02-04-katana.html) chapter of the Starknet Book."
msgstr ""
"Oylama sözleşmesini dağıtmak için katana'ı kullanarak yerel bir geliştirme "
"düğümü kuracağız. Daha sonra, işlevlerini arayarak ve çağırarak sözleşmeyle "
"etkileşime gireceğiz. Ayrıca katana yerine Goerli Testnet'i de "
"kullanabilirsiniz. Bununla birlikte, yerel geliştirme ve test için katana "
"kullanmanızı tavsiye ederiz. katana için eksiksiz öğreticiyi [\"Katana: A "
"Local Node\" bölümünde bulabilirsiniz."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:207
msgid "The `katana` Local Starknet Node"
msgstr "katana Yerel Starknet Düğümü"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:209
msgid ""
"`katana` is designed to support local development by the [Dojo team](https://"
"github.com/dojoengine/dojo/blob/main/crates/katana). It will allow you to do "
"everything you need to do with Starknet, but locally. It is a great tool for "
"development and testing."
msgstr ""
"katana [Dojo ekibi] tarafından yerel gelişimi desteklemek için "
"tasarlanmıştır(https://github.com/dojo/dojo/blob/main/crates/katana). "
"Starknet ile yapmanız gereken her şeyi yapmanıza izin verecektir, ancak "
"yerel olarak. Geliştirme ve test için harika bir araçtır."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:211
msgid ""
"To install `katana` from the source code, please refer to the [\"Basic "
"Installation\"](https://book.starknet.io/ch02-01-basic-installation."
"html#katana-node-installation) chapter of the Starknet Book."
msgstr ""
"katana'yı kaynak koddan yüklemek için Starknet Kitabı'nın [\"Temel "
"Kurulum\"] [https://book.starknet.io/ch02-01-basic-installation.html#katana-"
"node-installation] bölümüne bakınız."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:213
msgid ""
"Note: Please verify that the version of `katana` match the specified version "
"provided below."
msgstr ""
"Not: Lütfen katana sürümünün aşağıda belirtilen sürümle eşleştiğini "
"doğrulayın."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:220
msgid ""
"To upgrade `katana` version, refer to the [\"Basic Installation\"](https://"
"book.starknet.io/ch02-01-basic-installation.html#katana-node-installation) "
"chapter of the Starknet Book."
msgstr ""
"katana sürümünü yükseltmek için Starknet Kitabı'nın [\"Temel Kurulum\"] "
"[https://book.starknet.io/ch02-01-basic-installation.html#katana-node-"
"installation] bölümüne bakın."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:222
msgid ""
"Once you have `katana` installed, you can start the local Starknet node with:"
msgstr ""
"katana yükledikten sonra, yerel Starknet düğümünü şu şekilde "
"başlatabilirsiniz:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:228
msgid ""
"This command will start a local Starknet node with 3 deployed accounts. We "
"will use these accounts to deploy and interact with the voting contract:"
msgstr ""
"Bu komut, 3 konuşlandırılmış hesaba sahip yerel bir Starknet düğümü "
"başlatacaktır. Bu hesapları oy sözleşmesini dağıtmak ve etkileşimde bulunmak "
"için kullanacağız:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:233
msgid "================="
msgstr "=========="

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:249
msgid ""
"Before we can interact with the voting contract, we need to prepare the "
"voter and admin accounts on Starknet. Each voter account must be registered "
"and sufficiently funded for voting. For a more detailed understanding of how "
"accounts operate with Account Abstraction, refer to the [\"Account "
"Abstraction\"](https://book.starknet.io/ch04-00-account-abstraction.html) "
"chapter of the Starknet Book."
msgstr ""
"Oylama sözleşmesiyle etkileşime girmeden önce, Starknet'teki seçmen ve "
"yönetici hesaplarını hazırlamamız gerekir. Her seçmen hesabı kayıtlı olmalı "
"ve oylama için yeterince finanse edilmelidir. Hesapların Hesap Özeti ile "
"nasıl çalıştığını daha ayrıntılı anlamak için, Starknet Kitabı'nın [https://"
"book.starknet.io/ch04-00-account-abstraction.html] bölümüne bakın."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:255
msgid "Smart Wallets for Voting"
msgstr "Oylama için Akıllı Cüzdanlar"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:257
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a "
"command line tool that allows you to interact with Starknet. You can find "
"the installation instructions in the \\[\"Basic Installation\"\\]\\[starkli "
"installation\\] chapter of the Starknet Book."
msgstr ""
"Scarb'ın yanı sıra Starkli'nin yüklü olması gerekir. Starkli, Starknet ile "
"etkileşime girmenizi sağlayan bir komut satırı aracıdır. Kurulum "
"talimatlarını Starknet Kitabı'nın [\"Temel Kurulum\"][starkli kurulum] "
"bölümünde bulabilirsiniz."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:259
msgid ""
"Note: Please verify that the version of `starkli` match the specified "
"version provided below."
msgstr ""
"Not: Lütfen starkli sürümünün aşağıda belirtilen sürümle eşleştiğini "
"doğrulayın."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:266
msgid ""
"To upgrade `starkli` to `0.2.9`, use the `starkliup -v 0.2.9` command, or "
"simply `starkliup` which installed the latest stable version."
msgstr ""
"starkli'i 0.2.9'ye yükseltmek için, starkliup -v 0.2.9 komutunu veya en son "
"kararlı sürümü yükleyen starkliup'u kullanın."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:268
msgid ""
"For each smart wallet we'll use, we must create a Signer within the "
"encrypted keystore and an Account Descriptor. This process is also detailed "
"in the \\[\"Testnet Deployment\"\\]\\[signer creation\\] chapter of the "
"Starknet Book."
msgstr ""
"Kullanacağımız her akıllı cüzdan için şifreli anahtar deposunda bir Signer "
"ve bir Hesap Tanımlayıcısı oluşturmalıyız. Bu işlem Starknet Kitabının "
"[\"Testnet Dağıtımı\"][signer creation] bölümünde de detaylandırılmıştır."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:270
msgid ""
"We can create Signers and Account Descriptors for the accounts we want to "
"use for voting. Let's create a smart wallet for voting in our smart contract."
msgstr ""
"Oy vermek için kullanmak istediğimiz hesaplar için Signers ve Account "
"Descriptors oluşturabiliriz. Akıllı sözleşmemizde oy kullanmak için akıllı "
"bir cüzdan oluşturalım."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:272
msgid "Firstly, we create a signer from a private key:"
msgstr "Öncelikle, özel bir anahtardan bir imzacı oluşturuyoruz:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:278
msgid ""
"Then, we create the Account Descriptor by fetching the katana account we "
"want to use:"
msgstr ""
"Ardından, kullanmak istediğimiz katana hesabını getirerek Hesap "
"Tanımlayıcıyı oluşturuyoruz:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:284
msgid ""
"This command will create a new `account0_account.json` file containing the "
"following details:"
msgstr ""
"Bu komut, aşağıdaki ayrıntıları içeren yeni bir account0_account.json "
"dosyası oluşturacaktır:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:288
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:291
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:401
msgid "\"version\""
msgstr "\"sürüm\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:289
msgid "\"variant\""
msgstr "\"değişken\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:290
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:407
msgid "\"type\""
msgstr "\"tip\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:290
msgid "\"open_zeppelin\""
msgstr "\"open_zeppelin\" (İngilizce)."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:292
msgid "\"public_key\""
msgstr "\"public_key\" (İngilizce)."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:292
msgid "\"<SMART_WALLET_PUBLIC_KEY>\""
msgstr "\"SMART_WALLET_PUBLIC_KEY>\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:294
msgid "\"deployment\""
msgstr "\"Deployment\" (İngilizce)."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:295
msgid "\"status\""
msgstr "\"status\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:295
msgid "\"deployed\""
msgstr "\"işgal edildi\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:296
msgid "\"class_hash\""
msgstr "\"Sınıf_hash\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:296
msgid "\"<SMART_WALLET_CLASS_HASH>\""
msgstr "\"SMART_WALLET_CLASS_HASH>\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:297
msgid "\"address\""
msgstr "\"adres\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:297
msgid "\"<SMART_WALLET_ADDRESS>\""
msgstr "\"SMART_WALLET_ADDRESS>\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:302
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all "
"your smart wallets) with the following command. Notice the use of the `--"
"rpc` flag and the RPC endpoint provided by `katana`:"
msgstr ""
"Akıllı cüzdan sınıfı hash'i (tüm akıllı cüzdanlarınız için aynı olacaktır) "
"aşağıdaki komutla alabilirsiniz. --rpc bayrağının ve katana tarafından "
"sağlanan RPC uç noktasının kullanımına dikkat edin:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:304
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr "starkli class-hash-at SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:308
msgid ""
"For the public key, you can use the `starkli signer keystore inspect` "
"command with the directory of the keystore json file:"
msgstr ""
"Genel anahtar için starkli imzalayıcı anahtar deposu teftiş komutunu anahtar "
"deposu json dosyasının dizini ile kullanabilirsiniz:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:314
msgid ""
"This process is identical for `account_1` and `account_2` in case you want "
"to have a second and a third voter."
msgstr ""
"Bu işlem account_1 ve account_2 için aynıdır, eğer ikinci ve üçüncü bir "
"seçmene sahip olmak istiyorsanız."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:316
msgid ""
"\\[starkli installation\\]: https://book.starknet.io/ch02-01-basic-"
"installation.html#starkli-installation) \\[signer creation\\]: https://book."
"starknet.io/ch02-05-testnet-deployment.html?highlight=signer#creating-a-"
"signer"
msgstr ""
"[starkli enstalasyon]: https://book.starknet.io/ch02-01-basic-installation."
"html#starkli-installation] [signer creation]: https://book.starknet.io/"
"ch02-05-testnet-deployment.html?highlight=signer#creating-a-signer"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:319
msgid "Contract Deployment"
msgstr "Sözleşme Dağıtımı"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:321
msgid ""
"Before deploying, we need to declare the contract. We can do this with the "
"`starkli declare` command:"
msgstr ""
"Göreve başlamadan önce sözleşmeyi ilan etmeliyiz. Bunu starkli deklarasyonu "
"komutuyla yapabiliriz:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:327
msgid ""
"If the compiler version you're using is older than the one used by Starkli "
"and you encounter a `compiler-version` error while using the command above, "
"you can specify a compiler version to use in the command by adding the `--"
"compiler-version x.y.z` flag."
msgstr ""
"Kullandığınız derleyici sürümü Starkli tarafından kullanılandan daha eskiyse "
"ve yukarıdaki komutu kullanırken bir  compiler-version hatasıyla "
"karşılaşırsanız, komutta kullanılacak bir derleyici sürümünü --compiler-"
"version x.y.z bayrağını ekleyerek belirtebilirsiniz."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:329
msgid ""
"If you're still encountering issues with the compiler version, try upgrading "
"Starkli using the command: `starkliup` to make sure you're using the latest "
"version of starkli."
msgstr ""
"Derleyici sürümüyle ilgili sorunlarla hala karşılaşıyorsanız, Starkli'nin en "
"son sürümünü kullandığınızdan emin olmak için starkliup komutunu kullanarak "
"Starkli'yi yükseltmeyi deneyin."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:331
msgid ""
"The class hash of the contract is: "
"`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You "
"can declare this contract on Sepolia testnet and see that the class hash "
"will correspond."
msgstr ""
"Sözleşmenin sınıf hash'i: "
"0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52'dir. Bu "
"sözleşmeyi Sepolia testnet'te beyan edebilir ve sınıf hash'inin karşılık "
"geleceğini görebilirsiniz."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:333
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by "
"`katana`). The `--account` flag specifies the account to use for signing the "
"transaction. The account we use here is the one we created in the previous "
"step. The `--keystore` flag specifies the keystore file to use for signing "
"the transaction."
msgstr ""
"--rpc bayrağı, RPC uç noktasını kullanır (katana tarafından sağlanan). --"
"account bayrağı, işlemi imzalamak için kullanılacak hesabı belirtir. Burada "
"kullandığımız hesap, bir önceki adımda oluşturduğumuz hesaptır. --keystore "
"bayrağı, işlemi imzalamak için kullanılacak anahtar deposu dosyasını "
"belirtir."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:335
msgid ""
"Since we are using a local node, the transaction will achieve finality "
"immediately. If you are using the Goerli Testnet, you will need to wait for "
"the transaction to be final, which usually takes a few seconds."
msgstr ""
"Yerel bir düğüm kullandığımızdan, işlem hemen kesinliğe ulaşır. Goerli "
"Testnet'i kullanıyorsanız, işlemin nihai olmasını beklemeniz gerekir, bu "
"genellikle birkaç saniye sürer."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:337
msgid ""
"The following command deploys the voting contract and registers voter_0, "
"voter_1, and voter_2 as eligible voters. These are the constructor "
"arguments, so add a voter account that you can later vote with."
msgstr ""
"Aşağıdaki komut oylama sözleşmesini dağıtır ve seçmen_0, seçmen_1 ve "
"seçmen_2'yi uygun seçmenler olarak kaydeder. Bunlar kurucu argümanlardır, bu "
"nedenle daha sonra oy kullanabileceğiniz bir seçmen hesabı ekleyin."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:343
msgid "An example command:"
msgstr "Örnek bir komut:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:349
msgid ""
"In this case, the contract has been deployed at an specific address: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This "
"address will be different for you. We will use this address to interact with "
"the contract."
msgstr ""
"Bu durumda, sözleşme belirli bir adreste konuşlandırılmıştır: "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349. Bu adres "
"sizin için farklı olacaktır. Bu adresi sözleşme ile etkileşimde bulunmak "
"için kullanacağız."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:351
msgid "Voter Eligibility Verification"
msgstr "Seçmen Uygunluk Doğrulaması"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:353
msgid ""
"In our voting contract, we have two functions to validate voter eligibility, "
"`voter_can_vote` and `is_voter_registered`. These are external read "
"functions, which mean they don't alter the state of the contract but only "
"read the current state."
msgstr ""
"Oylama sözleşmemizde, seçmen uygunluğunu doğrulamak için iki işlevimiz var, "
"voter_can_vote ve is_voter_registered. Bunlar dış okuma işlevleridir, yani "
"sözleşmenin durumunu değiştirmezler, sadece mevcut durumu okurlar."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:355
msgid ""
"The `is_voter_registered` function checks whether a particular address is "
"registered as an eligible voter in the contract. The `voter_can_vote` "
"function, on the other hand, checks whether the voter at a specific address "
"is currently eligible to vote, i.e., they are registered and haven't voted "
"already."
msgstr ""
"is_voter_registered işlevi, belirli bir adresin sözleşmede uygun bir seçmen "
"olarak kayıtlı olup olmadığını kontrol eder. Öte yandan, voter_can_vote "
"işlevi, belirli bir adresteki seçmenin şu anda oy kullanmaya uygun olup "
"olmadığını, yani kayıtlı olup olmadıklarını ve daha önce oy vermediklerini "
"kontrol eder."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:357
msgid ""
"You can call these functions using the `starkli call` command. Note that the "
"`call` command is used for read functions, while the `invoke` command is "
"used for functions that can also write to storage. The `call` command does "
"not require signing, while the `invoke` command does."
msgstr ""
"Bu işlevleri starkli call komutunu kullanarak arayabilirsiniz. call komutu "
"okuma işlevleri için kullanılırken, invoke komutu depolamaya da yazabilen "
"işlevler için kullanılır. call komutu imzalama gerektirmez, invoke komutu "
"bunu yaparken."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:359
msgid ""
"```bash+\n"
"starkli call "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 "
"voter_can_vote "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc "
"http://0.0.0.0:5050\n"
"```"
msgstr ""
"bash+ starkli call "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 "
"seçmen_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a1dbb197480a63d71b"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:363
msgid ""
"First we added the address of the contract, then the function we want to "
"call, and finally the input for the function. In this case, we are checking "
"whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can "
"vote."
msgstr ""
"Önce sözleşmenin adresini, daha sonra aramak istediğimiz işlevi ve son "
"olarak fonksiyonun girdisini ekledik. Bu durumda, "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 "
"adresindeki seçmenin oy kullanıp kullanmadığını kontrol ediyoruz."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:365
msgid ""
"Since we provided a registered voter address as an input, the result is 1 "
"(boolean true), indicating the voter is eligible to vote."
msgstr ""
"Girdi olarak kayıtlı bir seçmen adresi sağladığımızdan, sonuç 1 (boolean "
"true), seçmenin oy kullanmaya uygun olduğunu gösterir."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:367
msgid ""
"Next, let's call the `is_voter_registered` function using an unregistered "
"account address to observe the output:"
msgstr ""
"Ardından, çıktıyı gözlemlemek için is_voter_registered fonksiyonunu kayıtsız "
"bir hesap adresi kullanarak çağıralım:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:373
msgid ""
"With an unregistered account address, the terminal output is 0 (i.e., "
"false), confirming that the account is not eligible to vote."
msgstr ""
"Kayıtsız bir hesap adresi ile, terminal çıktısı 0 (yani yanlış), hesabın oy "
"vermeye uygun olmadığını onaylar."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:375
msgid "Casting a Vote"
msgstr "Oy Vermek"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:377
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! "
"To vote, we interact with the `vote` function, which is flagged as external, "
"necessitating the use of the `starknet invoke` command."
msgstr ""
"Artık seçmen uygunluğunun nasıl doğrulanacağını belirlediğimize göre, oy "
"verebiliriz! Oy vermek için, starknet çağrısı komutunun kullanımını zorunlu "
"kılan dışsal olarak işaretlenen vote fonksiyonu ile etkileşimde bulunuyoruz."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:379
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we "
"submit either `1` (for Yes) or `0` (for No) as our input. When we invoke the "
"`vote` function, we are charged a fee, and the transaction must be signed by "
"the voter; we are writing to the contract's storage."
msgstr ""
"invoke komut sözdizimi call komutunu andırır, ancak oylama için, girdimiz "
"olarak 1 (Evet için) veya 0 (Hayır için) göndeririz. vote işlevini "
"çağırdığımızda, bir ücret alınır ve işlem seçmen tarafından imzalanmalıdır; "
"sözleşmenin deposuna yazıyoruz."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:389
msgid ""
"You will be prompted to enter the password for the signer. Once you enter "
"the password, the transaction will be signed and submitted to the Starknet "
"network. You will receive the transaction hash as output. With the starkli "
"transaction command, you can get more details about the transaction:"
msgstr ""
"İmzalayan kişinin şifresini girmeniz istenecektir. Şifreyi girdikten sonra "
"işlem imzalanacak ve Starknet ağına gönderilecektir. İşlem hash'ini çıktı "
"olarak alacaksınız. Starkli işlem komutu ile işlem hakkında daha fazla bilgi "
"alabilirsiniz:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:395
msgid "This returns:"
msgstr "Bu döner:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:399
msgid "\"transaction_hash\""
msgstr "\"transaction_hash\" (İngilizce)."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:399
msgid "\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""
msgstr "\"0x5604a9792b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:400
msgid "\"max_fee\""
msgstr "\"max_fee\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:400
msgid "\"0x430e81\""
msgstr "\"0x430e81\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:401
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:410
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:414
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:415
#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:416
msgid "\"0x1\""
msgstr "\"0x1\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:402
msgid "\"signature\""
msgstr "\"imza\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:403
msgid "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\""
msgstr "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72ffefa64bb6c306c314496e6e402d57\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:404
msgid "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""
msgstr "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:406
msgid "\"nonce\""
msgstr "\"Saçmalama\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:406
msgid "\"0x3\""
msgstr "\"0x3\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:407
msgid "\"INVOKE\""
msgstr "\"İNVOKE\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:408
msgid "\"sender_address\""
msgstr "\"sender_adres\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:408
msgid "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""
msgstr "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:409
msgid "\"calldata\""
msgstr "\"calldata\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:411
msgid "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""
msgstr "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:412
msgid "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""
msgstr "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:413
msgid "\"0x0\""
msgstr "\"0x0\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:421
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr ""
"Aynı imzalayıcı ile iki kez oy vermeye çalışırsanız bir hata alırsınız:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:424
msgid "\"Contract error\""
msgstr "\"Tartışma hatası\""

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:427
msgid ""
"The error is not very informative, but you can get more details when looking "
"at the output in the terminal where you started `katana` (our local Starknet "
"node):"
msgstr ""
"Hata çok bilgilendirici değildir, ancak katana (yerel Starknet düğümümüz) "
"başlattığınız terminaldeki çıktıya bakarken daha fazla ayrıntı alabilirsiniz:"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:431
msgid ""
"\"Error in the called contract "
"(0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution "
"failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
msgstr ""
"\"Söz konusu sözleşmede hata "
"(0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0): PC'de "
"hata=0d71cbd76652e0: Bir ipucu çalıştırırken bir istisna var: Özel İpucu "
"Hatası: Yürütme başarısız oldu. Arıza nedeni:  \"USER_ALREADY_VOTED\".\n"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:437
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr "Hatanın anahtarı USER_ALREADY_VOTED'dir."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:443
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the "
"accounts we want to use for voting. Remember that each Signer must be "
"created from a private key, and each Account Descriptor must be created from "
"a public key, a smart wallet address, and the smart wallet class hash (which "
"is the same for each voter)."
msgstr ""
"Oy vermek için kullanmak istediğimiz hesaplar için Signers ve Account "
"Descriptors oluşturmak için işlemi tekrarlayabiliriz. Her Signer'ın özel bir "
"anahtardan oluşturulması gerektiğini ve her Account Descriptor'un açık bir "
"anahtardan, akıllı bir cüzdan adresinden ve akıllı cüzdan sınıfı hash'ten "
"(her seçmen için aynı) oluşturulması gerektiğini unutmayın."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:451
msgid "Visualizing Vote Outcomes"
msgstr "Oy Sonuçlarını Görselleştirme"

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:453
msgid ""
"To examine the voting results, we invoke the `get_vote_status` function, "
"another view function, through the `starknet call` command."
msgstr ""
"Oylama sonuçlarını incelemek için, starknet call komutu aracılığıyla başka "
"bir görünüm fonksiyonu olan get_vote_status işlevini çağırıyoruz."

#: src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:459
msgid ""
"The output reveals the tally of \"Yes\" and \"No\" votes along with their "
"relative percentages."
msgstr ""
"Çıktı, göreli yüzdeleriyle birlikte \"Evet\" ve \"Hayır\" oylarının sayısını "
"ortaya koyuyor."

#: src/ch17-01-general-recommendations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually "
"straightforward. However, preventing unintended usage and vulnerabilities "
"can be more challenging."
msgstr ""
"Yazılım geliştirirken, amaçlandığı gibi çalışmasını sağlamak genellikle "
"basittir. Bununla birlikte, istenmeyen kullanımın ve güvenlik açıklarının "
"önlenmesi daha zor olabilir."

#: src/ch17-01-general-recommendations.md:5
msgid ""
"In smart contract development, security is very important. A single error "
"can result in the loss of valuable assets or the improper functioning of "
"certain features."
msgstr ""
"Akıllı sözleşme geliştirmede güvenlik çok önemlidir. Tek bir hata değerli "
"varlıkların kaybına veya belirli özelliklerin yanlış çalışmasına neden "
"olabilir."

#: src/ch17-01-general-recommendations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can "
"examine the code and interact with it. Any errors or vulnerabilities in the "
"code can be exploited by malicious actors."
msgstr ""
"Akıllı sözleşmeler, herkesin kodu inceleyebileceği ve onunla etkileşime "
"girebileceği bir kamu ortamında yürütülür. Koddaki herhangi bir hata veya "
"güvenlik açıkları kötü niyetli aktörler tarafından istismar edilebilir."

#: src/ch17-01-general-recommendations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart "
"contracts. By incorporating these concepts during development, you can "
"create robust and reliable smart contracts. This reduces the chance of "
"unexpected behavior or vulnerabilities."
msgstr ""
"Bu bölüm, güvenli akıllı sözleşmeler yazmak için genel öneriler sunar. "
"Geliştirme sırasında bu kavramları birleştirerek, sağlam ve güvenilir akıllı "
"sözleşmeler oluşturabilirsiniz. Bu, beklenmedik davranış veya güvenlik "
"açıklarının olasılığını azaltır."

#: src/ch17-01-general-recommendations.md:11
msgid "Disclaimer"
msgstr "Feragatname"

#: src/ch17-01-general-recommendations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security "
"issues, and it does not guarantee that your contracts will be completely "
"secure."
msgstr ""
"Bu bölüm, olası tüm güvenlik sorunlarının kapsamlı bir listesini sağlamaz ve "
"sözleşmelerinizin tamamen güvenli olacağını garanti etmez."

#: src/ch17-01-general-recommendations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly "
"recommended to conduct external audits performed by security experts."
msgstr ""
"Üretim kullanımı için akıllı sözleşmeler geliştiriyorsanız, güvenlik "
"uzmanları tarafından gerçekleştirilen dış denetimlerin yapılması şiddetle "
"tavsiye edilir."

#: src/ch17-01-general-recommendations.md:17
msgid "Mindset"
msgstr "Mindset"

#: src/ch17-01-general-recommendations.md:19
msgid ""
"Cairo is a highly safe language inspired by Rust. It is designed in a way "
"that forces you to cover all possible cases. Security issues on Starknet "
"mostly arise from the way smart contract flows are designed, not much from "
"the language itself."
msgstr ""
"Kahire, Rust'tan ilham alan son derece güvenli bir dildir. Sizi olası tüm "
"vakaları kapsamaya zorlayan bir şekilde tasarlanmıştır. Starknet'teki "
"güvenlik sorunları çoğunlukla akıllı sözleşme akışlarının dilden çok fazla "
"değil, tasarlanma biçiminden kaynaklanmaktadır."

#: src/ch17-01-general-recommendations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart "
"contracts. Try to always consider all possible scenarios when writing code."
msgstr ""
"Güvenlik zihniyetini benimsemek, güvenli akıllı sözleşmeler yazmanın ilk "
"adımıdır. Kod yazarken her zaman olası tüm senaryoları göz önünde "
"bulundurmaya çalışın."

#: src/ch17-01-general-recommendations.md:23
msgid "Viewing Smart Contracts as Finite State Machines"
msgstr "Akıllı Sözleşmeleri Sonlu Devlet Makineleri Olarak Görmek"

#: src/ch17-01-general-recommendations.md:25
msgid ""
"Transactions in smart contracts are atomic, meaning they either succeed or "
"fail without making any changes."
msgstr ""
"Akıllı sözleşmelerdeki işlemler atomiktir, yani herhangi bir değişiklik "
"yapmadan başarılı olurlar veya başarısız olurlar."

#: src/ch17-01-general-recommendations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial "
"states defined by the constructor constraints, and external functions "
"represent a set of possible state transitions. A transaction is nothing more "
"than a state transition."
msgstr ""
"Akıllı sözleşmeleri devlet makineleri olarak düşünün: constructor "
"kısıtlamaları ile tanımlanan bir dizi başlangıç durumu vardır ve harici "
"işlevler bir dizi olası durum geçişini temsil eder. Bir işlem bir devlet "
"geçişinden başka bir şey değildir."

#: src/ch17-01-general-recommendations.md:29
msgid ""
"The `assert!` or `panic!` macros can be used to validate conditions before "
"performing specific actions. You can learn more about these on the "
"[Unrecoverable Errors with panic](./ch09-01-unrecoverable-errors-with-panic."
"md) page."
msgstr ""
"assert! veya panic! makroları, belirli eylemleri gerçekleştirmeden önce "
"koşulları doğrulamak için kullanılabilir. Bunlar hakkında daha fazla bilgiyi "
"[Paniğe sahip kurtarılamaz Hatalar](./ch09-01-unrecoverable-errors-with-"
"panic.md) sayfasından edinebilirsiniz."

#: src/ch17-01-general-recommendations.md:31
msgid "These validations can include:"
msgstr "Bu doğrulamalar şunları içerebilir:"

#: src/ch17-01-general-recommendations.md:33
msgid "Inputs provided by the caller"
msgstr "Arayan tarafından sağlanan girişler"

#: src/ch17-01-general-recommendations.md:34
msgid "Execution requirements"
msgstr "Yürütme gereksinimleri"

#: src/ch17-01-general-recommendations.md:35
msgid "Invariants (conditions that must always be true)"
msgstr "Değişmeyenler (her zaman doğru olması gereken durumlar)"

#: src/ch17-01-general-recommendations.md:36
msgid "Return values from other function calls"
msgstr "Diğer işlev çağrılarından değerleri döndür"

#: src/ch17-01-general-recommendations.md:38
msgid ""
"For example, you could use the `assert!` macro to validate that a user has "
"enough funds to perform a withdraw transaction. If the condition is not met, "
"the transaction will fail and the state of the contract will not change."
msgstr ""
"Örneğin, assert! makrosunu kullanarak, bir kullanıcının geri çekme işlemini "
"gerçekleştirmek için yeterli paraya sahip olduğunu doğrulayabilirsiniz. "
"Durum karşılanmazsa, işlem başarısız olur ve sözleşmenin durumu değişmez."

#: src/ch17-01-general-recommendations.md:45
msgid "\"Insufficient funds\""
msgstr "\"Yetersiz fonlar\""

#: src/ch17-01-general-recommendations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly "
"define the boundaries of possible state transitions for each function in "
"your smart contract. These checks ensure that the behavior of the contract "
"stays within the expected limits."
msgstr ""
"Koşulları kontrol etmek için bu işlevleri kullanmak, akıllı sözleşmenizdeki "
"her bir işlev için olası durum geçişlerinin sınırlarını açıkça tanımlamaya "
"yardımcı olan kısıtlamalar ekler. Bu kontroller, sözleşmenin davranışının "
"beklenen sınırlar içinde kalmasını sağlar."

#: src/ch17-01-general-recommendations.md:53
msgid "Recommendations"
msgstr "Öneriler"

#: src/ch17-01-general-recommendations.md:55
msgid "Checks Effects Interactions Pattern"
msgstr "Kontroller Etkiler Etkileşimler Desen"

#: src/ch17-01-general-recommendations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to "
"prevent reentrancy attacks on Ethereum. While reentrancy is harder to "
"achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""
"Checks Effects Interactions deseni, Ethereum'a yeniden giriş saldırılarını "
"önlemek için kullanılan yaygın bir tasarım desenidir. Starknet'te yeniden "
"giriş yapmak daha zor olsa da, akıllı sözleşmelerinizde bu deseni "
"kullanmanız önerilir."

#: src/ch17-01-general-recommendations.md:61
msgid ""
"The pattern consists of following a specific order of operations in your "
"functions:"
msgstr ""
"Kalıp, işlevlerinizdeki belirli bir işlem sırasını takip etmekten oluşur:"

#: src/ch17-01-general-recommendations.md:63
msgid ""
"**Checks**: Validate all conditions and inputs before performing any state "
"changes."
msgstr ""
"**Kontroller**: Herhangi bir durum değişikliği gerçekleştirmeden önce tüm "
"koşulları ve girdileri doğrulayın."

#: src/ch17-01-general-recommendations.md:64
msgid "**Effects**: Perform all state changes."
msgstr "**Efektler**: Tüm durum değişikliklerini gerçekleştirin."

#: src/ch17-01-general-recommendations.md:65
msgid ""
"**Interactions**: All external calls to other contracts should be made at "
"the end of the function."
msgstr ""
"**İşlemler**: Diğer sözleşmelere yapılan tüm dış aramalar fonksiyonun "
"sonunda yapılmalıdır."

#: src/ch17-01-general-recommendations.md:67
msgid "Access Control"
msgstr "Erişim Kontrolü"

#: src/ch17-01-general-recommendations.md:69
msgid ""
"Access control is the process of restricting access to certain features or "
"resources. It is a common security mechanism used to prevent unauthorized "
"access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""
"Erişim kontrolü, belirli özelliklere veya kaynaklara erişimi kısıtlama "
"işlemidir. Hassas bilgilere veya eylemlere yetkisiz erişimi önlemek için "
"kullanılan yaygın bir güvenlik mekanizmasıdır. Akıllı sözleşmelerde, bazı "
"işlevler genellikle belirli kullanıcılar veya rollerle sınırlandırılabilir."

#: src/ch17-01-general-recommendations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. "
"This pattern consists of defining a set of roles and assigning them to "
"specific users. Each function can then be restricted to specific roles."
msgstr ""
"İzinleri kolayca yönetmek için erişim kontrol modelini uygulayabilirsiniz. "
"Bu kalıp, bir dizi rolü tanımlamak ve belirli kullanıcılara atamaktan "
"oluşur. Her işlev daha sonra belirli rollerle sınırlandırılabilir."

#: src/ch17-01-general-recommendations.md:92
msgid "// Role 'owner': only one address\n"
msgstr "// Rol'sahibi': sadece bir adres\n"

#: src/ch17-01-general-recommendations.md:94
msgid "// Role 'role_a': a set of addresses\n"
msgstr "// Rol 'role_a': bir dizi adres\n"

#: src/ch17-01-general-recommendations.md:103
msgid "// Guard functions to check roles\n"
msgstr "// Rolleri kontrol etmek için Guard fonksiyonları\n"

#: src/ch17-01-general-recommendations.md:118
msgid "\"Not owner\""
msgstr "\"Sahibi değil\""

#: src/ch17-01-general-recommendations.md:123
msgid "\"Not role A\""
msgstr "\"A rolü değil\""

#: src/ch17-01-general-recommendations.md:126
msgid "// You can easily combine guards to perform complex checks\n"
msgstr ""
"// Kolayca karmaşık kontroller yapmak için muhafızları birleştirebilirsiniz\n"

#: src/ch17-01-general-recommendations.md:128
msgid "\"Not allowed\""
msgstr "\"İzin verilmiyor\""

#: src/ch17-01-general-recommendations.md:131
msgid "// Functions to manage roles\n"
msgstr "// Rolleri yönetmek için fonksiyonlar\n"

#: src/ch17-01-general-recommendations.md:138
msgid ""
"// You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
msgstr ""
"// Artık sözleşmenizin iş mantığına odaklanabilirsiniz // ve koruma "
"işlevlerini kullanarak kodunuzun karmaşıklığını azaltabilirsiniz\n"

#: src/ch17-02-testing-smart-contracts.md:3
msgid ""
"Testing smart contracts is a critical part of the development process. It is "
"important to ensure that smart contracts behave as expected and that they "
"are secure."
msgstr ""
"Akıllı sözleşmelerin test edilmesi, geliştirme sürecinin kritik bir "
"parçasıdır. Akıllı sözleşmelerin beklendiği gibi davranmasını ve güvenli "
"olmasını sağlamak önemlidir."

#: src/ch17-02-testing-smart-contracts.md:5
msgid ""
"In a previous section of the Cairo Book, we learned how to write and "
"structure our tests for Cairo programs. We demonstrated how these tests "
"could be run using the `scarb` command-line tool. While this approach is "
"useful for testing standalone Cairo programs and functions, it lacks "
"functionality for testing smart contracts that require control over the "
"contract state and execution context. Therefore, in this section, we will "
"introduce how to use Starknet Foundry, a smart contract development "
"toolchain for Starknet, to test your Cairo contracts."
msgstr ""
"Kahire Kitabı'nın önceki bir bölümünde, Kahire programları için testlerimizi "
"nasıl yazacağımızı ve yapılandıracağımızı öğrendik. Bu testlerin scarb komut "
"satırı aracını kullanarak nasıl yürütülebileceğini gösterdik. Bu yaklaşım "
"bağımsız Kahire programlarını ve işlevlerini test etmek için kullanışlı olsa "
"da, sözleşme durumu ve yürütme bağlamı üzerinde kontrol gerektiren akıllı "
"sözleşmeleri test etmek için işlevsellikten yoksundur. Bu nedenle, bu "
"bölümde, Starknet Foundry, akıllı bir sözleşme geliştirme aracı olarak nasıl "
"kullanılacağını tanıtacağız."

#: src/ch17-02-testing-smart-contracts.md:8
msgid ""
"Throughout this chapter, we will be using as an example the `PizzaFactory` "
"contract in Listing 17-1 to demonstrate how to write tests with Starknet "
"Foundry."
msgstr ""
"Bu bölüm boyunca, Starknet Foundry ile testlerin nasıl yazılacağını "
"göstermek için Listeleme 17-1'deki PizzaFactory sözleşmesini örnek olarak "
"kullanacağız."

#: src/ch17-02-testing-smart-contracts.md:59
#: src/ch17-02-testing-smart-contracts.md:64
msgid "\"Amount cannot be 0\""
msgstr "\"Dağ 0 olamaz\""

#: src/ch17-02-testing-smart-contracts.md:69
msgid "\"Not enough pepperoni\""
msgstr "\"Yeterince pepperoni yok\""

#: src/ch17-02-testing-smart-contracts.md:70
msgid "\"Not enough pineapple\""
msgstr "\"Yeterince ananas yok\""

#: src/ch17-02-testing-smart-contracts.md:75
#: src/ch17-02-testing-smart-contracts.md:210
#: src/ch17-02-testing-smart-contracts.md:326
#: src/ch17-02-testing-smart-contracts.md:438
#: src/ch17-02-testing-smart-contracts.md:550
#: src/ch17-02-testing-smart-contracts.md:664
msgid "\"Only the owner can make pizza\""
msgstr "\"Sadece sahibi pizza yapabilir\""

#: src/ch17-02-testing-smart-contracts.md:101
#: src/ch17-02-testing-smart-contracts.md:200
#: src/ch17-02-testing-smart-contracts.md:316
#: src/ch17-02-testing-smart-contracts.md:428
#: src/ch17-02-testing-smart-contracts.md:540
#: src/ch17-02-testing-smart-contracts.md:654
msgid "\"Only the owner can set ownership\""
msgstr "\"Sahipliği sadece sahibi belirleyebilir\""

#: src/ch17-02-testing-smart-contracts.md:109
msgid ""
"<span class=\"caption\">Listing 17-1: A pizza factory that needs to be "
"tested</span>"
msgstr ""
"span class=\"caption\">Liste 17-1: Test edilmesi gereken bir pizza fabrikası/"
"span>"

#: src/ch17-02-testing-smart-contracts.md:111
msgid "Configuring your Scarb project with Starknet Foundry"
msgstr "Starknet Foundry ile Scarb projenizi yapılandırma"

#: src/ch17-02-testing-smart-contracts.md:113
msgid ""
"The settings of your Scarb project can be configured in the `Scarb.toml` "
"file. To use Starknet Foundry as your testing tool, you will need to add it "
"as a dev dependency in your `Scarb.toml` file. At the time of writing, the "
"latest version of Starknet Foundry is `v0.22.0` - but you should use the "
"latest version."
msgstr ""
"Scarb projenizin ayarları Scarb.toml dosyasında yapılandırılabilir. Starknet "
"Foundry'i test aracınız olarak kullanmak için Scarb.toml dosyanızda bir dev "
"bağımlılığı olarak eklemeniz gerekir. Yazma sırasında, Starknet Foundry'nin "
"en son sürümü v0.22.0 - ancak en son sürümü kullanmanız gerekir."

#: src/ch17-02-testing-smart-contracts.md:115
msgid ""
"```toml,noplayground\n"
"[dev-dependencies]\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry."
"git\", tag = \"v0.22.0\" }\n"
"\n"
"[scripts]\n"
"test = \"snforge test\"\n"
"```"
msgstr ""
"toml,noplayground [dev-dependencys] snforge_std =  git = \"https://github."
"com/foundry-rs/starknet-foundry.git\", tag = \"v0.22.0\"  [scripts] test = "
"\"snforge test\""

#: src/ch17-02-testing-smart-contracts.md:123
msgid ""
"The `scarb test` command is configured to execute `scarb cairo-test` by "
"default. In our settings, we have configured it to execute `snforge test` "
"instead. This will allow us to run our tests using Starknet Foundry when we "
"run the `scarb test` command."
msgstr ""
"scarb test komutu varsayılan olarak scarb cairo-test çalıştırılacak şekilde "
"yapılandırılmıştır. Ayarlarımızda, bunun yerine snforge test çalıştıracak "
"şekilde yapılandırdık. Bu, scarb test komutunu çalıştırdığımızda Starknet "
"Foundry kullanarak testlerimizi çalıştırmamızı sağlayacaktır."

#: src/ch17-02-testing-smart-contracts.md:125
msgid ""
"Once your project is configured, you will need to install Starknet Foundry "
"by following the installation guide from the [Starknet Foundry Documentation]"
"(https://foundry-rs.github.io/starknet-foundry/getting-started/installation."
"html). As usual, we recommend to use `asdf` to manage versions of your "
"development tools."
msgstr ""
"Projeniz yapılandırıldıktan sonra, [Starknet Dökümantasyonu] [https://"
"foundry-rs.github.io/starknet-foundry/getting-started/installation.html] "
"kurulum kılavuzunu izleyerek Starknet Dökümanını yüklemeniz gerekecektir. "
"Her zamanki gibi, geliştirme araçlarınızın sürümlerini yönetmek için asdf "
"kullanmanızı öneririz."

#: src/ch17-02-testing-smart-contracts.md:127
msgid "Testing Smart Contracts with Starknet Foundry"
msgstr "Starknet Foundry ile Akıllı Sözleşmeleri Test Etmek"

#: src/ch17-02-testing-smart-contracts.md:129
msgid ""
"The usual command to run your tests using Starknet Foundry is `snforge "
"test`. However, when we configured our projects, we defined that the `scarb "
"test` command will run the `snforge test` command. Therefore, during the "
"rest of this chapter, consider that the `scarb test` command will be using "
"`snforge test` under the hood."
msgstr ""
"Starknet Foundry kullanarak testlerinizi yürütmek için olağan komut snforge "
"test'dir. Ancak, projelerimizi yapılandırdığımızda, scarb test komutunun "
"snforge test komutunu çalıştıracağını tanımladık. Bu nedenle, bu bölümün "
"geri kalanında, scarb test komutunun başlık altında snforge test "
"kullanacağını düşünün."

#: src/ch17-02-testing-smart-contracts.md:131
msgid "The usual testing flow of a contract is as follows:"
msgstr "Bir sözleşmenin olağan test akışı aşağıdaki gibidir:"

#: src/ch17-02-testing-smart-contracts.md:133
msgid "Declare the class of the contract to test, identified by its name"
msgstr "Test etmek için sözleşmenin sınıfını ilan et, adı ile tanımlanan"

#: src/ch17-02-testing-smart-contracts.md:134
msgid "Serialize the constructor calldata into an array"
msgstr "Constructor CallData'yı bir dizi halinde serileştirin"

#: src/ch17-02-testing-smart-contracts.md:135
msgid "Deploy the contract and retrieve its address"
msgstr "Sözleşmeyi dağıtın ve adresini alın"

#: src/ch17-02-testing-smart-contracts.md:136
msgid "Interact with the contract's entrypoint to test various scenarios"
msgstr ""
"Çeşitli senaryoları test etmek için sözleşmenin giriş noktasıyla etkileşime "
"geçin"

#: src/ch17-02-testing-smart-contracts.md:138
msgid "Deploying the Contract to Test"
msgstr "Sözleşmenin Test Edilmesi"

#: src/ch17-02-testing-smart-contracts.md:140
msgid ""
"In Listing 17-2, we wrote a function that deploys the `PizzaFactory` "
"contract and sets up the dispatcher for interactions."
msgstr ""
"Listeleme 17-2'de, PizzaFactory sözleşmesini dağıtan ve etkileşimler için "
"göndericiyi ayarlayan bir işlev yazdık."

#: src/ch17-02-testing-smart-contracts.md:162
#: src/ch17-02-testing-smart-contracts.md:278
#: src/ch17-02-testing-smart-contracts.md:390
#: src/ch17-02-testing-smart-contracts.md:502
#: src/ch17-02-testing-smart-contracts.md:616
msgid "\"PizzaFactory\""
msgstr "\"PizzaFactory\""

#: src/ch17-02-testing-smart-contracts.md:178
#: src/ch17-02-testing-smart-contracts.md:294
#: src/ch17-02-testing-smart-contracts.md:406
#: src/ch17-02-testing-smart-contracts.md:518
#: src/ch17-02-testing-smart-contracts.md:632
msgid "\"pepperoni\""
msgstr "\"pepperoni\""

#: src/ch17-02-testing-smart-contracts.md:179
#: src/ch17-02-testing-smart-contracts.md:295
#: src/ch17-02-testing-smart-contracts.md:407
#: src/ch17-02-testing-smart-contracts.md:519
#: src/ch17-02-testing-smart-contracts.md:633
msgid "\"pineapple\""
msgstr "\"Pineapple\""

#: src/ch17-02-testing-smart-contracts.md:221
#: src/ch17-02-testing-smart-contracts.md:337
#: src/ch17-02-testing-smart-contracts.md:449
#: src/ch17-02-testing-smart-contracts.md:561
#: src/ch17-02-testing-smart-contracts.md:675
msgid "// Setup\n"
msgstr "// Kurulum\n"

#: src/ch17-02-testing-smart-contracts.md:226
#: src/ch17-02-testing-smart-contracts.md:342
#: src/ch17-02-testing-smart-contracts.md:454
#: src/ch17-02-testing-smart-contracts.md:566
#: src/ch17-02-testing-smart-contracts.md:680
msgid "// When\n"
msgstr "// Ne zaman\n"

#: src/ch17-02-testing-smart-contracts.md:229
#: src/ch17-02-testing-smart-contracts.md:345
#: src/ch17-02-testing-smart-contracts.md:457
#: src/ch17-02-testing-smart-contracts.md:569
#: src/ch17-02-testing-smart-contracts.md:683
msgid "// Then\n"
msgstr "// Sonra\n"

#: src/ch17-02-testing-smart-contracts.md:246
msgid ""
"<span class=\"caption\">Listing 17-2 Deploying the contract to test</span>"
msgstr ""
"span class=\"caption\">Yönetmelik 17-2 Sözleşmeyi test etmek için dağıtma/"
"span>"

#: src/ch17-02-testing-smart-contracts.md:248
msgid "Testing our Contract"
msgstr "Sözleşmemizi Test Etmek"

#: src/ch17-02-testing-smart-contracts.md:250
msgid ""
"Determining the behavior that your contract should respect is the first step "
"in writing tests. In the `PizzaFactory` contract, we determined that the "
"contract should have the following behavior:"
msgstr ""
"Sözleşmenizin saygı göstermesi gereken davranışı belirlemek, yazılı "
"testlerin ilk adımıdır. PizzaFactory sözleşmesinde, sözleşmenin aşağıdaki "
"davranışa sahip olması gerektiğini belirledik:"

#: src/ch17-02-testing-smart-contracts.md:252
msgid ""
"Upon deployment, the contract owner should be set to the address provided in "
"the constructor, and the factory should have 10 units of pepperoni and "
"pineapple, and no pizzas created."
msgstr ""
"Kurulduktan sonra, sözleşme sahibi constructor'da verilen adrese "
"ayarlanmalıdır ve fabrikada 10 adet pepperoni ve ananas bulunmalıdır ve "
"pizza oluşturulmamalıdır."

#: src/ch17-02-testing-smart-contracts.md:253
msgid ""
"If someone tries to make a pizza and they are not the owner, the operation "
"should fail. Otherwise, the pizza count should be incremented, and an event "
"should be emitted."
msgstr ""
"Birisi pizza yapmaya çalışırsa ve sahibi değilse, operasyon başarısız "
"olmalıdır. Aksi takdirde, pizza sayısı artırılmalı ve bir etkinlik "
"yayılmalıdır."

#: src/ch17-02-testing-smart-contracts.md:254
msgid ""
"If someone tries to take ownership of the contract and they are not the "
"owner, the operation should fail. Otherwise, the owner should be updated."
msgstr ""
"Birisi sözleşmenin mülkiyetini almaya çalışırsa ve sahibi değilse, işlem "
"başarısız olmalıdır. Aksi takdirde, sahibi güncellenmelidir."

#: src/ch17-02-testing-smart-contracts.md:256
msgid "Accessing Storage Variables with `load`"
msgstr "load ile Depolama Değişkenlerine Erişim"

#: src/ch17-02-testing-smart-contracts.md:362
msgid ""
"<span class=\"caption\">Listing 17-3: Testing the initial state by loading "
"storage variables </span>"
msgstr ""
"span class=\"caption\">Liste 17-3: Depolama değişkenlerini yükleyerek ilk "
"durumu test etmek /span>"

#: src/ch17-02-testing-smart-contracts.md:364
msgid ""
"Once our contract is deployed, we want to assert that the initial values are "
"set as expected. If our contract has an entrypoint that returns the value of "
"a storage variable, we can call this entrypoint. Otherwise, we can use the "
"`load` function from `snforge` to load the value of a storage variable "
"inside our contract, even if not exposed by an entrypoint."
msgstr ""
"Sözleşmemiz konuşlandırıldıktan sonra, başlangıç değerlerinin beklendiği "
"gibi ayarlandığını iddia etmek istiyoruz. Sözleşmemiz bir depolama "
"değişkeninin değerini döndüren bir giriş noktasına sahipse, bu giriş "
"noktasını arayabiliriz. Aksi takdirde, bir giriş noktası tarafından maruz "
"bırakılmasa bile, sözleşmemizin içindeki bir depolama değişkeninin değerini "
"yüklemek için snforge fonksiyonunu kullanabiliriz."

#: src/ch17-02-testing-smart-contracts.md:366
msgid "Mocking the Caller Address with `start_cheat_caller_address`"
msgstr "Arayan Adresini start_cheat_caller_address ile Alay Etmek"

#: src/ch17-02-testing-smart-contracts.md:368
msgid ""
"The security of our factory relies on the owner being the only one able to "
"make pizzas and transfer ownership. To test this, we can use the "
"`start_cheat_caller_address` function to mock the caller address and assert "
"that the contract behaves as expected."
msgstr ""
"Fabrikamızın güvenliği, pizza yapıp sahipliğini aktarabilen tek kişinin "
"sahibine bağlıdır. Bunu test etmek için, arayan adresiyle alay etmek ve "
"sözleşmenin beklendiği gibi davrandığını iddia etmek için "
"start_cheat_caller_address işlevini kullanabiliriz."

#: src/ch17-02-testing-smart-contracts.md:474
msgid ""
"<span class=\"caption\">Listing 17-4: Testing ownership of the contract by "
"mocking the caller address </span>"
msgstr ""
"span class=\"caption\">Liste 17-4: Arayan adresle alay ederek sözleşmenin "
"sahipliğini test etmek /span>"

#: src/ch17-02-testing-smart-contracts.md:476
msgid ""
"Using `start_cheat_caller_address`, we call the `change_owner` function "
"first as the owner, and then as a different address. We assert that the "
"operation fails when the caller is not the owner, and that the owner is "
"updated when the caller is the owner."
msgstr ""
"start_cheat_caller_address kullanarak, change_owner fonksiyonunu önce sahip "
"olarak, daha sonra da farklı bir adres olarak adlandırıyoruz. Arayan kişi "
"sahip olmadığında işlemin başarısız olduğunu ve arayanın sahip olduğunda "
"sahibinin güncellendiğini iddia ediyoruz."

#: src/ch17-02-testing-smart-contracts.md:478
msgid "Capturing Events with `spy_events`"
msgstr "spy_events ile Olayları Yakalamak"

#: src/ch17-02-testing-smart-contracts.md:480
msgid ""
"When a pizza is created, the contract emits an event. To test this, we can "
"use the `spy_events` function to capture the emitted events and assert that "
"the event was emitted with the expected parameters. Naturally, we can also "
"assert that the pizza count was incremented, and that only the owner can "
"make a pizza."
msgstr ""
"Bir pizza oluşturulduğunda, sözleşme bir etkinlik yayar. Bunu test etmek "
"için, yayılan olayları yakalamak ve olayın beklenen parametrelerle "
"yayıldığını iddia etmek için spy_events işlevini kullanabiliriz. Doğal "
"olarak, pizza sayısının arttığını ve sadece sahibinin pizza yapabileceğini "
"de iddia edebiliriz."

#: src/ch17-02-testing-smart-contracts.md:586
msgid ""
"<span class=\"caption\">Listing 17-5: Testing the events emitted when a "
"pizza is created</span>"
msgstr ""
"span class=\"caption\">Liste 17-5: Bir pizza oluşturulduğunda yayılan "
"olayları test etmek/span>"

#: src/ch17-02-testing-smart-contracts.md:588
msgid "Accessing Internal Functions with `contract_state_for_testing`"
msgstr "contract_state_for_testing ile İç Fonksiyonlara Erişim"

#: src/ch17-02-testing-smart-contracts.md:590
msgid ""
"All the tests we have seen so far have been using a workflow that involves "
"deploying the contract and interacting with the contract's entrypoints. "
"However, sometimes we may want to test the internals of the contract "
"directly, without deploying the contract. How could this be done, if we were "
"reasoning in purely Cairo terms?"
msgstr ""
"Şimdiye kadar gördüğümüz tüm testler, sözleşmeyi dağıtmayı ve sözleşmenin "
"giriş noktalarıyla etkileşime girmeyi içeren bir iş akışı kullanıyor. Ancak, "
"bazen sözleşmenin iç kısımlarını doğrudan, sözleşmeyi dağıtmadan test etmek "
"isteyebiliriz. Bu, tamamen Kahire terimleriyle akıl yürütmemiz durumunda "
"nasıl yapılabilirdi?"

#: src/ch17-02-testing-smart-contracts.md:592
msgid ""
"Recall the struct `ContractState`, which is used as a parameter to all the "
"entrypoints of a contract. To make it short, this struct contains zero-sized "
"fields, corresponding to the storage variables of the contract. The only "
"purpose of these fields is to allow the Cairo compiler to generate the "
"correct code for accessing the storage variables. If we could create an "
"instance of this struct, we could access these storage variables directly, "
"without deploying the contract..."
msgstr ""
"Bir sözleşmenin tüm giriş noktalarına parametre olarak kullanılan "
"ContractState yapısını hatırlayın. Kısa yapmak için, bu yapı, sözleşmenin "
"depolama değişkenlerine karşılık gelen sıfır boyutlu alanlar içerir. Bu "
"alanların tek amacı, Kahire derleyicisinin depolama değişkenlerine erişmek "
"için doğru kodu oluşturmasına izin vermektir. Bu yapı örneğini "
"oluşturabilirsek, bu depolama değişkenlerine doğrudan dağıtım yapmadan "
"erişebiliriz..."

#: src/ch17-02-testing-smart-contracts.md:594
msgid ""
"...and this is exactly what the `contract_state_for_testing` function does! "
"It creates an instance of the `ContractState` struct, allowing us to call "
"any function that takes as parameter a `ContractState` struct, without "
"deploying the contract. To interact with the storage variables properly, we "
"need to manually import the traits that define access to the storage "
"variables."
msgstr ""
"... ve bu tam olarak contract_state_for_testing fonksiyonunun yaptığı şey! "
"ContractState yapısının bir örneğini oluşturarak, sözleşmeyi dağıtmadan, "
"parametre olarak a ContractState yapısını alan herhangi bir işlevi "
"çağırmamızı sağlar. Depolama değişkenleriyle düzgün bir şekilde etkileşim "
"kurmak için, depolama değişkenlerine erişimi tanımlayan özellikleri manuel "
"olarak içe aktarmamız gerekir."

#: src/ch17-02-testing-smart-contracts.md:700
msgid ""
"<span class=\"caption\">Listing 17-6: Unit testing our contract without "
"deployment</span>"
msgstr ""
"span class=\"caption\">Liste 17-6: Sözleşmemizi konuşlandırmadan test eden "
"birim/span>"

#: src/ch17-02-testing-smart-contracts.md:702
msgid ""
"These imports give us access to our internal functions (notably, "
"`set_owner`), as well as the read/write access to the `owner` storage "
"variable. Once we have these, we can interact with the contract directly, "
"changing the address of the owner by calling the `set_owner` method, "
"accessible through `InternalTrait`, and reading the `owner` storage variable."
msgstr ""
"Bu ithalat bize dahili fonksiyonlarımıza (özellikle set_owner) ve owner "
"depolama değişkenine okuma/yazma erişimine erişim sağlar. Bunlara sahip "
"olduktan sonra, set_owner metodunu arayarak, InternalTrait aracılığıyla "
"erişilebilen ve owner depolama değişkenini okuyarak, doğrudan sözleşme ile "
"etkileşime geçebiliriz."

#: src/ch17-02-testing-smart-contracts.md:707
msgid ""
"Note: Both approaches cannot be used at the same time. If you decide to "
"deploy the contract, you interact with it using the dispatcher. If you "
"decide to test the internal functions, you interact with the `ContractState` "
"object directly."
msgstr ""
"Not: Her iki yaklaşım da aynı anda kullanılamaz. Sözleşmeyi dağıtmaya karar "
"verirseniz, göndericiyi kullanarak onunla etkileşimde bulunursunuz. İç "
"fonksiyonları test etmeye karar verirseniz, doğrudan ContractState nesnesi "
"ile etkileşimde bulunursunuz."

#: src/ch17-02-testing-smart-contracts.md:728
msgid ""
"The output of the tests shows that all the tests passed successfully, along "
"with an estimation of the gas consumed by each test."
msgstr ""
"Testlerin çıktısı, tüm testlerin, her test tarafından tüketilen gazın bir "
"tahmini ile birlikte başarıyla geçtiğini göstermektedir."

#: src/ch17-02-testing-smart-contracts.md:732
msgid ""
"In this chapter, we learned how to test smart contracts using Starknet "
"Foundry. We demonstrated how to deploy a contract and interact with it using "
"the dispatcher. We also showed how to test the contract's behavior by "
"mocking the caller address and capturing events. Finally, we demonstrated "
"how to test the internal functions of the contract directly, without "
"deploying the contract."
msgstr ""
"Bu bölümde Starknet Foundry kullanarak akıllı sözleşmelerin nasıl test "
"edileceğini öğrendik. Bir sözleşmenin nasıl dağıtılacağını ve göndericiyi "
"kullanarak nasıl etkileşimde bulunacağını gösterdik. Ayrıca, arayan "
"adresiyle alay ederek ve olayları yakalayarak sözleşmenin davranışını nasıl "
"test edeceğimizi gösterdik. Son olarak, sözleşmeyi dağıtmadan sözleşmenin iç "
"işlevlerini doğrudan nasıl test edeceğimizi gösterdik."

#: src/ch17-02-testing-smart-contracts.md:734
msgid ""
"To learn more about Starknet Foundry, refer to the [Starknet Foundry "
"documentation](https://foundry-rs.github.io/starknet-foundry/index.html)."
msgstr ""
"Starknet Foundry hakkında daha fazla bilgi edinmek için [Starknet Foundry "
"documentation](https://foundry-rs.github.io/starknet-foundry/index.html) "
"adresine bakın."

#: src/ch17-03-static-analysis-tools.md:3
msgid ""
"Static analysis refers to the process of examining code without its "
"execution, focusing on its structure, syntax, and properties. It involves "
"analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr ""
"Statik analiz, kodun çalıştırılmadan incelenmesi, yapısına, sözdizimine ve "
"özelliklerine odaklanma sürecini ifade eder. Potansiyel sorunları, güvenlik "
"açıklarını veya belirtilen kuralların ihlallerini tanımlamak için kaynak "
"kodu analiz etmeyi içerir."

#: src/ch17-03-static-analysis-tools.md:5
msgid ""
"By defining rules, such as coding conventions or security guidelines, "
"developers can utilize static analysis tools to automatically check the code "
"against these standards."
msgstr ""
"Kodlama sözleşmeleri veya güvenlik yönergeleri gibi kuralları tanımlayarak, "
"geliştiriciler kodu bu standartlara göre otomatik olarak kontrol etmek için "
"statik analiz araçlarını kullanabilirler."

#: src/ch17-03-static-analysis-tools.md:7
msgid "Reference:"
msgstr "Kaynakça:"

#: src/ch17-03-static-analysis-tools.md:9
msgid ""
"[Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-"
"supports-cairo-1-0)"
msgstr ""
"[Semgrep Cairo 1.0 desteği](https://semgrep.dev/blog/2023/semgrep-now-"
"supports-cairo-1-0)"

#: src/ch17-03-static-analysis-tools.md:10
msgid ""
"[Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"
msgstr ""
"[Caracal, bir Starknet statik analizörü](https://github.com/crytic/caracal)"

#: src/appendix-000.md
msgid ""
"The following sections contain reference material you may find useful in "
"your Starknet journey."
msgstr ""
"Aşağıdaki bölümler, Starknet seyahatinizde yararlı bulabileceğiniz referans "
"materyalleri içerir."

#: src/appendix-08-system-calls.md:1
msgid "Appendix A - System Calls"
msgstr "Ek A - Sistem Çağrıları"

#: src/appendix-08-system-calls.md:3
msgid ""
"This chapter is based on the StarkNet documentation available at [StarkNet "
"Docs](https://docs.starknet.io/documentation/architecture_and_concepts/"
"Smart_Contracts/system-calls-cairo1/)."
msgstr ""
"Bu bölüm [StarkNet Docs] adresinde bulunan StarkNet belgelerine "
"dayanmaktadır(https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/system-calls-cairo1/)."

#: src/appendix-08-system-calls.md:5
msgid ""
"Writing smart contracts requires various associated operations, such as "
"calling another contract or accessing the contract’s storage, that "
"standalone programs do not require."
msgstr ""
"Akıllı sözleşmeler yazmak, başka bir sözleşmeyi aramak veya bağımsız "
"programların gerektirmediği sözleşmenin deposuna erişmek gibi çeşitli "
"ilişkili işlemler gerektirir."

#: src/appendix-08-system-calls.md:7
msgid ""
"The Starknet contract language supports these operations by using system "
"calls. System calls enable a contract to require services from the Starknet "
"OS. You can use system calls in a function to get information that depends "
"on the broader state of Starknet, which would otherwise be inaccessible, "
"rather than local variables that appear in the function’s scope."
msgstr ""
"Starknet sözleşme dili, sistem çağrılarını kullanarak bu işlemleri "
"destekler. Sistem çağrıları, Starknet işletim sisteminden hizmet talep etmek "
"için bir sözleşmeyi etkinleştirir. Fonksiyonun kapsamı içinde görünen yerel "
"değişkenler yerine, Starknet'in daha geniş durumuna bağlı olan bilgileri "
"almak için bir işlevdeki sistem çağrılarını kullanabilirsiniz."

#: src/appendix-08-system-calls.md:9
msgid "Here is a list of the system calls available in Cairo 1.0:"
msgstr "İşte Kahire 1.0'daki sistem çağrılarının bir listesi:"

#: src/appendix-08-system-calls.md:11
msgid "[get_block_hash](#get_block_hash)"
msgstr "[get_block_hash](#get_block_hash)"

#: src/appendix-08-system-calls.md:12
msgid "[get_execution_info](#get_execution_info)"
msgstr "[get_execution_info](#get_execution_info]"

#: src/appendix-08-system-calls.md:13
msgid "[call_contract](#call_contract)"
msgstr "[call_contract](#call_contract)"

#: src/appendix-08-system-calls.md:14
msgid "[deploy](#deploy)"
msgstr "[deploy](#deploy)"

#: src/appendix-08-system-calls.md:15
msgid "[emit_event](#emit_event)"
msgstr "[emit_event](#emit_event)"

#: src/appendix-08-system-calls.md:16
msgid "[library_call](#library_call)"
msgstr "[library_call](#library_call)"

#: src/appendix-08-system-calls.md:17
msgid "[send_message_to_L1](#send_message_to_l1)"
msgstr "[send_message_to_L1](#send_message_to_l1)"

#: src/appendix-08-system-calls.md:18
msgid "[replace_class](#replace_class)"
msgstr "[replace_class](#replace_class)"

#: src/appendix-08-system-calls.md:19
msgid "[storage_read](#storage_read)"
msgstr "[storage_read](#storage_read)"

#: src/appendix-08-system-calls.md:20
msgid "[storage_write](#storage_write)"
msgstr "[storage_write](#storage_write)"

#: src/appendix-08-system-calls.md:22
msgid "`get_block_hash`"
msgstr "get_block_hash"

#: src/appendix-08-system-calls.md:24 src/appendix-08-system-calls.md:51
#: src/appendix-08-system-calls.md:79 src/appendix-08-system-calls.md:117
#: src/appendix-08-system-calls.md:153 src/appendix-08-system-calls.md:198
#: src/appendix-08-system-calls.md:230 src/appendix-08-system-calls.md:273
#: src/appendix-08-system-calls.md:305 src/appendix-08-system-calls.md:348
msgid "Syntax"
msgstr "Sözdizimi"

#: src/appendix-08-system-calls.md:32 src/appendix-08-system-calls.md:59
#: src/appendix-08-system-calls.md:87 src/appendix-08-system-calls.md:128
#: src/appendix-08-system-calls.md:161 src/appendix-08-system-calls.md:206
#: src/appendix-08-system-calls.md:238 src/appendix-08-system-calls.md:281
#: src/appendix-08-system-calls.md:313 src/appendix-08-system-calls.md:356
msgid "Description"
msgstr "Açıklama"

#: src/appendix-08-system-calls.md:34
msgid ""
"Gets the hash of a specific StarkNet block within the range of "
"`[first_v0_12_0_block, current_block - 10]`."
msgstr ""
"[first_v0_12_0_block, current_block - 10] aralığında belirli bir StarkNet "
"bloğunun hash'ini alır."

#: src/appendix-08-system-calls.md:36 src/appendix-08-system-calls.md:69
#: src/appendix-08-system-calls.md:103 src/appendix-08-system-calls.md:139
#: src/appendix-08-system-calls.md:173 src/appendix-08-system-calls.md:220
#: src/appendix-08-system-calls.md:252 src/appendix-08-system-calls.md:295
#: src/appendix-08-system-calls.md:327 src/appendix-08-system-calls.md:372
msgid "Return Values"
msgstr "Dönüş Değerleri"

#: src/appendix-08-system-calls.md:38
msgid "Returns the hash of the given block."
msgstr "Verilen bloğun hash'ini döndürür."

#: src/appendix-08-system-calls.md:40
msgid "Error Messages"
msgstr "Hata Mesajları"

#: src/appendix-08-system-calls.md:42
msgid ""
"`Block number out of range`: `block_number` is greater than "
"_`current_block`_`- 10`."
msgstr ""
"Block number out of range: block_number _current_block_- 10'den büyüktür."

#: src/appendix-08-system-calls.md:43
msgid "`0`: `block_number` is less than the first block number of v0.12.0."
msgstr "0: block_number, v0.12.0'ın ilk blok numarasından daha azdır."

#: src/appendix-08-system-calls.md:45 src/appendix-08-system-calls.md:73
#: src/appendix-08-system-calls.md:107 src/appendix-08-system-calls.md:147
#: src/appendix-08-system-calls.md:192 src/appendix-08-system-calls.md:224
#: src/appendix-08-system-calls.md:267 src/appendix-08-system-calls.md:299
#: src/appendix-08-system-calls.md:342 src/appendix-08-system-calls.md:376
msgid "Common Library"
msgstr "Ortak Kütüphane"

#: src/appendix-08-system-calls.md:47
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/"
"blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls."
"cairo#L37)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/"
"blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls."
"cairo#L37"

#: src/appendix-08-system-calls.md:49
msgid "`get_execution_info`"
msgstr "get_execution_info"

#: src/appendix-08-system-calls.md:61
msgid "Gets information about the original transaction."
msgstr "Orijinal işlem hakkında bilgi alır."

#: src/appendix-08-system-calls.md:63
msgid ""
"In Cairo 1.0, all block/transaction/execution context getters are batched "
"into this single system call."
msgstr ""
"Kahire 1.0'da, tüm blok / işlem / yürütme bağlamı alıcıları bu tek sistem "
"çağrısına toplu olarak gönderilir."

#: src/appendix-08-system-calls.md:65 src/appendix-08-system-calls.md:97
#: src/appendix-08-system-calls.md:132 src/appendix-08-system-calls.md:167
#: src/appendix-08-system-calls.md:212 src/appendix-08-system-calls.md:246
#: src/appendix-08-system-calls.md:291 src/appendix-08-system-calls.md:321
#: src/appendix-08-system-calls.md:364
msgid "Arguments"
msgstr "Tartışmalar"

#: src/appendix-08-system-calls.md:67 src/appendix-08-system-calls.md:175
#: src/appendix-08-system-calls.md:254 src/appendix-08-system-calls.md:297
#: src/appendix-08-system-calls.md:374
msgid "None."
msgstr "Hiç."

#: src/appendix-08-system-calls.md:71
msgid ""
"Returns a [struct](https://github.com/starkware-libs/cairo/blob/"
"efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8) "
"containing the execution info."
msgstr ""
"Uygulama bilgilerini içeren bir [struct](https://github.com/starkware-libs/"
"cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/"
"info.cairo#L8) döndürür."

#: src/appendix-08-system-calls.md:75
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L35)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L35"

#: src/appendix-08-system-calls.md:77
msgid "`call_contract`"
msgstr "call_contract"

#: src/appendix-08-system-calls.md:89
msgid ""
"Calls a given contract. This system call expects the address of the called "
"contract, a selector for a function within that contract, and call arguments."
msgstr ""
"Verilen bir sözleşmeyi çağırır. Bu sistem çağrısı, söz konusu sözleşmenin "
"adresini, o sözleşme içindeki bir işlev için bir seçiciyi ve çağrı "
"argümanlarını bekler."

#: src/appendix-08-system-calls.md:91 src/appendix-08-system-calls.md:285
msgid "**Note:**"
msgstr "**Not: **"

#: src/appendix-08-system-calls.md:93
msgid ""
"An internal call can’t return Err(\\_) as this is not handled by the "
"sequencer and the Starknet OS."
msgstr ""
"Dahili bir çağrı Err(_) döndüremez, çünkü bu, sekanslayıcı ve Starknet OS "
"tarafından ele alınmaz."

#: src/appendix-08-system-calls.md:95
msgid ""
"If call_contract_syscall fails, this can’t be caught and will therefore "
"result in the entire transaction being reverted."
msgstr ""
"Call_contract_syscall başarısız olursa, bu yakalanamaz ve bu nedenle tüm "
"işlemin geri döndürülmesine neden olur."

#: src/appendix-08-system-calls.md:99
msgid "_`address`_: The address of the contract you want to call."
msgstr "_adres_: Aradığınız sözleşmenin adresi."

#: src/appendix-08-system-calls.md:100
msgid ""
"_`entry_point_selector`_: A selector for a function within that contract, "
"can be computed with the `selector!` macro."
msgstr ""
"_entry_point_selector_: Bu sözleşme içindeki bir fonksiyon için bir seçici, "
"selector! makrosu ile hesaplanabilir."

#: src/appendix-08-system-calls.md:101
msgid "_`calldata`_: The calldata array."
msgstr "_calldata_: Calldata dizisi."

#: src/appendix-08-system-calls.md:105 src/appendix-08-system-calls.md:222
msgid "The call response, of type `SyscallResult<Span<felt252>>`."
msgstr "SyscallResultSpanfelt252> tipinin çağrı yanıtı."

#: src/appendix-08-system-calls.md:109
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L10)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L10)"

#: src/appendix-08-system-calls.md:111
msgid ""
"**Note:** This is considered a lower-level syntax for calling contracts. If "
"the interface of the called contract is available, then you can use a more "
"straightforward syntax."
msgstr ""
"**Not:** Bu, sözleşmeleri çağırmak için daha düşük seviyeli bir sözdizimi "
"olarak kabul edilir. Söz konusu sözleşmenin arayüzü mevcutsa, daha basit bir "
"sözdizimi kullanabilirsiniz."

#: src/appendix-08-system-calls.md:115
msgid "`deploy`"
msgstr "deploy"

#: src/appendix-08-system-calls.md:130
msgid "Deploys a new instance of a previously declared class."
msgstr "Önceden ilan edilmiş bir sınıfın yeni bir örneğini dağıtır."

#: src/appendix-08-system-calls.md:134
msgid "_`class_hash`_: The class hash of the contract to be deployed."
msgstr "_class_hash_: Görevlendirilecek sözleşmenin sınıf hash'i."

#: src/appendix-08-system-calls.md:135
msgid ""
"_`contract_address_salt`_: The salt, an arbitrary value provided by the "
"sender. It is used in the computation of the contract’s address."
msgstr ""
"_contract_address_salt_: Gönderici tarafından sağlanan keyfi bir değer olan "
"tuz. Sözleşmenin adresinin hesaplanmasında kullanılır."

#: src/appendix-08-system-calls.md:136
msgid "_`calldata`_: The constructor’s calldata. An array of felts."
msgstr "_calldata_: Yapılandırıcının calldata'sı. Bir dizi keçe."

#: src/appendix-08-system-calls.md:137
msgid ""
"_`deploy_from_zero`_: A flag used for the contract address computation. If "
"not set, the caller address will be used as the new contract’s deployer "
"address, otherwise 0 is used."
msgstr ""
"_deploy_from_zero_: Sözleşme adresi hesaplaması için kullanılan bir bayrak. "
"Ayarlanmamışsa, arayan adresi yeni sözleşmenin konuşlandırıcı adresi olarak "
"kullanılacaktır, aksi takdirde 0 kullanılır."

#: src/appendix-08-system-calls.md:141
msgid "A tuple wrapped with SyscallResult where:"
msgstr "SyscallResult ile sarılmış bir tuple nerede:"

#: src/appendix-08-system-calls.md:143
msgid ""
"The first element is the address of the deployed contract, of type "
"`ContractAddress`."
msgstr ""
"İlk unsur, ContractAddress tipinde konuşlandırılmış sözleşmenin adresidir."

#: src/appendix-08-system-calls.md:145
msgid ""
"The second element is the response array from the contract’s constructor, of "
"type `Span::<felt252>`."
msgstr ""
"İkinci unsur, sözleşmenin yapıcısından gelen yanıt dizisidir, türü Span:"
"felt252>'dir."

#: src/appendix-08-system-calls.md:149
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/"
"blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls."
"cairo#L22)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/"
"blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls."
"cairo#L22"

#: src/appendix-08-system-calls.md:151
msgid "`emit_event`"
msgstr "emit_event"

#: src/appendix-08-system-calls.md:163
msgid "Emits an event with a given set of keys and data."
msgstr "Belirli bir anahtar ve veri kümesine sahip bir olayı belirtir."

#: src/appendix-08-system-calls.md:165
msgid ""
"For more information and a higher-level syntax for emitting events, see "
"[Starknet events](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/starknet-events/)."
msgstr ""
"Daha fazla bilgi ve yayan olaylar için daha üst düzey bir sözdizimi için "
"[Starknet etkinlikleri](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/starknet-events/) sayfasına bakın."

#: src/appendix-08-system-calls.md:169
msgid ""
"_`keys`_: The event’s keys. These are analogous to Ethereum’s event topics, "
"you can use the starknet_getEvents method to filter by these keys."
msgstr ""
"_keys_: Etkinliğin anahtarları. Bunlar Ethereum'un etkinlik konularına "
"benzer, bu tuşlara göre filtrelemek için starknet_getEvents yöntemini "
"kullanabilirsiniz."

#: src/appendix-08-system-calls.md:171
msgid "_`data`_: The event’s data."
msgstr "_data_: Etkinliğin verileri."

#: src/appendix-08-system-calls.md:179
msgid ""
"The following example emits an event with two keys, the strings `status` and "
"`deposit` and three data elements: `1`, `2`, and `3`."
msgstr ""
"Aşağıdaki örnek, status ve deposit dizeleri ve üç veri elemanı olan bir olay "
"yayar: 1, 2 ve 3."

#: src/appendix-08-system-calls.md:194
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L30)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L30)"

#: src/appendix-08-system-calls.md:196
msgid "`library_call`"
msgstr "library_call"

#: src/appendix-08-system-calls.md:208
msgid ""
"Calls the requested function in any previously declared class. The class is "
"only used for its logic."
msgstr ""
"Daha önce ilan edilmiş herhangi bir sınıfta istenen işlevi çağırır. Sınıf "
"sadece mantığı için kullanılır."

#: src/appendix-08-system-calls.md:210
msgid ""
"This system call replaces the known delegate call functionality from "
"Ethereum, with the important difference that there is only one contract "
"involved."
msgstr ""
"Bu sistem çağrısı, yalnızca bir sözleşmenin söz konusu olduğu önemli farkla, "
"Ethereum'dan bilinen delege çağrı işlevselliğinin yerini alır."

#: src/appendix-08-system-calls.md:214
msgid "_`class_hash`_: The hash of the class you want to use."
msgstr "_class_hash_: Kullanmak istediğiniz sınıfın hash'i."

#: src/appendix-08-system-calls.md:216
msgid ""
"_`function_selector`_: A selector for a function within that class, can be "
"computed with the `selector!` macro."
msgstr ""
"_function_selector_: Bu sınıftaki bir fonksiyon için bir seçici, selector! "
"makrosu ile hesaplanabilir."

#: src/appendix-08-system-calls.md:218
msgid "_`calldata`_: The calldata."
msgstr "_calldata_: Calldata."

#: src/appendix-08-system-calls.md:226
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L43)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L43)"

#: src/appendix-08-system-calls.md:228
msgid "`send_message_to_L1`"
msgstr "send_message_to_L1"

#: src/appendix-08-system-calls.md:240
msgid "Sends a message to L1."
msgstr "L1'e bir mesaj gönderir."

#: src/appendix-08-system-calls.md:242
msgid ""
"This system call includes the message parameters as part of the proof’s "
"output and exposes these parameters to the `StarknetCore` contract on L1 "
"once the state update, including the transaction, is received."
msgstr ""
"Bu sistem çağrısı, kanıtın çıktısının bir parçası olarak mesaj "
"parametrelerini içerir ve bu parametreleri işlem de dahil olmak üzere devlet "
"güncellemesi alındıktan sonra L1'deki StarknetCore sözleşmesine ifşa eder."

#: src/appendix-08-system-calls.md:244
msgid ""
"For more information, see Starknet’s [messaging mechanism](https://docs."
"starknet.io/documentation/architecture_and_concepts/Network_Architecture/"
"messaging-mechanism/)."
msgstr ""
"Daha fazla bilgi için Starknet'in [mesajlama mekanizması](https://docs."
"starknet.io/documentation/architecture_and_concepts/Network_Architecture/"
"mesajlama-mekanizma/) sayfasına bakın."

#: src/appendix-08-system-calls.md:248
msgid "_`to_address`_: The recipient’s L1 address."
msgstr "_to_address_: Alıcının L1 adresi."

#: src/appendix-08-system-calls.md:250
msgid "_`payload`_: The array containing the message payload."
msgstr "_payload_: İleti yükünü içeren dizi."

#: src/appendix-08-system-calls.md:258
msgid ""
"The following example sends a message whose content is `(1,2)` to the L1 "
"contract whose address is `3423542542364363`."
msgstr ""
"Aşağıdaki örnek, içeriği (1,2) olan bir mesajı, adresi 3423542364363 olan L1 "
"sözleşmesine gönderir."

#: src/appendix-08-system-calls.md:269
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L51)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L51"

#: src/appendix-08-system-calls.md:271
msgid "`replace_class`"
msgstr "replace_class"

#: src/appendix-08-system-calls.md:283
msgid ""
"Once `replace_class` is called, the class of the calling contract (i.e. the "
"contract whose address is returned by `get_contract_address` at the time the "
"syscall is called) will be replaced by the class whose hash is given by the "
"class_hash argument."
msgstr ""
"Bir kez replace_class çağrıldığında, çağrı sözleşmesinin sınıfı (yani adresi "
"get_contract_address tarafından iade edilen sözleşme), syscall çağrıldığı "
"sırada, hash'ı class_hash argümanı tarafından verilen sınıfla değiştirilir."

#: src/appendix-08-system-calls.md:287
msgid ""
"After calling `replace_class`, the code currently executing from the old "
"class will finish running."
msgstr ""
"replace_class'yi aradıktan sonra, şu anda eski sınıftan çalıştırılan kod "
"çalışmayı bitirecektir."

#: src/appendix-08-system-calls.md:289
msgid ""
"The new class will be used from the next transaction onwards or if the "
"contract is called via the `call_contract` syscall in the same transaction "
"(after the replacement)."
msgstr ""
"Yeni sınıf, bir sonraki işlemden itibaren veya sözleşme aynı işlemde "
"(değiştirildikten sonra) call_contract syscall aracılığıyla çağrıldıysa "
"kullanılacaktır."

#: src/appendix-08-system-calls.md:293
msgid "_`class_hash`_: The hash of the class you want to use as a replacement."
msgstr "_class_hash_: Değiştirme olarak kullanmak istediğiniz sınıfın hash'i."

#: src/appendix-08-system-calls.md:301
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L77)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L77"

#: src/appendix-08-system-calls.md:303
msgid "`storage_read`"
msgstr "storage_read"

#: src/appendix-08-system-calls.md:315
msgid "Gets the value of a key in the storage of the calling contract."
msgstr "Arama sözleşmesinin depolanmasında bir anahtarın değerini alır."

#: src/appendix-08-system-calls.md:317
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.read()`, which enables you to read storage variables that "
"are defined explicitly in the contract."
msgstr ""
"Bu sistem çağrısı, sözleşmede açıkça tanımlanan depolama değişkenlerini "
"okumanızı sağlayan var.read() ile aksine, depolamadaki olası herhangi bir "
"anahtara doğrudan erişim sağlar."

#: src/appendix-08-system-calls.md:319 src/appendix-08-system-calls.md:362
msgid ""
"For information on accessing storage by using the storage variables, see "
"[storage variables](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/contract-storage/"
"#storage_variables)."
msgstr ""
"Depolama değişkenlerini kullanarak depolamaya erişim hakkında bilgi için "
"bkz. [depolama değişkenleri](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/contracts-storage/"
"#storage_variables)."

#: src/appendix-08-system-calls.md:323 src/appendix-08-system-calls.md:366
msgid ""
"_`address_domain`_: The domain of the key, used to separate between "
"different data availability modes. This separation is used in Starknet to "
"offer different data availability modes. Currently, only the onchain mode "
"(where all updates go to L1), indicated by domain `0`, is supported. Other "
"address domains which will be introduced in the future will behave "
"differently in terms of publication (in particular, they will not be posted "
"on L1, creating a tradeoff between cost and security)."
msgstr ""
"_address_domain_: Anahtarın etki alanı, farklı veri kullanılabilirlik "
"modları arasında ayırmak için kullanılır. Bu ayrım, Starknet'te farklı veri "
"kullanılabilirlik modları sunmak için kullanılır. Şu anda, yalnızca onchain "
"modu (tüm güncellemelerin L1'e gittiği, 0 etki alanı ile gösterilen) "
"desteklenir. Gelecekte tanıtılacak diğer adres etki alanları, yayın "
"açısından farklı davranacaktır (özellikle, L1'de yayınlanmayacaktır, bir "
"ticaret ve maliyet arasında)."

#: src/appendix-08-system-calls.md:325 src/appendix-08-system-calls.md:368
msgid "_`address`_: The requested storage address."
msgstr "_adres_: İstenen depolama adresi."

#: src/appendix-08-system-calls.md:329
msgid "The value of the key, of type `SyscallResult<felt252>`."
msgstr "Anahtarın değeri, türü SyscallResultfelt252>."

#: src/appendix-08-system-calls.md:344
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L60)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L60)"

#: src/appendix-08-system-calls.md:346
msgid "`storage_write`"
msgstr "storage_write"

#: src/appendix-08-system-calls.md:358
msgid "Sets the value of a key in the storage of the calling contract."
msgstr "Arama sözleşmesinin depolanmasında bir anahtarın değerini ayarlar."

#: src/appendix-08-system-calls.md:360
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.write()`, which enables you to write to storage variables "
"that are defined explicitly in the contract."
msgstr ""
"Bu sistem çağrısı, sözleşmede açıkça tanımlanan depolama değişkenlerine "
"yazmanızı sağlayan var.write() ile aksine, depolamadaki olası herhangi bir "
"anahtara doğrudan erişim sağlar."

#: src/appendix-08-system-calls.md:370
msgid "_`value`_: The value to write to the key."
msgstr "_value_: Anahtara yazılacak değer."

#: src/appendix-08-system-calls.md:378
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L70)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L70)"

#~ msgid "\"result is not 4\""
#~ msgstr "\"Sonuç 4 değil\""

#~ msgid "First of all, add the following code in your _lib.cairo_ file:"
#~ msgstr "Öncelikle _lib.cairo_ dosyanıza aşağıdaki kodu ekleyin:"

#~ msgid ""
#~ "Note that we still need to use the `#[cfg(test)]` attribute here, because "
#~ "we are in the _lib.cairo_ file of the _src_ directory. Then, create a "
#~ "_tests.cairo_ file and fill it as follows:"
#~ msgstr ""
#~ "#[cfg(test)] özniteliğini hala kullanmamız gerektiğini unutmayın, çünkü "
#~ "_src_ dizininin _lib.cairo_ dosyasındayız. Ardından, bir _tests.cairo_ "
#~ "dosyası oluşturun ve aşağıdaki gibi doldurun:"

#~ msgid ""
#~ "The result of the tests is the same as what we've been seeing: one line "
#~ "for each test."
#~ msgstr "Testlerin sonucu, gördüğümüzle aynıdır: her test için bir satır."
